{"file_name": "/home/qj213/afp-2021-10-22/thys/Fisher_Yates/Fisher_Yates.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Fisher_Yates", "problem_names": ["lemma integral_pmf_of_multiset:\n  \"A \\<noteq> {#} \\<Longrightarrow> (\\<integral>x. (f x :: real) \\<partial>measure_pmf (pmf_of_multiset A)) = \n     (\\<Sum>x\\<in>set_mset A. of_nat (count A x) * f x) / of_nat (size A)\"", "lemma pmf_bind_pmf_of_multiset:\n  \"A \\<noteq> {#} \\<Longrightarrow> pmf (pmf_of_multiset A \\<bind> f) y = \n     (\\<Sum>x\\<in>set_mset A. real (count A x) * pmf (f x) y) / real (size A)\"", "lemma pmf_map_inj_inv:\n  assumes \"inj_on f (set_pmf p)\"\n  assumes \"\\<And>x. f' (f x) = x\"\n  shows   \"pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\"", "lemma length_swap [simp]: \"length (swap xs i j) = length xs\"", "lemma swap_eq_Nil_iff [simp]: \"swap xs i j = [] \\<longleftrightarrow> xs = []\"", "lemma nth_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> \n    swap xs i j ! k = (if k = i then xs ! j else if k = j then xs ! i else xs ! k)\"", "lemma map_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> map f (swap xs i j) = swap (map f xs) i j\"", "lemma swap_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> swap (swap xs i j) j i = xs\"", "lemma mset_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> mset (swap xs i j) = mset xs\"", "lemma hd_swap_0: \"i < length xs \\<Longrightarrow> hd (swap xs 0 i) = xs ! i\"", "lemma pmf_of_set_permutations_of_multiset_nonempty:\n  assumes \"(A :: 'a multiset) \\<noteq> {#}\"\n  shows \"pmf_of_set (permutations_of_multiset A) =\n           do {x \\<leftarrow> pmf_of_multiset A;\n               xs \\<leftarrow> pmf_of_set (permutations_of_multiset (A - {#x#}));\n               return_pmf (x#xs)\n              }\" (is \"?lhs = ?rhs\")", "lemma shuffle_empty [simp]: \"shuffle [] = return_pmf []\"", "lemma shuffle_singleton [simp]: \"shuffle [x] = return_pmf [x]\"", "lemma shuffle_fisher_yates_step:\n  assumes xs_nonempty [simp]: \"xs \\<noteq> []\"\n  shows \"shuffle xs =  \n           do {i \\<leftarrow> pmf_of_set {..<length xs}; \n               let ys = swap xs 0 i; \n               zs \\<leftarrow> shuffle (tl ys);\n               return_pmf (hd ys # zs)\n              }\"", "lemma fisher_yates_aux_correct:\n  \"fisher_yates_aux i xs = map_pmf (\\<lambda>ys. take i xs @ ys) (shuffle (drop i xs))\"", "lemma fisher_yates_correct: \"fisher_yates xs = shuffle xs\"", "lemma fisher_yates_alt_aux_altdef:\n  \"i < length xs \\<Longrightarrow> fisher_yates_alt_aux i xs = \n     map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\"", "lemma fisher_yates_alt_aux_correct:\n  \"fisher_yates_alt xs = shuffle xs\""], "translations": [["", "lemma integral_pmf_of_multiset:\n  \"A \\<noteq> {#} \\<Longrightarrow> (\\<integral>x. (f x :: real) \\<partial>measure_pmf (pmf_of_multiset A)) = \n     (\\<Sum>x\\<in>set_mset A. of_nat (count A x) * f x) / of_nat (size A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {#} \\<Longrightarrow>\n    measure_pmf.expectation (pmf_of_multiset A) f =\n    (\\<Sum>x\\<in>set_mset A. real (count A x) * f x) / real (size A)", "by (subst integral_measure_pmf[where A = \"set_mset A\"])\n     (simp_all add: sum_divide_distrib mult_ac)"], ["", "lemma pmf_bind_pmf_of_multiset:\n  \"A \\<noteq> {#} \\<Longrightarrow> pmf (pmf_of_multiset A \\<bind> f) y = \n     (\\<Sum>x\\<in>set_mset A. real (count A x) * pmf (f x) y) / real (size A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {#} \\<Longrightarrow>\n    pmf (pmf_of_multiset A \\<bind> f) y =\n    (\\<Sum>x\\<in>set_mset A. real (count A x) * pmf (f x) y) / real (size A)", "by (simp add: pmf_bind integral_pmf_of_multiset)"], ["", "lemma pmf_map_inj_inv:\n  assumes \"inj_on f (set_pmf p)\"\n  assumes \"\\<And>x. f' (f x) = x\"\n  shows   \"pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "proof (cases \"x \\<in> f ` set_pmf p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n 2. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "case True"], ["proof (state)\nthis:\n  x \\<in> f ` set_pmf p\n\ngoal (2 subgoals):\n 1. x \\<in> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n 2. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "from this"], ["proof (chain)\npicking this:\n  x \\<in> f ` set_pmf p", "obtain y where y: \"y \\<in> set_pmf p\" \"x = f y\""], ["proof (prove)\nusing this:\n  x \\<in> f ` set_pmf p\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set_pmf p; x = f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> set_pmf p\n  x = f y\n\ngoal (2 subgoals):\n 1. x \\<in> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n 2. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "with assms(1)"], ["proof (chain)\npicking this:\n  inj_on f (set_pmf p)\n  y \\<in> set_pmf p\n  x = f y", "have \"pmf (map_pmf f p) x = pmf p y\""], ["proof (prove)\nusing this:\n  inj_on f (set_pmf p)\n  y \\<in> set_pmf p\n  x = f y\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f p) x = pmf p y", "by (simp add: pmf_map_inj)"], ["proof (state)\nthis:\n  pmf (map_pmf f p) x = pmf p y\n\ngoal (2 subgoals):\n 1. x \\<in> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n 2. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "also"], ["proof (state)\nthis:\n  pmf (map_pmf f p) x = pmf p y\n\ngoal (2 subgoals):\n 1. x \\<in> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n 2. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "from y assms(2)[of y]"], ["proof (chain)\npicking this:\n  y \\<in> set_pmf p\n  x = f y\n  f' (f y) = y", "have \"y = f' x\""], ["proof (prove)\nusing this:\n  y \\<in> set_pmf p\n  x = f y\n  f' (f y) = y\n\ngoal (1 subgoal):\n 1. y = f' x", "by simp"], ["proof (state)\nthis:\n  y = f' x\n\ngoal (2 subgoals):\n 1. x \\<in> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n 2. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "finally"], ["proof (chain)\npicking this:\n  pmf (map_pmf f p) x = pmf p (f' x)", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (map_pmf f p) x = pmf p (f' x)\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "using y"], ["proof (prove)\nusing this:\n  pmf (map_pmf f p) x = pmf p (f' x)\n  y \\<in> set_pmf p\n  x = f y\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "by simp"], ["proof (state)\nthis:\n  pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "case False"], ["proof (state)\nthis:\n  x \\<notin> f ` set_pmf p\n\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "hence \"x \\<notin> set_pmf (map_pmf f p)\""], ["proof (prove)\nusing this:\n  x \\<notin> f ` set_pmf p\n\ngoal (1 subgoal):\n 1. x \\<notin> set_pmf (map_pmf f p)", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set_pmf (map_pmf f p)\n\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "hence \"pmf (map_pmf f p) x = 0\""], ["proof (prove)\nusing this:\n  x \\<notin> set_pmf (map_pmf f p)\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f p) x = 0", "by (simp add: set_pmf_eq)"], ["proof (state)\nthis:\n  pmf (map_pmf f p) x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "also"], ["proof (state)\nthis:\n  pmf (map_pmf f p) x = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "from False"], ["proof (chain)\npicking this:\n  x \\<notin> f ` set_pmf p", "have \"0 = (if x \\<in> range f then pmf p (f' x) else 0)\""], ["proof (prove)\nusing this:\n  x \\<notin> f ` set_pmf p\n\ngoal (1 subgoal):\n 1. 0 = (if x \\<in> range f then pmf p (f' x) else 0)", "by (auto simp: assms(2) set_pmf_eq)"], ["proof (state)\nthis:\n  0 = (if x \\<in> range f then pmf p (f' x) else 0)\n\ngoal (1 subgoal):\n 1. x \\<notin> f ` set_pmf p \\<Longrightarrow>\n    pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "finally"], ["proof (chain)\npicking this:\n  pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n\ngoal (1 subgoal):\n 1. pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)", "."], ["proof (state)\nthis:\n  pmf (map_pmf f p) x = (if x \\<in> range f then pmf p (f' x) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* END MOVE *)"], ["", "subsection \\<open>Swapping elements in a list\\<close>"], ["", "definition swap where \"swap xs i j = xs[i := xs!j, j := xs ! i]\""], ["", "lemma length_swap [simp]: \"length (swap xs i j) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (swap xs i j) = length xs", "by (simp add: swap_def)"], ["", "lemma swap_eq_Nil_iff [simp]: \"swap xs i j = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap xs i j = []) = (xs = [])", "by (simp add: swap_def)"], ["", "lemma nth_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> \n    swap xs i j ! k = (if k = i then xs ! j else if k = j then xs ! i else xs ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> swap xs i j ! k =\n                      (if k = i then xs ! j\n                       else if k = j then xs ! i else xs ! k)", "by (auto simp: swap_def nth_list_update)"], ["", "lemma map_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> map f (swap xs i j) = swap (map f xs) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> map f (swap xs i j) = swap (map f xs) i j", "by (simp add: swap_def map_update map_nth)"], ["", "lemma swap_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> swap (swap xs i j) j i = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> swap (swap xs i j) j i = xs", "by (intro nth_equalityI) (auto simp: nth_swap nth_list_update)"], ["", "lemma mset_swap: \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> mset (swap xs i j) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> mset (swap xs i j) = mset xs", "by (simp add: mset_update swap_def nth_list_update)"], ["", "lemma hd_swap_0: \"i < length xs \\<Longrightarrow> hd (swap xs 0 i) = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow> hd (swap xs 0 i) = xs ! i", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    hd (xs[0 := xs ! i, i := xs ! 0]) = xs ! i", "by (subst hd_conv_nth) (subst nth_list_update | force)+"], ["", "subsection \\<open>Random Permutations\\<close>"], ["", "text \\<open>\n  First, we prove the intuitively obvious fact that choosing a random \n  permutation of a multiset can be done by first randomly choosing the \n  first element and then randomly choosing the rest of the list.\n\\<close>"], ["", "lemma pmf_of_set_permutations_of_multiset_nonempty:\n  assumes \"(A :: 'a multiset) \\<noteq> {#}\"\n  shows \"pmf_of_set (permutations_of_multiset A) =\n           do {x \\<leftarrow> pmf_of_multiset A;\n               xs \\<leftarrow> pmf_of_set (permutations_of_multiset (A - {#x#}));\n               return_pmf (x#xs)\n              }\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set (permutations_of_multiset A) =\n    pmf_of_multiset A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n        (\\<lambda>xs. return_pmf (x # xs)))", "proof (rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (pmf_of_set (permutations_of_multiset A)) i =\n       pmf (pmf_of_multiset A \\<bind>\n            (\\<lambda>x.\n                pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n                (\\<lambda>xs. return_pmf (x # xs))))\n        i", "fix xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (pmf_of_set (permutations_of_multiset A)) i =\n       pmf (pmf_of_multiset A \\<bind>\n            (\\<lambda>x.\n                pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n                (\\<lambda>xs. return_pmf (x # xs))))\n        i", "show \"pmf ?lhs xs = pmf ?rhs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "proof (cases \"xs \\<in> permutations_of_multiset A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs\n 2. xs \\<notin> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "case False"], ["proof (state)\nthis:\n  xs \\<notin> permutations_of_multiset A\n\ngoal (2 subgoals):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs\n 2. xs \\<notin> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "with assms"], ["proof (chain)\npicking this:\n  A \\<noteq> {#}\n  xs \\<notin> permutations_of_multiset A", "have \"xs \\<notin> set_pmf ?lhs\""], ["proof (prove)\nusing this:\n  A \\<noteq> {#}\n  xs \\<notin> permutations_of_multiset A\n\ngoal (1 subgoal):\n 1. xs \\<notin> set_pmf (pmf_of_set (permutations_of_multiset A))", "by simp"], ["proof (state)\nthis:\n  xs \\<notin> set_pmf (pmf_of_set (permutations_of_multiset A))\n\ngoal (2 subgoals):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs\n 2. xs \\<notin> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "moreover"], ["proof (state)\nthis:\n  xs \\<notin> set_pmf (pmf_of_set (permutations_of_multiset A))\n\ngoal (2 subgoals):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs\n 2. xs \\<notin> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "from assms False"], ["proof (chain)\npicking this:\n  A \\<noteq> {#}\n  xs \\<notin> permutations_of_multiset A", "have \"xs \\<notin> set_pmf ?rhs\""], ["proof (prove)\nusing this:\n  A \\<noteq> {#}\n  xs \\<notin> permutations_of_multiset A\n\ngoal (1 subgoal):\n 1. xs \\<notin> set_pmf\n                 (pmf_of_multiset A \\<bind>\n                  (\\<lambda>x.\n                      pmf_of_set\n                       (permutations_of_multiset (A - {#x#})) \\<bind>\n                      (\\<lambda>xs. return_pmf (x # xs))))", "by (auto simp: permutations_of_multiset_Cons_iff)"], ["proof (state)\nthis:\n  xs \\<notin> set_pmf\n               (pmf_of_multiset A \\<bind>\n                (\\<lambda>x.\n                    pmf_of_set\n                     (permutations_of_multiset (A - {#x#})) \\<bind>\n                    (\\<lambda>xs. return_pmf (x # xs))))\n\ngoal (2 subgoals):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs\n 2. xs \\<notin> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<notin> set_pmf (pmf_of_set (permutations_of_multiset A))\n  xs \\<notin> set_pmf\n               (pmf_of_multiset A \\<bind>\n                (\\<lambda>x.\n                    pmf_of_set\n                     (permutations_of_multiset (A - {#x#})) \\<bind>\n                    (\\<lambda>xs. return_pmf (x # xs))))", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<notin> set_pmf (pmf_of_set (permutations_of_multiset A))\n  xs \\<notin> set_pmf\n               (pmf_of_multiset A \\<bind>\n                (\\<lambda>x.\n                    pmf_of_set\n                     (permutations_of_multiset (A - {#x#})) \\<bind>\n                    (\\<lambda>xs. return_pmf (x # xs))))\n\ngoal (1 subgoal):\n 1. pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "by (simp add: set_pmf_eq)"], ["proof (state)\nthis:\n  pmf (pmf_of_set (permutations_of_multiset A)) xs =\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "case True"], ["proof (state)\nthis:\n  xs \\<in> permutations_of_multiset A\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "with assms"], ["proof (chain)\npicking this:\n  A \\<noteq> {#}\n  xs \\<in> permutations_of_multiset A", "have nonempty: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  A \\<noteq> {#}\n  xs \\<in> permutations_of_multiset A\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by (auto dest: permutations_of_multisetD)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "hence range_Cons: \"xs \\<in> range ((#) x) \\<longleftrightarrow> hd xs = x\" for x"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (xs \\<in> range ((#) x)) = (hd xs = x)", "by (cases xs) auto"], ["proof (state)\nthis:\n  (xs \\<in> range ((#) ?x)) = (hd xs = ?x)\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "from True nonempty"], ["proof (chain)\npicking this:\n  xs \\<in> permutations_of_multiset A\n  xs \\<noteq> []", "have hd_tl: \"hd xs \\<in># A \\<and> tl xs \\<in> permutations_of_multiset (A - {#hd xs#})\""], ["proof (prove)\nusing this:\n  xs \\<in> permutations_of_multiset A\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd xs \\<in># A \\<and>\n    tl xs \\<in> permutations_of_multiset (A - {#hd xs#})", "by (cases xs) (auto simp: permutations_of_multiset_Cons_iff)"], ["proof (state)\nthis:\n  hd xs \\<in># A \\<and> tl xs \\<in> permutations_of_multiset (A - {#hd xs#})\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "from assms"], ["proof (chain)\npicking this:\n  A \\<noteq> {#}", "have \"pmf ?rhs xs = \n      (\\<Sum>x\\<in>set_mset A. real (count A x) * pmf (map_pmf ((#) x) \n        (pmf_of_set (permutations_of_multiset (A - {#x#})))) xs) / real (size A)\" (is \"_ = ?S / _\")"], ["proof (prove)\nusing this:\n  A \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs =\n    (\\<Sum>x\\<in>set_mset A.\n       real (count A x) *\n       pmf (map_pmf ((#) x)\n             (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n        xs) /\n    real (size A)", "unfolding map_pmf_def [symmetric]"], ["proof (prove)\nusing this:\n  A \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             map_pmf ((#) x)\n              (pmf_of_set (permutations_of_multiset (A - {#x#})))))\n     xs =\n    (\\<Sum>x\\<in>set_mset A.\n       real (count A x) *\n       pmf (map_pmf ((#) x)\n             (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n        xs) /\n    real (size A)", "by (simp add: pmf_bind_pmf_of_multiset)"], ["proof (state)\nthis:\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs =\n  (\\<Sum>x\\<in>set_mset A.\n     real (count A x) *\n     pmf (map_pmf ((#) x)\n           (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n      xs) /\n  real (size A)\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "also"], ["proof (state)\nthis:\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs =\n  (\\<Sum>x\\<in>set_mset A.\n     real (count A x) *\n     pmf (map_pmf ((#) x)\n           (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n      xs) /\n  real (size A)\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "have \"?S = \n      (\\<Sum>x\\<in>set_mset A. if x = hd xs then real (count A (hd xs)) / \n         real (card (permutations_of_multiset (A - {#hd xs#}))) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset A.\n       real (count A x) *\n       pmf (map_pmf ((#) x)\n             (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n        xs) =\n    (\\<Sum>x\\<in>set_mset A.\n       if x = hd xs\n       then real (count A (hd xs)) /\n            real (card (permutations_of_multiset (A - {#hd xs#})))\n       else 0)", "using range_Cons hd_tl"], ["proof (prove)\nusing this:\n  (xs \\<in> range ((#) ?x)) = (hd xs = ?x)\n  hd xs \\<in># A \\<and> tl xs \\<in> permutations_of_multiset (A - {#hd xs#})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset A.\n       real (count A x) *\n       pmf (map_pmf ((#) x)\n             (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n        xs) =\n    (\\<Sum>x\\<in>set_mset A.\n       if x = hd xs\n       then real (count A (hd xs)) /\n            real (card (permutations_of_multiset (A - {#hd xs#})))\n       else 0)", "by (intro sum.cong refl, subst pmf_map_inj_inv[where f' = tl]) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset A.\n     real (count A x) *\n     pmf (map_pmf ((#) x)\n           (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n      xs) =\n  (\\<Sum>x\\<in>set_mset A.\n     if x = hd xs\n     then real (count A (hd xs)) /\n          real (card (permutations_of_multiset (A - {#hd xs#})))\n     else 0)\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset A.\n     real (count A x) *\n     pmf (map_pmf ((#) x)\n           (pmf_of_set (permutations_of_multiset (A - {#x#}))))\n      xs) =\n  (\\<Sum>x\\<in>set_mset A.\n     if x = hd xs\n     then real (count A (hd xs)) /\n          real (card (permutations_of_multiset (A - {#hd xs#})))\n     else 0)\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "have \"\\<dots> = real (count A (hd xs)) / \n                      real (card (permutations_of_multiset (A - {#hd xs#})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset A.\n       if x = hd xs\n       then real (count A (hd xs)) /\n            real (card (permutations_of_multiset (A - {#hd xs#})))\n       else 0) =\n    real (count A (hd xs)) /\n    real (card (permutations_of_multiset (A - {#hd xs#})))", "using hd_tl"], ["proof (prove)\nusing this:\n  hd xs \\<in># A \\<and> tl xs \\<in> permutations_of_multiset (A - {#hd xs#})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set_mset A.\n       if x = hd xs\n       then real (count A (hd xs)) /\n            real (card (permutations_of_multiset (A - {#hd xs#})))\n       else 0) =\n    real (count A (hd xs)) /\n    real (card (permutations_of_multiset (A - {#hd xs#})))", "by (simp add: sum.delta)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset A.\n     if x = hd xs\n     then real (count A (hd xs)) /\n          real (card (permutations_of_multiset (A - {#hd xs#})))\n     else 0) =\n  real (count A (hd xs)) /\n  real (card (permutations_of_multiset (A - {#hd xs#})))\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set_mset A.\n     if x = hd xs\n     then real (count A (hd xs)) /\n          real (card (permutations_of_multiset (A - {#hd xs#})))\n     else 0) =\n  real (count A (hd xs)) /\n  real (card (permutations_of_multiset (A - {#hd xs#})))\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "from hd_tl"], ["proof (chain)\npicking this:\n  hd xs \\<in># A \\<and> tl xs \\<in> permutations_of_multiset (A - {#hd xs#})", "have \"\\<dots> = real (size A) / real (card (permutations_of_multiset A))\""], ["proof (prove)\nusing this:\n  hd xs \\<in># A \\<and> tl xs \\<in> permutations_of_multiset (A - {#hd xs#})\n\ngoal (1 subgoal):\n 1. real (count A (hd xs)) /\n    real (card (permutations_of_multiset (A - {#hd xs#}))) =\n    real (size A) / real (card (permutations_of_multiset A))", "by (simp add: divide_simps real_card_permutations_of_multiset_remove[of \"hd xs\"])"], ["proof (state)\nthis:\n  real (count A (hd xs)) /\n  real (card (permutations_of_multiset (A - {#hd xs#}))) =\n  real (size A) / real (card (permutations_of_multiset A))\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "also"], ["proof (state)\nthis:\n  real (count A (hd xs)) /\n  real (card (permutations_of_multiset (A - {#hd xs#}))) =\n  real (size A) / real (card (permutations_of_multiset A))\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "have \" \\<dots> / real (size A) = pmf (pmf_of_set (permutations_of_multiset A)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (size A) / real (card (permutations_of_multiset A)) /\n    real (size A) =\n    pmf (pmf_of_set (permutations_of_multiset A)) xs", "using assms True"], ["proof (prove)\nusing this:\n  A \\<noteq> {#}\n  xs \\<in> permutations_of_multiset A\n\ngoal (1 subgoal):\n 1. real (size A) / real (card (permutations_of_multiset A)) /\n    real (size A) =\n    pmf (pmf_of_set (permutations_of_multiset A)) xs", "by simp"], ["proof (state)\nthis:\n  real (size A) / real (card (permutations_of_multiset A)) / real (size A) =\n  pmf (pmf_of_set (permutations_of_multiset A)) xs\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_multiset A \\<Longrightarrow>\n    pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", "finally"], ["proof (chain)\npicking this:\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs =\n  pmf (pmf_of_set (permutations_of_multiset A)) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs =\n  pmf (pmf_of_set (permutations_of_multiset A)) xs\n\ngoal (1 subgoal):\n 1. pmf (pmf_of_set (permutations_of_multiset A)) xs =\n    pmf (pmf_of_multiset A \\<bind>\n         (\\<lambda>x.\n             pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n             (\\<lambda>xs. return_pmf (x # xs))))\n     xs", ".."], ["proof (state)\nthis:\n  pmf (pmf_of_set (permutations_of_multiset A)) xs =\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf (pmf_of_set (permutations_of_multiset A)) xs =\n  pmf (pmf_of_multiset A \\<bind>\n       (\\<lambda>x.\n           pmf_of_set (permutations_of_multiset (A - {#x#})) \\<bind>\n           (\\<lambda>xs. return_pmf (x # xs))))\n   xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Shuffling Lists\\<close>"], ["", "text \\<open>\n  We define shuffling of a list as choosing from the set of all lists\n  that correspond to the same multiset uniformly at random.\n\\<close>"], ["", "definition shuffle :: \"'a list \\<Rightarrow> 'a list pmf\" where\n  \"shuffle xs = pmf_of_set (permutations_of_multiset (mset xs))\""], ["", "lemma shuffle_empty [simp]: \"shuffle [] = return_pmf []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shuffle [] = return_pmf []", "by (simp add: shuffle_def pmf_of_set_singleton)"], ["", "lemma shuffle_singleton [simp]: \"shuffle [x] = return_pmf [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shuffle [x] = return_pmf [x]", "by (simp add: shuffle_def pmf_of_set_singleton)"], ["", "text \\<open>\n  The crucial ingredient of the Fisher--Yates shuffle is the following lemma,\n  which decomposes a shuffle into swapping the first element of the list with \n  a random element of the remaining list and shuffling the new remaining list.\n\n  With a random-access implementation of a list -- such as an array -- all of\n  the required operations are cheap and the resulting algorithm runs in linear \n  time. \n\\<close>"], ["", "lemma shuffle_fisher_yates_step:\n  assumes xs_nonempty [simp]: \"xs \\<noteq> []\"\n  shows \"shuffle xs =  \n           do {i \\<leftarrow> pmf_of_set {..<length xs}; \n               let ys = swap xs 0 i; \n               zs \\<leftarrow> shuffle (tl ys);\n               return_pmf (hd ys # zs)\n              }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "have \"shuffle xs = do {x \\<leftarrow> pmf_of_multiset (mset xs);\n             xs \\<leftarrow> pmf_of_set (permutations_of_multiset (mset xs - {#x#}));\n             return_pmf (x#xs)\n            }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_multiset (mset xs) \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n        (\\<lambda>xs. return_pmf (x # xs)))", "unfolding shuffle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set (permutations_of_multiset (mset xs)) =\n    pmf_of_multiset (mset xs) \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n        (\\<lambda>xs. return_pmf (x # xs)))", "by (simp add: pmf_of_set_permutations_of_multiset_nonempty)"], ["proof (state)\nthis:\n  shuffle xs =\n  pmf_of_multiset (mset xs) \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n      (\\<lambda>xs. return_pmf (x # xs)))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "also"], ["proof (state)\nthis:\n  shuffle xs =\n  pmf_of_multiset (mset xs) \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n      (\\<lambda>xs. return_pmf (x # xs)))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "have \"pmf_of_multiset (mset xs) = \n               pmf_of_multiset (image_mset ((!) xs) (mset (upt 0 (length xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_multiset (mset xs) =\n    pmf_of_multiset (image_mset ((!) xs) (mset [0..<length xs]))", "by (subst mset_map [symmetric]) (simp add: map_nth)"], ["proof (state)\nthis:\n  pmf_of_multiset (mset xs) =\n  pmf_of_multiset (image_mset ((!) xs) (mset [0..<length xs]))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "also"], ["proof (state)\nthis:\n  pmf_of_multiset (mset xs) =\n  pmf_of_multiset (image_mset ((!) xs) (mset [0..<length xs]))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "have \"\\<dots> = map_pmf ((!) xs) (pmf_of_set {..<length xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_multiset (image_mset ((!) xs) (mset [0..<length xs])) =\n    map_pmf ((!) xs) (pmf_of_set {..<length xs})", "by (subst map_pmf_of_set) (auto simp add: map_pmf_of_set atLeast0LessThan lessThan_empty_iff)"], ["proof (state)\nthis:\n  pmf_of_multiset (image_mset ((!) xs) (mset [0..<length xs])) =\n  map_pmf ((!) xs) (pmf_of_set {..<length xs})\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "also"], ["proof (state)\nthis:\n  pmf_of_multiset (image_mset ((!) xs) (mset [0..<length xs])) =\n  map_pmf ((!) xs) (pmf_of_set {..<length xs})\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "have \"do {x \\<leftarrow> map_pmf ((!) xs) (pmf_of_set {..<length xs});\n                 ys \\<leftarrow> pmf_of_set (permutations_of_multiset (mset xs - {#x#}));\n                 return_pmf (x # ys)\n                } = \n             do {i \\<leftarrow> pmf_of_set {..<length xs};\n                 ys \\<leftarrow> pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#}));\n                 return_pmf (xs ! i # ys)\n                }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ((!) xs) (pmf_of_set {..<length xs}) \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n        (\\<lambda>ys. return_pmf (x # ys))) =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#})) \\<bind>\n        (\\<lambda>ys. return_pmf (xs ! i # ys)))", "by (simp add: map_pmf_def bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  map_pmf ((!) xs) (pmf_of_set {..<length xs}) \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n      (\\<lambda>ys. return_pmf (x # ys))) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#})) \\<bind>\n      (\\<lambda>ys. return_pmf (xs ! i # ys)))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "also"], ["proof (state)\nthis:\n  map_pmf ((!) xs) (pmf_of_set {..<length xs}) \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_multiset (mset xs - {#x#})) \\<bind>\n      (\\<lambda>ys. return_pmf (x # ys))) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#})) \\<bind>\n      (\\<lambda>ys. return_pmf (xs ! i # ys)))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "have \"\\<dots> = do {i \\<leftarrow> pmf_of_set {..<length xs};\n                      let ys = swap xs 0 i; \n                      zs \\<leftarrow> shuffle (tl (swap xs 0 i));\n                      return_pmf (hd ys # zs)\n                     }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#})) \\<bind>\n        (\\<lambda>ys. return_pmf (xs ! i # ys))) =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl (swap xs 0 i)) \\<bind>\n           (\\<lambda>zs. return_pmf (hd ys # zs)))", "unfolding Let_def shuffle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#})) \\<bind>\n        (\\<lambda>ys. return_pmf (xs ! i # ys))) =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        pmf_of_set\n         (permutations_of_multiset (mset (tl (swap xs 0 i)))) \\<bind>\n        (\\<lambda>zs. return_pmf (hd (swap xs 0 i) # zs)))", "by (intro bind_pmf_cong refl, subst (asm) set_pmf_of_set)\n       (auto simp: lessThan_empty_iff mset_tl mset_swap hd_swap_0)"], ["proof (state)\nthis:\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      pmf_of_set (permutations_of_multiset (mset xs - {#xs ! i#})) \\<bind>\n      (\\<lambda>ys. return_pmf (xs ! i # ys))) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      let ys = swap xs 0 i\n      in shuffle (tl (swap xs 0 i)) \\<bind>\n         (\\<lambda>zs. return_pmf (hd ys # zs)))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "finally"], ["proof (chain)\npicking this:\n  shuffle xs =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      let ys = swap xs 0 i\n      in shuffle (tl (swap xs 0 i)) \\<bind>\n         (\\<lambda>zs. return_pmf (hd ys # zs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  shuffle xs =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      let ys = swap xs 0 i\n      in shuffle (tl (swap xs 0 i)) \\<bind>\n         (\\<lambda>zs. return_pmf (hd ys # zs)))\n\ngoal (1 subgoal):\n 1. shuffle xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let ys = swap xs 0 i\n        in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  shuffle xs =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      let ys = swap xs 0 i\n      in shuffle (tl ys) \\<bind> (\\<lambda>zs. return_pmf (hd ys # zs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Forward Fisher-Yates Shuffle\\<close>"], ["", "text \\<open>\n  The actual Fisher--Yates shuffle is now merely a kind of tail-recursive version of\n  decomposition described above. Note that unlike the traditional Fisher--Yates shuffle, \n  we shuffle the list from front to back, which is the more natural way to do it when \n  working with linked lists.\n\\<close>"], ["", "function fisher_yates_aux where\n  \"fisher_yates_aux i xs = (if i + 1 \\<ge> length xs then return_pmf xs else \n     do {j \\<leftarrow> pmf_of_set {i..<length xs};\n         fisher_yates_aux (i + 1) (swap xs i j)})\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i xs. x = (i, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i xs ia xsa.\n       (i, xs) = (ia, xsa) \\<Longrightarrow>\n       (if length xs \\<le> i + 1 then return_pmf xs\n        else pmf_of_set {i..<length xs} \\<bind>\n             (\\<lambda>j. fisher_yates_aux_sumC (i + 1, swap xs i j))) =\n       (if length xsa \\<le> ia + 1 then return_pmf xsa\n        else pmf_of_set {ia..<length xsa} \\<bind>\n             (\\<lambda>j. fisher_yates_aux_sumC (ia + 1, swap xsa ia j)))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All fisher_yates_aux_dom", "by (relation \"Wellfounded.measure (\\<lambda>(i,xs). length xs - i)\") simp_all"], ["", "declare fisher_yates_aux.simps [simp del]"], ["", "lemma fisher_yates_aux_correct:\n  \"fisher_yates_aux i xs = map_pmf (\\<lambda>ys. take i xs @ ys) (shuffle (drop i xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "proof (induction i xs rule: fisher_yates_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       (\\<And>x.\n           \\<lbrakk>\\<not> length xs \\<le> i + 1;\n            x \\<in> set_pmf (pmf_of_set {i..<length xs})\\<rbrakk>\n           \\<Longrightarrow> fisher_yates_aux (i + 1) (swap xs i x) =\n                             map_pmf ((@) (take (i + 1) (swap xs i x)))\n                              (shuffle\n                                (drop (i + 1)\n                                  (swap xs i x)))) \\<Longrightarrow>\n       fisher_yates_aux i xs =\n       map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "case (1 i xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> length xs \\<le> i + 1;\n   ?x \\<in> set_pmf (pmf_of_set {i..<length xs})\\<rbrakk>\n  \\<Longrightarrow> fisher_yates_aux (i + 1) (swap xs i ?x) =\n                    map_pmf ((@) (take (i + 1) (swap xs i ?x)))\n                     (shuffle (drop (i + 1) (swap xs i ?x)))\n\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       (\\<And>x.\n           \\<lbrakk>\\<not> length xs \\<le> i + 1;\n            x \\<in> set_pmf (pmf_of_set {i..<length xs})\\<rbrakk>\n           \\<Longrightarrow> fisher_yates_aux (i + 1) (swap xs i x) =\n                             map_pmf ((@) (take (i + 1) (swap xs i x)))\n                              (shuffle\n                                (drop (i + 1)\n                                  (swap xs i x)))) \\<Longrightarrow>\n       fisher_yates_aux i xs =\n       map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "proof (cases \"i + 1 \\<ge> length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "case True"], ["proof (state)\nthis:\n  length xs \\<le> i + 1\n\ngoal (2 subgoals):\n 1. length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "proof (cases \"i \\<ge> length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "case False"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> i\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "with True"], ["proof (chain)\npicking this:\n  length xs \\<le> i + 1\n  \\<not> length xs \\<le> i", "have \"length xs = Suc i\" and i: \"i = length xs - 1\""], ["proof (prove)\nusing this:\n  length xs \\<le> i + 1\n  \\<not> length xs \\<le> i\n\ngoal (1 subgoal):\n 1. length xs = Suc i &&& i = length xs - 1", "by simp_all"], ["proof (state)\nthis:\n  length xs = Suc i\n  i = length xs - 1\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "hence \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  length xs = Suc i\n  i = length xs - 1\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "hence \"xs = butlast xs @ [last xs]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs = butlast xs @ [last xs]", "by (rule append_butlast_last_id [symmetric])"], ["proof (state)\nthis:\n  xs = butlast xs @ [last xs]\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  xs = butlast xs @ [last xs]\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "have \"butlast xs = take i xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast xs = take i xs", "by (simp add: butlast_conv_take i)"], ["proof (state)\nthis:\n  butlast xs = take i xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "finally"], ["proof (chain)\npicking this:\n  xs = take i xs @ [last xs]", "have eq: \"take i xs @ [last xs] = xs\""], ["proof (prove)\nusing this:\n  xs = take i xs @ [last xs]\n\ngoal (1 subgoal):\n 1. take i xs @ [last xs] = xs", ".."], ["proof (state)\nthis:\n  take i xs @ [last xs] = xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "moreover"], ["proof (state)\nthis:\n  take i xs @ [last xs] = xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "have \"xs = take i xs @ drop i xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take i xs @ drop i xs", "by simp"], ["proof (state)\nthis:\n  xs = take i xs @ drop i xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "ultimately"], ["proof (chain)\npicking this:\n  take i xs @ [last xs] = xs\n  xs = take i xs @ drop i xs", "have \"take i xs @ [last xs] = take i xs @ drop i xs\""], ["proof (prove)\nusing this:\n  take i xs @ [last xs] = xs\n  xs = take i xs @ drop i xs\n\ngoal (1 subgoal):\n 1. take i xs @ [last xs] = take i xs @ drop i xs", "by (rule trans)"], ["proof (state)\nthis:\n  take i xs @ [last xs] = take i xs @ drop i xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "hence \"drop i xs = [last xs]\""], ["proof (prove)\nusing this:\n  take i xs @ [last xs] = take i xs @ drop i xs\n\ngoal (1 subgoal):\n 1. drop i xs = [last xs]", "by (subst (asm) same_append_eq) simp_all"], ["proof (state)\nthis:\n  drop i xs = [last xs]\n\ngoal (2 subgoals):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n 2. \\<not> length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "with True"], ["proof (chain)\npicking this:\n  length xs \\<le> i + 1\n  drop i xs = [last xs]", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs \\<le> i + 1\n  drop i xs = [last xs]\n\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "by (simp add: eq fisher_yates_aux.simps)"], ["proof (state)\nthis:\n  fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n\ngoal (1 subgoal):\n 1. length xs \\<le> i \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "qed (simp_all add: fisher_yates_aux.simps)"], ["proof (state)\nthis:\n  fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "case False"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "from False"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1", "have xs_nonempty [simp]: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "have \"fisher_yates_aux i xs = \n             pmf_of_set {i..<length xs} \\<bind> (\\<lambda>j. fisher_yates_aux (i+1) (swap xs i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs =\n    pmf_of_set {i..<length xs} \\<bind>\n    (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j))", "using False"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs =\n    pmf_of_set {i..<length xs} \\<bind>\n    (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j))", "by (subst fisher_yates_aux.simps) simp"], ["proof (state)\nthis:\n  fisher_yates_aux i xs =\n  pmf_of_set {i..<length xs} \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  fisher_yates_aux i xs =\n  pmf_of_set {i..<length xs} \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "have \"{i..<length xs} = ((\\<lambda>j. j + i) ` {..<length xs - i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i..<length xs} = (\\<lambda>j. j + i) ` {..<length xs - i}", "using False"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. {i..<length xs} = (\\<lambda>j. j + i) ` {..<length xs - i}", "by (simp add: lessThan_atLeast0)"], ["proof (state)\nthis:\n  {i..<length xs} = (\\<lambda>j. j + i) ` {..<length xs - i}\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  {i..<length xs} = (\\<lambda>j. j + i) ` {..<length xs - i}\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "from False"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1", "have \"pmf_of_set \\<dots> = map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length xs - i})\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. pmf_of_set ((\\<lambda>j. j + i) ` {..<length xs - i}) =\n    map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length xs - i})", "by (subst map_pmf_of_set_inj) (simp_all add: lessThan_empty_iff)"], ["proof (state)\nthis:\n  pmf_of_set ((\\<lambda>j. j + i) ` {..<length xs - i}) =\n  map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length xs - i})\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  pmf_of_set ((\\<lambda>j. j + i) ` {..<length xs - i}) =\n  map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length xs - i})\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "from False"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1", "have \"length xs - i = length (drop i xs)\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. length xs - i = length (drop i xs)", "by simp"], ["proof (state)\nthis:\n  length xs - i = length (drop i xs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  length xs - i = length (drop i xs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "have \"map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length (drop i xs)}) \\<bind>\n                   (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j)) =\n               pmf_of_set {..<length (drop i xs)} \\<bind> (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j+i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length (drop i xs)}) \\<bind>\n    (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j)) =\n    pmf_of_set {..<length (drop i xs)} \\<bind>\n    (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j + i)))", "by (simp add: map_pmf_def bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length (drop i xs)}) \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j)) =\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j + i)))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>j. j + i) (pmf_of_set {..<length (drop i xs)}) \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i j)) =\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j + i)))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "have \"\\<dots> = do {j \\<leftarrow> pmf_of_set {..<length (drop i xs)};\n                        let ys = swap (drop i xs) 0 j;\n                        zs \\<leftarrow> shuffle (tl ys);\n                        return_pmf (take i xs @ hd ys # zs)}\" (is \"_ = bind_pmf _ ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<length (drop i xs)} \\<bind>\n    (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j + i))) =\n    pmf_of_set {..<length (drop i xs)} \\<bind>\n    (\\<lambda>j.\n        let ys = swap (drop i xs) 0 j\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "proof (intro bind_pmf_cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "assume \"j \\<in> set_pmf (pmf_of_set {..<length (drop i xs)})\""], ["proof (state)\nthis:\n  j \\<in> set_pmf (pmf_of_set {..<length (drop i xs)})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "with False"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1\n  j \\<in> set_pmf (pmf_of_set {..<length (drop i xs)})", "have j: \"j < length (drop i xs)\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n  j \\<in> set_pmf (pmf_of_set {..<length (drop i xs)})\n\ngoal (1 subgoal):\n 1. j < length (drop i xs)", "by (simp_all add: lessThan_empty_iff)"], ["proof (state)\nthis:\n  j < length (drop i xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "define ys where \"ys = swap xs i (j + i)\""], ["proof (state)\nthis:\n  ys = swap xs i (j + i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "have \"fisher_yates_aux (i + 1) ys = map_pmf ((@) (take (i+1) ys)) (shuffle (drop (i+1) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_aux (i + 1) ys =\n    map_pmf ((@) (take (i + 1) ys)) (shuffle (drop (i + 1) ys))", "using False j"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n  j < length (drop i xs)\n\ngoal (1 subgoal):\n 1. fisher_yates_aux (i + 1) ys =\n    map_pmf ((@) (take (i + 1) ys)) (shuffle (drop (i + 1) ys))", "unfolding ys_def"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n  j < length (drop i xs)\n\ngoal (1 subgoal):\n 1. fisher_yates_aux (i + 1) (swap xs i (j + i)) =\n    map_pmf ((@) (take (i + 1) (swap xs i (j + i))))\n     (shuffle (drop (i + 1) (swap xs i (j + i))))", "by (intro \"1.IH\") simp_all"], ["proof (state)\nthis:\n  fisher_yates_aux (i + 1) ys =\n  map_pmf ((@) (take (i + 1) ys)) (shuffle (drop (i + 1) ys))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "also"], ["proof (state)\nthis:\n  fisher_yates_aux (i + 1) ys =\n  map_pmf ((@) (take (i + 1) ys)) (shuffle (drop (i + 1) ys))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "from False"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1", "have \"take (i+1) ys = take i ys @ [hd (drop i ys)]\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. take (i + 1) ys = take i ys @ [hd (drop i ys)]", "by (simp add: ys_def take_hd_drop)"], ["proof (state)\nthis:\n  take (i + 1) ys = take i ys @ [hd (drop i ys)]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "also"], ["proof (state)\nthis:\n  take (i + 1) ys = take i ys @ [hd (drop i ys)]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "have \"drop (i+1) ys = tl (drop i ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (i + 1) ys = tl (drop i ys)", "by (simp add: ys_def tl_drop drop_Suc)"], ["proof (state)\nthis:\n  drop (i + 1) ys = tl (drop i ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "also"], ["proof (state)\nthis:\n  drop (i + 1) ys = tl (drop i ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "from False j"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1\n  j < length (drop i xs)", "have \"drop i ys = swap (drop i xs) 0 j\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n  j < length (drop i xs)\n\ngoal (1 subgoal):\n 1. drop i ys = swap (drop i xs) 0 j", "by (simp add: ys_def swap_def drop_update_swap add_ac)"], ["proof (state)\nthis:\n  drop i ys = swap (drop i xs) 0 j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "also"], ["proof (state)\nthis:\n  drop i ys = swap (drop i xs) 0 j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "from False j"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1\n  j < length (drop i xs)", "have \"take i ys = take i xs\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n  j < length (drop i xs)\n\ngoal (1 subgoal):\n 1. take i ys = take i xs", "by (simp add: ys_def swap_def)"], ["proof (state)\nthis:\n  take i ys = take i xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf\n                (pmf_of_set {..<length (drop i xs)}) \\<Longrightarrow>\n       fisher_yates_aux (i + 1) (swap xs i (x + i)) =\n       (let ys = swap (drop i xs) 0 x\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "finally"], ["proof (chain)\npicking this:\n  fisher_yates_aux (i + 1) ys =\n  map_pmf ((@) (take i xs @ [hd (swap (drop i xs) 0 j)]))\n   (shuffle (tl (swap (drop i xs) 0 j)))", "show \"fisher_yates_aux (i + 1) ys = ?T j\""], ["proof (prove)\nusing this:\n  fisher_yates_aux (i + 1) ys =\n  map_pmf ((@) (take i xs @ [hd (swap (drop i xs) 0 j)]))\n   (shuffle (tl (swap (drop i xs) 0 j)))\n\ngoal (1 subgoal):\n 1. fisher_yates_aux (i + 1) ys =\n    (let ys = swap (drop i xs) 0 j\n     in shuffle (tl ys) \\<bind>\n        (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))", "by (simp add: ys_def map_pmf_def Let_def bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  fisher_yates_aux (i + 1) ys =\n  (let ys = swap (drop i xs) 0 j\n   in shuffle (tl ys) \\<bind>\n      (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j + i))) =\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j.\n      let ys = swap (drop i xs) 0 j\n      in shuffle (tl ys) \\<bind>\n         (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "also"], ["proof (state)\nthis:\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j. fisher_yates_aux (i + 1) (swap xs i (j + i))) =\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j.\n      let ys = swap (drop i xs) 0 j\n      in shuffle (tl ys) \\<bind>\n         (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs)))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "from False"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> i + 1", "have \"\\<dots> = map_pmf (\\<lambda>zs. take i xs @ zs) (shuffle (drop i xs))\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> i + 1\n\ngoal (1 subgoal):\n 1. pmf_of_set {..<length (drop i xs)} \\<bind>\n    (\\<lambda>j.\n        let ys = swap (drop i xs) 0 j\n        in shuffle (tl ys) \\<bind>\n           (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs))) =\n    map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "by (subst shuffle_fisher_yates_step[of \"drop i xs\"])\n         (simp_all add: map_pmf_def Let_def bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  pmf_of_set {..<length (drop i xs)} \\<bind>\n  (\\<lambda>j.\n      let ys = swap (drop i xs) 0 j\n      in shuffle (tl ys) \\<bind>\n         (\\<lambda>zs. return_pmf (take i xs @ hd ys # zs))) =\n  map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> i + 1 \\<Longrightarrow>\n    fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "finally"], ["proof (chain)\npicking this:\n  fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n\ngoal (1 subgoal):\n 1. fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))", "."], ["proof (state)\nthis:\n  fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fisher_yates_aux i xs = map_pmf ((@) (take i xs)) (shuffle (drop i xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition fisher_yates where\n  \"fisher_yates = fisher_yates_aux 0\""], ["", "lemma fisher_yates_correct: \"fisher_yates xs = shuffle xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates xs = shuffle xs", "unfolding fisher_yates_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_aux 0 xs = shuffle xs", "by (subst fisher_yates_aux_correct) (simp_all add: map_pmf_def bind_return_pmf')"], ["", "subsection \\<open>Backwards Fisher-Yates Shuffle\\<close>"], ["", "text \\<open>\n  We can now easily derive the classical Fisher--Yates shuffle, which goes through \n  the list from back to front and show its equivalence to the forward Fisher--Yates\n  shuffle.\n\\<close>"], ["", "fun fisher_yates_alt_aux where\n  \"fisher_yates_alt_aux i xs = (if i = 0 then return_pmf xs else \n     do {j \\<leftarrow> pmf_of_set {..i};\n         fisher_yates_alt_aux (i - 1) (swap xs i j)})\""], ["", "declare fisher_yates_alt_aux.simps [simp del]"], ["", "lemma fisher_yates_alt_aux_altdef:\n  \"i < length xs \\<Longrightarrow> fisher_yates_alt_aux i xs = \n     map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "proof (induction i xs rule: fisher_yates_alt_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>i \\<noteq> 0;\n                    x \\<in> set_pmf (pmf_of_set {..i});\n                    i - 1 < length (swap xs i x)\\<rbrakk>\n                   \\<Longrightarrow> fisher_yates_alt_aux (i - 1)\n(swap xs i x) =\n                                     map_pmf rev\n(fisher_yates_aux (length (swap xs i x) - (i - 1) - 1) (rev (swap xs i x)));\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> fisher_yates_alt_aux i xs =\n                         map_pmf rev\n                          (fisher_yates_aux (length xs - i - 1) (rev xs))", "case (1 i xs)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<noteq> 0; ?x \\<in> set_pmf (pmf_of_set {..i});\n   i - 1 < length (swap xs i ?x)\\<rbrakk>\n  \\<Longrightarrow> fisher_yates_alt_aux (i - 1) (swap xs i ?x) =\n                    map_pmf rev\n                     (fisher_yates_aux (length (swap xs i ?x) - (i - 1) - 1)\n                       (rev (swap xs i ?x)))\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>i \\<noteq> 0;\n                    x \\<in> set_pmf (pmf_of_set {..i});\n                    i - 1 < length (swap xs i x)\\<rbrakk>\n                   \\<Longrightarrow> fisher_yates_alt_aux (i - 1)\n(swap xs i x) =\n                                     map_pmf rev\n(fisher_yates_aux (length (swap xs i x) - (i - 1) - 1) (rev (swap xs i x)));\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> fisher_yates_alt_aux i xs =\n                         map_pmf rev\n                          (fisher_yates_aux (length xs - i - 1) (rev xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "with \"1.prems\""], ["proof (chain)\npicking this:\n  i < length xs\n  i \\<noteq> 0", "have \"map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs)) = \n      pmf_of_set {length xs - Suc i..<length xs} \\<bind>\n        (\\<lambda>x. fisher_yates_aux (Suc (length xs - Suc i))\n          (swap (rev xs) (length xs - Suc i) x) \\<bind>\n            (\\<lambda>x. return_pmf (rev x)))\""], ["proof (prove)\nusing this:\n  i < length xs\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs)) =\n    pmf_of_set {length xs - Suc i..<length xs} \\<bind>\n    (\\<lambda>x.\n        fisher_yates_aux (Suc (length xs - Suc i))\n         (swap (rev xs) (length xs - Suc i) x) \\<bind>\n        (\\<lambda>x. return_pmf (rev x)))", "by (subst fisher_yates_aux.simps) (auto simp: map_pmf_def bind_return_pmf bind_assoc_pmf)"], ["proof (state)\nthis:\n  map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs)) =\n  pmf_of_set {length xs - Suc i..<length xs} \\<bind>\n  (\\<lambda>x.\n      fisher_yates_aux (Suc (length xs - Suc i))\n       (swap (rev xs) (length xs - Suc i) x) \\<bind>\n      (\\<lambda>x. return_pmf (rev x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "also"], ["proof (state)\nthis:\n  map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs)) =\n  pmf_of_set {length xs - Suc i..<length xs} \\<bind>\n  (\\<lambda>x.\n      fisher_yates_aux (Suc (length xs - Suc i))\n       (swap (rev xs) (length xs - Suc i) x) \\<bind>\n      (\\<lambda>x. return_pmf (rev x)))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "from \"1.prems\" False"], ["proof (chain)\npicking this:\n  i < length xs\n  i \\<noteq> 0", "have bij: \"bij_betw (\\<lambda>j. length xs - Suc j) {..i} {length xs - Suc i..<length xs}\""], ["proof (prove)\nusing this:\n  i < length xs\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>j. length xs - Suc j) {..i}\n     {length xs - Suc i..<length xs}", "by (intro bij_betwI[where g = \"\\<lambda>j. length xs - Suc j\"]) auto"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>j. length xs - Suc j) {..i}\n   {length xs - Suc i..<length xs}\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "from bij"], ["proof (chain)\npicking this:\n  bij_betw (\\<lambda>j. length xs - Suc j) {..i}\n   {length xs - Suc i..<length xs}", "have \"{length xs - Suc i..<length xs} = (\\<lambda>j. length xs - Suc j) ` {..i}\""], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>j. length xs - Suc j) {..i}\n   {length xs - Suc i..<length xs}\n\ngoal (1 subgoal):\n 1. {length xs - Suc i..<length xs} =\n    (\\<lambda>j. length xs - Suc j) ` {..i}", "by (simp add: bij_betw_def)"], ["proof (state)\nthis:\n  {length xs - Suc i..<length xs} = (\\<lambda>j. length xs - Suc j) ` {..i}\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "also"], ["proof (state)\nthis:\n  {length xs - Suc i..<length xs} = (\\<lambda>j. length xs - Suc j) ` {..i}\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "from bij"], ["proof (chain)\npicking this:\n  bij_betw (\\<lambda>j. length xs - Suc j) {..i}\n   {length xs - Suc i..<length xs}", "have \"pmf_of_set \\<dots> = map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i})\""], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>j. length xs - Suc j) {..i}\n   {length xs - Suc i..<length xs}\n\ngoal (1 subgoal):\n 1. pmf_of_set ((\\<lambda>j. length xs - Suc j) ` {..i}) =\n    map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i})", "by (subst map_pmf_of_set_inj) (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  pmf_of_set ((\\<lambda>j. length xs - Suc j) ` {..i}) =\n  map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i})\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "also"], ["proof (state)\nthis:\n  pmf_of_set ((\\<lambda>j. length xs - Suc j) ` {..i}) =\n  map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i})\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "have \"map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i}) \\<bind>\n                 (\\<lambda>x. fisher_yates_aux (Suc (length xs - Suc i))\n                   (swap (rev xs) (length xs - Suc i) x) \\<bind> (\\<lambda>x. return_pmf (rev x))) =\n               pmf_of_set {..i} \\<bind> (\\<lambda>x. map_pmf rev (\n                 fisher_yates_aux (length xs - i) (rev (swap xs i x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i}) \\<bind>\n    (\\<lambda>x.\n        fisher_yates_aux (Suc (length xs - Suc i))\n         (swap (rev xs) (length xs - Suc i) x) \\<bind>\n        (\\<lambda>x. return_pmf (rev x))) =\n    pmf_of_set {..i} \\<bind>\n    (\\<lambda>x.\n        map_pmf rev (fisher_yates_aux (length xs - i) (rev (swap xs i x))))", "using \"1.prems\" False"], ["proof (prove)\nusing this:\n  i < length xs\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i}) \\<bind>\n    (\\<lambda>x.\n        fisher_yates_aux (Suc (length xs - Suc i))\n         (swap (rev xs) (length xs - Suc i) x) \\<bind>\n        (\\<lambda>x. return_pmf (rev x))) =\n    pmf_of_set {..i} \\<bind>\n    (\\<lambda>x.\n        map_pmf rev (fisher_yates_aux (length xs - i) (rev (swap xs i x))))", "by (auto simp add: map_pmf_def bind_assoc_pmf bind_return_pmf Suc_diff_Suc\n            swap_def rev_update rev_nth intro!: bind_pmf_cong)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i}) \\<bind>\n  (\\<lambda>x.\n      fisher_yates_aux (Suc (length xs - Suc i))\n       (swap (rev xs) (length xs - Suc i) x) \\<bind>\n      (\\<lambda>x. return_pmf (rev x))) =\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>x.\n      map_pmf rev (fisher_yates_aux (length xs - i) (rev (swap xs i x))))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>j. length xs - Suc j) (pmf_of_set {..i}) \\<bind>\n  (\\<lambda>x.\n      fisher_yates_aux (Suc (length xs - Suc i))\n       (swap (rev xs) (length xs - Suc i) x) \\<bind>\n      (\\<lambda>x. return_pmf (rev x))) =\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>x.\n      map_pmf rev (fisher_yates_aux (length xs - i) (rev (swap xs i x))))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "have \"\\<dots> = pmf_of_set {..i} \\<bind> (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..i} \\<bind>\n    (\\<lambda>x.\n        map_pmf rev\n         (fisher_yates_aux (length xs - i) (rev (swap xs i x)))) =\n    pmf_of_set {..i} \\<bind>\n    (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j))", "using \"1.prems\" False \"1.IH\" [symmetric]"], ["proof (prove)\nusing this:\n  i < length xs\n  i \\<noteq> 0\n  \\<lbrakk>i \\<noteq> 0; ?x \\<in> set_pmf (pmf_of_set {..i});\n   i - 1 < length (swap xs i ?x)\\<rbrakk>\n  \\<Longrightarrow> map_pmf rev\n                     (fisher_yates_aux (length (swap xs i ?x) - (i - 1) - 1)\n                       (rev (swap xs i ?x))) =\n                    fisher_yates_alt_aux (i - 1) (swap xs i ?x)\n\ngoal (1 subgoal):\n 1. pmf_of_set {..i} \\<bind>\n    (\\<lambda>x.\n        map_pmf rev\n         (fisher_yates_aux (length xs - i) (rev (swap xs i x)))) =\n    pmf_of_set {..i} \\<bind>\n    (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j))", "by (auto intro!: bind_pmf_cong)"], ["proof (state)\nthis:\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>x.\n      map_pmf rev (fisher_yates_aux (length xs - i) (rev (swap xs i x)))) =\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "also"], ["proof (state)\nthis:\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>x.\n      map_pmf rev (fisher_yates_aux (length xs - i) (rev (swap xs i x)))) =\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "from \"1.prems\" False"], ["proof (chain)\npicking this:\n  i < length xs\n  i \\<noteq> 0", "have \"\\<dots> = fisher_yates_alt_aux i xs\""], ["proof (prove)\nusing this:\n  i < length xs\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pmf_of_set {..i} \\<bind>\n    (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j)) =\n    fisher_yates_alt_aux i xs", "by (subst fisher_yates_alt_aux.simps[of i]) simp_all"], ["proof (state)\nthis:\n  pmf_of_set {..i} \\<bind>\n  (\\<lambda>j. fisher_yates_alt_aux (i - 1) (swap xs i j)) =\n  fisher_yates_alt_aux i xs\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "finally"], ["proof (chain)\npicking this:\n  map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs)) =\n  fisher_yates_alt_aux i xs", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs)) =\n  fisher_yates_alt_aux i xs\n\ngoal (1 subgoal):\n 1. fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", ".."], ["proof (state)\nthis:\n  fisher_yates_alt_aux i xs =\n  map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    fisher_yates_alt_aux i xs =\n    map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))", "qed (insert \"1.prems\", simp_all add: fisher_yates_aux.simps fisher_yates_alt_aux.simps)"], ["proof (state)\nthis:\n  fisher_yates_alt_aux i xs =\n  map_pmf rev (fisher_yates_aux (length xs - i - 1) (rev xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition fisher_yates_alt where\n  \"fisher_yates_alt xs = fisher_yates_alt_aux (length xs - 1) xs\""], ["", "lemma fisher_yates_alt_aux_correct:\n  \"fisher_yates_alt xs = shuffle xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fisher_yates_alt xs = shuffle xs", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs\n 2. xs \\<noteq> [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs\n 2. xs \\<noteq> [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. fisher_yates_alt xs = shuffle xs", "by (simp add: fisher_yates_alt_def fisher_yates_alt_aux.simps)"], ["proof (state)\nthis:\n  fisher_yates_alt xs = shuffle xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fisher_yates_alt xs = shuffle xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. fisher_yates_alt xs = shuffle xs", "unfolding fisher_yates_alt_def"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. fisher_yates_alt_aux (length xs - 1) xs = shuffle xs", "by (subst fisher_yates_alt_aux_altdef)\n       (simp_all add: fisher_yates_aux_correct shuffle_def map_pmf_of_set_inj)"], ["proof (state)\nthis:\n  fisher_yates_alt xs = shuffle xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Code generation test\\<close>"], ["", "text \\<open>\n  Isabelle's code generator allows us to produce executable code both for\n  @{const shuffle} and for @{const fisher_yates} and @{const fisher_yates_alt}.\n  However, this code does not produce a random sample (i.e. a single randomly \n  permuted list) -- which is, in fact, the only purpose of the Fisher--Yates \n  algorithm -- but the entire probability distribution consisting of $n!$ \n  lists, each with probability $1/n!$.\n\n  In the future, it would be nice if Isabelle also had some code generation \n  facility that supports generating sampling code.\n\\<close>"], ["", "value [code] \"shuffle ''abcd''\""], ["", "value [code] \"fisher_yates ''abcd''\""], ["", "value [code] \"fisher_yates_alt ''abcd''\""], ["", "end"]]}