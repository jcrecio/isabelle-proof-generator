{"file_name": "/home/qj213/afp-2021-10-22/thys/Store_Buffer_Reduction/PIMP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Store_Buffer_Reduction", "problem_names": ["lemma valid_sops_expr_mono: \"\\<And>t t'. valid_sops_expr t e \\<Longrightarrow> t \\<le> t'  \\<Longrightarrow> valid_sops_expr t' e\"", "lemma valid_sops_stmt_mono: \"\\<And>t t'.  valid_sops_stmt t s \\<Longrightarrow> t \\<le> t'  \\<Longrightarrow> valid_sops_stmt t' s\"", "lemma valid_sops_expr_valid_sop: \"\\<And>t. valid_sops_expr t e \\<Longrightarrow> valid_sop (eval_expr t e)\"", "lemma valid_sops_expr_eval_expr_in_range: \n  \"\\<And>t. valid_sops_expr t e \\<Longrightarrow> \\<forall>t' \\<in> fst (eval_expr t e). t' < t + used_tmps e\"", "lemma stmt_step_tmps_count_mono:\n  assumes step: \"\\<theta>\\<turnstile> (s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  shows \"t \\<le> t'\"", "lemma valid_sops_stmt_invariant:\n  assumes step: \"\\<theta>\\<turnstile> (s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  shows \"valid_sops_stmt t s \\<Longrightarrow> valid_sops_stmt t' s'\"", "lemma map_le_restrict_map_eq: \"m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2 \\<Longrightarrow> D \\<subseteq> dom m\\<^sub>1 \\<Longrightarrow> m\\<^sub>2 |` D = m\\<^sub>1 |` D\"", "lemma sbh_step_preserves_load_tmps_bound: \n  assumes step: \"(is,\\<O>,\\<D>,\\<theta>,sb,\\<S>,m) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<O>',\\<D>',\\<theta>',sb',\\<S>',m')\"\n  assumes less: \"\\<forall>i \\<in> load_tmps is. i < n\" \n  shows \"\\<forall>i \\<in> load_tmps is'. i < n\"", "lemma sbh_step_preserves_read_tmps_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<S>')\"\n  assumes less_is: \"\\<forall>i \\<in> load_tmps is. i < n\" \n  assumes less_sb: \"\\<forall>i \\<in> read_tmps sb. i < n\" \n  shows \"\\<forall>i \\<in> read_tmps sb'. i < n\"", "lemma sbh_step_preserves_tmps_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<S>')\"\n  assumes less_dom: \"\\<forall>i \\<in> dom \\<theta>. i < n\" \n  assumes less_is: \"\\<forall>i \\<in> load_tmps is. i < n\" \n  shows \"\\<forall>i \\<in> dom \\<theta>'. i < n\"", "lemma flush_step_preserves_read_tmps:\n  assumes step: \"(m,sb,\\<O>) \\<rightarrow>\\<^sub>f (m',sb',\\<O>')\"\n  assumes less_sb: \"\\<forall>i \\<in> read_tmps sb. i < n\" \n  shows \"\\<forall>i \\<in> read_tmps sb'. i < n\"", "lemma flush_step_preserves_write_sops:\n  assumes step: \"(m,sb,\\<O>) \\<rightarrow>\\<^sub>f (m',sb',\\<O>')\"\n  assumes less_sb: \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb). i < t\" \n  shows \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb'). i < t\"", "lemma issue_expr_load_tmps_range': \n  \"\\<And>t. load_tmps (issue_expr t e) = {i. t \\<le> i \\<and> i < t + used_tmps e}\"", "lemma issue_expr_load_tmps_range: \n  \"\\<And>t. \\<forall>i \\<in> load_tmps (issue_expr t e). t \\<le> i \\<and> i < t + (used_tmps e)\"", "lemma stmt_step_load_tmps_range':\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  shows \"load_tmps is = {i. t \\<le> i \\<and> i < t'}\"", "lemma stmt_step_load_tmps_range:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  shows \"\\<forall>i \\<in> load_tmps is. t \\<le> i \\<and> i < t'\"", "lemma distinct_load_tmps_issue_expr: \"\\<And>t. distinct_load_tmps (issue_expr t e)\"", "lemma max_used_load_tmps: \"t + used_tmps e \\<notin> load_tmps (issue_expr t e)\"", "lemma stmt_step_distinct_load_tmps:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  shows \"distinct_load_tmps is\"", "lemma store_sops_issue_expr [simp]: \"\\<And>t. store_sops (issue_expr t e) = {}\"", "lemma stmt_step_data_store_sops_range:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"\\<forall>(D,f) \\<in> store_sops is. \\<forall>i \\<in> D. i < t'\"", "lemma sbh_step_distinct_load_tmps_prog_step: \n      assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is')\"\n  assumes load_tmps_le: \"\\<forall>i \\<in> load_tmps is. i < t\"\n  assumes read_tmps_le: \"\\<forall>i \\<in> read_tmps sb. i < t\"\n  shows \"distinct_load_tmps is' \\<and> (load_tmps is' \\<inter> load_tmps is = {}) \\<and>\n         (load_tmps is' \\<inter> read_tmps sb) = {}\"", "lemma data_dependency_consistent_instrs_issue_expr: \n  \"\\<And>t T. data_dependency_consistent_instrs T (issue_expr t e)\"", "lemma dom_eval_expr:\n  \"\\<And>t. \\<lbrakk>valid_sops_expr t e; x \\<in> fst (eval_expr t e)\\<rbrakk> \\<Longrightarrow> x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t e)\"", "lemma Cond_not_s\\<^sub>1: \"s\\<^sub>1 \\<noteq> Cond e s\\<^sub>1 s\\<^sub>2 \"", "lemma Cond_not_s\\<^sub>2: \"s\\<^sub>2 \\<noteq> Cond e s\\<^sub>1 s\\<^sub>2 \"", "lemma Seq_not_s\\<^sub>1: \"s\\<^sub>1 \\<noteq> Seq s\\<^sub>1 s\\<^sub>2\"", "lemma Seq_not_s\\<^sub>2: \"s\\<^sub>2 \\<noteq> Seq s\\<^sub>1 s\\<^sub>2\"", "lemma prog_step_progress:\n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  shows \"(s',t') \\<noteq> (s,t) \\<or> is \\<noteq> []\"", "lemma stmt_step_data_dependency_consistent_instrs:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"data_dependency_consistent_instrs ({i. i < t}) is\"", "lemma sbh_valid_data_dependency_prog_step: \n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is')\"\n  assumes store_sops_le: \"\\<forall>i \\<in> \\<Union>(fst ` store_sops is). i < t\"\n  assumes write_sops_le: \"\\<forall>i \\<in> \\<Union>(fst ` write_sops sb). i < t\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"data_dependency_consistent_instrs ({i. i < t}) is' \\<and> \n         load_tmps is' \\<inter> \\<Union>(fst ` store_sops is)  = {} \\<and>\n         load_tmps is' \\<inter> \\<Union>(fst ` write_sops sb)  = {}\"", "lemma sbh_load_tmps_fresh_prog_step:\n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is')\"\n  assumes tmps_le: \"\\<forall>i \\<in> dom \\<theta>. i < t\"\n  shows \"load_tmps is' \\<inter> dom \\<theta> = {}\"", "lemma sbh_valid_sops_prog_step:\n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"\\<forall>sop\\<in>store_sops is. valid_sop sop\"", "lemma prog_configs_append: \"\\<And>ys. prog_configs (xs@ys) = prog_configs xs \\<union> prog_configs ys\"", "lemma prog_configs_in1: \"Prog\\<^sub>s\\<^sub>b p\\<^sub>1 p\\<^sub>2 is \\<in> set xs \\<Longrightarrow> p\\<^sub>1 \\<in> prog_configs xs\"", "lemma prog_configs_in2: \"Prog\\<^sub>s\\<^sub>b p\\<^sub>1 p\\<^sub>2 is \\<in> set xs \\<Longrightarrow> p\\<^sub>2 \\<in> prog_configs xs\"", "lemma prog_configs_mono: \"\\<And>ys. set xs \\<subseteq> set ys \\<Longrightarrow> prog_configs xs \\<subseteq> prog_configs ys\"", "lemma (in separated_tmps)\n  tmps_le': \n  assumes i_bound: \"i < length ts\" \n  assumes ts_i: \"ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\"\n  shows \"\\<forall>i \\<in> dom \\<theta>. i < t\"", "lemma (in separated_tmps) separated_tmps_nth_update: \n  \"\\<lbrakk>i < length ts; valid_sops_stmt t s; \\<forall>(s',t') \\<in> prog_configs sb. valid_sops_stmt t' s'; \n   \\<forall>i \\<in> load_tmps is. i < t;\\<forall>i \\<in> read_tmps sb. i < t;\n    \\<forall>i \\<in> \\<Union>(fst ` store_sops is). i < t; \\<forall>i \\<in> \\<Union>(fst ` write_sops sb). i < t; dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk> \n   \\<Longrightarrow>\n   separated_tmps (ts[i:=((s,t),is,\\<theta>,sb,\\<D>,\\<O>)])\"", "lemma hd_prog_app_in_first: \"\\<And>ys. Prog\\<^sub>s\\<^sub>b p p' is \\<in> set xs \\<Longrightarrow> hd_prog q (xs @ ys) = hd_prog q xs\"", "lemma hd_prog_app_in_eq: \"\\<And>ys. Prog\\<^sub>s\\<^sub>b p p' is \\<in> set xs \\<Longrightarrow> hd_prog q xs = hd_prog x xs\"", "lemma hd_prog_app_notin_first: \"\\<And>ys. \\<forall>p p' is. Prog\\<^sub>s\\<^sub>b p p' is \\<notin> set xs \\<Longrightarrow> hd_prog q (xs @ ys) = hd_prog q ys\"", "lemma union_eq_subsetD: \"A \\<union> B = C \\<Longrightarrow> A \\<union> B \\<subseteq> C \\<and>  C \\<subseteq> A \\<union> B\"", "lemma prog_step_preserves_separated_tmps:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb,\\<D>,\\<O>)\" \n  assumes prog_step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n  assumes sep: \"separated_tmps ts\"\n  shows \"separated_tmps \n             (ts [i:=(p',is@is',\\<theta>,sb@[Prog\\<^sub>s\\<^sub>b p p' is'],\\<D>,\\<O>)])\"", "lemma flush_step_sb_subset:\n  assumes step: \"(m,sb,\\<O>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>')\"\n  shows \"set sb' \\<subseteq> set sb\"", "lemma flush_step_preserves_separated_tmps:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb,\\<D>,\\<O>,\\<R>)\" \n  assumes flush_step: \"(m,sb,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>',\\<R>',\\<S>')\"\n  assumes sep: \"separated_tmps ts\"\n  shows \"separated_tmps (ts [i:=(p,is,\\<theta>,sb',\\<D>,\\<O>',\\<R>')])\"", "lemma sbh_step_preserves_store_sops_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  assumes store_sops_le: \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is). i < t\"\n  shows \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is'). i < t\"", "lemma sbh_step_preserves_write_sops_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  assumes store_sops_le: \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is). i < t\"\n  assumes write_sops_le: \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb). i < t\"\n  shows \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb'). i < t\"", "lemma sbh_step_prog_configs_eq:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  shows \"prog_configs sb' = prog_configs sb\"", "lemma sbh_step_preserves_tmps_bound':\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  shows \"dom \\<theta> \\<union> load_tmps is = dom \\<theta>' \\<union> load_tmps is'\"", "lemma sbh_step_preserves_separated_tmps:\n  assumes i_bound: \"i < length ts\" \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb,\\<D>,\\<O>,\\<R>)\" \n  assumes memop_step: \"(is, \\<theta>, sb, m,\\<D>, \\<O>, \\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h \n                        (is', \\<theta>', sb', m',\\<D>', \\<O>', \\<R>',\\<S>')\" \n  assumes instr: \"separated_tmps ts\"\n  shows \"separated_tmps (ts [i:=(p,is',\\<theta>',sb',\\<D>',\\<O>',\\<R>')])\"", "lemma prog_step_preserves_valid:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb::stmt_config store_buffer,\\<D>,\\<O>,\\<R>)\" \n  assumes prog_step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n  assumes valid: \"valid_pimp ts\"\n  shows \"valid_pimp (ts [i:=(p',is@is',\\<theta>,sb@[Prog\\<^sub>s\\<^sub>b p p' is'],\\<D>,\\<O>,\\<R>)])\"", "lemma flush_step_preserves_valid:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb::stmt_config store_buffer,\\<D>,\\<O>,\\<R>)\" \n  assumes flush_step: \"(m,sb,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>',\\<R>',\\<S>')\"\n  assumes valid: \"valid_pimp ts\"\n  shows \"valid_pimp (ts [i:=(p,is,\\<theta>,sb',\\<D>,\\<O>',\\<R>')])\"", "lemma sbh_step_preserves_valid:\n  assumes i_bound: \"i < length ts\" \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb::stmt_config store_buffer,\\<D>,\\<O>,\\<R>)\" \n  assumes memop_step: \"(is, \\<theta>, sb, m,\\<D>, \\<O>, \\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h \n                        (is', \\<theta>', sb', m',\\<D>', \\<O>', \\<R>', \\<S>')\" \n  assumes valid: \"valid_pimp ts\"\n  shows \"valid_pimp (ts [i:=(p,is',\\<theta>',sb',\\<D>',\\<O>',\\<R>')])\"", "lemma hd_prog_prog_configs: \"hd_prog p sb = p \\<or> hd_prog p sb \\<in> prog_configs sb\"", "lemma Assign_Const_ex: \n\"([((Assign True (Tmp ({},\\<lambda>\\<theta>. a)) (Const c) (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),t),[],\\<theta>,(),\\<D>,\\<O>,\\<R>)],m,\\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* \n ([((Skip,t),[],\\<theta>,(),True,\\<O> \\<union> A - R,Map.empty)],m(a := c),\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\"", "lemma \n\" ([((Assign True (Tmp ({},\\<lambda>\\<theta>. a)) (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),t),[],\\<theta>,(),\\<D>,\\<O>,\\<R>)],m,S) \n \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* \n ([((Skip,t + 2),[],\\<theta>(t\\<mapsto>m x, t + 1 \\<mapsto>m y),(),True,\\<O> \\<union> A - R,Map.empty)],m(a := m x + m y),S  \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\"", "lemma  \nassumes isTrue: \"isTrue c\"\nshows  \n\"([((Cond (Const c) (Assign True (Tmp ({},\\<lambda>\\<theta>. a)) (Const c) (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W)) Skip,t) ,[],\\<theta>,(),\\<D>,\\<O>,\\<R>)],m,\\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* \n ([((Skip,t),[],\\<theta>,(),True,\\<O> \\<union> A - R,Map.empty)],m(a := c),\\<S>  \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\""], "translations": [["", "lemma valid_sops_expr_mono: \"\\<And>t t'. valid_sops_expr t e \\<Longrightarrow> t \\<le> t'  \\<Longrightarrow> valid_sops_expr t' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t t'.\n       \\<lbrakk>valid_sops_expr t e; t \\<le> t'\\<rbrakk>\n       \\<Longrightarrow> valid_sops_expr t' e", "by (induct e) auto"], ["", "lemma valid_sops_stmt_mono: \"\\<And>t t'.  valid_sops_stmt t s \\<Longrightarrow> t \\<le> t'  \\<Longrightarrow> valid_sops_stmt t' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t t'.\n       \\<lbrakk>valid_sops_stmt t s; t \\<le> t'\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' s", "by (induct s) (auto intro: valid_sops_expr_mono)"], ["", "lemma valid_sops_expr_valid_sop: \"\\<And>t. valid_sops_expr t e \\<Longrightarrow> valid_sop (eval_expr t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. valid_sops_expr t e \\<Longrightarrow> valid_sop (eval_expr t e)", "proof (induct e)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   valid_sop (eval_expr t e);\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "case (Unop f e)"], ["proof (state)\nthis:\n  valid_sops_expr ?t e \\<Longrightarrow> valid_sop (eval_expr ?t e)\n  valid_sops_expr t (Unop f e)\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   valid_sop (eval_expr t e);\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "then"], ["proof (chain)\npicking this:\n  valid_sops_expr ?t e \\<Longrightarrow> valid_sop (eval_expr ?t e)\n  valid_sops_expr t (Unop f e)", "obtain \"valid_sops_expr t e\""], ["proof (prove)\nusing this:\n  valid_sops_expr ?t e \\<Longrightarrow> valid_sop (eval_expr ?t e)\n  valid_sops_expr t (Unop f e)\n\ngoal (1 subgoal):\n 1. (valid_sops_expr t e \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  valid_sops_expr t e\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   valid_sop (eval_expr t e);\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "from Unop.hyps [OF this]"], ["proof (chain)\npicking this:\n  valid_sop (eval_expr t e)", "have vs: \"valid_sop (eval_expr t e)\""], ["proof (prove)\nusing this:\n  valid_sop (eval_expr t e)\n\ngoal (1 subgoal):\n 1. valid_sop (eval_expr t e)", "by simp"], ["proof (state)\nthis:\n  valid_sop (eval_expr t e)\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   valid_sop (eval_expr t e);\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "obtain D g where eval_e: \"eval_expr t e = (D,g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D g.\n        eval_expr t e = (D, g) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"eval_expr t e\")"], ["proof (state)\nthis:\n  eval_expr t e = (D, g)\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   valid_sop (eval_expr t e);\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "interpret valid_sop \"(D,g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sop (D, g)", "using vs eval_e"], ["proof (prove)\nusing this:\n  valid_sop (eval_expr t e)\n  eval_expr t e = (D, g)\n\ngoal (1 subgoal):\n 1. valid_sop (D, g)", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   valid_sop (eval_expr t e);\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sop (eval_expr t (Unop f e))", "apply (clarsimp simp add: Let_def valid_sop_def eval_e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<theta>.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       f (g \\<theta>) = f (g (\\<theta> |` D))", "apply (drule valid_sop [OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<theta>.\n       g \\<theta> = g (\\<theta> |` D) \\<Longrightarrow>\n       f (g \\<theta>) = f (g (\\<theta> |` D))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_sop (eval_expr t (Unop f e))\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "case (Binop f e\\<^sub>1 e\\<^sub>2)"], ["proof (state)\nthis:\n  valid_sops_expr ?t e\\<^sub>1 \\<Longrightarrow>\n  valid_sop (eval_expr ?t e\\<^sub>1)\n  valid_sops_expr ?t e\\<^sub>2 \\<Longrightarrow>\n  valid_sop (eval_expr ?t e\\<^sub>2)\n  valid_sops_expr t (Binop f e\\<^sub>1 e\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "then"], ["proof (chain)\npicking this:\n  valid_sops_expr ?t e\\<^sub>1 \\<Longrightarrow>\n  valid_sop (eval_expr ?t e\\<^sub>1)\n  valid_sops_expr ?t e\\<^sub>2 \\<Longrightarrow>\n  valid_sop (eval_expr ?t e\\<^sub>2)\n  valid_sops_expr t (Binop f e\\<^sub>1 e\\<^sub>2)", "obtain v1: \"valid_sops_expr t e\\<^sub>1\" and v2: \"valid_sops_expr t e\\<^sub>2\""], ["proof (prove)\nusing this:\n  valid_sops_expr ?t e\\<^sub>1 \\<Longrightarrow>\n  valid_sop (eval_expr ?t e\\<^sub>1)\n  valid_sops_expr ?t e\\<^sub>2 \\<Longrightarrow>\n  valid_sop (eval_expr ?t e\\<^sub>2)\n  valid_sops_expr t (Binop f e\\<^sub>1 e\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>valid_sops_expr t e\\<^sub>1;\n      valid_sops_expr t e\\<^sub>2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  valid_sops_expr t e\\<^sub>1\n  valid_sops_expr t e\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "with Binop.hyps (1) [of t]  Binop.hyps (2) [of \"(t + used_tmps e\\<^sub>1)\"]  \n    valid_sops_expr_mono [OF v2, of \"(t + used_tmps e\\<^sub>1)\"]"], ["proof (chain)\npicking this:\n  valid_sops_expr t e\\<^sub>1 \\<Longrightarrow>\n  valid_sop (eval_expr t e\\<^sub>1)\n  valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 \\<Longrightarrow>\n  valid_sop (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2)\n  t \\<le> t + used_tmps e\\<^sub>1 \\<Longrightarrow>\n  valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2\n  valid_sops_expr t e\\<^sub>1\n  valid_sops_expr t e\\<^sub>2", "obtain vs1: \"valid_sop (eval_expr t e\\<^sub>1)\" and vs2: \"valid_sop (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2)\""], ["proof (prove)\nusing this:\n  valid_sops_expr t e\\<^sub>1 \\<Longrightarrow>\n  valid_sop (eval_expr t e\\<^sub>1)\n  valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 \\<Longrightarrow>\n  valid_sop (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2)\n  t \\<le> t + used_tmps e\\<^sub>1 \\<Longrightarrow>\n  valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2\n  valid_sops_expr t e\\<^sub>1\n  valid_sops_expr t e\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>valid_sop (eval_expr t e\\<^sub>1);\n      valid_sop (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_sop (eval_expr t e\\<^sub>1)\n  valid_sop (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "obtain D\\<^sub>1 g\\<^sub>1 where eval_e\\<^sub>1: \"eval_expr t e\\<^sub>1 = (D\\<^sub>1,g\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D\\<^sub>1 g\\<^sub>1.\n        eval_expr t e\\<^sub>1 = (D\\<^sub>1, g\\<^sub>1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"eval_expr t e\\<^sub>1\")"], ["proof (state)\nthis:\n  eval_expr t e\\<^sub>1 = (D\\<^sub>1, g\\<^sub>1)\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "obtain D\\<^sub>2 g\\<^sub>2 where eval_e\\<^sub>2: \"eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 = (D\\<^sub>2,g\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D\\<^sub>2 g\\<^sub>2.\n        eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 =\n        (D\\<^sub>2, g\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2\")"], ["proof (state)\nthis:\n  eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 = (D\\<^sub>2, g\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "interpret vs1: valid_sop \"(D\\<^sub>1,g\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sop (D\\<^sub>1, g\\<^sub>1)", "using vs1 eval_e\\<^sub>1"], ["proof (prove)\nusing this:\n  valid_sop (eval_expr t e\\<^sub>1)\n  eval_expr t e\\<^sub>1 = (D\\<^sub>1, g\\<^sub>1)\n\ngoal (1 subgoal):\n 1. valid_sop (D\\<^sub>1, g\\<^sub>1)", "by auto"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "interpret vs2: valid_sop \"(D\\<^sub>2,g\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sop (D\\<^sub>2, g\\<^sub>2)", "using vs2 eval_e\\<^sub>2"], ["proof (prove)\nusing this:\n  valid_sop (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2)\n  eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 = (D\\<^sub>2, g\\<^sub>2)\n\ngoal (1 subgoal):\n 1. valid_sop (D\\<^sub>2, g\\<^sub>2)", "by auto"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "fix \\<theta>:: \"nat\\<Rightarrow>val option\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "assume D1: \"D\\<^sub>1 \\<subseteq> dom \\<theta>\""], ["proof (state)\nthis:\n  D\\<^sub>1 \\<subseteq> dom \\<theta>\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "assume D2: \"D\\<^sub>2 \\<subseteq> dom \\<theta>\""], ["proof (state)\nthis:\n  D\\<^sub>2 \\<subseteq> dom \\<theta>\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "have \"f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) = f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))) (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "from vs1.valid_sop [OF refl D1]"], ["proof (chain)\npicking this:\n  g\\<^sub>1 \\<theta> = g\\<^sub>1 (\\<theta> |` D\\<^sub>1)", "have \"g\\<^sub>1 \\<theta> = g\\<^sub>1 (\\<theta> |` D\\<^sub>1)\""], ["proof (prove)\nusing this:\n  g\\<^sub>1 \\<theta> = g\\<^sub>1 (\\<theta> |` D\\<^sub>1)\n\ngoal (1 subgoal):\n 1. g\\<^sub>1 \\<theta> = g\\<^sub>1 (\\<theta> |` D\\<^sub>1)", "."], ["proof (state)\nthis:\n  g\\<^sub>1 \\<theta> = g\\<^sub>1 (\\<theta> |` D\\<^sub>1)\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "also"], ["proof (state)\nthis:\n  g\\<^sub>1 \\<theta> = g\\<^sub>1 (\\<theta> |` D\\<^sub>1)\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "from D1"], ["proof (chain)\npicking this:\n  D\\<^sub>1 \\<subseteq> dom \\<theta>", "have D1': \"D\\<^sub>1 \\<subseteq> dom (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\""], ["proof (prove)\nusing this:\n  D\\<^sub>1 \\<subseteq> dom \\<theta>\n\ngoal (1 subgoal):\n 1. D\\<^sub>1 \\<subseteq> dom (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))", "by auto"], ["proof (state)\nthis:\n  D\\<^sub>1 \\<subseteq> dom (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "have \"\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1 = \\<theta> |` D\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1 =\n    \\<theta> |` D\\<^sub>1", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1) x =\n       (\\<theta> |` D\\<^sub>1) x", "apply (auto simp add: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1 =\n  \\<theta> |` D\\<^sub>1\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "with vs1.valid_sop [OF refl D1']"], ["proof (chain)\npicking this:\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1)\n  \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1 =\n  \\<theta> |` D\\<^sub>1", "have \"g\\<^sub>1 (\\<theta> |` D\\<^sub>1) = g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\""], ["proof (prove)\nusing this:\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1)\n  \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>1 =\n  \\<theta> |` D\\<^sub>1\n\ngoal (1 subgoal):\n 1. g\\<^sub>1 (\\<theta> |` D\\<^sub>1) =\n    g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))", "by auto"], ["proof (state)\nthis:\n  g\\<^sub>1 (\\<theta> |` D\\<^sub>1) =\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "finally"], ["proof (chain)\npicking this:\n  g\\<^sub>1 \\<theta> =\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))", "have g1: \"g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) = g\\<^sub>1 \\<theta>\""], ["proof (prove)\nusing this:\n  g\\<^sub>1 \\<theta> =\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\n\ngoal (1 subgoal):\n 1. g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n    g\\<^sub>1 \\<theta>", "by simp"], ["proof (state)\nthis:\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>1 \\<theta>\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "from vs2.valid_sop [OF refl D2]"], ["proof (chain)\npicking this:\n  g\\<^sub>2 \\<theta> = g\\<^sub>2 (\\<theta> |` D\\<^sub>2)", "have \"g\\<^sub>2 \\<theta> = g\\<^sub>2 (\\<theta> |` D\\<^sub>2)\""], ["proof (prove)\nusing this:\n  g\\<^sub>2 \\<theta> = g\\<^sub>2 (\\<theta> |` D\\<^sub>2)\n\ngoal (1 subgoal):\n 1. g\\<^sub>2 \\<theta> = g\\<^sub>2 (\\<theta> |` D\\<^sub>2)", "."], ["proof (state)\nthis:\n  g\\<^sub>2 \\<theta> = g\\<^sub>2 (\\<theta> |` D\\<^sub>2)\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "also"], ["proof (state)\nthis:\n  g\\<^sub>2 \\<theta> = g\\<^sub>2 (\\<theta> |` D\\<^sub>2)\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "from D2"], ["proof (chain)\npicking this:\n  D\\<^sub>2 \\<subseteq> dom \\<theta>", "have D2': \"D\\<^sub>2 \\<subseteq> dom (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\""], ["proof (prove)\nusing this:\n  D\\<^sub>2 \\<subseteq> dom \\<theta>\n\ngoal (1 subgoal):\n 1. D\\<^sub>2 \\<subseteq> dom (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))", "by auto"], ["proof (state)\nthis:\n  D\\<^sub>2 \\<subseteq> dom (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "have \"\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2 = \\<theta> |` D\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2 =\n    \\<theta> |` D\\<^sub>2", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2) x =\n       (\\<theta> |` D\\<^sub>2) x", "apply (auto simp add: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2 =\n  \\<theta> |` D\\<^sub>2\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "with vs2.valid_sop [OF refl D2']"], ["proof (chain)\npicking this:\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2)\n  \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2 =\n  \\<theta> |` D\\<^sub>2", "have \"g\\<^sub>2 (\\<theta> |` D\\<^sub>2) = g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\""], ["proof (prove)\nusing this:\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2)\n  \\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2) |` D\\<^sub>2 =\n  \\<theta> |` D\\<^sub>2\n\ngoal (1 subgoal):\n 1. g\\<^sub>2 (\\<theta> |` D\\<^sub>2) =\n    g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))", "by auto"], ["proof (state)\nthis:\n  g\\<^sub>2 (\\<theta> |` D\\<^sub>2) =\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "finally"], ["proof (chain)\npicking this:\n  g\\<^sub>2 \\<theta> =\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))", "have g2: \"g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) = g\\<^sub>2 \\<theta>\""], ["proof (prove)\nusing this:\n  g\\<^sub>2 \\<theta> =\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2))\n\ngoal (1 subgoal):\n 1. g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n    g\\<^sub>2 \\<theta>", "by simp"], ["proof (state)\nthis:\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>2 \\<theta>\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "from g1 g2"], ["proof (chain)\npicking this:\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>1 \\<theta>\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>2 \\<theta>", "show ?thesis"], ["proof (prove)\nusing this:\n  g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>1 \\<theta>\n  g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)) =\n  g\\<^sub>2 \\<theta>\n\ngoal (1 subgoal):\n 1. f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n    f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n     (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "by simp"], ["proof (state)\nthis:\n  f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n  f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n   (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n  f (g\\<^sub>1 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n   (g\\<^sub>2 (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>D\\<^sub>1 \\<subseteq> dom ?\\<theta>2;\n   D\\<^sub>2 \\<subseteq> dom ?\\<theta>2\\<rbrakk>\n  \\<Longrightarrow> f (g\\<^sub>1 ?\\<theta>2) (g\\<^sub>2 ?\\<theta>2) =\n                    f (g\\<^sub>1\n                        (?\\<theta>2 |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n                     (g\\<^sub>2\n                       (?\\<theta>2 |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "note lem=this"], ["proof (state)\nthis:\n  \\<lbrakk>D\\<^sub>1 \\<subseteq> dom ?\\<theta>2;\n   D\\<^sub>2 \\<subseteq> dom ?\\<theta>2\\<rbrakk>\n  \\<Longrightarrow> f (g\\<^sub>1 ?\\<theta>2) (g\\<^sub>2 ?\\<theta>2) =\n                    f (g\\<^sub>1\n                        (?\\<theta>2 |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n                     (g\\<^sub>2\n                       (?\\<theta>2 |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   valid_sop (eval_expr t e1);\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           valid_sop (eval_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> valid_sop (eval_expr t (Binop x1a e1 e2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sop (eval_expr t (Binop f e\\<^sub>1 e\\<^sub>2))", "apply (clarsimp simp add: Let_def valid_sop_def eval_e\\<^sub>1 eval_e\\<^sub>2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<theta>.\n       \\<lbrakk>D\\<^sub>1 \\<subseteq> dom \\<theta>;\n        D\\<^sub>2 \\<subseteq> dom \\<theta>\\<rbrakk>\n       \\<Longrightarrow> f (g\\<^sub>1 \\<theta>) (g\\<^sub>2 \\<theta>) =\n                         f (g\\<^sub>1\n                             (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))\n                          (g\\<^sub>2\n                            (\\<theta> |` (D\\<^sub>1 \\<union> D\\<^sub>2)))", "apply (rule lem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<theta>.\n       \\<lbrakk>D\\<^sub>1 \\<subseteq> dom \\<theta>;\n        D\\<^sub>2 \\<subseteq> dom \\<theta>\\<rbrakk>\n       \\<Longrightarrow> D\\<^sub>1 \\<subseteq> dom \\<theta>\n 2. \\<And>\\<theta>.\n       \\<lbrakk>D\\<^sub>1 \\<subseteq> dom \\<theta>;\n        D\\<^sub>2 \\<subseteq> dom \\<theta>\\<rbrakk>\n       \\<Longrightarrow> D\\<^sub>2 \\<subseteq> dom \\<theta>", "by auto"], ["proof (state)\nthis:\n  valid_sop (eval_expr t (Binop f e\\<^sub>1 e\\<^sub>2))\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Const x))\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       valid_sop (eval_expr t (Mem x1a x2))\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       valid_sop (eval_expr t (Tmp x))", "qed (auto simp add: valid_sop_def)"], ["", "lemma valid_sops_expr_eval_expr_in_range: \n  \"\\<And>t. valid_sops_expr t e \\<Longrightarrow> \\<forall>t' \\<in> fst (eval_expr t e). t' < t + used_tmps e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_expr t e \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t e). t' < t + used_tmps e", "proof (induct e)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e).\n                      t' < t + used_tmps e;\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst (eval_expr t (Unop x1a e)).\n                            t' < t + used_tmps (Unop x1a e)\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "case (Unop f e)"], ["proof (state)\nthis:\n  valid_sops_expr ?t e \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e). t' < ?t + used_tmps e\n  valid_sops_expr t (Unop f e)\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e).\n                      t' < t + used_tmps e;\n        valid_sops_expr t (Unop x1a e)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst (eval_expr t (Unop x1a e)).\n                            t' < t + used_tmps (Unop x1a e)\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_expr ?t e \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e). t' < ?t + used_tmps e\n  valid_sops_expr t (Unop f e)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>fst (eval_expr t (Unop f e)).\n       t' < t + used_tmps (Unop f e)", "apply (cases \"eval_expr t e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e).\n                      t' < t + used_tmps e;\n        valid_sops_expr t (Unop f e); eval_expr t e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst (eval_expr t (Unop f e)).\n                            t' < t + used_tmps (Unop f e)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>fst (eval_expr t (Unop f e)).\n     t' < t + used_tmps (Unop f e)\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "case (Binop f e\\<^sub>1 e\\<^sub>2)"], ["proof (state)\nthis:\n  valid_sops_expr ?t e\\<^sub>1 \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e\\<^sub>1).\n     t' < ?t + used_tmps e\\<^sub>1\n  valid_sops_expr ?t e\\<^sub>2 \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e\\<^sub>2).\n     t' < ?t + used_tmps e\\<^sub>2\n  valid_sops_expr t (Binop f e\\<^sub>1 e\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "then"], ["proof (chain)\npicking this:\n  valid_sops_expr ?t e\\<^sub>1 \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e\\<^sub>1).\n     t' < ?t + used_tmps e\\<^sub>1\n  valid_sops_expr ?t e\\<^sub>2 \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e\\<^sub>2).\n     t' < ?t + used_tmps e\\<^sub>2\n  valid_sops_expr t (Binop f e\\<^sub>1 e\\<^sub>2)", "obtain v1: \"valid_sops_expr t e\\<^sub>1\" and v2: \"valid_sops_expr t e\\<^sub>2\""], ["proof (prove)\nusing this:\n  valid_sops_expr ?t e\\<^sub>1 \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e\\<^sub>1).\n     t' < ?t + used_tmps e\\<^sub>1\n  valid_sops_expr ?t e\\<^sub>2 \\<Longrightarrow>\n  \\<forall>t'\\<in>fst (eval_expr ?t e\\<^sub>2).\n     t' < ?t + used_tmps e\\<^sub>2\n  valid_sops_expr t (Binop f e\\<^sub>1 e\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>valid_sops_expr t e\\<^sub>1;\n      valid_sops_expr t e\\<^sub>2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  valid_sops_expr t e\\<^sub>1\n  valid_sops_expr t e\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "from valid_sops_expr_mono [OF v2]"], ["proof (chain)\npicking this:\n  t \\<le> ?t' \\<Longrightarrow> valid_sops_expr ?t' e\\<^sub>2", "have v2': \"valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2\""], ["proof (prove)\nusing this:\n  t \\<le> ?t' \\<Longrightarrow> valid_sops_expr ?t' e\\<^sub>2\n\ngoal (1 subgoal):\n 1. valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  valid_sops_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   valid_sops_expr t e1 \\<Longrightarrow>\n                   \\<forall>t'\\<in>fst (eval_expr t e1).\n                      t' < t + used_tmps e1;\n        \\<And>t.\n           valid_sops_expr t e2 \\<Longrightarrow>\n           \\<forall>t'\\<in>fst (eval_expr t e2). t' < t + used_tmps e2;\n        valid_sops_expr t (Binop x1a e1 e2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop x1a e1 e2)).\n                            t' < t + used_tmps (Binop x1a e1 e2)", "from Binop.hyps (1) [OF v1] Binop.hyps (2) [OF v2']"], ["proof (chain)\npicking this:\n  \\<forall>t'\\<in>fst (eval_expr t e\\<^sub>1). t' < t + used_tmps e\\<^sub>1\n  \\<forall>t'\\<in>fst (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2).\n     t' < t + used_tmps e\\<^sub>1 + used_tmps e\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>t'\\<in>fst (eval_expr t e\\<^sub>1). t' < t + used_tmps e\\<^sub>1\n  \\<forall>t'\\<in>fst (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2).\n     t' < t + used_tmps e\\<^sub>1 + used_tmps e\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<in>fst (eval_expr t (Binop f e\\<^sub>1 e\\<^sub>2)).\n       t' < t + used_tmps (Binop f e\\<^sub>1 e\\<^sub>2)", "apply (cases \"eval_expr t e\\<^sub>1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>t'\\<in>fst (eval_expr t e\\<^sub>1).\n                   t' < t + used_tmps e\\<^sub>1;\n        \\<forall>t'\\<in>fst (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2).\n           t' < t + used_tmps e\\<^sub>1 + used_tmps e\\<^sub>2;\n        eval_expr t e\\<^sub>1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop f e\\<^sub>1 e\\<^sub>2)).\n                            t' < t + used_tmps (Binop f e\\<^sub>1 e\\<^sub>2)", "apply (cases \"eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>t'\\<in>fst (eval_expr t e\\<^sub>1).\n                   t' < t + used_tmps e\\<^sub>1;\n        \\<forall>t'\\<in>fst (eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2).\n           t' < t + used_tmps e\\<^sub>1 + used_tmps e\\<^sub>2;\n        eval_expr t e\\<^sub>1 = (a, b);\n        eval_expr (t + used_tmps e\\<^sub>1) e\\<^sub>2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t'\\<in>fst\n    (eval_expr t (Binop f e\\<^sub>1 e\\<^sub>2)).\n                            t' < t + used_tmps (Binop f e\\<^sub>1 e\\<^sub>2)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>t'\\<in>fst (eval_expr t (Binop f e\\<^sub>1 e\\<^sub>2)).\n     t' < t + used_tmps (Binop f e\\<^sub>1 e\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       valid_sops_expr t (Const x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Const x)).\n          t' < t + used_tmps (Const x)\n 2. \\<And>x1a x2 t.\n       valid_sops_expr t (Mem x1a x2) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Mem x1a x2)).\n          t' < t + used_tmps (Mem x1a x2)\n 3. \\<And>x t.\n       valid_sops_expr t (Tmp x) \\<Longrightarrow>\n       \\<forall>t'\\<in>fst (eval_expr t (Tmp x)). t' < t + used_tmps (Tmp x)", "qed auto"], ["", "lemma stmt_step_tmps_count_mono:\n  assumes step: \"\\<theta>\\<turnstile> (s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  shows \"t \\<le> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> t'", "using step"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n\ngoal (1 subgoal):\n 1. t \\<le> t'", "by (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct) force+"], ["", "lemma valid_sops_stmt_invariant:\n  assumes step: \"\\<theta>\\<turnstile> (s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  shows \"valid_sops_stmt t s \\<Longrightarrow> valid_sops_stmt t' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sops_stmt t s \\<Longrightarrow> valid_sops_stmt t' s'", "using step"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t s \\<Longrightarrow> valid_sops_stmt t' s'", "proof (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (Assign volatile (Tmp (eval_expr t a)) e A L R W)\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e) Skip\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\nA total of 13 subgoals...", "case AssignAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (Assign volatile (Tmp (eval_expr t a)) e A L R W)\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e) Skip\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt (t_ + used_tmps a_)\n     (Assign volatile_ (Tmp (eval_expr t_ a_)) e_ A_ L_ R_ W_)", "by \n  (force simp add: valid_sops_expr_valid_sop intro: valid_sops_stmt_mono valid_sops_expr_mono  \n     dest: valid_sops_expr_eval_expr_in_range)"], ["proof (state)\nthis:\n  valid_sops_stmt (t_ + used_tmps a_)\n   (Assign volatile_ (Tmp (eval_expr t_ a_)) e_ A_ L_ R_ W_)\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e) Skip\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e) Skip\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\nA total of 12 subgoals...", "case Assign"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_)\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e) Skip\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt (t_ + used_tmps e_) Skip", "by simp"], ["proof (state)\nthis:\n  valid_sops_stmt (t_ + used_tmps e_) Skip\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        valid_sops_stmt t Skip\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        valid_sops_stmt t Skip\nA total of 11 subgoals...", "case CASAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps a)\n                          (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L\n                            R W)\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        valid_sops_stmt t Skip\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt (t_ + used_tmps a_)\n     (CAS (Tmp (eval_expr t_ a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)", "by \n  (force simp add: valid_sops_expr_valid_sop intro: valid_sops_stmt_mono valid_sops_expr_mono  \n     dest: valid_sops_expr_eval_expr_in_range)"], ["proof (state)\nthis:\n  valid_sops_stmt (t_ + used_tmps a_)\n   (CAS (Tmp (eval_expr t_ a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case CASComp"], ["proof (state)\nthis:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps c\\<^sub>e)\n                          (CAS (Tmp (D\\<^sub>a, a))\n                            (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L R W)\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt (t_ + used_tmps c\\<^sub>e_)\n     (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (eval_expr t_ c\\<^sub>e_)) s\\<^sub>e_\n       A_ L_ R_ W_)", "by \n  (force simp add: valid_sops_expr_valid_sop intro: valid_sops_stmt_mono valid_sops_expr_mono  \n     dest: valid_sops_expr_eval_expr_in_range)"], ["proof (state)\nthis:\n  valid_sops_stmt (t_ + used_tmps c\\<^sub>e_)\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (eval_expr t_ c\\<^sub>e_)) s\\<^sub>e_ A_\n     L_ R_ W_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case CAS"], ["proof (state)\nthis:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n     W_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (Suc (t + used_tmps s\\<^sub>e))\n                          Skip\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n     W_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt (Suc (t_ + used_tmps s\\<^sub>e_)) Skip", "by simp"], ["proof (state)\nthis:\n  valid_sops_stmt (Suc (t_ + used_tmps s\\<^sub>e_)) Skip\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case Seq"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  valid_sops_stmt t'_ s\\<^sub>1'_\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        valid_sops_stmt t' s\\<^sub>1';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' (Seq s\\<^sub>1' s\\<^sub>2)\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  valid_sops_stmt t'_ s\\<^sub>1'_\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t'_ (Seq s\\<^sub>1'_ s\\<^sub>2_)", "by (force intro: valid_sops_stmt_mono dest: stmt_step_tmps_count_mono)"], ["proof (state)\nthis:\n  valid_sops_stmt t'_ (Seq s\\<^sub>1'_ s\\<^sub>2_)\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case SeqSkip"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       valid_sops_stmt t s\\<^sub>2\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t_ s\\<^sub>2_", "by auto"], ["proof (state)\nthis:\n  valid_sops_stmt t_ s\\<^sub>2_\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case Cond"], ["proof (state)\nthis:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt (t + used_tmps e)\n                          (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2)\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt (t_ + used_tmps e_)\n     (Cond (Tmp (eval_expr t_ e_)) s\\<^sub>1_ s\\<^sub>2_)", "by (fastforce simp add: valid_sops_expr_valid_sop intro: valid_sops_stmt_mono \n     dest: valid_sops_expr_eval_expr_in_range)"], ["proof (state)\nthis:\n  valid_sops_stmt (t_ + used_tmps e_)\n   (Cond (Tmp (eval_expr t_ e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case CondTrue"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>1\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t_ s\\<^sub>1_", "by force"], ["proof (state)\nthis:\n  valid_sops_stmt t_ s\\<^sub>1_\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case CondFalse"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t s\\<^sub>2\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t_ s\\<^sub>2_", "by force"], ["proof (state)\nthis:\n  valid_sops_stmt t_ s\\<^sub>2_\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case While"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       valid_sops_stmt t (Cond e (Seq s (While e s)) Skip)\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t_ (Cond e_ (Seq s_ (While e_ s_)) Skip)", "by auto"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (Cond e_ (Seq s_ (While e_ s_)) Skip)\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case SGhost"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       valid_sops_stmt t Skip\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t_ Skip", "by simp"], ["proof (state)\nthis:\n  valid_sops_stmt t_ Skip\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "case SFence"], ["proof (state)\nthis:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow> valid_sops_stmt t Skip", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t_ Skip", "by simp"], ["proof (state)\nthis:\n  valid_sops_stmt t_ Skip\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_le_restrict_map_eq: \"m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2 \\<Longrightarrow> D \\<subseteq> dom m\\<^sub>1 \\<Longrightarrow> m\\<^sub>2 |` D = m\\<^sub>1 |` D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2;\n     D \\<subseteq> dom m\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> m\\<^sub>2 |` D = m\\<^sub>1 |` D", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m\\<^sub>1 \\<subseteq>\\<^sub>m m\\<^sub>2;\n        D \\<subseteq> dom m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (m\\<^sub>2 |` D) x = (m\\<^sub>1 |` D) x", "apply (force simp add: restrict_map_def map_le_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sbh_step_preserves_load_tmps_bound: \n  assumes step: \"(is,\\<O>,\\<D>,\\<theta>,sb,\\<S>,m) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<O>',\\<D>',\\<theta>',sb',\\<S>',m')\"\n  assumes less: \"\\<forall>i \\<in> load_tmps is. i < n\" \n  shows \"\\<forall>i \\<in> load_tmps is'. i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps is'. i < n", "using step less"], ["proof (prove)\nusing this:\n  (is, \\<O>, \\<D>, \\<theta>, sb, \\<S>,\n   m) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<O>', \\<D>', \\<theta>',\n       sb', \\<S>', m')\n  \\<forall>i\\<in>load_tmps is. i < n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps is'. i < n", "by cases auto"], ["", "lemma sbh_step_preserves_read_tmps_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<S>')\"\n  assumes less_is: \"\\<forall>i \\<in> load_tmps is. i < n\" \n  assumes less_sb: \"\\<forall>i \\<in> read_tmps sb. i < n\" \n  shows \"\\<forall>i \\<in> read_tmps sb'. i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps sb'. i < n", "using step less_is less_sb"], ["proof (prove)\nusing this:\n  (is, \\<theta>, sb, m, \\<D>, \\<O>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<S>')\n  \\<forall>i\\<in>load_tmps is. i < n\n  \\<forall>i\\<in>read_tmps sb. i < n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps sb'. i < n", "by cases (auto simp add: read_tmps_append)"], ["", "lemma sbh_step_preserves_tmps_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<S>')\"\n  assumes less_dom: \"\\<forall>i \\<in> dom \\<theta>. i < n\" \n  assumes less_is: \"\\<forall>i \\<in> load_tmps is. i < n\" \n  shows \"\\<forall>i \\<in> dom \\<theta>'. i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>dom \\<theta>'. i < n", "using step less_dom  less_is"], ["proof (prove)\nusing this:\n  (is, \\<theta>, sb, m, \\<D>, \\<O>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<S>')\n  \\<forall>i\\<in>dom \\<theta>. i < n\n  \\<forall>i\\<in>load_tmps is. i < n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>dom \\<theta>'. i < n", "by cases (auto simp add: read_tmps_append)"], ["", "lemma flush_step_preserves_read_tmps:\n  assumes step: \"(m,sb,\\<O>) \\<rightarrow>\\<^sub>f (m',sb',\\<O>')\"\n  assumes less_sb: \"\\<forall>i \\<in> read_tmps sb. i < n\" \n  shows \"\\<forall>i \\<in> read_tmps sb'. i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps sb'. i < n", "using step less_sb"], ["proof (prove)\nusing this:\n  (m, sb, \\<O>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>')\n  \\<forall>i\\<in>read_tmps sb. i < n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps sb'. i < n", "by cases (auto simp add: read_tmps_append)"], ["", "lemma flush_step_preserves_write_sops:\n  assumes step: \"(m,sb,\\<O>) \\<rightarrow>\\<^sub>f (m',sb',\\<O>')\"\n  assumes less_sb: \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb). i < t\" \n  shows \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb'). i < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "using step less_sb"], ["proof (prove)\nusing this:\n  (m, sb, \\<O>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>')\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "by cases (auto simp add: read_tmps_append)"], ["", "lemma issue_expr_load_tmps_range': \n  \"\\<And>t. load_tmps (issue_expr t e) = {i. t \\<le> i \\<and> i < t + used_tmps e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       load_tmps (issue_expr t e) =\n       {i. t \\<le> i \\<and> i < t + used_tmps e}", "apply (induct e)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       load_tmps (issue_expr t (Const x)) =\n       {i. t \\<le> i \\<and> i < t + used_tmps (Const x)}\n 2. \\<And>x1a x2 t.\n       load_tmps (issue_expr t (Mem x1a x2)) =\n       {i. t \\<le> i \\<and> i < t + used_tmps (Mem x1a x2)}\n 3. \\<And>x t.\n       load_tmps (issue_expr t (Tmp x)) =\n       {i. t \\<le> i \\<and> i < t + used_tmps (Tmp x)}\n 4. \\<And>x1a e t.\n       (\\<And>t.\n           load_tmps (issue_expr t e) =\n           {i. t \\<le> i \\<and> i < t + used_tmps e}) \\<Longrightarrow>\n       load_tmps (issue_expr t (Unop x1a e)) =\n       {i. t \\<le> i \\<and> i < t + used_tmps (Unop x1a e)}\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   load_tmps (issue_expr t e1) =\n                   {i. t \\<le> i \\<and> i < t + used_tmps e1};\n        \\<And>t.\n           load_tmps (issue_expr t e2) =\n           {i. t \\<le> i \\<and> i < t + used_tmps e2}\\<rbrakk>\n       \\<Longrightarrow> load_tmps (issue_expr t (Binop x1a e1 e2)) =\n                         {i. t \\<le> i \\<and>\n                             i < t + used_tmps (Binop x1a e1 e2)}", "apply (force simp add: load_tmps_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma issue_expr_load_tmps_range: \n  \"\\<And>t. \\<forall>i \\<in> load_tmps (issue_expr t e). t \\<le> i \\<and> i < t + (used_tmps e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<forall>i\\<in>load_tmps (issue_expr t e).\n          t \\<le> i \\<and> i < t + used_tmps e", "by (auto simp add: issue_expr_load_tmps_range')"], ["", "lemma stmt_step_load_tmps_range':\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  shows \"load_tmps is = {i. t \\<le> i \\<and> i < t'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. load_tmps is = {i. t \\<le> i \\<and> i < t'}", "using step"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n\ngoal (1 subgoal):\n 1. load_tmps is = {i. t \\<le> i \\<and> i < t'}", "apply (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       load_tmps (issue_expr t a) =\n       {i. t \\<le> i \\<and> i < t + used_tmps a}\n 2. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       load_tmps\n        (issue_expr t e @\n         [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n           (L \\<theta>) (R \\<theta>) (W \\<theta>)]) =\n       {i. t \\<le> i \\<and> i < t + used_tmps e}\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       load_tmps (issue_expr t a) =\n       {i. t \\<le> i \\<and> i < t + used_tmps a}\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       load_tmps (issue_expr t c\\<^sub>e) =\n       {i. t \\<le> i \\<and> i < t + used_tmps c\\<^sub>e}\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> load_tmps\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)]) =\n                         {i. t \\<le> i \\<and>\n                             i < Suc (t + used_tmps s\\<^sub>e)}\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        load_tmps is = {i. t \\<le> i \\<and> i < t'}\\<rbrakk>\n       \\<Longrightarrow> load_tmps is = {i. t \\<le> i \\<and> i < t'}\n 7. \\<And>s\\<^sub>2 t. load_tmps [] = {i. t \\<le> i \\<and> i < t}\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       load_tmps (issue_expr t e) =\n       {i. t \\<le> i \\<and> i < t + used_tmps e}\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> load_tmps [] = {i. t \\<le> i \\<and> i < t}\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>;\n         \\<not> isTrue (e \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> load_tmps [] = {i. t \\<le> i \\<and> i < t}\nA total of 13 subgoals...", "apply (force simp add: load_tmps_append simp add: issue_expr_load_tmps_range')+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stmt_step_load_tmps_range:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  shows \"\\<forall>i \\<in> load_tmps is. t \\<le> i \\<and> i < t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps is. t \\<le> i \\<and> i < t'", "using stmt_step_load_tmps_range' [OF step]"], ["proof (prove)\nusing this:\n  load_tmps is = {i. t \\<le> i \\<and> i < t'}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps is. t \\<le> i \\<and> i < t'", "by auto"], ["", "lemma distinct_load_tmps_issue_expr: \"\\<And>t. distinct_load_tmps (issue_expr t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. distinct_load_tmps (issue_expr t e)", "apply (induct e)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x t. distinct_load_tmps (issue_expr t (Const x))\n 2. \\<And>x1a x2 t. distinct_load_tmps (issue_expr t (Mem x1a x2))\n 3. \\<And>x t. distinct_load_tmps (issue_expr t (Tmp x))\n 4. \\<And>x1a e t.\n       (\\<And>t. distinct_load_tmps (issue_expr t e)) \\<Longrightarrow>\n       distinct_load_tmps (issue_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t. distinct_load_tmps (issue_expr t e1);\n        \\<And>t. distinct_load_tmps (issue_expr t e2)\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps (issue_expr t (Binop x1a e1 e2))", "apply (auto simp add: distinct_load_tmps_append dest!: issue_expr_load_tmps_range [rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma max_used_load_tmps: \"t + used_tmps e \\<notin> load_tmps (issue_expr t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + used_tmps e \\<notin> load_tmps (issue_expr t e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t + used_tmps e \\<notin> load_tmps (issue_expr t e)", "from issue_expr_load_tmps_range [rule_format, of \"t+used_tmps e\"]"], ["proof (chain)\npicking this:\n  t + used_tmps e \\<in> load_tmps (issue_expr ?t ?e) \\<Longrightarrow>\n  ?t \\<le> t + used_tmps e \\<and> t + used_tmps e < ?t + used_tmps ?e", "show ?thesis"], ["proof (prove)\nusing this:\n  t + used_tmps e \\<in> load_tmps (issue_expr ?t ?e) \\<Longrightarrow>\n  ?t \\<le> t + used_tmps e \\<and> t + used_tmps e < ?t + used_tmps ?e\n\ngoal (1 subgoal):\n 1. t + used_tmps e \\<notin> load_tmps (issue_expr t e)", "by auto"], ["proof (state)\nthis:\n  t + used_tmps e \\<notin> load_tmps (issue_expr t e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stmt_step_distinct_load_tmps:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  shows \"distinct_load_tmps is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_load_tmps is", "using step"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is", "apply (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       distinct_load_tmps (issue_expr t a)\n 2. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       distinct_load_tmps\n        (issue_expr t e @\n         [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n           (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       distinct_load_tmps (issue_expr t a)\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       distinct_load_tmps (issue_expr t c\\<^sub>e)\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        distinct_load_tmps is\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is\n 7. \\<And>s\\<^sub>2 t. distinct_load_tmps []\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       distinct_load_tmps (issue_expr t e)\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps []\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>;\n         \\<not> isTrue (e \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> distinct_load_tmps []\nA total of 13 subgoals...", "apply (force simp add: distinct_load_tmps_append distinct_load_tmps_issue_expr max_used_load_tmps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma store_sops_issue_expr [simp]: \"\\<And>t. store_sops (issue_expr t e) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. store_sops (issue_expr t e) = {}", "apply (induct e)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x t. store_sops (issue_expr t (Const x)) = {}\n 2. \\<And>x1a x2 t. store_sops (issue_expr t (Mem x1a x2)) = {}\n 3. \\<And>x t. store_sops (issue_expr t (Tmp x)) = {}\n 4. \\<And>x1a e t.\n       (\\<And>t. store_sops (issue_expr t e) = {}) \\<Longrightarrow>\n       store_sops (issue_expr t (Unop x1a e)) = {}\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t. store_sops (issue_expr t e1) = {};\n        \\<And>t. store_sops (issue_expr t e2) = {}\\<rbrakk>\n       \\<Longrightarrow> store_sops (issue_expr t (Binop x1a e1 e2)) = {}", "apply (auto simp add: store_sops_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stmt_step_data_store_sops_range:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"\\<forall>(D,f) \\<in> store_sops is. \\<forall>i \\<in> D. i < t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t'", "using step valid"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t'", "proof (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t e @\n   [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                             \\<forall>i\\<in>D. i < t\nA total of 13 subgoals...", "case AssignAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t e @\n   [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                             \\<forall>i\\<in>D. i < t\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops (issue_expr t_ a_).\n       \\<forall>i\\<in>D. i < t_ + used_tmps a_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops (issue_expr t_ a_).\n     \\<forall>i\\<in>D. i < t_ + used_tmps a_\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t e @\n   [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t e @\n   [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\nA total of 12 subgoals...", "case (Assign D volatile a e)"], ["proof (state)\nthis:\n  D \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile (Tmp (D, a)) e A_ L_ R_ W_)\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t e @\n   [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  D \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile (Tmp (D, a)) e A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\n             \\<in>store_sops\n                   (issue_expr t_ e @\n                    [Write volatile (a \\<theta>) (eval_expr t_ e)\n                      (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>)\n                      (W_ \\<theta>)]).\n       \\<forall>i\\<in>D. i < t_ + used_tmps e", "apply (cases \"eval_expr t e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t_ (Assign volatile (Tmp (D, a)) e A_ L_ R_ W_);\n        eval_expr t e = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t_ e @\n   [Write volatile (a \\<theta>) (eval_expr t_ e) (A_ \\<theta>) (L_ \\<theta>)\n     (R_ \\<theta>) (W_ \\<theta>)]).\n                            \\<forall>i\\<in>D. i < t_ + used_tmps e", "apply (auto simp add: store_sops_append intro: valid_sops_expr_eval_expr_in_range [rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>(D, f)\n           \\<in>store_sops\n                 (issue_expr t_ e @\n                  [Write volatile (a \\<theta>) (eval_expr t_ e)\n                    (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>)\n                    (W_ \\<theta>)]).\n     \\<forall>i\\<in>D. i < t_ + used_tmps e\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        \\<forall>(D, f)\n                 \\<in>store_sops\n                       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                         (W \\<theta>)].\n           \\<forall>i\\<in>D. i < t\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        \\<forall>(D, f)\n                 \\<in>store_sops\n                       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                         (W \\<theta>)].\n           \\<forall>i\\<in>D. i < t\nA total of 11 subgoals...", "case CASAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t a).\n                            \\<forall>i\\<in>D. i < t + used_tmps a\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        \\<forall>(D, f)\n                 \\<in>store_sops\n                       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                         (W \\<theta>)].\n           \\<forall>i\\<in>D. i < t\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops (issue_expr t_ a_).\n       \\<forall>i\\<in>D. i < t_ + used_tmps a_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops (issue_expr t_ a_).\n     \\<forall>i\\<in>D. i < t_ + used_tmps a_\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case CASComp"], ["proof (state)\nthis:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops (issue_expr t c\\<^sub>e).\n                            \\<forall>i\\<in>D. i < t + used_tmps c\\<^sub>e\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops (issue_expr t_ c\\<^sub>e_).\n       \\<forall>i\\<in>D. i < t_ + used_tmps c\\<^sub>e_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops (issue_expr t_ c\\<^sub>e_).\n     \\<forall>i\\<in>D. i < t_ + used_tmps c\\<^sub>e_\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case (CAS _ _ D f a A L R)"], ["proof (state)\nthis:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr D f = (a, A)\n  valid_sops_stmt D\n   (CAS (Tmp (D\\<^sub>a_, L)) (Tmp (D\\<^sub>c_, R)) f A_ L_ R_ W_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\n                                  \\<in>store_sops\n  (issue_expr t s\\<^sub>e @\n   [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n     (\\<lambda>\\<theta>.\n         the (\\<theta> (t + used_tmps s\\<^sub>e)) = c \\<theta>)\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A \\<theta>) (L \\<theta>)\n     (R \\<theta>) (W \\<theta>)]).\n                            \\<forall>i\\<in>D.\n                               i < Suc (t + used_tmps s\\<^sub>e)\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr D f = (a, A)\n  valid_sops_stmt D\n   (CAS (Tmp (D\\<^sub>a_, L)) (Tmp (D\\<^sub>c_, R)) f A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. \\<forall>(Da, fa)\n             \\<in>store_sops\n                   (issue_expr D f @\n                    [RMW (L \\<theta>) (D + used_tmps f) (a, A)\n                      (\\<lambda>\\<theta>.\n                          the (\\<theta> (D + used_tmps f)) = R \\<theta>)\n                      (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                      (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>)\n                      (W_ \\<theta>)]).\n       \\<forall>i\\<in>Da. i < Suc (D + used_tmps f)", "by (fastforce simp add: store_sops_append dest: valid_sops_expr_eval_expr_in_range [rule_format])"], ["proof (state)\nthis:\n  \\<forall>(Da, fa)\n           \\<in>store_sops\n                 (issue_expr D f @\n                  [RMW (L \\<theta>) (D + used_tmps f) (a, A)\n                    (\\<lambda>\\<theta>.\n                        the (\\<theta> (D + used_tmps f)) = R \\<theta>)\n                    (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>)\n                    (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]).\n     \\<forall>i\\<in>Da. i < Suc (D + used_tmps f)\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case Seq"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  \\<forall>(D, f)\\<in>store_sops is_. \\<forall>i\\<in>D. i < t'_\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        \\<forall>(D, f)\\<in>store_sops is. \\<forall>i\\<in>D. i < t';\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops is.\n                            \\<forall>i\\<in>D. i < t'\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  \\<forall>(D, f)\\<in>store_sops is_. \\<forall>i\\<in>D. i < t'_\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops is_. \\<forall>i\\<in>D. i < t'_", "by (force intro: valid_sops_stmt_mono )"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops is_. \\<forall>i\\<in>D. i < t'_\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case SeqSkip"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_", "by simp"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case Cond"], ["proof (state)\nthis:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops (issue_expr t e).\n                            \\<forall>i\\<in>D. i < t + used_tmps e\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops (issue_expr t_ e_).\n       \\<forall>i\\<in>D. i < t_ + used_tmps e_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops (issue_expr t_ e_).\n     \\<forall>i\\<in>D. i < t_ + used_tmps e_\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case CondTrue"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case CondFalse"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(D, f)\\<in>store_sops [].\n                            \\<forall>i\\<in>D. i < t\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case While"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops []. \\<forall>i\\<in>D. i < t_\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case SGhost"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       \\<forall>(D, f)\n                \\<in>store_sops\n                      [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                        (W \\<theta>)].\n          \\<forall>i\\<in>D. i < t\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\n             \\<in>store_sops\n                   [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>)\n                     (W_ \\<theta>)].\n       \\<forall>i\\<in>D. i < t_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\n           \\<in>store_sops\n                 [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>)\n                   (W_ \\<theta>)].\n     \\<forall>i\\<in>D. i < t_\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "case SFence"], ["proof (state)\nthis:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t_", "by auto"], ["proof (state)\nthis:\n  \\<forall>(D, f)\\<in>store_sops [Fence]. \\<forall>i\\<in>D. i < t_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sbh_step_distinct_load_tmps_prog_step: \n      assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is')\"\n  assumes load_tmps_le: \"\\<forall>i \\<in> load_tmps is. i < t\"\n  assumes read_tmps_le: \"\\<forall>i \\<in> read_tmps sb. i < t\"\n  shows \"distinct_load_tmps is' \\<and> (load_tmps is' \\<inter> load_tmps is = {}) \\<and>\n         (load_tmps is' \\<inter> read_tmps sb) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "from stmt_step_load_tmps_range [OF step] stmt_step_distinct_load_tmps [OF step] \n    load_tmps_le read_tmps_le"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  distinct_load_tmps is'\n  \\<forall>i\\<in>load_tmps is. i < t\n  \\<forall>i\\<in>read_tmps sb. i < t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  distinct_load_tmps is'\n  \\<forall>i\\<in>load_tmps is. i < t\n  \\<forall>i\\<in>read_tmps sb. i < t\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "by force"], ["proof (state)\nthis:\n  distinct_load_tmps is' \\<and>\n  load_tmps is' \\<inter> load_tmps is = {} \\<and>\n  load_tmps is' \\<inter> read_tmps sb = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma data_dependency_consistent_instrs_issue_expr: \n  \"\\<And>t T. data_dependency_consistent_instrs T (issue_expr t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t T. data_dependency_consistent_instrs T (issue_expr t e)", "apply (induct e)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x t T.\n       data_dependency_consistent_instrs T (issue_expr t (Const x))\n 2. \\<And>x1a x2 t T.\n       data_dependency_consistent_instrs T (issue_expr t (Mem x1a x2))\n 3. \\<And>x t T. data_dependency_consistent_instrs T (issue_expr t (Tmp x))\n 4. \\<And>x1a e t T.\n       (\\<And>t T.\n           data_dependency_consistent_instrs T\n            (issue_expr t e)) \\<Longrightarrow>\n       data_dependency_consistent_instrs T (issue_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t T.\n       \\<lbrakk>\\<And>t T.\n                   data_dependency_consistent_instrs T (issue_expr t e1);\n        \\<And>t T.\n           data_dependency_consistent_instrs T (issue_expr t e2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs T\n                          (issue_expr t (Binop x1a e1 e2))", "apply (auto simp add: data_dependency_consistent_instrs_append \n    dest!: issue_expr_load_tmps_range [rule_format] \n    )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_eval_expr:\n  \"\\<And>t. \\<lbrakk>valid_sops_expr t e; x \\<in> fst (eval_expr t e)\\<rbrakk> \\<Longrightarrow> x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>valid_sops_expr t e; x \\<in> fst (eval_expr t e)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t e)", "proof (induct e)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Const xa);\n        x \\<in> fst (eval_expr t (Const xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Const xa))\n 2. \\<And>x1a x2 t.\n       \\<lbrakk>valid_sops_expr t (Mem x1a x2);\n        x \\<in> fst (eval_expr t (Mem x1a x2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Mem x1a x2))\n 3. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "case Const"], ["proof (state)\nthis:\n  valid_sops_expr t (Const x_)\n  x \\<in> fst (eval_expr t (Const x_))\n\ngoal (5 subgoals):\n 1. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Const xa);\n        x \\<in> fst (eval_expr t (Const xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Const xa))\n 2. \\<And>x1a x2 t.\n       \\<lbrakk>valid_sops_expr t (Mem x1a x2);\n        x \\<in> fst (eval_expr t (Mem x1a x2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Mem x1a x2))\n 3. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 4. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 5. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_expr t (Const x_)\n  x \\<in> fst (eval_expr t (Const x_))\n\ngoal (1 subgoal):\n 1. x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Const x_))", "by simp"], ["proof (state)\nthis:\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Const x_))\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2 t.\n       \\<lbrakk>valid_sops_expr t (Mem x1a x2);\n        x \\<in> fst (eval_expr t (Mem x1a x2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Mem x1a x2))\n 2. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 3. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a x2 t.\n       \\<lbrakk>valid_sops_expr t (Mem x1a x2);\n        x \\<in> fst (eval_expr t (Mem x1a x2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Mem x1a x2))\n 2. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 3. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "case Mem"], ["proof (state)\nthis:\n  valid_sops_expr t (Mem x1a_ x2_)\n  x \\<in> fst (eval_expr t (Mem x1a_ x2_))\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2 t.\n       \\<lbrakk>valid_sops_expr t (Mem x1a x2);\n        x \\<in> fst (eval_expr t (Mem x1a x2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Mem x1a x2))\n 2. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 3. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 4. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_expr t (Mem x1a_ x2_)\n  x \\<in> fst (eval_expr t (Mem x1a_ x2_))\n\ngoal (1 subgoal):\n 1. x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Mem x1a_ x2_))", "by simp"], ["proof (state)\nthis:\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Mem x1a_ x2_))\n\ngoal (3 subgoals):\n 1. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 2. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 3. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 2. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 3. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "case Tmp"], ["proof (state)\nthis:\n  valid_sops_expr t (Tmp x_)\n  x \\<in> fst (eval_expr t (Tmp x_))\n\ngoal (3 subgoals):\n 1. \\<And>xa t.\n       \\<lbrakk>valid_sops_expr t (Tmp xa);\n        x \\<in> fst (eval_expr t (Tmp xa))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Tmp xa))\n 2. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 3. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_expr t (Tmp x_)\n  x \\<in> fst (eval_expr t (Tmp x_))\n\ngoal (1 subgoal):\n 1. x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Tmp x_))", "by simp"], ["proof (state)\nthis:\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Tmp x_))\n\ngoal (2 subgoals):\n 1. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 2. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 2. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "case (Unop f e)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_sops_expr ?t e; x \\<in> fst (eval_expr ?t e)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union> load_tmps (issue_expr ?t e)\n  valid_sops_expr t (Unop f e)\n  x \\<in> fst (eval_expr t (Unop f e))\n\ngoal (2 subgoals):\n 1. \\<And>x1a e t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e;\n                    x \\<in> fst (eval_expr t e)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e);\n        valid_sops_expr t (Unop x1a e);\n        x \\<in> fst (eval_expr t (Unop x1a e))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Unop x1a e))\n 2. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_sops_expr ?t e; x \\<in> fst (eval_expr ?t e)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union> load_tmps (issue_expr ?t e)\n  valid_sops_expr t (Unop f e)\n  x \\<in> fst (eval_expr t (Unop f e))\n\ngoal (1 subgoal):\n 1. x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Unop f e))", "by (cases \"eval_expr t e\") auto"], ["proof (state)\nthis:\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Unop f e))\n\ngoal (1 subgoal):\n 1. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "case (Binop f e1 e2)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_sops_expr ?t e1; x \\<in> fst (eval_expr ?t e1)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union>\n                            load_tmps (issue_expr ?t e1)\n  \\<lbrakk>valid_sops_expr ?t e2; x \\<in> fst (eval_expr ?t e2)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union>\n                            load_tmps (issue_expr ?t e2)\n  valid_sops_expr t (Binop f e1 e2)\n  x \\<in> fst (eval_expr t (Binop f e1 e2))\n\ngoal (1 subgoal):\n 1. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_sops_expr ?t e1; x \\<in> fst (eval_expr ?t e1)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union>\n                            load_tmps (issue_expr ?t e1)\n  \\<lbrakk>valid_sops_expr ?t e2; x \\<in> fst (eval_expr ?t e2)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union>\n                            load_tmps (issue_expr ?t e2)\n  valid_sops_expr t (Binop f e1 e2)\n  x \\<in> fst (eval_expr t (Binop f e1 e2))", "obtain valid1: \"valid_sops_expr t e1\" and valid2: \"valid_sops_expr t e2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_sops_expr ?t e1; x \\<in> fst (eval_expr ?t e1)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union>\n                            load_tmps (issue_expr ?t e1)\n  \\<lbrakk>valid_sops_expr ?t e2; x \\<in> fst (eval_expr ?t e2)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {i. i < ?t} \\<union>\n                            load_tmps (issue_expr ?t e2)\n  valid_sops_expr t (Binop f e1 e2)\n  x \\<in> fst (eval_expr t (Binop f e1 e2))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>valid_sops_expr t e1; valid_sops_expr t e2\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_sops_expr t e1\n  valid_sops_expr t e2\n\ngoal (1 subgoal):\n 1. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "from valid_sops_expr_mono [OF valid2]"], ["proof (chain)\npicking this:\n  t \\<le> ?t' \\<Longrightarrow> valid_sops_expr ?t' e2", "have valid2': \"valid_sops_expr (t+used_tmps e1) e2\""], ["proof (prove)\nusing this:\n  t \\<le> ?t' \\<Longrightarrow> valid_sops_expr ?t' e2\n\ngoal (1 subgoal):\n 1. valid_sops_expr (t + used_tmps e1) e2", "by auto"], ["proof (state)\nthis:\n  valid_sops_expr (t + used_tmps e1) e2\n\ngoal (1 subgoal):\n 1. \\<And>x1a e1 e2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>valid_sops_expr t e1;\n                    x \\<in> fst (eval_expr t e1)\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n       load_tmps (issue_expr t e1);\n        \\<And>t.\n           \\<lbrakk>valid_sops_expr t e2;\n            x \\<in> fst (eval_expr t e2)\\<rbrakk>\n           \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                     load_tmps (issue_expr t e2);\n        valid_sops_expr t (Binop x1a e1 e2);\n        x \\<in> fst (eval_expr t (Binop x1a e1 e2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop x1a e1 e2))", "from Binop.hyps (1) [OF valid1] Binop.hyps (2) [OF valid2'] Binop.prems"], ["proof (chain)\npicking this:\n  x \\<in> fst (eval_expr t e1) \\<Longrightarrow>\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t e1)\n  x \\<in> fst (eval_expr (t + used_tmps e1) e2) \\<Longrightarrow>\n  x \\<in> {i. i < t + used_tmps e1} \\<union>\n          load_tmps (issue_expr (t + used_tmps e1) e2)\n  valid_sops_expr t (Binop f e1 e2)\n  x \\<in> fst (eval_expr t (Binop f e1 e2))", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> fst (eval_expr t e1) \\<Longrightarrow>\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t e1)\n  x \\<in> fst (eval_expr (t + used_tmps e1) e2) \\<Longrightarrow>\n  x \\<in> {i. i < t + used_tmps e1} \\<union>\n          load_tmps (issue_expr (t + used_tmps e1) e2)\n  valid_sops_expr t (Binop f e1 e2)\n  x \\<in> fst (eval_expr t (Binop f e1 e2))\n\ngoal (1 subgoal):\n 1. x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Binop f e1 e2))", "apply (case_tac \"eval_expr t e1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> fst (eval_expr t e1) \\<Longrightarrow>\n                x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t e1);\n        x \\<in> fst (eval_expr (t + used_tmps e1) e2) \\<Longrightarrow>\n        x \\<in> {i. i < t + used_tmps e1} \\<union>\n                load_tmps (issue_expr (t + used_tmps e1) e2);\n        valid_sops_expr t (Binop f e1 e2);\n        x \\<in> fst (eval_expr t (Binop f e1 e2));\n        eval_expr t e1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop f e1 e2))", "apply (case_tac \"eval_expr (t+used_tmps e1) e2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x \\<in> fst (eval_expr t e1) \\<Longrightarrow>\n                x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t e1);\n        x \\<in> fst (eval_expr (t + used_tmps e1) e2) \\<Longrightarrow>\n        x \\<in> {i. i < t + used_tmps e1} \\<union>\n                load_tmps (issue_expr (t + used_tmps e1) e2);\n        valid_sops_expr t (Binop f e1 e2);\n        x \\<in> fst (eval_expr t (Binop f e1 e2)); eval_expr t e1 = (a, b);\n        eval_expr (t + used_tmps e1) e2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {i. i < t} \\<union>\n                                 load_tmps (issue_expr t (Binop f e1 e2))", "apply (auto simp add: load_tmps_append issue_expr_load_tmps_range')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<in> {i. i < t} \\<union> load_tmps (issue_expr t (Binop f e1 e2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cond_not_s\\<^sub>1: \"s\\<^sub>1 \\<noteq> Cond e s\\<^sub>1 s\\<^sub>2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<noteq> Cond e s\\<^sub>1 s\\<^sub>2", "by (induct s\\<^sub>1) auto"], ["", "lemma Cond_not_s\\<^sub>2: \"s\\<^sub>2 \\<noteq> Cond e s\\<^sub>1 s\\<^sub>2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>2 \\<noteq> Cond e s\\<^sub>1 s\\<^sub>2", "by (induct s\\<^sub>2) auto"], ["", "lemma Seq_not_s\\<^sub>1: \"s\\<^sub>1 \\<noteq> Seq s\\<^sub>1 s\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<noteq> Seq s\\<^sub>1 s\\<^sub>2", "by (induct s\\<^sub>1) auto"], ["", "lemma Seq_not_s\\<^sub>2: \"s\\<^sub>2 \\<noteq> Seq s\\<^sub>1 s\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>2 \\<noteq> Seq s\\<^sub>1 s\\<^sub>2", "by (induct s\\<^sub>2) auto"], ["", "lemma prog_step_progress:\n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  shows \"(s',t') \\<noteq> (s,t) \\<or> is \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', t') \\<noteq> (s, t) \\<or> is \\<noteq> []", "using step"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n\ngoal (1 subgoal):\n 1. (s', t') \\<noteq> (s, t) \\<or> is \\<noteq> []", "proof (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (Assign volatile (Tmp (eval_expr t a)) e A L R W,\n        t + used_tmps a) \\<noteq>\n       (Assign volatile a e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 2. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       (Skip, t + used_tmps e) \\<noteq>\n       (Assign volatile (Tmp (D, a)) e A L R W, t) \\<or>\n       issue_expr t e @\n       [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n         (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 7. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>;\n         \\<not> isTrue (e \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                          (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                          [] \\<noteq> []\nA total of 13 subgoals...", "case (AssignAddr a _ _ _ _ _ _ t)"], ["proof (state)\nthis:\n  \\<forall>sop. a \\<noteq> Tmp sop\n\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (Assign volatile (Tmp (eval_expr t a)) e A L R W,\n        t + used_tmps a) \\<noteq>\n       (Assign volatile a e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 2. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       (Skip, t + used_tmps e) \\<noteq>\n       (Assign volatile (Tmp (D, a)) e A L R W, t) \\<or>\n       issue_expr t e @\n       [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n         (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 7. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>;\n         \\<not> isTrue (e \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                          (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                          [] \\<noteq> []\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a \\<noteq> Tmp sop\n\ngoal (1 subgoal):\n 1. (Assign volatile_ (Tmp (eval_expr t a)) e_ A_ L_ R_ W_,\n     t + used_tmps a) \\<noteq>\n    (Assign volatile_ a e_ A_ L_ R_ W_, t) \\<or>\n    issue_expr t a \\<noteq> []", "by (cases \"eval_expr t a\") auto"], ["proof (state)\nthis:\n  (Assign volatile_ (Tmp (eval_expr t a)) e_ A_ L_ R_ W_,\n   t + used_tmps a) \\<noteq>\n  (Assign volatile_ a e_ A_ L_ R_ W_, t) \\<or>\n  issue_expr t a \\<noteq> []\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       (Skip, t + used_tmps e) \\<noteq>\n       (Assign volatile (Tmp (D, a)) e A L R W, t) \\<or>\n       issue_expr t e @\n       [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n         (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 6. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 10. \\<And>e s t.\n        (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n        [] \\<noteq> []\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       (Skip, t + used_tmps e) \\<noteq>\n       (Assign volatile (Tmp (D, a)) e A L R W, t) \\<or>\n       issue_expr t e @\n       [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n         (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 6. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 10. \\<And>e s t.\n        (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n        [] \\<noteq> []\nA total of 12 subgoals...", "case Assign"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       D \\<subseteq> dom \\<theta> \\<Longrightarrow>\n       (Skip, t + used_tmps e) \\<noteq>\n       (Assign volatile (Tmp (D, a)) e A L R W, t) \\<or>\n       issue_expr t e @\n       [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>)\n         (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 6. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 10. \\<And>e s t.\n        (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n        [] \\<noteq> []\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n\ngoal (1 subgoal):\n 1. (Skip, t_ + used_tmps e_) \\<noteq>\n    (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_, t_) \\<or>\n    issue_expr t_ e_ @\n    [Write volatile_ (a_ \\<theta>) (eval_expr t_ e_) (A_ \\<theta>)\n      (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)] \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  (Skip, t_ + used_tmps e_) \\<noteq>\n  (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_, t_) \\<or>\n  issue_expr t_ e_ @\n  [Write volatile_ (a_ \\<theta>) (eval_expr t_ e_) (A_ \\<theta>)\n    (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)] \\<noteq>\n  []\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 5. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 9. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 10. \\<And>A L R W t.\n        (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n        []\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 5. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 9. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 10. \\<And>A L R W t.\n        (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n        []\nA total of 11 subgoals...", "case (CASAddr a _ _ _ _ _ _ t)"], ["proof (state)\nthis:\n  \\<forall>sop. a \\<noteq> Tmp sop\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<forall>sop. a \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (eval_expr t a)) c\\<^sub>e s\\<^sub>e A L R W,\n        t + used_tmps a) \\<noteq>\n       (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t a \\<noteq> []\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 5. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 9. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 10. \\<And>A L R W t.\n        (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n        []\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a \\<noteq> Tmp sop\n\ngoal (1 subgoal):\n 1. (CAS (Tmp (eval_expr t a)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_,\n     t + used_tmps a) \\<noteq>\n    (CAS a c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_, t) \\<or>\n    issue_expr t a \\<noteq> []", "by (cases \"eval_expr t a\") auto"], ["proof (state)\nthis:\n  (CAS (Tmp (eval_expr t a)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_,\n   t + used_tmps a) \\<noteq>\n  (CAS a c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_, t) \\<or>\n  issue_expr t a \\<noteq> []\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 4. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 8. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 9. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 10. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 4. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 8. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 9. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 10. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case (CASComp c\\<^sub>e _ _ _ _ _ _ _ t)"], ["proof (state)\nthis:\n  \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop \\<Longrightarrow>\n       (CAS (Tmp (D\\<^sub>a, a)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e A L\n         R W,\n        t + used_tmps c\\<^sub>e) \\<noteq>\n       (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W, t) \\<or>\n       issue_expr t c\\<^sub>e \\<noteq> []\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 4. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 8. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 9. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 10. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop\n\ngoal (1 subgoal):\n 1. (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e_ A_\n      L_ R_ W_,\n     t + used_tmps c\\<^sub>e) \\<noteq>\n    (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e s\\<^sub>e_ A_ L_ R_ W_, t) \\<or>\n    issue_expr t c\\<^sub>e \\<noteq> []", "by (cases \"eval_expr t c\\<^sub>e\") auto"], ["proof (state)\nthis:\n  (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (eval_expr t c\\<^sub>e)) s\\<^sub>e_ A_ L_\n    R_ W_,\n   t + used_tmps c\\<^sub>e) \\<noteq>\n  (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e s\\<^sub>e_ A_ L_ R_ W_, t) \\<or>\n  issue_expr t c\\<^sub>e \\<noteq> []\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 3. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 7. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 8. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 9. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 3. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 7. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 8. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 9. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case CAS"], ["proof (state)\nthis:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>;\n        eval_expr t s\\<^sub>e = (D, f)\\<rbrakk>\n       \\<Longrightarrow> (Skip, Suc (t + used_tmps s\\<^sub>e)) \\<noteq>\n                         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c))\n                           s\\<^sub>e A L R W,\n                          t) \\<or>\n                         issue_expr t s\\<^sub>e @\n                         [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e) (D, f)\n                           (\\<lambda>\\<theta>.\n                               the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                               c \\<theta>)\n                           (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                           (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                           (W \\<theta>)] \\<noteq>\n                         []\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 3. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 7. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 8. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 9. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n\ngoal (1 subgoal):\n 1. (Skip, Suc (t_ + used_tmps s\\<^sub>e_)) \\<noteq>\n    (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n      W_,\n     t_) \\<or>\n    issue_expr t_ s\\<^sub>e_ @\n    [RMW (a_ \\<theta>) (t_ + used_tmps s\\<^sub>e_) (D_, f_)\n      (\\<lambda>\\<theta>.\n          the (\\<theta> (t_ + used_tmps s\\<^sub>e_)) = c_ \\<theta>)\n      (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>) (L_ \\<theta>)\n      (R_ \\<theta>) (W_ \\<theta>)] \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  (Skip, Suc (t_ + used_tmps s\\<^sub>e_)) \\<noteq>\n  (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_ W_,\n   t_) \\<or>\n  issue_expr t_ s\\<^sub>e_ @\n  [RMW (a_ \\<theta>) (t_ + used_tmps s\\<^sub>e_) (D_, f_)\n    (\\<lambda>\\<theta>.\n        the (\\<theta> (t_ + used_tmps s\\<^sub>e_)) = c_ \\<theta>)\n    (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>) (L_ \\<theta>)\n    (R_ \\<theta>) (W_ \\<theta>)] \\<noteq>\n  []\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 6. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 7. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 8. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 6. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 7. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 8. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case (Cond e _ _ t)"], ["proof (state)\nthis:\n  \\<forall>sop. e \\<noteq> Tmp sop\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow>\n       (Cond (Tmp (eval_expr t e)) s\\<^sub>1 s\\<^sub>2,\n        t + used_tmps e) \\<noteq>\n       (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<or>\n       issue_expr t e \\<noteq> []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 6. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 7. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 8. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. e \\<noteq> Tmp sop\n\ngoal (1 subgoal):\n 1. (Cond (Tmp (eval_expr t e)) s\\<^sub>1_ s\\<^sub>2_,\n     t + used_tmps e) \\<noteq>\n    (Cond e s\\<^sub>1_ s\\<^sub>2_, t) \\<or>\n    issue_expr t e \\<noteq> []", "by (cases \"eval_expr t e\") auto"], ["proof (state)\nthis:\n  (Cond (Tmp (eval_expr t e)) s\\<^sub>1_ s\\<^sub>2_,\n   t + used_tmps e) \\<noteq>\n  (Cond e s\\<^sub>1_ s\\<^sub>2_, t) \\<or>\n  issue_expr t e \\<noteq> []\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 5. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 6. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 7. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 5. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 6. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 7. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case CondTrue"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>1, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 5. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 6. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 7. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>1_, t_) \\<noteq>\n    (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n    [] \\<noteq> []", "using Cond_not_s\\<^sub>1"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  ?s\\<^sub>1 \\<noteq> Cond ?e ?s\\<^sub>1 ?s\\<^sub>2\n\ngoal (1 subgoal):\n 1. (s\\<^sub>1_, t_) \\<noteq>\n    (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n    [] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (s\\<^sub>1_, t_) \\<noteq>\n  (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n  [] \\<noteq> []\n\ngoal (6 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 4. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 5. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 6. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 4. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 5. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 6. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case CondFalse"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n\ngoal (6 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        \\<not> isTrue (e \\<theta>)\\<rbrakk>\n       \\<Longrightarrow> (s\\<^sub>2, t) \\<noteq>\n                         (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         [] \\<noteq> []\n 4. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 5. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 6. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>2_, t_) \\<noteq>\n    (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n    [] \\<noteq> []", "using Cond_not_s\\<^sub>2"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  ?s\\<^sub>2 \\<noteq> Cond ?e ?s\\<^sub>1 ?s\\<^sub>2\n\ngoal (1 subgoal):\n 1. (s\\<^sub>2_, t_) \\<noteq>\n    (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n    [] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (s\\<^sub>2_, t_) \\<noteq>\n  (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n  [] \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 4. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 5. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 4. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 5. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case Seq"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  (s\\<^sub>1'_, t'_) \\<noteq> (s\\<^sub>1_, t_) \\<or> is_ \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        (s\\<^sub>1', t') \\<noteq> (s\\<^sub>1, t) \\<or>\n        is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (Seq s\\<^sub>1' s\\<^sub>2, t') \\<noteq>\n                         (Seq s\\<^sub>1 s\\<^sub>2, t) \\<or>\n                         is \\<noteq> []\n 2. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 3. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 4. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 5. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  (s\\<^sub>1'_, t'_) \\<noteq> (s\\<^sub>1_, t_) \\<or> is_ \\<noteq> []\n\ngoal (1 subgoal):\n 1. (Seq s\\<^sub>1'_ s\\<^sub>2_, t'_) \\<noteq>\n    (Seq s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n    is_ \\<noteq> []", "by force"], ["proof (state)\nthis:\n  (Seq s\\<^sub>1'_ s\\<^sub>2_, t'_) \\<noteq>\n  (Seq s\\<^sub>1_ s\\<^sub>2_, t_) \\<or>\n  is_ \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 2. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 3. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 4. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 2. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 3. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 4. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case SeqSkip"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       (s\\<^sub>2, t) \\<noteq> (Seq Skip s\\<^sub>2, t) \\<or> [] \\<noteq> []\n 2. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 3. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 4. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<^sub>2_, t_) \\<noteq> (Seq Skip s\\<^sub>2_, t_) \\<or> [] \\<noteq> []", "using Seq_not_s\\<^sub>2"], ["proof (prove)\nusing this:\n  ?s\\<^sub>2 \\<noteq> Seq ?s\\<^sub>1 ?s\\<^sub>2\n\ngoal (1 subgoal):\n 1. (s\\<^sub>2_, t_) \\<noteq> (Seq Skip s\\<^sub>2_, t_) \\<or> [] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (s\\<^sub>2_, t_) \\<noteq> (Seq Skip s\\<^sub>2_, t_) \\<or> [] \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 2. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 3. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 2. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 3. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case While"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       (Cond e (Seq s (While e s)) Skip, t) \\<noteq> (While e s, t) \\<or>\n       [] \\<noteq> []\n 2. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 3. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cond e_ (Seq s_ (While e_ s_)) Skip, t_) \\<noteq>\n    (While e_ s_, t_) \\<or>\n    [] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (Cond e_ (Seq s_ (While e_ s_)) Skip, t_) \\<noteq> (While e_ s_, t_) \\<or>\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 2. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 2. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case SGhost"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       (Skip, t) \\<noteq> (SGhost A L R W, t) \\<or>\n       [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)] \\<noteq>\n       []\n 2. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Skip, t_) \\<noteq> (SGhost A_ L_ R_ W_, t_) \\<or>\n    [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)] \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  (Skip, t_) \\<noteq> (SGhost A_ L_ R_ W_, t_) \\<or>\n  [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "case SFence"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>t. (Skip, t) \\<noteq> (SFence, t) \\<or> [Fence] \\<noteq> []", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Skip, t_) \\<noteq> (SFence, t_) \\<or> [Fence] \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  (Skip, t_) \\<noteq> (SFence, t_) \\<or> [Fence] \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stmt_step_data_dependency_consistent_instrs:\n  assumes step: \"\\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'),is)\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"data_dependency_consistent_instrs ({i. i < t}) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t} is", "using step valid"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t} is", "proof (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" T rule: stmt_step.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e @\n                           [Write volatile (a \\<theta>) (eval_expr t e)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\nA total of 13 subgoals...", "case AssignAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e @\n                           [Write volatile (a \\<theta>) (eval_expr t e)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ a_)", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append \n    data_dependency_consistent_instrs_issue_expr load_tmps_append\n    dest: dom_eval_expr)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ a_)\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e @\n                           [Write volatile (a \\<theta>) (eval_expr t e)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} []\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e @\n                           [Write volatile (a \\<theta>) (eval_expr t e)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} []\nA total of 12 subgoals...", "case Assign"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_)\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e @\n                           [Write volatile (a \\<theta>) (eval_expr t e)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} []\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_}\n     (issue_expr t_ e_ @\n      [Write volatile_ (a_ \\<theta>) (eval_expr t_ e_) (A_ \\<theta>)\n        (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)])", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append \n    data_dependency_consistent_instrs_issue_expr load_tmps_append\n    dest: dom_eval_expr)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_}\n   (issue_expr t_ e_ @\n    [Write volatile_ (a_ \\<theta>) (eval_expr t_ e_) (A_ \\<theta>)\n      (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)])\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t}\n         [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t}\n         [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\nA total of 11 subgoals...", "case CASAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t a)\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t}\n         [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ a_)", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append \n    data_dependency_consistent_instrs_issue_expr load_tmps_append\n    dest: dom_eval_expr)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ a_)\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} [Fence]", "case CASComp"], ["proof (state)\nthis:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t c\\<^sub>e)\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ c\\<^sub>e_)", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append \n    data_dependency_consistent_instrs_issue_expr load_tmps_append\n    dest: dom_eval_expr)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ c\\<^sub>e_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case CAS"], ["proof (state)\nthis:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n     W_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t s\\<^sub>e @\n                           [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                             (D, f)\n                             (\\<lambda>\\<theta>.\n                                 the (\\<theta> (t + used_tmps s\\<^sub>e)) =\n                                 c \\<theta>)\n                             (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                             (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                             (W \\<theta>)])\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n     W_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_}\n     (issue_expr t_ s\\<^sub>e_ @\n      [RMW (a_ \\<theta>) (t_ + used_tmps s\\<^sub>e_) (D_, f_)\n        (\\<lambda>\\<theta>.\n            the (\\<theta> (t_ + used_tmps s\\<^sub>e_)) = c_ \\<theta>)\n        (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>)\n        (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)])", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append \n      data_dependency_consistent_instrs_issue_expr load_tmps_append\n      dest: dom_eval_expr)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_}\n   (issue_expr t_ s\\<^sub>e_ @\n    [RMW (a_ \\<theta>) (t_ + used_tmps s\\<^sub>e_) (D_, f_)\n      (\\<lambda>\\<theta>.\n          the (\\<theta> (t_ + used_tmps s\\<^sub>e_)) = c_ \\<theta>)\n      (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>) (L_ \\<theta>)\n      (R_ \\<theta>) (W_ \\<theta>)])\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case Seq"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  data_dependency_consistent_instrs {i. i < t_} is_\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        data_dependency_consistent_instrs {i. i < t} is;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} is\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  data_dependency_consistent_instrs {i. i < t_} is_\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} is_", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} is_\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case SeqSkip"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} []", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} []\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case Cond"], ["proof (state)\nthis:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t}\n                          (issue_expr t e)\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ e_)", "by (fastforce simp add: simp add: data_dependency_consistent_instrs_append \n      data_dependency_consistent_instrs_issue_expr load_tmps_append\n      dest: dom_eval_expr)"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} (issue_expr t_ e_)\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case CondTrue"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} []", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} []\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case CondFalse"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} []", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} []\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case While"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} []\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} []", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} []\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case SGhost"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t}\n        [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_}\n     [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_}\n   [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "case SFence"], ["proof (state)\nthis:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       data_dependency_consistent_instrs {i. i < t} [Fence]", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t_} [Fence]", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t_} [Fence]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sbh_valid_data_dependency_prog_step: \n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is')\"\n  assumes store_sops_le: \"\\<forall>i \\<in> \\<Union>(fst ` store_sops is). i < t\"\n  assumes write_sops_le: \"\\<forall>i \\<in> \\<Union>(fst ` write_sops sb). i < t\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"data_dependency_consistent_instrs ({i. i < t}) is' \\<and> \n         load_tmps is' \\<inter> \\<Union>(fst ` store_sops is)  = {} \\<and>\n         load_tmps is' \\<inter> \\<Union>(fst ` write_sops sb)  = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t} is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t} is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "from stmt_step_data_dependency_consistent_instrs [OF step valid] stmt_step_load_tmps_range [OF step]\n  store_sops_le write_sops_le"], ["proof (chain)\npicking this:\n  data_dependency_consistent_instrs {i. i < t} is'\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t", "show ?thesis"], ["proof (prove)\nusing this:\n  data_dependency_consistent_instrs {i. i < t} is'\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs {i. i < t} is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "by fastforce"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs {i. i < t} is' \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sbh_load_tmps_fresh_prog_step:\n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is')\"\n  assumes tmps_le: \"\\<forall>i \\<in> dom \\<theta>. i < t\"\n  shows \"load_tmps is' \\<inter> dom \\<theta> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "from stmt_step_load_tmps_range [OF step] tmps_le"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  \\<forall>i\\<in>dom \\<theta>. i < t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  \\<forall>i\\<in>dom \\<theta>. i < t\n\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t';\n        \\<forall>i\\<in>dom \\<theta>. i < t; x \\<in> load_tmps is';\n        x \\<in> dom \\<theta>\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t';\n     \\<forall>i\\<in>dom \\<theta>. i < t; x \\<in> load_tmps is';\n     x \\<in> dom \\<theta>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac x=x in bspec )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>dom \\<theta>. i < t; x \\<in> load_tmps is';\n     x \\<in> dom \\<theta>\\<rbrakk>\n    \\<Longrightarrow> x \\<in> load_tmps is'\n 2. \\<lbrakk>\\<forall>i\\<in>dom \\<theta>. i < t; x \\<in> load_tmps is';\n     x \\<in> dom \\<theta>; t \\<le> x \\<and> x < t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply  assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>dom \\<theta>. i < t; x \\<in> load_tmps is';\n     x \\<in> dom \\<theta>; t \\<le> x \\<and> x < t'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac x=x in bspec )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> load_tmps is'; x \\<in> dom \\<theta>;\n     t \\<le> x \\<and> x < t'\\<rbrakk>\n    \\<Longrightarrow> x \\<in> dom \\<theta>\n 2. \\<lbrakk>x \\<in> load_tmps is'; x \\<in> dom \\<theta>;\n     t \\<le> x \\<and> x < t'; x < t\\<rbrakk>\n    \\<Longrightarrow> False", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> load_tmps is'; x \\<in> dom \\<theta>;\n     t \\<le> x \\<and> x < t'; x < t\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  load_tmps is' \\<inter> dom \\<theta> = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sbh_valid_sops_prog_step:\n  assumes step: \"\\<theta>\\<turnstile>(s,t) \\<rightarrow>\\<^sub>s ((s',t'),is)\"\n  assumes valid: \"valid_sops_stmt t s\"\n  shows \"\\<forall>sop\\<in>store_sops is. valid_sop sop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "using step valid"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "proof (induct x==\"(s,t)\" y==\"((s',t'),is)\" arbitrary: s t s' t' \"is\" rule: stmt_step.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t e @\n                             [Write volatile (a \\<theta>) (eval_expr t e)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> Ball (store_sops []) valid_sop\nA total of 13 subgoals...", "case AssignAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (13 subgoals):\n 1. \\<And>a volatile e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (Assign volatile a e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 2. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t e @\n                             [Write volatile (a \\<theta>) (eval_expr t e)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 3. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 4. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 5. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 6. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 7. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 8. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 10. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n        \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n         valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> Ball (store_sops []) valid_sop\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Assign volatile_ a_ e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops (issue_expr t_ a_)) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops (issue_expr t_ a_)) valid_sop\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t e @\n                             [Write volatile (a \\<theta>) (eval_expr t e)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        Ball (store_sops []) valid_sop\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t e @\n                             [Write volatile (a \\<theta>) (eval_expr t e)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        Ball (store_sops []) valid_sop\nA total of 12 subgoals...", "case Assign"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_)\n\ngoal (12 subgoals):\n 1. \\<And>D volatile a e A L R W t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>;\n        valid_sops_stmt t (Assign volatile (Tmp (D, a)) e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t e @\n                             [Write volatile (a \\<theta>) (eval_expr t e)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 2. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 3. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 4. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 5. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 6. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 7. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 9. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 10. \\<And>e s t.\n        valid_sops_stmt t (While e s) \\<Longrightarrow>\n        Ball (store_sops []) valid_sop\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  valid_sops_stmt t_ (Assign volatile_ (Tmp (D_, a_)) e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. Ball\n     (store_sops\n       (issue_expr t_ e_ @\n        [Write volatile_ (a_ \\<theta>) (eval_expr t_ e_) (A_ \\<theta>)\n          (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]))\n     valid_sop", "by (auto simp add: store_sops_append valid_sops_expr_valid_sop)"], ["proof (state)\nthis:\n  Ball\n   (store_sops\n     (issue_expr t_ e_ @\n      [Write volatile_ (a_ \\<theta>) (eval_expr t_ e_) (A_ \\<theta>)\n        (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]))\n   valid_sop\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        Ball\n         (store_sops\n           [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n         valid_sop\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        Ball\n         (store_sops\n           [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n         valid_sop\nA total of 11 subgoals...", "case CASAddr"], ["proof (state)\nthis:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (11 subgoals):\n 1. \\<And>a c\\<^sub>e s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop;\n        valid_sops_stmt t (CAS a c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t a)) valid_sop\n 2. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 3. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 4. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 5. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 6. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 8. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 9. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 10. \\<And>A L R W t.\n        valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n        Ball\n         (store_sops\n           [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n         valid_sop\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. a_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (CAS a_ c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops (issue_expr t_ a_)) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops (issue_expr t_ a_)) valid_sop\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        Ball (store_sops [Fence]) valid_sop", "case CASComp"], ["proof (state)\nthis:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (10 subgoals):\n 1. \\<And>c\\<^sub>e D\\<^sub>a a s\\<^sub>e A L R W t.\n       \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) c\\<^sub>e s\\<^sub>e A L R W)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t c\\<^sub>e))\n                          valid_sop\n 2. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 3. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 4. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 5. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 7. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 8. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 9. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 10. \\<And>t.\n        valid_sops_stmt t SFence \\<Longrightarrow>\n        Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. c\\<^sub>e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) c\\<^sub>e_ s\\<^sub>e_ A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops (issue_expr t_ c\\<^sub>e_)) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops (issue_expr t_ c\\<^sub>e_)) valid_sop\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case CAS"], ["proof (state)\nthis:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n     W_)\n\ngoal (9 subgoals):\n 1. \\<And>D\\<^sub>a D\\<^sub>c t s\\<^sub>e D f a c A L R W.\n       \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n        D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n        valid_sops_stmt t\n         (CAS (Tmp (D\\<^sub>a, a)) (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R\n           W)\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (store_sops\n                            (issue_expr t s\\<^sub>e @\n                             [RMW (a \\<theta>) (t + used_tmps s\\<^sub>e)\n                               (D, f)\n                               (\\<lambda>\\<theta>.\n                                   the (\\<theta>\n   (t + used_tmps s\\<^sub>e)) =\n                                   c \\<theta>)\n                               (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1)\n                               (A \\<theta>) (L \\<theta>) (R \\<theta>)\n                               (W \\<theta>)]))\n                          valid_sop\n 2. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 3. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 4. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 6. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 7. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 8. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 9. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  D\\<^sub>a_ \\<subseteq> dom \\<theta>\n  D\\<^sub>c_ \\<subseteq> dom \\<theta>\n  eval_expr t_ s\\<^sub>e_ = (D_, f_)\n  valid_sops_stmt t_\n   (CAS (Tmp (D\\<^sub>a_, a_)) (Tmp (D\\<^sub>c_, c_)) s\\<^sub>e_ A_ L_ R_\n     W_)\n\ngoal (1 subgoal):\n 1. Ball\n     (store_sops\n       (issue_expr t_ s\\<^sub>e_ @\n        [RMW (a_ \\<theta>) (t_ + used_tmps s\\<^sub>e_) (D_, f_)\n          (\\<lambda>\\<theta>.\n              the (\\<theta> (t_ + used_tmps s\\<^sub>e_)) = c_ \\<theta>)\n          (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>)\n          (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]))\n     valid_sop", "by (fastforce simp add: store_sops_append dest: valid_sops_expr_valid_sop)"], ["proof (state)\nthis:\n  Ball\n   (store_sops\n     (issue_expr t_ s\\<^sub>e_ @\n      [RMW (a_ \\<theta>) (t_ + used_tmps s\\<^sub>e_) (D_, f_)\n        (\\<lambda>\\<theta>.\n            the (\\<theta> (t_ + used_tmps s\\<^sub>e_)) = c_ \\<theta>)\n        (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1) (A_ \\<theta>)\n        (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)]))\n   valid_sop\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case Seq"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  Ball (store_sops is_) valid_sop\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (8 subgoals):\n 1. \\<And>s\\<^sub>1 t s\\<^sub>1' t' is s\\<^sub>2.\n       \\<lbrakk>\\<theta>\\<turnstile> (s\\<^sub>1,\nt) \\<rightarrow>\\<^sub>s ((s\\<^sub>1', t'), is);\n        valid_sops_stmt t s\\<^sub>1 \\<Longrightarrow>\n        Ball (store_sops is) valid_sop;\n        valid_sops_stmt t (Seq s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops is) valid_sop\n 2. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 3. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 5. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 6. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 7. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 8. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  \\<theta>\\<turnstile> (s\\<^sub>1_,\n                        t_) \\<rightarrow>\\<^sub>s ((s\\<^sub>1'_, t'_), is_)\n  valid_sops_stmt t_ s\\<^sub>1_ \\<Longrightarrow>\n  Ball (store_sops is_) valid_sop\n  valid_sops_stmt t_ (Seq s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops is_) valid_sop", "by (force intro: valid_sops_stmt_mono )"], ["proof (state)\nthis:\n  Ball (store_sops is_) valid_sop\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case SeqSkip"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (7 subgoals):\n 1. \\<And>s\\<^sub>2 t.\n       valid_sops_stmt t (Seq Skip s\\<^sub>2) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 2. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 4. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 5. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 6. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 7. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (Seq Skip s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops []) valid_sop", "by simp"], ["proof (state)\nthis:\n  Ball (store_sops []) valid_sop\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case Cond"], ["proof (state)\nthis:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (6 subgoals):\n 1. \\<And>e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop;\n        valid_sops_stmt t (Cond e s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops (issue_expr t e)) valid_sop\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 3. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 4. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 5. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 6. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sop. e_ \\<noteq> Tmp sop\n  valid_sops_stmt t_ (Cond e_ s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops (issue_expr t_ e_)) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops (issue_expr t_ e_)) valid_sop\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case CondTrue"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (5 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 2. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 3. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 4. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 5. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops []) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops []) valid_sop\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case CondFalse"], ["proof (state)\nthis:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (4 subgoals):\n 1. \\<And>D e s\\<^sub>1 s\\<^sub>2 t.\n       \\<lbrakk>D \\<subseteq> dom \\<theta>; \\<not> isTrue (e \\<theta>);\n        valid_sops_stmt t (Cond (Tmp (D, e)) s\\<^sub>1 s\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Ball (store_sops []) valid_sop\n 2. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 3. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 4. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  D_ \\<subseteq> dom \\<theta>\n  \\<not> isTrue (e_ \\<theta>)\n  valid_sops_stmt t_ (Cond (Tmp (D_, e_)) s\\<^sub>1_ s\\<^sub>2_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops []) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops []) valid_sop\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case While"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (3 subgoals):\n 1. \\<And>e s t.\n       valid_sops_stmt t (While e s) \\<Longrightarrow>\n       Ball (store_sops []) valid_sop\n 2. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 3. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (While e_ s_)\n\ngoal (1 subgoal):\n 1. Ball (store_sops []) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops []) valid_sop\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case SGhost"], ["proof (state)\nthis:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (2 subgoals):\n 1. \\<And>A L R W t.\n       valid_sops_stmt t (SGhost A L R W) \\<Longrightarrow>\n       Ball\n        (store_sops\n          [Ghost (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)])\n        valid_sop\n 2. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ (SGhost A_ L_ R_ W_)\n\ngoal (1 subgoal):\n 1. Ball\n     (store_sops\n       [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)])\n     valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball\n   (store_sops\n     [Ghost (A_ \\<theta>) (L_ \\<theta>) (R_ \\<theta>) (W_ \\<theta>)])\n   valid_sop\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "case SFence"], ["proof (state)\nthis:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       valid_sops_stmt t SFence \\<Longrightarrow>\n       Ball (store_sops [Fence]) valid_sop", "thus ?case"], ["proof (prove)\nusing this:\n  valid_sops_stmt t_ SFence\n\ngoal (1 subgoal):\n 1. Ball (store_sops [Fence]) valid_sop", "by auto"], ["proof (state)\nthis:\n  Ball (store_sops [Fence]) valid_sop\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec prog_configs:: \"'a memref list \\<Rightarrow> 'a set\"\nwhere\n\"prog_configs [] = {}\"\n|\"prog_configs (x#xs) = (case x of \n                         Prog\\<^sub>s\\<^sub>b p p' is \\<Rightarrow> {p,p'} \\<union> prog_configs xs\n                       | _ \\<Rightarrow> prog_configs xs)\""], ["", "lemma prog_configs_append: \"\\<And>ys. prog_configs (xs@ys) = prog_configs xs \\<union> prog_configs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       prog_configs (xs @ ys) = prog_configs xs \\<union> prog_configs ys", "by (induct xs) (auto split: memref.splits)"], ["", "lemma prog_configs_in1: \"Prog\\<^sub>s\\<^sub>b p\\<^sub>1 p\\<^sub>2 is \\<in> set xs \\<Longrightarrow> p\\<^sub>1 \\<in> prog_configs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prog\\<^sub>s\\<^sub>b p\\<^sub>1 p\\<^sub>2 is\n    \\<in> set xs \\<Longrightarrow>\n    p\\<^sub>1 \\<in> prog_configs xs", "by (induct xs) (auto split: memref.splits)"], ["", "lemma prog_configs_in2: \"Prog\\<^sub>s\\<^sub>b p\\<^sub>1 p\\<^sub>2 is \\<in> set xs \\<Longrightarrow> p\\<^sub>2 \\<in> prog_configs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prog\\<^sub>s\\<^sub>b p\\<^sub>1 p\\<^sub>2 is\n    \\<in> set xs \\<Longrightarrow>\n    p\\<^sub>2 \\<in> prog_configs xs", "by (induct xs) (auto split: memref.splits)"], ["", "lemma prog_configs_mono: \"\\<And>ys. set xs \\<subseteq> set ys \\<Longrightarrow> prog_configs xs \\<subseteq> prog_configs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       set xs \\<subseteq> set ys \\<Longrightarrow>\n       prog_configs xs \\<subseteq> prog_configs ys", "by (induct xs) (auto split: memref.splits simp add: prog_configs_append\n  prog_configs_in1 prog_configs_in2)"], ["", "locale separated_tmps = \nfixes ts\nassumes valid_sops_stmt: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\\<rbrakk> \n  \\<Longrightarrow> valid_sops_stmt t s\"\nassumes valid_sops_stmt_sb: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>); (s',t') \\<in> prog_configs sb\\<rbrakk> \n  \\<Longrightarrow>  valid_sops_stmt t' s'\"\nassumes load_tmps_le: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\\<rbrakk> \n  \\<Longrightarrow> \\<forall>i \\<in> load_tmps is. i < t\"\nassumes read_tmps_le: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\\<rbrakk> \n  \\<Longrightarrow> \\<forall>i \\<in> read_tmps sb. i < t\"\nassumes store_sops_le: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\\<rbrakk> \n  \\<Longrightarrow> \\<forall>i \\<in> \\<Union>(fst ` store_sops is). i < t\"\nassumes write_sops_le: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\\<rbrakk> \n  \\<Longrightarrow> \\<forall>i \\<in> \\<Union>(fst ` write_sops sb). i < t\"\nassumes tmps_le: \"\\<lbrakk>i < length ts; ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\\<rbrakk> \n  \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is = {i. i < t}\""], ["", "lemma (in separated_tmps)\n  tmps_le': \n  assumes i_bound: \"i < length ts\" \n  assumes ts_i: \"ts!i = ((s,t),is,\\<theta>,sb,\\<D>,\\<O>)\"\n  shows \"\\<forall>i \\<in> dom \\<theta>. i < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>dom \\<theta>. i < t", "using tmps_le [OF i_bound ts_i]"], ["proof (prove)\nusing this:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>dom \\<theta>. i < t", "by auto"], ["", "lemma (in separated_tmps) separated_tmps_nth_update: \n  \"\\<lbrakk>i < length ts; valid_sops_stmt t s; \\<forall>(s',t') \\<in> prog_configs sb. valid_sops_stmt t' s'; \n   \\<forall>i \\<in> load_tmps is. i < t;\\<forall>i \\<in> read_tmps sb. i < t;\n    \\<forall>i \\<in> \\<Union>(fst ` store_sops is). i < t; \\<forall>i \\<in> \\<Union>(fst ` write_sops sb). i < t; dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk> \n   \\<Longrightarrow>\n   separated_tmps (ts[i:=((s,t),is,\\<theta>,sb,\\<D>,\\<O>)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ts; valid_sops_stmt t s;\n     \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n     \\<forall>i\\<in>load_tmps is. i < t; \\<forall>i\\<in>read_tmps sb. i < t;\n     \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n     \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n     dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk>\n    \\<Longrightarrow> separated_tmps\n                       (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)])", "apply (unfold_locales)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt ta sa\n 2. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>' s' t'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>');\n        (s', t') \\<in> prog_configs sba\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' s'\n 3. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>load_tmps isa. i < ta\n 4. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>read_tmps sba. i < ta\n 5. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` store_sops isa).\n                            i < ta\n 6. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` write_sops sba).\n                            i < ta\n 7. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply       (force intro: valid_sops_stmt  simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>' s' t'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>');\n        (s', t') \\<in> prog_configs sba\\<rbrakk>\n       \\<Longrightarrow> valid_sops_stmt t' s'\n 2. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>load_tmps isa. i < ta\n 3. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>read_tmps sba. i < ta\n 4. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` store_sops isa).\n                            i < ta\n 5. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` write_sops sba).\n                            i < ta\n 6. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply      (fastforce intro: valid_sops_stmt_sb  simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>load_tmps isa. i < ta\n 2. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>read_tmps sba. i < ta\n 3. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` store_sops isa).\n                            i < ta\n 4. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` write_sops sba).\n                            i < ta\n 5. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply     (fastforce intro: load_tmps_le [rule_format] simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>read_tmps sba. i < ta\n 2. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` store_sops isa).\n                            i < ta\n 3. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` write_sops sba).\n                            i < ta\n 4. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply    (fastforce intro: read_tmps_le [rule_format] simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` store_sops isa).\n                            i < ta\n 2. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` write_sops sba).\n                            i < ta\n 3. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply   (fastforce intro: store_sops_le [rule_format] simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>\\<Union> (fst ` write_sops sba).\n                            i < ta\n 2. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply  (fastforce intro: write_sops_le [rule_format] simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia sa ta isa \\<theta>' sba \\<D>' \\<O>'.\n       \\<lbrakk>i < length ts; valid_sops_stmt t s;\n        \\<forall>(s', t')\\<in>prog_configs sb. valid_sops_stmt t' s';\n        \\<forall>i\\<in>load_tmps is. i < t;\n        \\<forall>i\\<in>read_tmps sb. i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t;\n        \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t;\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        ia < length (ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)]);\n        ts[i := ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)] ! ia =\n        ((sa, ta), isa, \\<theta>', sba, \\<D>', \\<O>')\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta>' \\<union> load_tmps isa = {i. i < ta}", "apply (fastforce dest: tmps_le [rule_format] simp add: nth_list_update split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hd_prog_app_in_first: \"\\<And>ys. Prog\\<^sub>s\\<^sub>b p p' is \\<in> set xs \\<Longrightarrow> hd_prog q (xs @ ys) = hd_prog q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       Prog\\<^sub>s\\<^sub>b p p' is \\<in> set xs \\<Longrightarrow>\n       hd_prog q (xs @ ys) = hd_prog q xs", "by (induct xs) (auto split: memref.splits)"], ["", "lemma hd_prog_app_in_eq: \"\\<And>ys. Prog\\<^sub>s\\<^sub>b p p' is \\<in> set xs \\<Longrightarrow> hd_prog q xs = hd_prog x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       Prog\\<^sub>s\\<^sub>b p p' is \\<in> set xs \\<Longrightarrow>\n       hd_prog q xs = hd_prog x xs", "by (induct xs) (auto split: memref.splits)"], ["", "lemma hd_prog_app_notin_first: \"\\<And>ys. \\<forall>p p' is. Prog\\<^sub>s\\<^sub>b p p' is \\<notin> set xs \\<Longrightarrow> hd_prog q (xs @ ys) = hd_prog q ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<forall>p p' is.\n          Prog\\<^sub>s\\<^sub>b p p' is \\<notin> set xs \\<Longrightarrow>\n       hd_prog q (xs @ ys) = hd_prog q ys", "by (induct xs) (auto split: memref.splits)"], ["", "lemma union_eq_subsetD: \"A \\<union> B = C \\<Longrightarrow> A \\<union> B \\<subseteq> C \\<and>  C \\<subseteq> A \\<union> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B = C \\<Longrightarrow>\n    A \\<union> B \\<subseteq> C \\<and> C \\<subseteq> A \\<union> B", "by auto"], ["", "lemma prog_step_preserves_separated_tmps:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb,\\<D>,\\<O>)\" \n  assumes prog_step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n  assumes sep: \"separated_tmps ts\"\n  shows \"separated_tmps \n             (ts [i:=(p',is@is',\\<theta>,sb@[Prog\\<^sub>s\\<^sub>b p p' is'],\\<D>,\\<O>)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "obtain s' t' where p': \"p'=(s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "note ts_i = ts_i [simplified p]"], ["proof (state)\nthis:\n  ts ! i = ((s, t), is, \\<theta>, sb, \\<D>, \\<O>)\n\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "note step = prog_step [simplified p p']"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is')\n\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "interpret separated_tmps ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps ts", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "have \"separated_tmps (ts[i := ((s',t'), is @ is', \\<theta>, \n    sb @ [Prog\\<^sub>s\\<^sub>b (s,t) (s',t') is'], \\<D>,\\<O>)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := ((s', t'), is @ is', \\<theta>,\n               sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'], \\<D>,\n               \\<O>)])", "proof (rule separated_tmps_nth_update [OF i_bound])"], ["proof (state)\ngoal (7 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>load_tmps (is @ is'). i < t'\n 4. \\<forall>i\\<in>read_tmps\n                    (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       i < t'\n 5. \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'\n 6. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 7. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "from stmt_step_load_tmps_range [OF step] load_tmps_le [OF i_bound ts_i]\n    stmt_step_tmps_count_mono [OF step]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  \\<forall>i\\<in>load_tmps is. i < t\n  t \\<le> t'", "show \"\\<forall>i\\<in>load_tmps (is @ is'). i < t'\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>load_tmps is'. t \\<le> i \\<and> i < t'\n  \\<forall>i\\<in>load_tmps is. i < t\n  t \\<le> t'\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps (is @ is'). i < t'", "by (auto simp add: load_tmps_append)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>load_tmps (is @ is'). i < t'\n\ngoal (6 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>read_tmps\n                    (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       i < t'\n 4. \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'\n 5. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 6. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>read_tmps\n                    (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       i < t'\n 4. \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'\n 5. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 6. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "from read_tmps_le [OF i_bound ts_i] stmt_step_tmps_count_mono [OF step]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>read_tmps sb. i < t\n  t \\<le> t'", "show \"\\<forall>i\\<in>read_tmps (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']). i < t'\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>read_tmps sb. i < t\n  t \\<le> t'\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps\n                    (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       i < t'", "by (auto simp add: read_tmps_append)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>read_tmps\n                  (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n     i < t'\n\ngoal (5 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'\n 4. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 5. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'\n 4. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 5. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "from stmt_step_data_store_sops_range [OF step] stmt_step_tmps_count_mono [OF step]\n    store_sops_le [OF i_bound ts_i] valid_sops_stmt [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t s \\<Longrightarrow>\n  \\<forall>(D, f)\\<in>store_sops is'. \\<forall>i\\<in>D. i < t'\n  t \\<le> t'\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n  valid_sops_stmt t s", "show \"\\<forall>i\\<in>\\<Union>(fst ` store_sops (is @ is')). i < t'\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t s \\<Longrightarrow>\n  \\<forall>(D, f)\\<in>store_sops is'. \\<forall>i\\<in>D. i < t'\n  t \\<le> t'\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'", "by (fastforce simp add: store_sops_append)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops (is @ is')). i < t'\n\ngoal (4 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 4. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'\n 4. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "from \n      stmt_step_tmps_count_mono [OF step] write_sops_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  t \\<le> t'\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t", "show \"\\<forall>i\\<in>\\<Union>(fst ` write_sops (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])). i < t'\""], ["proof (prove)\nusing this:\n  t \\<le> t'\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union>\n                    (fst `\n                     write_sops\n                      (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n       i < t'", "by (fastforce simp add: write_sops_append)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>\\<Union>\n                  (fst `\n                   write_sops\n                    (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])).\n     i < t'\n\ngoal (3 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "from tmps_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}", "have \"dom \\<theta> \\<union> load_tmps is = {i. i < t}\""], ["proof (prove)\nusing this:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (1 subgoal):\n 1. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "by simp"], ["proof (state)\nthis:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (3 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'\n 3. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "with stmt_step_load_tmps_range' [OF step] stmt_step_tmps_count_mono [OF step]"], ["proof (chain)\npicking this:\n  load_tmps is' = {i. t \\<le> i \\<and> i < t'}\n  t \\<le> t'\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}", "show \"dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}\""], ["proof (prove)\nusing this:\n  load_tmps is' = {i. t \\<le> i \\<and> i < t'}\n  t \\<le> t'\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (1 subgoal):\n 1. dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}", "apply (clarsimp simp add: load_tmps_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk>\n    \\<Longrightarrow> dom \\<theta> \\<union>\n                      (load_tmps is \\<union> {i. t \\<le> i \\<and> i < t'}) =\n                      {i. i < t'}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk>\n    \\<Longrightarrow> dom \\<theta> \\<union>\n                      (load_tmps is \\<union> {i. t \\<le> i \\<and> i < t'})\n                      \\<subseteq> {i. i < t'}\n 2. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk>\n    \\<Longrightarrow> {i. i < t'}\n                      \\<subseteq> dom \\<theta> \\<union>\n                                  (load_tmps is \\<union>\n                                   {i. t \\<le> i \\<and> i < t'})", "apply  (drule union_eq_subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is \\<subseteq> {i. i < t} \\<and>\n     {i. i < t} \\<subseteq> dom \\<theta> \\<union> load_tmps is\\<rbrakk>\n    \\<Longrightarrow> dom \\<theta> \\<union>\n                      (load_tmps is \\<union> {i. t \\<le> i \\<and> i < t'})\n                      \\<subseteq> {i. i < t'}\n 2. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk>\n    \\<Longrightarrow> {i. i < t'}\n                      \\<subseteq> dom \\<theta> \\<union>\n                                  (load_tmps is \\<union>\n                                   {i. t \\<le> i \\<and> i < t'})", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t}\\<rbrakk>\n    \\<Longrightarrow> {i. i < t'}\n                      \\<subseteq> dom \\<theta> \\<union>\n                                  (load_tmps is \\<union>\n                                   {i. t \\<le> i \\<and> i < t'})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n        dom \\<theta> \\<union> load_tmps is = {i. i < t};\n        x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is\\<rbrakk>\n       \\<Longrightarrow> t \\<le> x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is\\<rbrakk>\n    \\<Longrightarrow> t \\<le> x", "apply (case_tac \"t \\<le> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is;\n     t \\<le> x\\<rbrakk>\n    \\<Longrightarrow> t \\<le> x\n 2. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is;\n     \\<not> t \\<le> x\\<rbrakk>\n    \\<Longrightarrow> t \\<le> x", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is;\n     \\<not> t \\<le> x\\<rbrakk>\n    \\<Longrightarrow> t \\<le> x", "apply (subgoal_tac \"x < t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is;\n     \\<not> t \\<le> x; x < t\\<rbrakk>\n    \\<Longrightarrow> t \\<le> x\n 2. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is;\n     \\<not> t \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x < t", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>load_tmps is' = {i. t \\<le> i \\<and> i < t'}; t \\<le> t';\n     dom \\<theta> \\<union> load_tmps is = {i. i < t};\n     x \\<notin> dom \\<theta>; x < t'; x \\<notin> load_tmps is;\n     \\<not> t \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x < t", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom \\<theta> \\<union> load_tmps (is @ is') = {i. i < t'}\n\ngoal (2 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_sops_stmt t' s'\n 2. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "from valid_sops_stmt_invariant [OF prog_step [simplified p p'] valid_sops_stmt [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t' s'", "show \"valid_sops_stmt t' s'\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t' s'", "."], ["proof (state)\nthis:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "show \"\\<forall>(s', t')\\<in>prog_configs (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n             valid_sops_stmt t' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "fix s\\<^sub>1 t\\<^sub>1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "assume cfgs: \"(s\\<^sub>1,t\\<^sub>1) \\<in> prog_configs (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])\""], ["proof (state)\nthis:\n  (s\\<^sub>1, t\\<^sub>1)\n  \\<in> prog_configs (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "have \"valid_sops_stmt t\\<^sub>1 s\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "from valid_sops_stmt [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t s", "have \"valid_sops_stmt t s\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t s", "."], ["proof (state)\nthis:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "from valid_sops_stmt_invariant [OF prog_step [simplified p p'] valid_sops_stmt [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t' s'", "have \"valid_sops_stmt t' s'\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t' s'", "."], ["proof (state)\nthis:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "note valid_sops_stmt_sb [OF i_bound ts_i]"], ["proof (state)\nthis:\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  valid_sops_stmt t s\n  valid_sops_stmt t' s'\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_sops_stmt t s\n  valid_sops_stmt t' s'\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "using cfgs"], ["proof (prove)\nusing this:\n  valid_sops_stmt t s\n  valid_sops_stmt t' s'\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n  (s\\<^sub>1, t\\<^sub>1)\n  \\<in> prog_configs (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'])\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t\\<^sub>1 s\\<^sub>1", "by (auto simp add: prog_configs_append)"], ["proof (state)\nthis:\n  valid_sops_stmt t\\<^sub>1 s\\<^sub>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_sops_stmt t\\<^sub>1 s\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "}"], ["proof (state)\nthis:\n  (?s\\<^sub>12, ?t\\<^sub>12)\n  \\<in> prog_configs\n         (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']) \\<Longrightarrow>\n  valid_sops_stmt ?t\\<^sub>12 ?s\\<^sub>12\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?s\\<^sub>12, ?t\\<^sub>12)\n  \\<in> prog_configs\n         (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']) \\<Longrightarrow>\n  valid_sops_stmt ?t\\<^sub>12 ?s\\<^sub>12\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\n             \\<in>prog_configs\n                   (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n       valid_sops_stmt t' s'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(s', t')\n           \\<in>prog_configs\n                 (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n     valid_sops_stmt t' s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(s', t')\n           \\<in>prog_configs\n                 (sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is']).\n     valid_sops_stmt t' s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated_tmps\n   (ts[i := ((s', t'), is @ is', \\<theta>,\n             sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'], \\<D>, \\<O>)])\n\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "then"], ["proof (chain)\npicking this:\n  separated_tmps\n   (ts[i := ((s', t'), is @ is', \\<theta>,\n             sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'], \\<D>, \\<O>)])", "show ?thesis"], ["proof (prove)\nusing this:\n  separated_tmps\n   (ts[i := ((s', t'), is @ is', \\<theta>,\n             sb @ [Prog\\<^sub>s\\<^sub>b (s, t) (s', t') is'], \\<D>, \\<O>)])\n\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>)])", "by (simp add: p p')"], ["proof (state)\nthis:\n  separated_tmps\n   (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n             \\<D>, \\<O>)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flush_step_sb_subset:\n  assumes step: \"(m,sb,\\<O>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>')\"\n  shows \"set sb' \\<subseteq> set sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set sb' \\<subseteq> set sb", "using step"], ["proof (prove)\nusing this:\n  (m, sb, \\<O>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>')\n\ngoal (1 subgoal):\n 1. set sb' \\<subseteq> set sb", "apply (induct c1==\"(m,sb,\\<O>)\" c2==\"(m',sb',\\<O>')\" arbitrary: m sb \\<O> acq m' sb' \\<O>' acq\n  rule: flush_step.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<O>' volatile \\<O> A R \\<S>' \\<S> W L \\<R>' \\<R> m a sop v rs.\n       \\<lbrakk>\\<O>' = (if volatile then \\<O> \\<union> A - R else \\<O>);\n        \\<S>' =\n        (if volatile\n         then \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\n         else \\<S>);\n        \\<R>' = (if volatile then Map.empty else \\<R>)\\<rbrakk>\n       \\<Longrightarrow> set rs\n                         \\<subseteq> set\n(Write\\<^sub>s\\<^sub>b volatile a sop v A L R W # rs)\n 2. \\<And>m volatile a t v rs \\<O> \\<R> \\<S>.\n       set rs \\<subseteq> set (Read\\<^sub>s\\<^sub>b volatile a t v # rs)\n 3. \\<And>m p p' is rs \\<O> \\<R> \\<S>.\n       set rs \\<subseteq> set (Prog\\<^sub>s\\<^sub>b p p' is # rs)\n 4. \\<And>m A L R W rs \\<O> \\<R> \\<S>.\n       set rs \\<subseteq> set (Ghost\\<^sub>s\\<^sub>b A L R W # rs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flush_step_preserves_separated_tmps:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb,\\<D>,\\<O>,\\<R>)\" \n  assumes flush_step: \"(m,sb,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>',\\<R>',\\<S>')\"\n  assumes sep: \"separated_tmps ts\"\n  shows \"separated_tmps (ts [i:=(p,is,\\<theta>,sb',\\<D>,\\<O>',\\<R>')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "note ts_i = ts_i [simplified p]"], ["proof (state)\nthis:\n  ts ! i = ((s, t), is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "interpret separated_tmps ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps ts", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "have \"separated_tmps (ts [i:=((s,t),is,\\<theta>,sb',\\<D>,\\<O>',\\<R>')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := ((s, t), is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "proof (rule separated_tmps_nth_update [OF i_bound])"], ["proof (state)\ngoal (7 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>load_tmps is. i < t\n 4. \\<forall>i\\<in>read_tmps sb'. i < t\n 5. \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n 6. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 7. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "from load_tmps_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>load_tmps is. i < t", "show \"\\<forall>i\\<in>load_tmps is. i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>load_tmps is. i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps is. i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>load_tmps is. i < t\n\ngoal (6 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>read_tmps sb'. i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n 5. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 6. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>read_tmps sb'. i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n 5. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 6. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "from flush_step_preserves_read_tmps [OF flush_step read_tmps_le [OF i_bound ts_i] ]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>read_tmps sb'. i < t", "show \"\\<forall>i\\<in>read_tmps sb'. i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>read_tmps sb'. i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps sb'. i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>read_tmps sb'. i < t\n\ngoal (5 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 5. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 5. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "from store_sops_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t", "show \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is). i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n\ngoal (4 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 4. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 4. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "from flush_step_preserves_write_sops [OF flush_step write_sops_le [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "show \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb'). i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n\ngoal (3 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "from tmps_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}", "show \"dom \\<theta> \\<union> load_tmps is = {i. i < t}\""], ["proof (prove)\nusing this:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (1 subgoal):\n 1. dom \\<theta> \\<union> load_tmps is = {i. i < t}", "by auto"], ["proof (state)\nthis:\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (2 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "from valid_sops_stmt [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t s", "show \"valid_sops_stmt t s\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t s", "."], ["proof (state)\nthis:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "from valid_sops_stmt_sb [OF i_bound ts_i] flush_step_sb_subset [OF flush_step]"], ["proof (chain)\npicking this:\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n  set sb' \\<subseteq> set sb", "show \"\\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\""], ["proof (prove)\nusing this:\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n  set sb' \\<subseteq> set sb\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "by (auto dest!: prog_configs_mono)"], ["proof (state)\nthis:\n  \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated_tmps (ts[i := ((s, t), is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "then"], ["proof (chain)\npicking this:\n  separated_tmps (ts[i := ((s, t), is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "show ?thesis"], ["proof (prove)\nusing this:\n  separated_tmps (ts[i := ((s, t), is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "by (simp add: p)"], ["proof (state)\nthis:\n  separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sbh_step_preserves_store_sops_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  assumes store_sops_le: \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is). i < t\"\n  shows \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is'). i < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t", "using step store_sops_le"], ["proof (prove)\nusing this:\n  (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<R>', \\<S>')\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t", "by cases auto"], ["", "lemma sbh_step_preserves_write_sops_bound:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  assumes store_sops_le: \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is). i < t\"\n  assumes write_sops_le: \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb). i < t\"\n  shows \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb'). i < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "using step store_sops_le write_sops_le"], ["proof (prove)\nusing this:\n  (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<R>', \\<S>')\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is). i < t\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "by cases (auto simp add: write_sops_append)"], ["", "lemma sbh_step_prog_configs_eq:\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  shows \"prog_configs sb' = prog_configs sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog_configs sb' = prog_configs sb", "using step"], ["proof (prove)\nusing this:\n  (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<R>', \\<S>')\n\ngoal (1 subgoal):\n 1. prog_configs sb' = prog_configs sb", "apply (cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a v volatile t.\n       \\<lbrakk>is = Read volatile a t # is';\n        \\<theta>' = \\<theta>(t \\<mapsto> v);\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v]; m' = m;\n        \\<D>' = \\<D>; \\<O>' = \\<O>; \\<R>' = \\<R>; \\<S>' = \\<S>;\n        buffered_val sb a = Some v\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 2. \\<And>a volatile t.\n       \\<lbrakk>is = Read volatile a t # is';\n        \\<theta>' = \\<theta>(t \\<mapsto> m a);\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t (m a)]; m' = m;\n        \\<D>' = \\<D>; \\<O>' = \\<O>; \\<R>' = \\<R>; \\<S>' = \\<S>;\n        buffered_val sb a = None\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 3. \\<And>a D f A L R W.\n       \\<lbrakk>is = Write False a (D, f) A L R W # is';\n        \\<theta>' = \\<theta>;\n        sb' =\n        sb @ [Write\\<^sub>s\\<^sub>b False a (D, f) (f \\<theta>) A L R W];\n        m' = m; \\<D>' = \\<D>; \\<O>' = \\<O>; \\<R>' = \\<R>;\n        \\<S>' = \\<S>\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 4. \\<And>a D f A L R W.\n       \\<lbrakk>is = Write True a (D, f) A L R W # is';\n        \\<theta>' = \\<theta>;\n        sb' =\n        sb @ [Write\\<^sub>s\\<^sub>b True a (D, f) (f \\<theta>) A L R W];\n        m' = m; \\<D>' = True; \\<O>' = \\<O>; \\<R>' = \\<R>;\n        \\<S>' = \\<S>\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 5. \\<lbrakk>is = Fence # is'; sb = []; \\<theta>' = \\<theta>; sb' = [];\n     m' = m; \\<D>' = False; \\<O>' = \\<O>; \\<R>' = Map.empty;\n     \\<S>' = \\<S>\\<rbrakk>\n    \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 6. \\<And>cond t a D f ret A L R W.\n       \\<lbrakk>is = RMW a t (D, f) cond ret A L R W # is'; sb = [];\n        \\<theta>' = \\<theta>(t \\<mapsto> m a); sb' = []; m' = m;\n        \\<D>' = False; \\<O>' = \\<O>; \\<R>' = Map.empty; \\<S>' = \\<S>;\n        \\<not> cond (\\<theta>(t \\<mapsto> m a))\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 7. \\<And>cond t a D f ret A L R W.\n       \\<lbrakk>is = RMW a t (D, f) cond ret A L R W # is'; sb = [];\n        \\<theta>' = \\<theta>(t \\<mapsto>\n        ret (m a) (f (\\<theta>(t \\<mapsto> m a))));\n        sb' = []; m' = m(a := f (\\<theta>(t \\<mapsto> m a))); \\<D>' = False;\n        \\<O>' = \\<O> \\<union> A - R; \\<R>' = Map.empty;\n        \\<S>' =\n        \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L;\n        cond (\\<theta>(t \\<mapsto> m a))\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb\n 8. \\<And>A L R W.\n       \\<lbrakk>is = Ghost A L R W # is'; \\<theta>' = \\<theta>;\n        sb' = sb @ [Ghost\\<^sub>s\\<^sub>b A L R W]; m' = m; \\<D>' = \\<D>;\n        \\<O>' = \\<O>; \\<R>' = \\<R>; \\<S>' = \\<S>\\<rbrakk>\n       \\<Longrightarrow> prog_configs sb' = prog_configs sb", "apply (auto simp add: prog_configs_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sbh_step_preserves_tmps_bound':\n  assumes step: \"(is,\\<theta>,sb,m,\\<D>,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is',\\<theta>',sb',m',\\<D>',\\<O>',\\<R>',\\<S>')\"\n  shows \"dom \\<theta> \\<union> load_tmps is = dom \\<theta>' \\<union> load_tmps is'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<theta> \\<union> load_tmps is =\n    dom \\<theta>' \\<union> load_tmps is'", "using step"], ["proof (prove)\nusing this:\n  (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<R>', \\<S>')\n\ngoal (1 subgoal):\n 1. dom \\<theta> \\<union> load_tmps is =\n    dom \\<theta>' \\<union> load_tmps is'", "apply cases"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a v volatile t.\n       \\<lbrakk>is = Read volatile a t # is';\n        \\<theta>' = \\<theta>(t \\<mapsto> v);\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v]; m' = m;\n        \\<D>' = \\<D>; \\<O>' = \\<O>; \\<R>' = \\<R>; \\<S>' = \\<S>;\n        buffered_val sb a = Some v\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'\n 2. \\<And>a volatile t.\n       \\<lbrakk>is = Read volatile a t # is';\n        \\<theta>' = \\<theta>(t \\<mapsto> m a);\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t (m a)]; m' = m;\n        \\<D>' = \\<D>; \\<O>' = \\<O>; \\<R>' = \\<R>; \\<S>' = \\<S>;\n        buffered_val sb a = None\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'\n 3. \\<And>a D f A L R W.\n       \\<lbrakk>is = Write False a (D, f) A L R W # is';\n        \\<theta>' = \\<theta>;\n        sb' =\n        sb @ [Write\\<^sub>s\\<^sub>b False a (D, f) (f \\<theta>) A L R W];\n        m' = m; \\<D>' = \\<D>; \\<O>' = \\<O>; \\<R>' = \\<R>;\n        \\<S>' = \\<S>\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'\n 4. \\<And>a D f A L R W.\n       \\<lbrakk>is = Write True a (D, f) A L R W # is';\n        \\<theta>' = \\<theta>;\n        sb' =\n        sb @ [Write\\<^sub>s\\<^sub>b True a (D, f) (f \\<theta>) A L R W];\n        m' = m; \\<D>' = True; \\<O>' = \\<O>; \\<R>' = \\<R>;\n        \\<S>' = \\<S>\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'\n 5. \\<lbrakk>is = Fence # is'; sb = []; \\<theta>' = \\<theta>; sb' = [];\n     m' = m; \\<D>' = False; \\<O>' = \\<O>; \\<R>' = Map.empty;\n     \\<S>' = \\<S>\\<rbrakk>\n    \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                      dom \\<theta>' \\<union> load_tmps is'\n 6. \\<And>cond t a D f ret A L R W.\n       \\<lbrakk>is = RMW a t (D, f) cond ret A L R W # is'; sb = [];\n        \\<theta>' = \\<theta>(t \\<mapsto> m a); sb' = []; m' = m;\n        \\<D>' = False; \\<O>' = \\<O>; \\<R>' = Map.empty; \\<S>' = \\<S>;\n        \\<not> cond (\\<theta>(t \\<mapsto> m a))\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'\n 7. \\<And>cond t a D f ret A L R W.\n       \\<lbrakk>is = RMW a t (D, f) cond ret A L R W # is'; sb = [];\n        \\<theta>' = \\<theta>(t \\<mapsto>\n        ret (m a) (f (\\<theta>(t \\<mapsto> m a))));\n        sb' = []; m' = m(a := f (\\<theta>(t \\<mapsto> m a))); \\<D>' = False;\n        \\<O>' = \\<O> \\<union> A - R; \\<R>' = Map.empty;\n        \\<S>' =\n        \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L;\n        cond (\\<theta>(t \\<mapsto> m a))\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'\n 8. \\<And>A L R W.\n       \\<lbrakk>is = Ghost A L R W # is'; \\<theta>' = \\<theta>;\n        sb' = sb @ [Ghost\\<^sub>s\\<^sub>b A L R W]; m' = m; \\<D>' = \\<D>;\n        \\<O>' = \\<O>; \\<R>' = \\<R>; \\<S>' = \\<S>\\<rbrakk>\n       \\<Longrightarrow> dom \\<theta> \\<union> load_tmps is =\n                         dom \\<theta>' \\<union> load_tmps is'", "apply (auto simp add: read_tmps_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sbh_step_preserves_separated_tmps:\n  assumes i_bound: \"i < length ts\" \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb,\\<D>,\\<O>,\\<R>)\" \n  assumes memop_step: \"(is, \\<theta>, sb, m,\\<D>, \\<O>, \\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h \n                        (is', \\<theta>', sb', m',\\<D>', \\<O>', \\<R>',\\<S>')\" \n  assumes instr: \"separated_tmps ts\"\n  shows \"separated_tmps (ts [i:=(p,is',\\<theta>',sb',\\<D>',\\<O>',\\<R>')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "note ts_i = ts_i [simplified p]"], ["proof (state)\nthis:\n  ts ! i = ((s, t), is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "interpret separated_tmps ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps ts", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "have \"separated_tmps (ts [i:=((s,t),is',\\<theta>',sb',\\<D>',\\<O>',\\<R>')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_tmps\n     (ts[i := ((s, t), is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "proof (rule separated_tmps_nth_update [OF i_bound])"], ["proof (state)\ngoal (7 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>load_tmps is'. i < t\n 4. \\<forall>i\\<in>read_tmps sb'. i < t\n 5. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n 6. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 7. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "from sbh_step_preserves_load_tmps_bound [OF memop_step load_tmps_le [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>load_tmps is'. i < t", "show \"\\<forall>i\\<in>load_tmps is'. i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>load_tmps is'. i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>load_tmps is'. i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>load_tmps is'. i < t\n\ngoal (6 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>read_tmps sb'. i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n 5. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 6. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>read_tmps sb'. i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n 5. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 6. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "from sbh_step_preserves_read_tmps_bound [OF memop_step load_tmps_le [OF i_bound ts_i]\n        read_tmps_le [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>read_tmps sb'. i < t", "show \"\\<forall>i\\<in>read_tmps sb'. i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>read_tmps sb'. i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>read_tmps sb'. i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>read_tmps sb'. i < t\n\ngoal (5 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 5. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n 4. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 5. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "from sbh_step_preserves_store_sops_bound [OF memop_step store_sops_le [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t", "show \"\\<forall>i\\<in>\\<Union>(fst ` store_sops is'). i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>\\<Union> (fst ` store_sops is'). i < t\n\ngoal (4 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 4. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n 4. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "from sbh_step_preserves_write_sops_bound [OF memop_step store_sops_le [OF i_bound ts_i] \n      write_sops_le [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "show \"\\<forall>i\\<in>\\<Union>(fst ` write_sops sb'). i < t\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t", "."], ["proof (state)\nthis:\n  \\<forall>i\\<in>\\<Union> (fst ` write_sops sb'). i < t\n\ngoal (3 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n 3. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "from sbh_step_preserves_tmps_bound' [OF memop_step] tmps_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  dom \\<theta> \\<union> load_tmps is = dom \\<theta>' \\<union> load_tmps is'\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}", "show \"dom \\<theta>' \\<union> load_tmps is' = {i. i < t}\""], ["proof (prove)\nusing this:\n  dom \\<theta> \\<union> load_tmps is = dom \\<theta>' \\<union> load_tmps is'\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (1 subgoal):\n 1. dom \\<theta>' \\<union> load_tmps is' = {i. i < t}", "by auto"], ["proof (state)\nthis:\n  dom \\<theta>' \\<union> load_tmps is' = {i. i < t}\n\ngoal (2 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_sops_stmt t s\n 2. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "from valid_sops_stmt [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t s", "show \"valid_sops_stmt t s\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t s", "."], ["proof (state)\nthis:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "from valid_sops_stmt_sb [OF i_bound ts_i] sbh_step_prog_configs_eq [OF memop_step]"], ["proof (chain)\npicking this:\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n  prog_configs sb' = prog_configs sb", "show \"\\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\""], ["proof (prove)\nusing this:\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n  prog_configs sb' = prog_configs sb\n\ngoal (1 subgoal):\n 1. \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(s', t')\\<in>prog_configs sb'. valid_sops_stmt t' s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated_tmps\n   (ts[i := ((s, t), is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "then"], ["proof (chain)\npicking this:\n  separated_tmps\n   (ts[i := ((s, t), is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "show ?thesis"], ["proof (prove)\nusing this:\n  separated_tmps\n   (ts[i := ((s, t), is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "by (simp add: p)"], ["proof (state)\nthis:\n  separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \n  \"valid_pimp ts \\<equiv> separated_tmps ts\""], ["", "lemma prog_step_preserves_valid:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb::stmt_config store_buffer,\\<D>,\\<O>,\\<R>)\" \n  assumes prog_step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n  assumes valid: \"valid_pimp ts\"\n  shows \"valid_pimp (ts [i:=(p',is@is',\\<theta>,sb@[Prog\\<^sub>s\\<^sub>b p p' is'],\\<D>,\\<O>,\\<R>)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_pimp\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>, \\<R>)])", "using prog_step_preserves_separated_tmps [OF i_bound ts_i prog_step] valid"], ["proof (prove)\nusing this:\n  separated_tmps ts \\<Longrightarrow>\n  separated_tmps\n   (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n             \\<D>, \\<O>, \\<R>)])\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. valid_pimp\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>, \\<R>)])", "by (auto simp add: valid_pimp_def)"], ["", "lemma flush_step_preserves_valid:\n  assumes i_bound: \"i < length ts\"  \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb::stmt_config store_buffer,\\<D>,\\<O>,\\<R>)\" \n  assumes flush_step: \"(m,sb,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>',\\<R>',\\<S>')\"\n  assumes valid: \"valid_pimp ts\"\n  shows \"valid_pimp (ts [i:=(p,is,\\<theta>,sb',\\<D>,\\<O>',\\<R>')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "using flush_step_preserves_separated_tmps [OF i_bound ts_i flush_step] valid"], ["proof (prove)\nusing this:\n  separated_tmps ts \\<Longrightarrow>\n  separated_tmps (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "by (auto simp add: valid_pimp_def)"], ["", "lemma sbh_step_preserves_valid:\n  assumes i_bound: \"i < length ts\" \n  assumes ts_i: \"ts!i = (p,is,\\<theta>,sb::stmt_config store_buffer,\\<D>,\\<O>,\\<R>)\" \n  assumes memop_step: \"(is, \\<theta>, sb, m,\\<D>, \\<O>, \\<R>,\\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h \n                        (is', \\<theta>', sb', m',\\<D>', \\<O>', \\<R>', \\<S>')\" \n  assumes valid: \"valid_pimp ts\"\n  shows \"valid_pimp (ts [i:=(p,is',\\<theta>',sb',\\<D>',\\<O>',\\<R>')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "using \nsbh_step_preserves_separated_tmps [OF i_bound ts_i memop_step] valid"], ["proof (prove)\nusing this:\n  separated_tmps ts \\<Longrightarrow>\n  separated_tmps (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "by (auto simp add: valid_pimp_def)"], ["", "lemma hd_prog_prog_configs: \"hd_prog p sb = p \\<or> hd_prog p sb \\<in> prog_configs sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd_prog p sb = p \\<or> hd_prog p sb \\<in> prog_configs sb", "by (induct sb) (auto split:memref.splits)"], ["", "interpretation PIMP: xvalid_program_progress stmt_step \"\\<lambda>(s,t). valid_sops_stmt t s\" valid_pimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. xvalid_program_progress stmt_step (\\<lambda>(s, t). valid_sops_stmt t s)\n     valid_pimp", "proof"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p',\n               is') \\<Longrightarrow>\n       p' \\<noteq> p \\<or> is' \\<noteq> []\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 8. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n        \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (m, sb, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                     \\<R>')])\nA total of 11 subgoals...", "fix \\<theta> p p' is'"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p',\n               is') \\<Longrightarrow>\n       p' \\<noteq> p \\<or> is' \\<noteq> []\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 8. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n        \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (m, sb, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                     \\<R>')])\nA total of 11 subgoals...", "assume step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\""], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\n\ngoal (11 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p',\n               is') \\<Longrightarrow>\n       p' \\<noteq> p \\<or> is' \\<noteq> []\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 8. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n        \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (m, sb, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                     \\<R>')])\nA total of 11 subgoals...", "obtain s t where p: \"p = (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (11 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p',\n               is') \\<Longrightarrow>\n       p' \\<noteq> p \\<or> is' \\<noteq> []\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 8. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n        \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (m, sb, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                     \\<R>')])\nA total of 11 subgoals...", "obtain s' t' where p': \"p' = (s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (11 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p',\n               is') \\<Longrightarrow>\n       p' \\<noteq> p \\<or> is' \\<noteq> []\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 8. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n        \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (m, sb, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                     \\<R>')])\nA total of 11 subgoals...", "from prog_step_progress [OF step [simplified p p']]"], ["proof (chain)\npicking this:\n  (s', t') \\<noteq> (s, t) \\<or> is' \\<noteq> []", "show \"p' \\<noteq> p \\<or> is' \\<noteq> []\""], ["proof (prove)\nusing this:\n  (s', t') \\<noteq> (s, t) \\<or> is' \\<noteq> []\n\ngoal (1 subgoal):\n 1. p' \\<noteq> p \\<or> is' \\<noteq> []", "by (simp add: p p')"], ["proof (state)\nthis:\n  p' \\<noteq> p \\<or> is' \\<noteq> []\n\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "fix \\<theta> p p' is'"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "assume step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\" \n    and valid_stmt: \"(\\<lambda>(s, t). valid_sops_stmt t s) p\""], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\n  case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "obtain s t where p: \"p = (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "obtain s' t' where p': \"p' = (s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "from valid_sops_stmt_invariant [OF step [simplified p p'] valid_stmt [simplified p, simplified]]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t' s'", "have \"valid_sops_stmt t' s'\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. valid_sops_stmt t' s'", "."], ["proof (state)\nthis:\n  valid_sops_stmt t' s'\n\ngoal (10 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 7. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 10. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n        \\<D>' \\<O>' \\<R>' \\<S>'.\n        \\<lbrakk>i < length ts;\n         ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n         (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n          \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                 m', \\<D>', \\<O>', \\<R>', \\<S>');\n         valid_pimp ts\\<rbrakk>\n        \\<Longrightarrow> valid_pimp\n                           (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                     \\<R>')])", "then"], ["proof (chain)\npicking this:\n  valid_sops_stmt t' s'", "show \"(\\<lambda>(s, t). valid_sops_stmt t s) p'\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t' s'\n\ngoal (1 subgoal):\n 1. case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s", "by (simp add: p')"], ["proof (state)\nthis:\n  case p' of (s, t) \\<Rightarrow> valid_sops_stmt t s\n\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb::(stmt \\<times> nat) memref list, \\<D>, \\<O>,\\<R>)\" \n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  valid_pimp ts\n\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from valid"], ["proof (chain)\npicking this:\n  valid_pimp ts", "have \"separated_tmps ts\""], ["proof (prove)\nusing this:\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "by (simp add: valid_pimp_def)"], ["proof (state)\nthis:\n  separated_tmps ts\n\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "then"], ["proof (chain)\npicking this:\n  separated_tmps ts", "interpret separated_tmps ts"], ["proof (prove)\nusing this:\n  separated_tmps ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "."], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "obtain s t where p: \"p = (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (9 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 6. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 9. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from valid_sops_stmt [OF i_bound ts_i [simplified p]]"], ["proof (chain)\npicking this:\n  valid_sops_stmt t s", "show \"(\\<lambda>(s, t). valid_sops_stmt t s) p\""], ["proof (prove)\nusing this:\n  valid_sops_stmt t s\n\ngoal (1 subgoal):\n 1. case p of (s, t) \\<Rightarrow> valid_sops_stmt t s", "by (auto simp add: p)"], ["proof (state)\nthis:\n  case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D>  \\<theta> sb"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb::(stmt \\<times> nat) memref list, \\<D>, \\<O>,\\<R>)\" \n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  valid_pimp ts\n\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from valid"], ["proof (chain)\npicking this:\n  valid_pimp ts", "have \"separated_tmps ts\""], ["proof (prove)\nusing this:\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "by (simp add: valid_pimp_def)"], ["proof (state)\nthis:\n  separated_tmps ts\n\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "then"], ["proof (chain)\npicking this:\n  separated_tmps ts", "interpret separated_tmps ts"], ["proof (prove)\nusing this:\n  separated_tmps ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "."], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "obtain s t where p: \"p = (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (8 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R>.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> case hd_prog p sb of\n                         (s, t) \\<Rightarrow> valid_sops_stmt t s\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 5. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 8. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from hd_prog_prog_configs [of p sb] valid_sops_stmt [OF i_bound ts_i [simplified p]]\n  valid_sops_stmt_sb [OF i_bound ts_i [simplified p]]"], ["proof (chain)\npicking this:\n  hd_prog p sb = p \\<or> hd_prog p sb \\<in> prog_configs sb\n  valid_sops_stmt t s\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'", "show \"(\\<lambda>(s, t). valid_sops_stmt t s) (hd_prog p sb)\""], ["proof (prove)\nusing this:\n  hd_prog p sb = p \\<or> hd_prog p sb \\<in> prog_configs sb\n  valid_sops_stmt t s\n  (?s', ?t') \\<in> prog_configs sb \\<Longrightarrow> valid_sops_stmt ?t' ?s'\n\ngoal (1 subgoal):\n 1. case hd_prog p sb of (s, t) \\<Rightarrow> valid_sops_stmt t s", "by (auto simp add: p)"], ["proof (state)\nthis:\n  case hd_prog p sb of (s, t) \\<Rightarrow> valid_sops_stmt t s\n\ngoal (7 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 4. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 4. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb p' is'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 4. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>,\\<R>)\" \n    and step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\n  valid_pimp ts\n\ngoal (7 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> distinct_load_tmps is' \\<and>\n                         load_tmps is' \\<inter> load_tmps is = {} \\<and>\n                         load_tmps is' \\<inter> read_tmps sb = {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 4. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 7. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "show \"distinct_load_tmps is' \\<and>\n          load_tmps is' \\<inter> load_tmps is = {} \\<and>\n          load_tmps is' \\<inter> read_tmps sb = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "obtain s' t' where p': \"p'=(s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "note ts_i = ts_i [simplified p]"], ["proof (state)\nthis:\n  ts ! i = ((s, t), is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "note step = step [simplified p p']"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is')\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "from valid"], ["proof (chain)\npicking this:\n  valid_pimp ts", "interpret separated_tmps ts"], ["proof (prove)\nusing this:\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "by (simp add: valid_pimp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "from sbh_step_distinct_load_tmps_prog_step [OF step load_tmps_le [OF i_bound ts_i]\n      read_tmps_le [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  distinct_load_tmps is' \\<and>\n  load_tmps is' \\<inter> load_tmps is = {} \\<and>\n  load_tmps is' \\<inter> read_tmps sb = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct_load_tmps is' \\<and>\n  load_tmps is' \\<inter> load_tmps is = {} \\<and>\n  load_tmps is' \\<inter> read_tmps sb = {}\n\ngoal (1 subgoal):\n 1. distinct_load_tmps is' \\<and>\n    load_tmps is' \\<inter> load_tmps is = {} \\<and>\n    load_tmps is' \\<inter> read_tmps sb = {}", "."], ["proof (state)\nthis:\n  distinct_load_tmps is' \\<and>\n  load_tmps is' \\<inter> load_tmps is = {} \\<and>\n  load_tmps is' \\<inter> read_tmps sb = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct_load_tmps is' \\<and>\n  load_tmps is' \\<inter> load_tmps is = {} \\<and>\n  load_tmps is' \\<inter> read_tmps sb = {}\n\ngoal (6 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 3. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 3. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb p' is'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 3. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>,\\<R>)\" \n    and step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\n  valid_pimp ts\n\ngoal (6 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> data_dependency_consistent_instrs\n                          (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` store_sops is) =\n                         {} \\<and>\n                         load_tmps is' \\<inter>\n                         \\<Union> (fst ` write_sops sb) =\n                         {}\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 3. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 6. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "show \"data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is) is' \\<and>\n          load_tmps is' \\<inter> \\<Union>(fst ` store_sops is) = {} \\<and>\n          load_tmps is' \\<inter> \\<Union>(fst ` write_sops sb) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "obtain s' t' where p': \"p'=(s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "note ts_i = ts_i [simplified p]"], ["proof (state)\nthis:\n  ts ! i = ((s, t), is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "note step = step [simplified p p']"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is')\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "from valid"], ["proof (chain)\npicking this:\n  valid_pimp ts", "interpret separated_tmps ts"], ["proof (prove)\nusing this:\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "by (simp add: valid_pimp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "from sbh_valid_data_dependency_prog_step [OF step store_sops_le [OF i_bound ts_i]\n      write_sops_le [OF i_bound ts_i] valid_sops_stmt [OF i_bound ts_i]] tmps_le [OF i_bound ts_i]"], ["proof (chain)\npicking this:\n  data_dependency_consistent_instrs {i. i < t} is' \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}", "show ?thesis"], ["proof (prove)\nusing this:\n  data_dependency_consistent_instrs {i. i < t} is' \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}\n  dom \\<theta> \\<union> load_tmps is = {i. i < t}\n\ngoal (1 subgoal):\n 1. data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n     is' \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n    load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}", "by auto"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n   is' \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  data_dependency_consistent_instrs (dom \\<theta> \\<union> load_tmps is)\n   is' \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` store_sops is) = {} \\<and>\n  load_tmps is' \\<inter> \\<Union> (fst ` write_sops sb) = {}\n\ngoal (5 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb p' is'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>,\\<R>)\" \n    and step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\n  valid_pimp ts\n\ngoal (5 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> load_tmps is' \\<inter> dom \\<theta> = {}\n 2. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 5. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "show \"load_tmps is' \\<inter> dom \\<theta> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "obtain s' t' where p': \"p'=(s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "note ts_i = ts_i [simplified p]"], ["proof (state)\nthis:\n  ts ! i = ((s, t), is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "note step = step [simplified p p']"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is')\n\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "from valid"], ["proof (chain)\npicking this:\n  valid_pimp ts", "interpret separated_tmps ts"], ["proof (prove)\nusing this:\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. separated_tmps ts", "by (simp add: valid_pimp_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "from sbh_load_tmps_fresh_prog_step [OF step tmps_le' [OF i_bound ts_i]]"], ["proof (chain)\npicking this:\n  load_tmps is' \\<inter> dom \\<theta> = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  load_tmps is' \\<inter> dom \\<theta> = {}\n\ngoal (1 subgoal):\n 1. load_tmps is' \\<inter> dom \\<theta> = {}", "."], ["proof (state)\nthis:\n  load_tmps is' \\<inter> dom \\<theta> = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  load_tmps is' \\<inter> dom \\<theta> = {}\n\ngoal (4 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix \\<theta> p p' \"is\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume  step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is)\"\n    and valid: \"(\\<lambda>(s, t). valid_sops_stmt t s) p\""], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is)\n  case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\n\ngoal (4 subgoals):\n 1. \\<And>\\<theta> p p' is'.\n       \\<lbrakk>\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        case p of (s, t) \\<Rightarrow> valid_sops_stmt t s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sop\\<in>store_sops is'. valid_sop sop\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 4. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "show  \"\\<forall>sop\\<in>store_sops is. valid_sop sop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "obtain s t where p: \"p=(s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s t. p = (s, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = (s, t)\n\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "obtain s' t' where p': \"p'=(s',t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' t'. p' = (s', t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p')"], ["proof (state)\nthis:\n  p' = (s', t')\n\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "note step = step [simplified p p']"], ["proof (state)\nthis:\n  \\<theta>\\<turnstile> (s, t) \\<rightarrow>\\<^sub>s ((s', t'), is)\n\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "from sbh_valid_sops_prog_step [OF step valid [simplified p,simplified]]"], ["proof (chain)\npicking this:\n  \\<forall>sop\\<in>store_sops is. valid_sop sop", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sop\\<in>store_sops is. valid_sop sop\n\ngoal (1 subgoal):\n 1. \\<forall>sop\\<in>store_sops is. valid_sop sop", "."], ["proof (state)\nthis:\n  \\<forall>sop\\<in>store_sops is. valid_sop sop\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>sop\\<in>store_sops is. valid_sop sop\n\ngoal (3 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb p' is'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb::stmt_config store_buffer, \\<D>, \\<O>,\\<R>)\" \n    and step: \"\\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\"\n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is')\n  valid_pimp ts\n\ngoal (3 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> p' is'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        \\<theta>\\<turnstile> p \\<rightarrow>\\<^sub>s (p', is');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p', is @ is', \\<theta>,\n                                    sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n                                    \\<D>, \\<O>, \\<R>)])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 3. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from prog_step_preserves_valid [OF i_bound ts_i step valid]"], ["proof (chain)\npicking this:\n  valid_pimp\n   (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n             \\<D>, \\<O>, \\<R>)])", "show \"valid_pimp (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'], \\<D>, \\<O>,\\<R>)])\""], ["proof (prove)\nusing this:\n  valid_pimp\n   (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n             \\<D>, \\<O>, \\<R>)])\n\ngoal (1 subgoal):\n 1. valid_pimp\n     (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n               \\<D>, \\<O>, \\<R>)])", "."], ["proof (state)\nthis:\n  valid_pimp\n   (ts[i := (p', is @ is', \\<theta>, sb @ [Prog\\<^sub>s\\<^sub>b p p' is'],\n             \\<D>, \\<O>, \\<R>)])\n\ngoal (2 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb  \\<S> m m' sb' \\<O>' \\<R>' \\<S>'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb::stmt_config store_buffer, \\<D>, \\<O>,\\<R>)\" \n    and step: \"(m, sb, \\<O>, \\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m', sb',\\<O>',\\<R>',\\<S>')\"\n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  (m, sb, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>')\n  valid_pimp ts\n\ngoal (2 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "thm flush_step_preserves_valid [OF ]"], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  (m, sb, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>')\n  valid_pimp ts\n\ngoal (2 subgoals):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> m' sb' \\<O>' \\<R>'\n       \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (m, sb, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>f (m', sb', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\n                                    \\<R>')])\n 2. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from flush_step_preserves_valid [OF i_bound ts_i step valid]"], ["proof (chain)\npicking this:\n  valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "show \"valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>',\\<R>')])\""], ["proof (prove)\nusing this:\n  valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])", "."], ["proof (state)\nthis:\n  valid_pimp (ts[i := (p, is, \\<theta>, sb', \\<D>, \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "fix i ts p \"is\" \\<O> \\<R> \\<D> \\<theta> sb \\<S> m is' \\<O>' \\<R>' \\<D>' \\<theta>' sb' \\<S>' m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "assume i_bound: \"i < length ts\" \n    and ts_i: \"ts ! i = (p, is, \\<theta>, sb::stmt_config store_buffer, \\<D>, \\<O>,\\<R>)\"\n    and step: \"(is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>, \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h \n                  (is', \\<theta>', sb', m',\\<D>', \\<O>', \\<R>',\\<S>')\"\n    and valid: \"valid_pimp ts\""], ["proof (state)\nthis:\n  i < length ts\n  ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>)\n  (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n   \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb', m',\n          \\<D>', \\<O>', \\<R>', \\<S>')\n  valid_pimp ts\n\ngoal (1 subgoal):\n 1. \\<And>i ts p is \\<theta> sb \\<D> \\<O> \\<R> m \\<S> is' \\<theta>' sb' m'\n       \\<D>' \\<O>' \\<R>' \\<S>'.\n       \\<lbrakk>i < length ts;\n        ts ! i = (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>);\n        (is, \\<theta>, sb, m, \\<D>, \\<O>, \\<R>,\n         \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is', \\<theta>', sb',\n                m', \\<D>', \\<O>', \\<R>', \\<S>');\n        valid_pimp ts\\<rbrakk>\n       \\<Longrightarrow> valid_pimp\n                          (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\n                                    \\<R>')])", "from sbh_step_preserves_valid [OF i_bound ts_i step valid]"], ["proof (chain)\npicking this:\n  valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "show \"valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>',\\<R>')])\""], ["proof (prove)\nusing this:\n  valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])\n\ngoal (1 subgoal):\n 1. valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])", "."], ["proof (state)\nthis:\n  valid_pimp (ts[i := (p, is', \\<theta>', sb', \\<D>', \\<O>', \\<R>')])\n\ngoal:\nNo subgoals!", "qed"], ["", "thm PIMP.concurrent_direct_steps_simulates_store_buffer_history_step"], ["", "thm PIMP.concurrent_direct_steps_simulates_store_buffer_history_steps"], ["", "thm PIMP.concurrent_direct_steps_simulates_store_buffer_step"], ["", "text \\<open>We can instantiate PIMP with the various memory models.\\<close>"], ["", "(* FIXME: note I used () instead of sb , because simplifier rewrites sb::unit to sb.\n  Make this consistent with interpretations/theorems in ReduceStoreBuffer *)"], ["", "interpretation direct: \n  computation direct_memop_step empty_storebuffer_step stmt_step \"\\<lambda>p p' is sb. ()\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation virtual: \n  computation virtual_memop_step empty_storebuffer_step stmt_step \"\\<lambda>p p' is sb. ()\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation store_buffer:\n  computation sb_memop_step store_buffer_step stmt_step \"\\<lambda>p p' is sb. sb\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation store_buffer_history:\n  computation sbh_memop_step flush_step stmt_step \"\\<lambda>p p' is sb. sb @ [Prog\\<^sub>s\\<^sub>b p p' is]\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation direct_pimp_step:: \n  \"(stmt_config,unit,bool,owns,rels,shared) global_config \\<Rightarrow> (stmt_config,unit,bool,owns,rels,shared) global_config \\<Rightarrow> bool\" \n  (\"_ \\<Rightarrow>\\<^sub>d\\<^sub>p _\" [60,60] 100)\nwhere\n\"c \\<Rightarrow>\\<^sub>d\\<^sub>p d \\<equiv> direct.concurrent_step c d\""], ["", "abbreviation direct_pimp_steps:: \n  \"(stmt_config,unit,bool,owns,rels,shared) global_config \\<Rightarrow> (stmt_config,unit,bool,owns,rels,shared) global_config \\<Rightarrow> bool\" \n  (\"_ \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* _\" [60,60] 100)\nwhere\n\"direct_pimp_steps == direct_pimp_step^**\""], ["", "text \\<open>Execution examples\\<close>"], ["", "lemma Assign_Const_ex: \n\"([((Assign True (Tmp ({},\\<lambda>\\<theta>. a)) (Const c) (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),t),[],\\<theta>,(),\\<D>,\\<O>,\\<R>)],m,\\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* \n ([((Skip,t),[],\\<theta>,(),True,\\<O> \\<union> A - R,Map.empty)],m(a := c),\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b\n 2. ?b \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>, (),\n          True, \\<O> \\<union> A - R, Map.empty)],\n        m(a := c),\n        \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Program [where i=0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length\n         [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n             (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n             (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n            t),\n           [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n 2. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n        (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p3, ?is3, ?\\<theta>3, ?sb3, ?\\<D>3, ?\\<O>3, ?\\<R>3)\n 3. ?\\<theta>3\\<turnstile> ?p3 \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 4. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, ?is3 @ ?is'3, ?\\<theta>3, (), ?\\<D>3, ?\\<O>3, ?\\<R>3)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n        (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p3, ?is3, ?\\<theta>3, ?sb3, ?\\<D>3, ?\\<O>3, ?\\<R>3)\n 2. ?\\<theta>3\\<turnstile> ?p3 \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 3. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, ?is3 @ ?is'3, ?\\<theta>3, (), ?\\<D>3, ?\\<O>3, ?\\<R>3)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<theta>\\<turnstile> (Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n                           (Const c) (\\<lambda>\\<theta>. A)\n                           (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n                           (\\<lambda>\\<theta>. W),\n                          t) \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 2. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, [] @ ?is'3, \\<theta>, (), \\<D>, \\<O>, \\<R>)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule Assign)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} \\<subseteq> dom \\<theta>\n 2. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b20\n 2. ?b20 \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n            (), True, \\<O> \\<union> A - R, Map.empty)],\n          m(a := c),\n          \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Memop [where i=0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length\n         ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n              (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n              (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n             t),\n            [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n          [0 := ((Skip, t + used_tmps (Const c)),\n                 [] @\n                 issue_expr t (Const c) @\n                 [Write True a (eval_expr t (Const c)) A L R W],\n                 \\<theta>, (), \\<D>, \\<O>, \\<R>)])\n 2. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n        (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n    [0 := ((Skip, t + used_tmps (Const c)),\n           [] @\n           issue_expr t (Const c) @\n           [Write True a (eval_expr t (Const c)) A L R W],\n           \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p23, ?is23, ?\\<theta>23, ?sb23, ?\\<D>23, ?\\<O>23, ?\\<R>23)\n 3. (?is23, ?\\<theta>23, ?sb23, m, ?\\<D>23, ?\\<O>23, ?\\<R>23,\n     \\<S>) \\<rightarrow> (?is'23, ?\\<theta>'23, ?sb'23, ?m'23, ?\\<D>'23,\n                          ?\\<O>'23, ?\\<R>'23, ?\\<S>'23)\n 4. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := (?p23, ?is'23, ?\\<theta>'23, ?sb'23, ?\\<D>'23, ?\\<O>'23,\n            ?\\<R>'23)],\n     ?m'23,\n     ?\\<S>'23) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                  \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := c),\n                \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n        (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n    [0 := ((Skip, t + used_tmps (Const c)),\n           [] @\n           issue_expr t (Const c) @\n           [Write True a (eval_expr t (Const c)) A L R W],\n           \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p23, ?is23, ?\\<theta>23, ?sb23, ?\\<D>23, ?\\<O>23, ?\\<R>23)\n 2. (?is23, ?\\<theta>23, ?sb23, m, ?\\<D>23, ?\\<O>23, ?\\<R>23,\n     \\<S>) \\<rightarrow> (?is'23, ?\\<theta>'23, ?sb'23, ?m'23, ?\\<D>'23,\n                          ?\\<O>'23, ?\\<R>'23, ?\\<S>'23)\n 3. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := (?p23, ?is'23, ?\\<theta>'23, ?sb'23, ?\\<D>'23, ?\\<O>'23,\n            ?\\<R>'23)],\n     ?m'23,\n     ?\\<S>'23) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                  \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := c),\n                \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([Write True a ({}, \\<lambda>\\<theta>. c) A L R W], \\<theta>, ?sb23, m,\n     \\<D>, \\<O>, \\<R>,\n     \\<S>) \\<rightarrow> (?is'23, ?\\<theta>'23, ?sb'23, ?m'23, ?\\<D>'23,\n                          ?\\<O>'23, ?\\<R>'23, ?\\<S>'23)\n 2. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := ((Skip, t), ?is'23, ?\\<theta>'23, ?sb'23, ?\\<D>'23, ?\\<O>'23,\n            ?\\<R>'23)],\n     ?m'23,\n     ?\\<S>'23) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                  \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := c),\n                \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct_memop_step.WriteVolatile)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Const c)),\n            [] @\n            issue_expr t (Const c) @\n            [Write True a (eval_expr t (Const c)) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := ((Skip, t), [], \\<theta>, ?sb23, True, \\<O> \\<union> A - R,\n            Map.empty)],\n     m(a := c),\n     \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip,\n                                  t),\n                                 [], \\<theta>, (), True,\n                                 \\<O> \\<union> A - R, Map.empty)],\n                               m(a := c),\n                               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n\" ([((Assign True (Tmp ({},\\<lambda>\\<theta>. a)) (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),t),[],\\<theta>,(),\\<D>,\\<O>,\\<R>)],m,S) \n \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* \n ([((Skip,t + 2),[],\\<theta>(t\\<mapsto>m x, t + 1 \\<mapsto>m y),(),True,\\<O> \\<union> A - R,Map.empty)],m(a := m x + m y),S  \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n              \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b\n 2. ?b \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [], \\<theta>\n          (t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n          \\<O> \\<union> A - R, Map.empty)],\n        m(a := m x + m y),\n        S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Program [where i=0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length\n         [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n             (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n             (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n             (\\<lambda>\\<theta>. W),\n            t),\n           [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n 2. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n        (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n        (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p3, ?is3, ?\\<theta>3, ?sb3, ?\\<D>3, ?\\<O>3, ?\\<R>3)\n 3. ?\\<theta>3\\<turnstile> ?p3 \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 4. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, ?is3 @ ?is'3, ?\\<theta>3, (), ?\\<D>3, ?\\<O>3, ?\\<R>3)], m,\n     S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [], \\<theta>\n           (t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n           \\<O> \\<union> A - R, Map.empty)],\n         m(a := m x + m y),\n         S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n        (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n        (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p3, ?is3, ?\\<theta>3, ?sb3, ?\\<D>3, ?\\<O>3, ?\\<R>3)\n 2. ?\\<theta>3\\<turnstile> ?p3 \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 3. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, ?is3 @ ?is'3, ?\\<theta>3, (), ?\\<D>3, ?\\<O>3, ?\\<R>3)], m,\n     S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [], \\<theta>\n           (t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n           \\<O> \\<union> A - R, Map.empty)],\n         m(a := m x + m y),\n         S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<theta>\\<turnstile> (Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n                           (Binop (+) (Mem True x) (Mem True y))\n                           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n                           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n                          t) \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 2. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, [] @ ?is'3, \\<theta>, (), \\<D>, \\<O>, \\<R>)], m,\n     S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [], \\<theta>\n           (t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n           \\<O> \\<union> A - R, Map.empty)],\n         m(a := m x + m y),\n         S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule Assign)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} \\<subseteq> dom \\<theta>\n 2. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n              \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n              \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b20\n 2. ?b20 \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n            \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n            \\<O> \\<union> A - R, Map.empty)],\n          m(a := m x + m y),\n          S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Memop)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?i23\n    < length\n       ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n            (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n            (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n            (\\<lambda>\\<theta>. W),\n           t),\n          [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n        [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n               [] @\n               issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n               [Write True a\n                 (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R\n                 W],\n               \\<theta>, (), \\<D>, \\<O>, \\<R>)])\n 2. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n        (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n        (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n    [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n           [] @\n           issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n           [Write True a (eval_expr t (Binop (+) (Mem True x) (Mem True y)))\n             A L R W],\n           \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    ?i23 =\n    (?p23, ?is23, ?\\<theta>23, ?sb23, ?\\<D>23, ?\\<O>23, ?\\<R>23)\n 3. (?is23, ?\\<theta>23, ?sb23, m, ?\\<D>23, ?\\<O>23, ?\\<R>23,\n     S) \\<rightarrow> (?is'23, ?\\<theta>'23, ?sb'23, ?m'23, ?\\<D>'23,\n                       ?\\<O>'23, ?\\<R>'23, ?\\<S>'23)\n 4. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      ?i23 :=\n        (?p23, ?is'23, ?\\<theta>'23, ?sb'23, ?\\<D>'23, ?\\<O>'23, ?\\<R>'23)],\n     ?m'23,\n     ?\\<S>'23) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n                  \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n                  \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n        (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n        (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n        (\\<lambda>\\<theta>. W),\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n    [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n           [] @\n           issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n           [Write True a (eval_expr t (Binop (+) (Mem True x) (Mem True y)))\n             A L R W],\n           \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p23, ?is23, ?\\<theta>23, ?sb23, ?\\<D>23, ?\\<O>23, ?\\<R>23)\n 2. (?is23, ?\\<theta>23, ?sb23, m, ?\\<D>23, ?\\<O>23, ?\\<R>23,\n     S) \\<rightarrow> (?is'23, ?\\<theta>'23, ?sb'23, ?m'23, ?\\<D>'23,\n                       ?\\<O>'23, ?\\<R>'23, ?\\<S>'23)\n 3. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := (?p23, ?is'23, ?\\<theta>'23, ?sb'23, ?\\<D>'23, ?\\<O>'23,\n            ?\\<R>'23)],\n     ?m'23,\n     ?\\<S>'23) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n                  \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n                  \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([Read True x t, Read True y (Suc t),\n      Write True a\n       ({Suc t, t},\n        \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n       A L R W],\n     \\<theta>, ?sb23, m, \\<D>, \\<O>, \\<R>,\n     S) \\<rightarrow> (?is'23, ?\\<theta>'23, ?sb'23, ?m'23, ?\\<D>'23,\n                       ?\\<O>'23, ?\\<R>'23, ?\\<S>'23)\n 2. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := ((Skip, Suc (Suc t)), ?is'23, ?\\<theta>'23, ?sb'23, ?\\<D>'23,\n            ?\\<O>'23, ?\\<R>'23)],\n     ?m'23,\n     ?\\<S>'23) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n                  \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n                  \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct_memop_step.Read )"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n         (Binop (+) (Mem True x) (Mem True y)) (\\<lambda>\\<theta>. A)\n         (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n         (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, t + used_tmps (Binop (+) (Mem True x) (Mem True y))),\n            [] @\n            issue_expr t (Binop (+) (Mem True x) (Mem True y)) @\n            [Write True a\n              (eval_expr t (Binop (+) (Mem True x) (Mem True y))) A L R W],\n            \\<theta>, (), \\<D>, \\<O>, \\<R>),\n      0 := ((Skip, Suc (Suc t)),\n            [Read True y (Suc t),\n             Write True a\n              ({Suc t, t},\n               \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n              A L R W],\n            \\<theta>(t \\<mapsto> m x), ?sb23, \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t + 2), [],\n              \\<theta>(t \\<mapsto> m x, t + 1 \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Skip, Suc (Suc t)),\n       [Read True y (Suc t),\n        Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)), [],\n              \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Skip, Suc (Suc t)),\n       [Read True y (Suc t),\n        Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b40\n 2. ?b40 \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)), [],\n            \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), True,\n            \\<O> \\<union> A - R, Map.empty)],\n          m(a := m x + m y),\n          S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Memop)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?i43\n    < length\n       [((Skip, Suc (Suc t)),\n         [Read True y (Suc t),\n          Write True a\n           ({Suc t, t},\n            \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n           A L R W],\n         \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)]\n 2. [((Skip, Suc (Suc t)),\n      [Read True y (Suc t),\n       Write True a\n        ({Suc t, t},\n         \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n        A L R W],\n      \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)] !\n    ?i43 =\n    (?p43, ?is43, ?\\<theta>43, ?sb43, ?\\<D>43, ?\\<O>43, ?\\<R>43)\n 3. (?is43, ?\\<theta>43, ?sb43, m, ?\\<D>43, ?\\<O>43, ?\\<R>43,\n     S) \\<rightarrow> (?is'43, ?\\<theta>'43, ?sb'43, ?m'43, ?\\<D>'43,\n                       ?\\<O>'43, ?\\<R>'43, ?\\<S>'43)\n 4. ([((Skip, Suc (Suc t)),\n       [Read True y (Suc t),\n        Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)]\n     [?i43 :=\n        (?p43, ?is'43, ?\\<theta>'43, ?sb'43, ?\\<D>'43, ?\\<O>'43, ?\\<R>'43)],\n     ?m'43,\n     ?\\<S>'43) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)),\n                  [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (),\n                  True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Skip, Suc (Suc t)),\n      [Read True y (Suc t),\n       Write True a\n        ({Suc t, t},\n         \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n        A L R W],\n      \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p43, ?is43, ?\\<theta>43, ?sb43, ?\\<D>43, ?\\<O>43, ?\\<R>43)\n 2. (?is43, ?\\<theta>43, ?sb43, m, ?\\<D>43, ?\\<O>43, ?\\<R>43,\n     S) \\<rightarrow> (?is'43, ?\\<theta>'43, ?sb'43, ?m'43, ?\\<D>'43,\n                       ?\\<O>'43, ?\\<R>'43, ?\\<S>'43)\n 3. ([((Skip, Suc (Suc t)),\n       [Read True y (Suc t),\n        Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p43, ?is'43, ?\\<theta>'43, ?sb'43, ?\\<D>'43, ?\\<O>'43,\n            ?\\<R>'43)],\n     ?m'43,\n     ?\\<S>'43) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)),\n                  [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (),\n                  True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([Read True y (Suc t),\n      Write True a\n       ({Suc t, t},\n        \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n       A L R W],\n     \\<theta>(t \\<mapsto> m x), ?sb43, m, \\<D>, \\<O>, \\<R>,\n     S) \\<rightarrow> (?is'43, ?\\<theta>'43, ?sb'43, ?m'43, ?\\<D>'43,\n                       ?\\<O>'43, ?\\<R>'43, ?\\<S>'43)\n 2. ([((Skip, Suc (Suc t)),\n       [Read True y (Suc t),\n        Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, Suc (Suc t)), ?is'43, ?\\<theta>'43, ?sb'43, ?\\<D>'43,\n            ?\\<O>'43, ?\\<R>'43)],\n     ?m'43,\n     ?\\<S>'43) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)),\n                  [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (),\n                  True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct_memop_step.Read)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Skip, Suc (Suc t)),\n       [Read True y (Suc t),\n        Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x), (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Skip, Suc (Suc t)),\n            [Write True a\n              ({Suc t, t},\n               \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n              A L R W],\n            \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), ?sb43, \\<D>,\n            \\<O>, \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)), [],\n              \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Skip, Suc (Suc t)),\n       [Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n       \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)), [],\n              \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), True,\n              \\<O> \\<union> A - R, Map.empty)],\n            m(a := m x + m y),\n            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Skip, Suc (Suc t)),\n       [Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n       \\<R>)],\n     m, S) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b60\n 2. ?b60 \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)), [],\n            \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), True,\n            \\<O> \\<union> A - R, Map.empty)],\n          m(a := m x + m y),\n          S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Memop)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?i63\n    < length\n       [((Skip, Suc (Suc t)),\n         [Write True a\n           ({Suc t, t},\n            \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n           A L R W],\n         \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n         \\<R>)]\n 2. [((Skip, Suc (Suc t)),\n      [Write True a\n        ({Suc t, t},\n         \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n        A L R W],\n      \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n      \\<R>)] !\n    ?i63 =\n    (?p63, ?is63, ?\\<theta>63, ?sb63, ?\\<D>63, ?\\<O>63, ?\\<R>63)\n 3. (?is63, ?\\<theta>63, ?sb63, m, ?\\<D>63, ?\\<O>63, ?\\<R>63,\n     S) \\<rightarrow> (?is'63, ?\\<theta>'63, ?sb'63, ?m'63, ?\\<D>'63,\n                       ?\\<O>'63, ?\\<R>'63, ?\\<S>'63)\n 4. ([((Skip, Suc (Suc t)),\n       [Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n       \\<R>)]\n     [?i63 :=\n        (?p63, ?is'63, ?\\<theta>'63, ?sb'63, ?\\<D>'63, ?\\<O>'63, ?\\<R>'63)],\n     ?m'63,\n     ?\\<S>'63) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)),\n                  [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (),\n                  True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Skip, Suc (Suc t)),\n      [Write True a\n        ({Suc t, t},\n         \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n        A L R W],\n      \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n      \\<R>)] !\n    0 =\n    (?p63, ?is63, ?\\<theta>63, ?sb63, ?\\<D>63, ?\\<O>63, ?\\<R>63)\n 2. (?is63, ?\\<theta>63, ?sb63, m, ?\\<D>63, ?\\<O>63, ?\\<R>63,\n     S) \\<rightarrow> (?is'63, ?\\<theta>'63, ?sb'63, ?m'63, ?\\<D>'63,\n                       ?\\<O>'63, ?\\<R>'63, ?\\<S>'63)\n 3. ([((Skip, Suc (Suc t)),\n       [Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n       \\<R>)]\n     [0 := (?p63, ?is'63, ?\\<theta>'63, ?sb'63, ?\\<D>'63, ?\\<O>'63,\n            ?\\<R>'63)],\n     ?m'63,\n     ?\\<S>'63) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)),\n                  [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (),\n                  True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([Write True a\n       ({Suc t, t},\n        \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n       A L R W],\n     \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), ?sb63, m, \\<D>, \\<O>,\n     \\<R>,\n     S) \\<rightarrow> (?is'63, ?\\<theta>'63, ?sb'63, ?m'63, ?\\<D>'63,\n                       ?\\<O>'63, ?\\<R>'63, ?\\<S>'63)\n 2. ([((Skip, Suc (Suc t)),\n       [Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n       \\<R>)]\n     [0 := ((Skip, Suc (Suc t)), ?is'63, ?\\<theta>'63, ?sb'63, ?\\<D>'63,\n            ?\\<O>'63, ?\\<R>'63)],\n     ?m'63,\n     ?\\<S>'63) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, Suc (Suc t)),\n                  [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (),\n                  True, \\<O> \\<union> A - R, Map.empty)],\n                m(a := m x + m y),\n                S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct_memop_step.WriteVolatile )"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Skip, Suc (Suc t)),\n       [Write True a\n         ({Suc t, t},\n          \\<lambda>\\<theta>. the (\\<theta> t) + the (\\<theta> (Suc t)))\n         A L R W],\n       \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y), (), \\<D>, \\<O>,\n       \\<R>)]\n     [0 := ((Skip, Suc (Suc t)), [], \\<theta>(t \\<mapsto> m x, Suc t \n            \\<mapsto> m y), ?sb63, True, \\<O> \\<union> A - R, Map.empty)],\n     m(a := the ((\\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y)) t) +\n            the ((\\<theta>(t \\<mapsto> m x, Suc t \\<mapsto> m y)) (Suc t))),\n     S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip,\n                               Suc (Suc t)),\n                              [], \\<theta>(t \\<mapsto> m x, Suc t \\<mapsto>\n                              m y), (), True, \\<O> \\<union> A - R,\n                              Map.empty)],\n                            m(a := m x + m y),\n                            S \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  \nassumes isTrue: \"isTrue c\"\nshows  \n\"([((Cond (Const c) (Assign True (Tmp ({},\\<lambda>\\<theta>. a)) (Const c) (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W)) Skip,t) ,[],\\<theta>,(),\\<D>,\\<O>,\\<R>)],m,\\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* \n ([((Skip,t),[],\\<theta>,(),True,\\<O> \\<union> A - R,Map.empty)],m(a := c),\\<S>  \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b\n 2. ?b \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>, (),\n          True, \\<O> \\<union> A - R, Map.empty)],\n        m(a := c),\n        \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Program [where i=0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length\n         [((Cond (Const c)\n             (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n               (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n               (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n             Skip,\n            t),\n           [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n 2. [((Cond (Const c)\n        (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n          (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n          (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n        Skip,\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p3, ?is3, ?\\<theta>3, ?sb3, ?\\<D>3, ?\\<O>3, ?\\<R>3)\n 3. ?\\<theta>3\\<turnstile> ?p3 \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 4. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, ?is3 @ ?is'3, ?\\<theta>3, (), ?\\<D>3, ?\\<O>3, ?\\<R>3)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Cond (Const c)\n        (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n          (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n          (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n        Skip,\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p3, ?is3, ?\\<theta>3, ?sb3, ?\\<D>3, ?\\<O>3, ?\\<R>3)\n 2. ?\\<theta>3\\<turnstile> ?p3 \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 3. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, ?is3 @ ?is'3, ?\\<theta>3, (), ?\\<D>3, ?\\<O>3, ?\\<R>3)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<theta>\\<turnstile> (Cond (Const c)\n                           (Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n                             (Const c) (\\<lambda>\\<theta>. A)\n                             (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n                             (\\<lambda>\\<theta>. W))\n                           Skip,\n                          t) \\<rightarrow>\\<^sub>s (?p'3, ?is'3)\n 2. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'3, [] @ ?is'3, \\<theta>, (), \\<D>, \\<O>, \\<R>)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule Cond)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>sop. Const c \\<noteq> Tmp sop\n 2. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Cond (Tmp (eval_expr t (Const c)))\n              (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n                (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n                (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n              Skip,\n             t + used_tmps (Const c)),\n            [] @ issue_expr t (Const c), \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Cond (Const c)\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Cond (Tmp (eval_expr t (Const c)))\n              (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n                (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n                (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n              Skip,\n             t + used_tmps (Const c)),\n            [] @ issue_expr t (Const c), \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p ?b20\n 2. ?b20 \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n            (), True, \\<O> \\<union> A - R, Map.empty)],\n          m(a := c),\n          \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule direct.Program [where i=0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length\n         [((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n             (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n               (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n               (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n             Skip,\n            t),\n           [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n 2. [((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n        (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n          (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n          (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n        Skip,\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p23, ?is23, ?\\<theta>23, ?sb23, ?\\<D>23, ?\\<O>23, ?\\<R>23)\n 3. ?\\<theta>23\\<turnstile> ?p23 \\<rightarrow>\\<^sub>s (?p'23, ?is'23)\n 4. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'23, ?is23 @ ?is'23, ?\\<theta>23, (), ?\\<D>23, ?\\<O>23,\n            ?\\<R>23)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. [((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n        (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n          (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n          (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n        Skip,\n       t),\n      [], \\<theta>, (), \\<D>, \\<O>, \\<R>)] !\n    0 =\n    (?p23, ?is23, ?\\<theta>23, ?sb23, ?\\<D>23, ?\\<O>23, ?\\<R>23)\n 2. ?\\<theta>23\\<turnstile> ?p23 \\<rightarrow>\\<^sub>s (?p'23, ?is'23)\n 3. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'23, ?is23 @ ?is'23, ?\\<theta>23, (), ?\\<D>23, ?\\<O>23,\n            ?\\<R>23)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<theta>\\<turnstile> (Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n                           (Assign True (Tmp ({}, \\<lambda>\\<theta>. a))\n                             (Const c) (\\<lambda>\\<theta>. A)\n                             (\\<lambda>\\<theta>. L) (\\<lambda>\\<theta>. R)\n                             (\\<lambda>\\<theta>. W))\n                           Skip,\n                          t) \\<rightarrow>\\<^sub>s (?p'23, ?is'23)\n 2. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := (?p'23, [] @ ?is'23, \\<theta>, (), \\<D>, \\<O>, \\<R>)], m,\n     \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [], \\<theta>,\n              (), True, \\<O> \\<union> A - R, Map.empty)],\n            m(a := c),\n            \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (rule CondTrue)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {} \\<subseteq> dom \\<theta>\n 2. isTrue c\n 3. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n              (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n              (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n             t),\n            [] @ [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. isTrue c\n 2. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n              (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n              (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n             t),\n            [] @ [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply  (simp add: isTrue)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Cond (Tmp ({}, \\<lambda>\\<theta>. c))\n         (Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n           (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n           (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W))\n         Skip,\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)]\n     [0 := ((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n              (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n              (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n             t),\n            [] @ [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((Assign True (Tmp ({}, \\<lambda>\\<theta>. a)) (Const c)\n         (\\<lambda>\\<theta>. A) (\\<lambda>\\<theta>. L)\n         (\\<lambda>\\<theta>. R) (\\<lambda>\\<theta>. W),\n        t),\n       [], \\<theta>, (), \\<D>, \\<O>, \\<R>)],\n     m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sub>p\\<^sup>* ([((Skip, t), [],\n                 \\<theta>, (), True, \\<O> \\<union> A - R, Map.empty)],\n               m(a := c),\n               \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)", "apply (rule Assign_Const_ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}