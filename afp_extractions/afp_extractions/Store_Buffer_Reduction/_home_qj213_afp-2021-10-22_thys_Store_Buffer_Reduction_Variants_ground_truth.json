{"file_name": "/home/qj213/afp-2021-10-22/thys/Store_Buffer_Reduction/Variants.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Store_Buffer_Reduction", "problem_names": ["lemma restrict_map_inverse: \"m |` (dom m - X) = m |`(-X)\"", "lemma conj_assoc: \"((P \\<and> Q) \\<and> X) = (P \\<and> Q \\<and> X)\"", "lemma sim_direct_config_def': \"ts\\<^sub>s\\<^sub>b \\<sim>\\<^sub>d ts \\<equiv>\n(ts\\<^sub>s\\<^sub>b = (map (\\<lambda>(p,is, \\<theta>,sb::unit,\\<D>, \\<O>,\\<R>). (p,is,\\<theta>,[],(),(),())) ts))\"", "lemma DRead: \"(Read volatile a t # is,\\<theta>, x, m,ghst) \\<rightarrow>\n               (is, \\<theta> (t\\<mapsto>m a), x, m, ghst)\"", "lemma DWriteNonVolatile:\"\n  (Write False a (D,f) A L R W#is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>, x, m(a := f \\<theta>), ghst)\"", "lemma DWriteVolatile:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (True, \\<O> \\<union> A - R, Map.empty, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \n   \\<Longrightarrow> (Write True a (D,f) A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>,  x, m(a:=f \\<theta>), ghst')\"", "lemma DGhost:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (\\<D>, \\<O> \\<union> A - R, augment_rels (dom \\<S>) R \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \n   \\<Longrightarrow> (Ghost A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>,  x, m, ghst')\"", "lemma DRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst'=(False, \\<O>, Map.empty,\\<S>)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W # is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>(t\\<mapsto>m a),x,m, ghst')\"", "lemma DRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \n    \\<theta>' = \\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));\n    m' = m(a:= f(\\<theta>(t\\<mapsto>m a)));\n    ghst = (\\<D>, \\<O>, \\<R>, \\<S>); \n   ghst' = (False,\\<O> \\<union> A - R, Map.empty, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \n   \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>',x, m' , ghst')\"", "lemma VRead: \"(Read volatile a t # is,\\<theta>, x, m,ghst) \\<rightarrow>\\<^sub>v\n               (is, \\<theta> (t\\<mapsto>m a), x, m, ghst)\"", "lemma VWriteNonVolatile:\"\n  (Write False a (D,f) A L R W#is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m(a := f \\<theta>), ghst)\"", "lemma VWriteVolatile:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (True, \\<O> \\<union> A - R, \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \n   \\<Longrightarrow> (Write True a (D,f) A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>,  x, m(a:=f \\<theta>), ghst')\"", "lemma VRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst'=(False, \\<O>,\\<R>,\\<S>)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W # is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>(t\\<mapsto>m a),x,m, ghst')\"", "lemma VFence:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (False, \\<O>, \\<R>, \\<S>) \n   \\<Longrightarrow> (Fence# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>,  x, m, ghst')\"", "lemma VGhost:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (\\<D>, \\<O> \\<union> A - R, \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)  \n   \\<Longrightarrow> (Ghost A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>,  x, m, ghst')\"", "lemma VRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \n    \\<theta>' = \\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));\n    m' = m(a:= f(\\<theta>(t\\<mapsto>m a)));\n    ghst = (\\<D>, \\<O>, \\<R>, \\<S>); \n   ghst' = (False,\\<O> \\<union> A - R, \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \n   \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>',x, m' , ghst')\"", "lemma SafeWriteVolatile:\n  \"\\<lbrakk>\\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> \\<O>s!j; a \\<notin> read_only \\<S>;    \n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow>  A \\<inter>  \\<O>s!j = {};\n    A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n   \\<rbrakk>\n   \\<Longrightarrow> \n   \\<O>s,i\\<turnstile>(Write True a (D,f) A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\"", "lemma SafeDelayedWriteVolatile:\n  \"\\<lbrakk>\\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> (\\<O>s!j \\<union> dom (\\<R>s!j)); a \\<notin> read_only \\<S>;\n  \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow>  A \\<inter>  (\\<O>s!j \\<union> dom (\\<R>s!j)) = {};\n    A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n   \\<rbrakk>\n   \\<Longrightarrow> \n   \\<O>s,\\<R>s,i\\<turnstile>(Write True a (D,f) A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\"", "lemma SafeRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); a \\<in> dom \\<S> \\<union> \\<O>\\<rbrakk> \\<Longrightarrow> \n   \\<O>s,i\\<turnstile> (RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\"", "lemma SafeDelayedRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); a \\<in> dom \\<S> \\<union> \\<O>; \n   \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> (\\<R>s!j) a \\<noteq> Some False \\<comment> \\<open>no release of unshared address\\<close>\\<rbrakk>\n   \\<Longrightarrow> \n   \\<O>s,\\<R>s,i\\<turnstile>(RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\"", "lemma SafeRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a));  \n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> \\<O>s!j; a \\<notin> read_only \\<S>;\n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> A \\<inter> \\<O>s!j  = {};    \n    A \\<subseteq>  \\<O> \\<union> dom \\<S>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n    \\<rbrakk> \n   \\<Longrightarrow> \n   \\<O>s,i\\<turnstile> (RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\"", "lemma SafeDelayedRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); a \\<in> dom \\<S> \\<union> \\<O>;  \n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> (\\<O>s!j \\<union> dom (\\<R>s!j));a \\<notin> read_only \\<S>;\n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> A \\<inter> (\\<O>s!j \\<union> dom (\\<R>s!j))  = {};\n    A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n    \\<rbrakk> \n   \\<Longrightarrow> \n   \\<O>s,\\<R>s,i\\<turnstile>(RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\"", "lemma  Write\\<^sub>s\\<^sub>bNonVolatile: \n  \"(m, Write\\<^sub>s\\<^sub>b False a sop v A L R W# rs,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m(a := v), rs,\\<O>,\\<R>,\\<S>)\"", "lemma Write\\<^sub>s\\<^sub>bVolatile: \n\"\\<lbrakk>\\<O>'= \\<O> \\<union> A - R;  \\<S>'=(\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \\<Longrightarrow>\n  (m, Write\\<^sub>s\\<^sub>b True a sop v A L R W# rs,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m(a := v), rs,\\<O>',Map.empty,\\<S>')\"", "lemma Ghost\\<^sub>s\\<^sub>b: \"\\<lbrakk>\\<O>'= \\<O> \\<union> A - R; \\<R>'= augment_rels (dom \\<S>) R \\<R>; \\<S>'=\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk> \\<Longrightarrow> \n             (m, Ghost\\<^sub>s\\<^sub>b A L R W# rs,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m, rs,\\<O>',\\<R>',\\<S>')\"", "lemma  SBHRead: \n  \"\\<lbrakk>v = (case (buffered_val sb a) of Some v' \\<Rightarrow> v' | None \\<Rightarrow> m a);\n   sb' = sb@[Read\\<^sub>s\\<^sub>b volatile a t v] \\<rbrakk>\n   \\<Longrightarrow>\n   (Read volatile a t # is, \\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is, \\<theta> (t\\<mapsto>v), sb', m,ghst)\"", "lemma  SBRead: \n  \"\\<lbrakk>v = (case (buffered_val sb a) of Some v' \\<Rightarrow> v' | None \\<Rightarrow> m a)\\<rbrakk>\n   \\<Longrightarrow>\n   (Read volatile a t # is, \\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n          (is, \\<theta> (t\\<mapsto>v), sb, m,ghst)\"", "lemma  SBHReadBuffered': \n  \"\\<lbrakk>buffered_val sb a = Some v;\n   sb' = sb@[Read\\<^sub>s\\<^sub>b volatile a t v] \\<rbrakk>\n   \\<Longrightarrow>\n   (Read volatile a t # is, \\<theta>, sb, m, \\<D>, \\<O>,\\<R>, \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is, \\<theta> (t\\<mapsto>v), sb', m, \\<D>, \\<O>,\\<R>, \\<S>)\"", "lemma SBHReadUnbuffered': \n  \"\\<lbrakk>buffered_val sb a = None;\n    sb' = sb@[Read\\<^sub>s\\<^sub>b volatile a t (m a)]\\<rbrakk> \n   \\<Longrightarrow>\n   (Read volatile a t # is,\\<theta>, sb, m, \\<D>, \\<O>,\\<R>, \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is,\\<theta> (t\\<mapsto>m a), sb', m, \\<D>, \\<O>,\\<R>, \\<S>)\"", "lemma SBHWriteNonVolatile':\n  \"\\<lbrakk> sb'= sb@ [Write\\<^sub>s\\<^sub>b False a (D,f) (f \\<theta>) A L R W]\\<rbrakk> \n   \\<Longrightarrow>\n   (Write False a (D,f) A L R W#is,\\<theta>, sb, m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is, \\<theta>, sb', m, ghst)\"", "lemma SBWriteNonVolatile':\n  \"\\<lbrakk> sb'= sb@ [Write\\<^sub>s\\<^sub>b False a (D,f) (f \\<theta>) A L R W]\\<rbrakk> \n   \\<Longrightarrow>\n   (Write False a (D,f) A L R W#is,\\<theta>, sb, m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n          (is, \\<theta>, sb', m, ghst)\"", "lemma SBHWriteVolatile':\n  \"\\<lbrakk>sb'= sb@[Write\\<^sub>s\\<^sub>b True a (D,f) (f \\<theta>) A L R W]; ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst' = (True, \\<O>,\\<R>, \\<S>)\\<rbrakk>\n   \\<Longrightarrow> \n   (Write True a (D,f) A L R W# is,\\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n         (is,\\<theta>, sb', m,ghst')\"", "lemma SBHGhost':\n  \"(Ghost A L R W# is, \\<theta>, sb, m, G) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n         (is, \\<theta>, sb@[Ghost\\<^sub>s\\<^sub>b A L R W], m, G)\"", "lemma SBWriteVolatile':\n  \"\\<lbrakk>sb'= sb@[Write\\<^sub>s\\<^sub>b True a (D,f) (f \\<theta>) A L R W]\\<rbrakk>\n   \\<Longrightarrow> \n   (Write True a (D,f) A L R W# is,\\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n         (is,\\<theta>, sb', m,ghst)\"", "lemma SBWrite':\n  \"\\<lbrakk>sb'= sb@[Write\\<^sub>s\\<^sub>b volatile a (D,f) (f \\<theta>) A L R W]\\<rbrakk>\n   \\<Longrightarrow> \n   (Write volatile a (D,f) A L R W# is,\\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n         (is,\\<theta>, sb', m,ghst)\"", "lemma SBHRMWReadOnly':\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst' = (False, \\<O>, Map.empty,\\<S>)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is, \\<theta>(t\\<mapsto>m a),[], m, ghst')\"", "lemma SBHRMWWrite':\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \\<theta>'=\\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));m'=m(a:= f(\\<theta>(t\\<mapsto>m a)));\n   ghst = (\\<D>, \\<O>,\\<R>, \\<S>); ghst'=(False, \\<O> \\<union> A - R, Map.empty,\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n         (is, \\<theta>',[], m', ghst')\"", "lemma SBRMWReadOnly':\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); \\<theta>'=\\<theta>(t\\<mapsto>m a)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>',[], m, ghst)\"", "lemma SBRMWWrite':\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \\<theta>'=\\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));m'=m(a:= f(\\<theta>(t\\<mapsto>m a)))\\<rbrakk> \n   \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n         (is, \\<theta>',[], m', ghst)\"", "lemma sim_config':\n  \"\\<lbrakk>m = flush_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h m\\<^sub>s\\<^sub>b\\<^sub>h;\n    \\<S> = share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n    length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts; \n    \\<forall>i < length ts\\<^sub>s\\<^sub>b\\<^sub>h. \n           let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h, \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb, \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\\<R>\\<^sub>s\\<^sub>b\\<^sub>h) = ts\\<^sub>s\\<^sub>b\\<^sub>h!i;\n               execs = takeWhile (Not \\<circ> is_volatile_Write\\<^sub>s\\<^sub>b) sb;\n               suspends = dropWhile (Not \\<circ> is_volatile_Write\\<^sub>s\\<^sub>b) sb\n            in  \\<exists>is \\<D>. instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h = is @ prog_instrs suspends \\<and>\n                    \\<D>\\<^sub>s\\<^sub>b\\<^sub>h = (\\<D> \\<or> outstanding_refs is_volatile_Write\\<^sub>s\\<^sub>b sb \\<noteq> {}) \\<and>\n                ts!i = (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, \n                        is,\n                        \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |` (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),(),\n                        \\<D>,  \n                        acquired True execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n                        release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\n   \\<rbrakk> \n    \\<Longrightarrow> \n     (ts\\<^sub>s\\<^sub>b\\<^sub>h,m\\<^sub>s\\<^sub>b\\<^sub>h,\\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts,m,\\<S>)\"", "lemma  AssignAddr':\n  \"\\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop; a'=Tmp (eval_expr t a); t'= t + used_tmps a; is=issue_expr t a \\<rbrakk> \\<Longrightarrow>\n   \\<theta>\\<turnstile> (Assign volatile a e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((Assign volatile a' e A L R W, t'),is)\"", "lemma  Assign':\n  \"\\<lbrakk>D \\<subseteq> dom \\<theta>; is= issue_expr t e@[Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\\<rbrakk> \\<Longrightarrow> \n   \\<theta>\\<turnstile> (Assign volatile (Tmp (D,a)) e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((Skip, t + used_tmps e), is)\"", "lemma CASAddr':\n  \"\\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop; a'=(Tmp (eval_expr t a));t'=t + used_tmps a; is=issue_expr t a \\<rbrakk> \\<Longrightarrow>\n   \\<theta>\\<turnstile> (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((CAS a' c\\<^sub>e s\\<^sub>e A L R W, t'), is)\"", "lemma CASComp':\n  \"\\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;c\\<^sub>e'=(Tmp (eval_expr t c\\<^sub>e));t'=t + used_tmps c\\<^sub>e; is= issue_expr t c\\<^sub>e \\<rbrakk> \\<Longrightarrow>\n   \\<theta>\\<turnstile> (CAS (Tmp a) c\\<^sub>e s\\<^sub>e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((CAS (Tmp a) c\\<^sub>e' s\\<^sub>e A L R W, t'), is)\"", "lemma CAS':\n  \"\\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>; D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e  = (D,f);t'=(t + used_tmps s\\<^sub>e); \n   cond = (\\<lambda>\\<theta>. the (\\<theta> t') = c \\<theta>);\n   ret = (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1);\n   is = issue_expr t s\\<^sub>e@\n           [RMW (a \\<theta>) t' (D,f) cond ret \n            (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>) ]\\<rbrakk>  \n   \\<Longrightarrow>\n   \\<theta>\\<turnstile> (CAS (Tmp (D\\<^sub>a,a)) (Tmp (D\\<^sub>c,c)) s\\<^sub>e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((Skip, Suc t'),is )\"", "lemma SCond':\n  \"\\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow> e'= (Tmp (eval_expr t e)) \\<Longrightarrow> t'=t + used_tmps e \\<Longrightarrow> is=issue_expr t e\n   \\<Longrightarrow>\n   \\<theta>\\<turnstile> (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<rightarrow>\\<^sub>s \n    ((Cond e' s\\<^sub>1 s\\<^sub>2, t'), is)\"", "lemma SWhile':\n  \"s'= (Cond e (Seq s (While e s)) Skip) \\<Longrightarrow>\n   \\<theta>\\<turnstile> (While e s, t) \\<rightarrow>\\<^sub>s ((s', t),[])\"", "theorem (in xvalid_program) simulation_hol:\n  \"(ts\\<^sub>s\\<^sub>b\\<^sub>h,m\\<^sub>s\\<^sub>b\\<^sub>h,\\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (ts\\<^sub>s\\<^sub>b\\<^sub>h',m\\<^sub>s\\<^sub>b\\<^sub>h',\\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<and>\n   (ts\\<^sub>s\\<^sub>b\\<^sub>h,m\\<^sub>s\\<^sub>b\\<^sub>h,\\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts,m,\\<S>) \\<and> safe_reach_direct safe_delayed (ts, m, \\<S>) \\<and>\n   invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h m\\<^sub>s\\<^sub>b\\<^sub>h \\<longrightarrow>\n  invariant ts\\<^sub>s\\<^sub>b\\<^sub>h' \\<S>\\<^sub>s\\<^sub>b\\<^sub>h' m\\<^sub>s\\<^sub>b\\<^sub>h' \\<and>\n           (\\<exists>ts' \\<S>' m'. (ts,m,\\<S>) \\<Rightarrow>\\<^sub>d\\<^sup>* (ts',m',\\<S>') \\<and> (ts\\<^sub>s\\<^sub>b\\<^sub>h',m\\<^sub>s\\<^sub>b\\<^sub>h',\\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<sim> (ts',m',\\<S>'))\"", "theorem (in xvalid_program_progress) store_buffer_execution_result_sequential_consistent'_hol:\n\"(ts\\<^sub>s\\<^sub>b,m,x) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sup>* (ts\\<^sub>s\\<^sub>b',m',x') \\<and>\nempty_store_buffers ts\\<^sub>s\\<^sub>b' \\<and>\nts\\<^sub>s\\<^sub>b \\<sim>\\<^sub>d ts \\<and>\ninitial\\<^sub>v ts \\<S> valid \\<and>\nsafe_reach_virtual safe_free_flowing (ts,m,\\<S>) \n\\<longrightarrow>\n(\\<exists>ts' \\<S>'. \n          (ts,m,\\<S>) \\<Rightarrow>\\<^sub>v\\<^sup>* (ts',m',\\<S>') \\<and> ts\\<^sub>s\\<^sub>b' \\<sim>\\<^sub>d ts')\""], "translations": [["", "lemma restrict_map_inverse: \"m |` (dom m - X) = m |`(-X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` (dom m - X) = m |` (- X)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (m |` (dom m - X)) x = (m |` (- X)) x", "apply (auto simp add: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conj_assoc: \"((P \\<and> Q) \\<and> X) = (P \\<and> Q \\<and> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<and> Q) \\<and> X) = (P \\<and> Q \\<and> X)", "by simp"], ["", "(* Constructor markup for some datatypes *)\n(* instr *)"], ["", "notation (latex output)\nRead (\"\\<^latex>\\<open>\\\\constructor{Read}\\<close>\")"], ["", "notation (latex output)\nWrite (\"\\<^latex>\\<open>\\\\constructor{Write}\\<close>\")"], ["", "notation (latex output)\nRMW (\"\\<^latex>\\<open>\\\\constructor{RMW}\\<close>\")"], ["", "notation (latex output)\nFence (\"\\<^latex>\\<open>\\\\constructor{Fence}\\<close>\")"], ["", "notation (latex output)\nGhost (\"\\<^latex>\\<open>\\\\constructor{Ghost}\\<close>\")"], ["", "(* memref *)"], ["", "notation (latex output)\nWrite\\<^sub>s\\<^sub>b (\"\\<^latex>\\<open>\\\\constructor{Write}\\<close>\\<^sub>s\\<^sub>b\")"], ["", "notation (latex output)\nRead\\<^sub>s\\<^sub>b (\"\\<^latex>\\<open>\\\\constructor{Read}\\<close>\\<^sub>s\\<^sub>b\")"], ["", "notation (latex output)\nProg\\<^sub>s\\<^sub>b (\"\\<^latex>\\<open>\\\\constructor{Prog}\\<close>\\<^sub>s\\<^sub>b\")"], ["", "notation (latex output)\nGhost\\<^sub>s\\<^sub>b (\"\\<^latex>\\<open>\\\\constructor{Ghost}\\<close>\\<^sub>s\\<^sub>b\")"], ["", "(* expr *)"], ["", "notation (latex output)\nConst (\"\\<^latex>\\<open>\\\\constructor{Const}\\<close>\")"], ["", "notation (latex output)\nMem (\"\\<^latex>\\<open>\\\\constructor{Mem}\\<close>\")"], ["", "notation (latex output)\nTmp (\"\\<^latex>\\<open>\\\\constructor{Tmp}\\<close>\")"], ["", "notation (latex output)\nUnop (\"\\<^latex>\\<open>\\\\constructor{Unop}\\<close>\")"], ["", "notation (latex output)\nBinop (\"\\<^latex>\\<open>\\\\constructor{Binop}\\<close>\")"], ["", "(* stmt *)"], ["", "notation (latex output)\nSkip (\"\\<^latex>\\<open>\\\\constructor{Skip}\\<close>\")"], ["", "notation (latex output)\nAssign (\"\\<^latex>\\<open>\\\\constructor{Assign}\\<close>\")"], ["", "notation (latex output)\nCAS (\"\\<^latex>\\<open>\\\\constructor{CAS}\\<close>\")"], ["", "notation (latex output)\nSeq (\"\\<^latex>\\<open>\\\\constructor{Seq}\\<close>\")"], ["", "notation (latex output)\nCond (\"\\<^latex>\\<open>\\\\constructor{Cond}\\<close>\")"], ["", "notation (latex output)\nWhile (\"\\<^latex>\\<open>\\\\constructor{While}\\<close>\")"], ["", "notation (latex output)\nSGhost (\"\\<^latex>\\<open>\\\\constructor{SGhost}\\<close>\")"], ["", "notation (latex output)\nSFence (\"\\<^latex>\\<open>\\\\constructor{SFence}\\<close>\")"], ["", "lemma sim_direct_config_def': \"ts\\<^sub>s\\<^sub>b \\<sim>\\<^sub>d ts \\<equiv>\n(ts\\<^sub>s\\<^sub>b = (map (\\<lambda>(p,is, \\<theta>,sb::unit,\\<D>, \\<O>,\\<R>). (p,is,\\<theta>,[],(),(),())) ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts\\<^sub>s\\<^sub>b \\<sim> ts  \\<equiv>\n    ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts", "apply (rule HOL.eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ts\\<^sub>s\\<^sub>b \\<sim> ts  =\n    (ts\\<^sub>s\\<^sub>b =\n     map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n             (p, is, \\<theta>, []))\n      ts)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. ts\\<^sub>s\\<^sub>b \\<sim> ts  \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply  (erule sim_direct_config.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tsa ts\\<^sub>d.\n       \\<lbrakk>ts\\<^sub>s\\<^sub>b = tsa; ts = ts\\<^sub>d;\n        length tsa = length ts\\<^sub>d;\n        \\<forall>i<length tsa.\n           \\<exists>\\<O>' \\<D>' \\<R>'.\n              let (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) = ts\\<^sub>d ! i\n              in tsa ! i =\n                 (p, is, \\<theta>, [], \\<D>', \\<O>', \\<R>')\\<rbrakk>\n       \\<Longrightarrow> ts\\<^sub>s\\<^sub>b =\n                         map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>,\n                                 \\<R>). (p, is, \\<theta>, []))\n                          ts\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply  (clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length ts\\<^sub>s\\<^sub>b = length ts;\n     \\<forall>i<length ts.\n        case ts ! i of\n        (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) \\<Rightarrow>\n          ts\\<^sub>s\\<^sub>b ! i = (p, is, \\<theta>, [])\\<rbrakk>\n    \\<Longrightarrow> ts\\<^sub>s\\<^sub>b =\n                      map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n                              (p, is, \\<theta>, []))\n                       ts\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply  (rule nth_equalityI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length ts\\<^sub>s\\<^sub>b = length ts;\n     \\<forall>i<length ts.\n        case ts ! i of\n        (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) \\<Rightarrow>\n          ts\\<^sub>s\\<^sub>b ! i = (p, is, \\<theta>, [])\\<rbrakk>\n    \\<Longrightarrow> length ts\\<^sub>s\\<^sub>b =\n                      length\n                       (map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>,\n                                \\<R>). (p, is, \\<theta>, []))\n                         ts)\n 2. \\<And>i.\n       \\<lbrakk>length ts\\<^sub>s\\<^sub>b = length ts;\n        \\<forall>i<length ts.\n           case ts ! i of\n           (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) \\<Rightarrow>\n             ts\\<^sub>s\\<^sub>b ! i = (p, is, \\<theta>, []);\n        i < length ts\\<^sub>s\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> ts\\<^sub>s\\<^sub>b ! i =\n                         map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>,\n                                 \\<R>). (p, is, \\<theta>, []))\n                          ts !\n                         i\n 3. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length ts\\<^sub>s\\<^sub>b = length ts;\n        \\<forall>i<length ts.\n           case ts ! i of\n           (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) \\<Rightarrow>\n             ts\\<^sub>s\\<^sub>b ! i = (p, is, \\<theta>, []);\n        i < length ts\\<^sub>s\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> ts\\<^sub>s\\<^sub>b ! i =\n                         map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>,\n                                 \\<R>). (p, is, \\<theta>, []))\n                          ts !\n                         i\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length ts\\<^sub>s\\<^sub>b = length ts;\n        \\<forall>i<length ts.\n           case ts ! i of\n           (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) \\<Rightarrow>\n             ts\\<^sub>s\\<^sub>b ! i = (p, is, \\<theta>, []);\n        i < length ts\\<rbrakk>\n       \\<Longrightarrow> ts\\<^sub>s\\<^sub>b ! i =\n                         (case ts ! i of\n                          (p, is, \\<theta>, sb, \\<D>, \\<O>,\n                           \\<R>) \\<Rightarrow>\n                            (p, is, \\<theta>, []))\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply  (case_tac \"ts!i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i a b c d e f g.\n       \\<lbrakk>length ts\\<^sub>s\\<^sub>b = length ts;\n        \\<forall>i<length ts.\n           case ts ! i of\n           (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) \\<Rightarrow>\n             ts\\<^sub>s\\<^sub>b ! i = (p, is, \\<theta>, []);\n        i < length ts; ts ! i = (a, b, c, d, e, f, g)\\<rbrakk>\n       \\<Longrightarrow> ts\\<^sub>s\\<^sub>b ! i =\n                         (case ts ! i of\n                          (p, is, \\<theta>, sb, \\<D>, \\<O>,\n                           \\<R>) \\<Rightarrow>\n                            (p, is, \\<theta>, []))\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts", "apply (rule sim_direct_config.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    length ts\\<^sub>s\\<^sub>b = length ts\n 2. ts\\<^sub>s\\<^sub>b =\n    map (\\<lambda>(p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>).\n            (p, is, \\<theta>, []))\n     ts \\<Longrightarrow>\n    \\<forall>i<length ts\\<^sub>s\\<^sub>b.\n       \\<exists>\\<O>' \\<D>' \\<R>'.\n          let (p, is, \\<theta>, sb, \\<D>, \\<O>, \\<R>) = ts ! i\n          in ts\\<^sub>s\\<^sub>b ! i =\n             (p, is, \\<theta>, [], \\<D>', \\<O>', \\<R>')", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "ML \\<open>@{term \"(\\<lambda>(p,is, \\<theta>,sb::unit,\\<D>, \\<O>,\\<R>). (p,is,\\<theta>,[],(),(),()))\"}\\<close>"], ["", "lemma DRead: \"(Read volatile a t # is,\\<theta>, x, m,ghst) \\<rightarrow>\n               (is, \\<theta> (t\\<mapsto>m a), x, m, ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Read volatile a t # is, \\<theta>, x, m,\n     ghst) \\<rightarrow> (is, \\<theta>(t \\<mapsto> m a), x, m, ghst)", "apply (cases ghst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       ghst = (aa, b, c, d) \\<Longrightarrow>\n       (Read volatile a t # is, \\<theta>, x, m,\n        ghst) \\<rightarrow> (is, \\<theta>(t \\<mapsto> m a), x, m, ghst)", "apply (simp add: direct_memop_step.Read)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DWriteNonVolatile:\"\n  (Write False a (D,f) A L R W#is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>, x, m(a := f \\<theta>), ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Write False a (D, f) A L R W # is, \\<theta>, x, m,\n     ghst) \\<rightarrow> (is, \\<theta>, x, m(a := f \\<theta>), ghst)", "apply (cases ghst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       ghst = (aa, b, c, d) \\<Longrightarrow>\n       (Write False a (D, f) A L R W # is, \\<theta>, x, m,\n        ghst) \\<rightarrow> (is, \\<theta>, x, m(a := f \\<theta>), ghst)", "apply (simp add: direct_memop_step.WriteNonVolatile)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DWriteVolatile:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (True, \\<O> \\<union> A - R, Map.empty, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \n   \\<Longrightarrow> (Write True a (D,f) A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>,  x, m(a:=f \\<theta>), ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (True, \\<O> \\<union> A - R, Map.empty,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (Write True a (D, f) A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow> (is, \\<theta>, x, m\n      (a := f \\<theta>), ghst')", "by (simp add: direct_memop_step.WriteVolatile)"], ["", "lemma DGhost:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (\\<D>, \\<O> \\<union> A - R, augment_rels (dom \\<S>) R \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \n   \\<Longrightarrow> (Ghost A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>,  x, m, ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (\\<D>, \\<O> \\<union> A - R, aug (dom \\<S>) R \\<R>,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (Ghost A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow> (is, \\<theta>, x, m, ghst')", "by (simp add: direct_memop_step.Ghost)"], ["", "lemma DRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst'=(False, \\<O>, Map.empty,\\<S>)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W # is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>(t\\<mapsto>m a),x,m, ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' = (False, \\<O>, Map.empty, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow> (is, \\<theta>(t \\<mapsto> m a),\n      x, m, ghst')", "apply (simp add: direct_memop_step.RMWReadOnly)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \n    \\<theta>' = \\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));\n    m' = m(a:= f(\\<theta>(t\\<mapsto>m a)));\n    ghst = (\\<D>, \\<O>, \\<R>, \\<S>); \n   ghst' = (False,\\<O> \\<union> A - R, Map.empty, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \n   \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow> (is, \\<theta>',x, m' , ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<theta>' = \\<theta>(t \\<mapsto>\n     ret (m a) (f (\\<theta>(t \\<mapsto> m a))));\n     m' = m(a := f (\\<theta>(t \\<mapsto> m a)));\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (False, \\<O> \\<union> A - R, Map.empty,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow> (is, \\<theta>', x, m', ghst')", "apply (simp add: direct_memop_step.RMWWrite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma VRead: \"(Read volatile a t # is,\\<theta>, x, m,ghst) \\<rightarrow>\\<^sub>v\n               (is, \\<theta> (t\\<mapsto>m a), x, m, ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Read volatile a t # is, \\<theta>, x, m,\n     ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>(t \\<mapsto> m a), x, m, ghst)", "apply (cases ghst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       ghst = (aa, b, c, d) \\<Longrightarrow>\n       (Read volatile a t # is, \\<theta>, x, m,\n        ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>(t \\<mapsto> m a), x, m,\n                                     ghst)", "apply (simp add: virtual_memop_step.Read)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma VWriteNonVolatile:\"\n  (Write False a (D,f) A L R W#is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m(a := f \\<theta>), ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Write False a (D, f) A L R W # is, \\<theta>, x, m,\n     ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m(a := f \\<theta>), ghst)", "apply (cases ghst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       ghst = (aa, b, c, d) \\<Longrightarrow>\n       (Write False a (D, f) A L R W # is, \\<theta>, x, m,\n        ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m(a := f \\<theta>),\n                                     ghst)", "apply (simp add: virtual_memop_step.WriteNonVolatile)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma VWriteVolatile:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (True, \\<O> \\<union> A - R, \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L) \n   \\<Longrightarrow> (Write True a (D,f) A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>,  x, m(a:=f \\<theta>), ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (True, \\<O> \\<union> A - R, \\<R>,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (Write True a (D, f) A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m\n              (a := f \\<theta>), ghst')", "by (simp add: virtual_memop_step.WriteVolatile)"], ["", "lemma VRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst'=(False, \\<O>,\\<R>,\\<S>)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W # is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>(t\\<mapsto>m a),x,m, ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' = (False, \\<O>, \\<R>, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>(t \\<mapsto>\n              m a), x, m, ghst')", "apply (simp add: virtual_memop_step.RMWReadOnly)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma VFence:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (False, \\<O>, \\<R>, \\<S>) \n   \\<Longrightarrow> (Fence# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>,  x, m, ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' = (False, \\<O>, \\<R>, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> (Fence # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m,\n              ghst')", "by (simp add: virtual_memop_step.Fence)"], ["", "lemma VGhost:\n  \"ghst = (\\<D>, \\<O>, \\<R>, \\<S>) \\<Longrightarrow> ghst' = (\\<D>, \\<O> \\<union> A - R, \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)  \n   \\<Longrightarrow> (Ghost A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>,  x, m, ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (\\<D>, \\<O> \\<union> A - R, \\<R>,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (Ghost A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>, x, m,\n              ghst')", "by (simp add: virtual_memop_step.Ghost)"], ["", "lemma VRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \n    \\<theta>' = \\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));\n    m' = m(a:= f(\\<theta>(t\\<mapsto>m a)));\n    ghst = (\\<D>, \\<O>, \\<R>, \\<S>); \n   ghst' = (False,\\<O> \\<union> A - R, \\<R>, \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \n   \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, x, m, ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>',x, m' , ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<theta>' = \\<theta>(t \\<mapsto>\n     ret (m a) (f (\\<theta>(t \\<mapsto> m a))));\n     m' = m(a := f (\\<theta>(t \\<mapsto> m a)));\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (False, \\<O> \\<union> A - R, \\<R>,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, x, m,\n                       ghst) \\<rightarrow>\\<^sub>v (is, \\<theta>', x, m',\n              ghst')", "apply (simp add: virtual_memop_step.RMWWrite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SafeWriteVolatile:\n  \"\\<lbrakk>\\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> \\<O>s!j; a \\<notin> read_only \\<S>;    \n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow>  A \\<inter>  \\<O>s!j = {};\n    A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n   \\<rbrakk>\n   \\<Longrightarrow> \n   \\<O>s,i\\<turnstile>(Write True a (D,f) A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<O>s,i\\<turnstile> (Write True a (D, f) A L R W # is,\n     \\<theta>, m, \\<D>, \\<O>, \\<S>) \\<surd>", "apply (rule safe_direct_memop_state.WriteVolatile)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j\n 2. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> dom \\<S> \\<union> \\<O>\n 3. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> L \\<subseteq> A\n 4. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> R \\<subseteq> \\<O>\n 5. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> R = _emptyset\n 6. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         A \\<inter> \\<O>s ! j = _emptyset\n 7. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> read_only \\<S>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SafeDelayedWriteVolatile:\n  \"\\<lbrakk>\\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> (\\<O>s!j \\<union> dom (\\<R>s!j)); a \\<notin> read_only \\<S>;\n  \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow>  A \\<inter>  (\\<O>s!j \\<union> dom (\\<R>s!j)) = {};\n    A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n   \\<rbrakk>\n   \\<Longrightarrow> \n   \\<O>s,\\<R>s,i\\<turnstile>(Write True a (D,f) A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<O>s,\\<R>s,i\\<turnstile> (Write True a (D, f) A L R\n            W #\n           is,\n           \\<theta>, m, \\<D>, \\<O>, \\<S>) \\<surd>", "apply (rule safe_delayed_direct_memop_state.WriteVolatile)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j)\n 2. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> dom \\<S> \\<union> \\<O>\n 3. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> L \\<subseteq> A\n 4. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> R \\<subseteq> \\<O>\n 5. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> R = _emptyset\n 6. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) =\n                         _emptyset\n 7. \\<lbrakk>\\<forall>j<length \\<O>s.\n                i \\<noteq> j \\<longrightarrow>\n                a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> read_only \\<S>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SafeRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); a \\<in> dom \\<S> \\<union> \\<O>\\<rbrakk> \\<Longrightarrow> \n   \\<O>s,i\\<turnstile> (RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>\\<rbrakk>\n    \\<Longrightarrow> \\<O>s,i\\<turnstile> (RMW a t (D, f) cond ret A L R W #\n     is,\n     \\<theta>, m, \\<D>, \\<O>, \\<S>) \\<surd>", "apply (rule safe_direct_memop_state.RMWReadOnly)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>\\<rbrakk>\n    \\<Longrightarrow> \\<not> cond (\\<theta>(t \\<mapsto> m a))\n 2. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>\\<rbrakk>\n    \\<Longrightarrow> a \\<in> \\<O> \\<or> a \\<in> dom \\<S>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SafeDelayedRMWReadOnly:\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); a \\<in> dom \\<S> \\<union> \\<O>; \n   \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> (\\<R>s!j) a \\<noteq> Some False \\<comment> \\<open>no release of unshared address\\<close>\\<rbrakk>\n   \\<Longrightarrow> \n   \\<O>s,\\<R>s,i\\<turnstile>(RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        (\\<R>s ! j) a \\<noteq> Some False\\<rbrakk>\n    \\<Longrightarrow> \\<O>s,\\<R>s,i\\<turnstile> (RMW a t (D, f) cond ret A L\n            R W #\n           is,\n           \\<theta>, m, \\<D>, \\<O>, \\<S>) \\<surd>", "apply (rule safe_delayed_direct_memop_state.RMWReadOnly)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        (\\<R>s ! j) a \\<noteq> Some False\\<rbrakk>\n    \\<Longrightarrow> \\<not> cond (\\<theta>(t \\<mapsto> m a))\n 2. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        (\\<R>s ! j) a \\<noteq> Some False\\<rbrakk>\n    \\<Longrightarrow> a \\<in> \\<O> \\<or> a \\<in> dom \\<S>\n 3. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        (\\<R>s ! j) a \\<noteq> Some False\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         (\\<R>s ! j) a \\<noteq> Some False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SafeRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a));  \n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> \\<O>s!j; a \\<notin> read_only \\<S>;\n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> A \\<inter> \\<O>s!j  = {};    \n    A \\<subseteq>  \\<O> \\<union> dom \\<S>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n    \\<rbrakk> \n   \\<Longrightarrow> \n   \\<O>s,i\\<turnstile> (RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<O>s,i\\<turnstile> (RMW a t (D, f) cond ret A L R W #\n     is,\n     \\<theta>, m, \\<D>, \\<O>, \\<S>) \\<surd>", "apply (rule safe_direct_memop_state.RMWWrite)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> cond (\\<theta>(t \\<mapsto> m a))\n 2. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j\n 3. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> dom \\<S> \\<union> \\<O>\n 4. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> L \\<subseteq> A\n 5. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> R \\<subseteq> \\<O>\n 6. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> R = _emptyset\n 7. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         A \\<inter> \\<O>s ! j = _emptyset\n 8. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> a \\<notin> \\<O>s ! j;\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow> A \\<inter> \\<O>s ! j = _emptyset;\n     A \\<subseteq> \\<O> \\<union> dom \\<S>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> read_only \\<S>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SafeDelayedRMWWrite:\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); a \\<in> dom \\<S> \\<union> \\<O>;  \n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> a \\<notin> (\\<O>s!j \\<union> dom (\\<R>s!j));a \\<notin> read_only \\<S>;\n    \\<forall>j < length \\<O>s. i\\<noteq>j \\<longrightarrow> A \\<inter> (\\<O>s!j \\<union> dom (\\<R>s!j))  = {};\n    A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A; R \\<subseteq> \\<O>; A \\<inter> R = {}\n    \\<rbrakk> \n   \\<Longrightarrow> \n   \\<O>s,\\<R>s,i\\<turnstile>(RMW a t (D,f) cond ret A L R W# is, \\<theta>, m, \\<D>, \\<O>, \\<S>)\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<O>s,\\<R>s,i\\<turnstile> (RMW a t (D, f) cond ret A L\n            R W #\n           is,\n           \\<theta>, m, \\<D>, \\<O>, \\<S>) \\<surd>", "apply (rule safe_delayed_direct_memop_state.RMWWrite)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> cond (\\<theta>(t \\<mapsto> m a))\n 2. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> a \\<in> \\<O> \\<or> a \\<in> dom \\<S>\n 3. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j)\n 4. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> dom \\<S> \\<union> \\<O>\n 5. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> L \\<subseteq> A\n 6. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> R \\<subseteq> \\<O>\n 7. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> R = _emptyset\n 8. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length \\<O>s.\n                         i \\<noteq> j \\<longrightarrow>\n                         A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) =\n                         _emptyset\n 9. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     a \\<in> dom \\<S> \\<union> \\<O>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        a \\<notin> \\<O>s ! j \\<union> dom (\\<R>s ! j);\n     a \\<notin> read_only \\<S>;\n     \\<forall>j<length \\<O>s.\n        i \\<noteq> j \\<longrightarrow>\n        A \\<inter> (\\<O>s ! j \\<union> dom (\\<R>s ! j)) = _emptyset;\n     A \\<subseteq> dom \\<S> \\<union> \\<O>; L \\<subseteq> A;\n     R \\<subseteq> \\<O>; A \\<inter> R = _emptyset\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> read_only \\<S>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  Write\\<^sub>s\\<^sub>bNonVolatile: \n  \"(m, Write\\<^sub>s\\<^sub>b False a sop v A L R W# rs,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m(a := v), rs,\\<O>,\\<R>,\\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, Write\\<^sub>s\\<^sub>b False a sop v A L R W # rs, \\<O>, \\<R>,\n     \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (m(a := v), rs, \\<O>, \\<R>,\n            \\<S>)", "apply (rule flush_step.Write\\<^sub>s\\<^sub>b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<O> = (if False then \\<O> \\<union> A - R else \\<O>)\n 2. \\<S> =\n    (if False\n     then \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\n     else \\<S>)\n 3. \\<R> = (if False then Map.empty else \\<R>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Write\\<^sub>s\\<^sub>bVolatile: \n\"\\<lbrakk>\\<O>'= \\<O> \\<union> A - R;  \\<S>'=(\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \\<Longrightarrow>\n  (m, Write\\<^sub>s\\<^sub>b True a sop v A L R W# rs,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m(a := v), rs,\\<O>',Map.empty,\\<S>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<O>' = \\<O> \\<union> A - R;\n     \\<S>' =\n     \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk>\n    \\<Longrightarrow> (m, Write\\<^sub>s\\<^sub>b True a sop v A L R W # rs,\n                       \\<O>, \\<R>,\n                       \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (m\n                              (a := v), rs, \\<O>', Map.empty, \\<S>')", "apply (rule flush_step.Write\\<^sub>s\\<^sub>b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<O>' = \\<O> \\<union> A - R;\n     \\<S>' =\n     \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk>\n    \\<Longrightarrow> \\<O>' = (if True then \\<O> \\<union> A - R else \\<O>)\n 2. \\<lbrakk>\\<O>' = \\<O> \\<union> A - R;\n     \\<S>' =\n     \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk>\n    \\<Longrightarrow> \\<S>' =\n                      (if True\n                       then \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\n                       else \\<S>)\n 3. \\<lbrakk>\\<O>' = \\<O> \\<union> A - R;\n     \\<S>' =\n     \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk>\n    \\<Longrightarrow> Map.empty = (if True then Map.empty else \\<R>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Ghost\\<^sub>s\\<^sub>b: \"\\<lbrakk>\\<O>'= \\<O> \\<union> A - R; \\<R>'= augment_rels (dom \\<S>) R \\<R>; \\<S>'=\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk> \\<Longrightarrow> \n             (m, Ghost\\<^sub>s\\<^sub>b A L R W# rs,\\<O>,\\<R>,\\<S>) \\<rightarrow>\\<^sub>f (m, rs,\\<O>',\\<R>',\\<S>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<O>' = \\<O> \\<union> A - R; \\<R>' = aug (dom \\<S>) R \\<R>;\n     \\<S>' =\n     \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L\\<rbrakk>\n    \\<Longrightarrow> (m, Ghost\\<^sub>s\\<^sub>b A L R W # rs, \\<O>, \\<R>,\n                       \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (m, rs,\n                              \\<O>', \\<R>', \\<S>')", "by (simp add: flush_step.Ghost)"], ["", "lemma  SBHRead: \n  \"\\<lbrakk>v = (case (buffered_val sb a) of Some v' \\<Rightarrow> v' | None \\<Rightarrow> m a);\n   sb' = sb@[Read\\<^sub>s\\<^sub>b volatile a t v] \\<rbrakk>\n   \\<Longrightarrow>\n   (Read volatile a t # is, \\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is, \\<theta> (t\\<mapsto>v), sb', m,ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v =\n             (case buffered_val sb a of None \\<Rightarrow> m a\n              | Some v' \\<Rightarrow> v');\n     sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v]\\<rbrakk>\n    \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                       ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                              \\<theta>(t \\<mapsto> v), sb', m, ghst)", "apply (cases ghst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       \\<lbrakk>v =\n                (case buffered_val sb a of None \\<Rightarrow> m a\n                 | Some v' \\<Rightarrow> v');\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v];\n        ghst = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                          ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                                 \\<theta>(t \\<mapsto> v), sb', m, ghst)", "apply (cases \"buffered_val sb a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c d.\n       \\<lbrakk>v =\n                (case buffered_val sb a of None \\<Rightarrow> m a\n                 | Some v' \\<Rightarrow> v');\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v];\n        ghst = (aa, b, c, d); buffered_val sb a = None\\<rbrakk>\n       \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                          ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                                 \\<theta>(t \\<mapsto> v), sb', m, ghst)\n 2. \\<And>aa b c d aaa.\n       \\<lbrakk>v =\n                (case buffered_val sb a of None \\<Rightarrow> m a\n                 | Some v' \\<Rightarrow> v');\n        sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v];\n        ghst = (aa, b, c, d); buffered_val sb a = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                          ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                                 \\<theta>(t \\<mapsto> v), sb', m, ghst)", "apply (auto simp add: SBHReadBuffered SBHReadUnbuffered)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  SBRead: \n  \"\\<lbrakk>v = (case (buffered_val sb a) of Some v' \\<Rightarrow> v' | None \\<Rightarrow> m a)\\<rbrakk>\n   \\<Longrightarrow>\n   (Read volatile a t # is, \\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n          (is, \\<theta> (t\\<mapsto>v), sb, m,ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v =\n    (case buffered_val sb a of None \\<Rightarrow> m a\n     | Some v' \\<Rightarrow> v') \\<Longrightarrow>\n    (Read volatile a t # is, \\<theta>, sb, m,\n     ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>(t \\<mapsto> v), sb,\n    m, ghst)", "apply (cases ghst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       \\<lbrakk>v =\n                (case buffered_val sb a of None \\<Rightarrow> m a\n                 | Some v' \\<Rightarrow> v');\n        ghst = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                          ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>\n                         (t \\<mapsto> v), sb, m, ghst)", "apply (cases \"buffered_val sb a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b c d.\n       \\<lbrakk>v =\n                (case buffered_val sb a of None \\<Rightarrow> m a\n                 | Some v' \\<Rightarrow> v');\n        ghst = (aa, b, c, d); buffered_val sb a = None\\<rbrakk>\n       \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                          ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>\n                         (t \\<mapsto> v), sb, m, ghst)\n 2. \\<And>aa b c d aaa.\n       \\<lbrakk>v =\n                (case buffered_val sb a of None \\<Rightarrow> m a\n                 | Some v' \\<Rightarrow> v');\n        ghst = (aa, b, c, d); buffered_val sb a = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m,\n                          ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>\n                         (t \\<mapsto> v), sb, m, ghst)", "apply (auto simp add: SBReadBuffered SBReadUnbuffered)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  SBHReadBuffered': \n  \"\\<lbrakk>buffered_val sb a = Some v;\n   sb' = sb@[Read\\<^sub>s\\<^sub>b volatile a t v] \\<rbrakk>\n   \\<Longrightarrow>\n   (Read volatile a t # is, \\<theta>, sb, m, \\<D>, \\<O>,\\<R>, \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is, \\<theta> (t\\<mapsto>v), sb', m, \\<D>, \\<O>,\\<R>, \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>buffered_val sb a = Some v;\n     sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t v]\\<rbrakk>\n    \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m, \\<D>, \\<O>,\n                       \\<R>,\n                       \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                              \\<theta>(t \\<mapsto> v), sb', m, \\<D>, \\<O>,\n                              \\<R>, \\<S>)", "by (simp add: SBHReadBuffered)"], ["", "lemma SBHReadUnbuffered': \n  \"\\<lbrakk>buffered_val sb a = None;\n    sb' = sb@[Read\\<^sub>s\\<^sub>b volatile a t (m a)]\\<rbrakk> \n   \\<Longrightarrow>\n   (Read volatile a t # is,\\<theta>, sb, m, \\<D>, \\<O>,\\<R>, \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is,\\<theta> (t\\<mapsto>m a), sb', m, \\<D>, \\<O>,\\<R>, \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>buffered_val sb a = None;\n     sb' = sb @ [Read\\<^sub>s\\<^sub>b volatile a t (m a)]\\<rbrakk>\n    \\<Longrightarrow> (Read volatile a t # is, \\<theta>, sb, m, \\<D>, \\<O>,\n                       \\<R>,\n                       \\<S>) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                              \\<theta>(t \\<mapsto> m a), sb', m, \\<D>, \\<O>,\n                              \\<R>, \\<S>)", "by (simp add: SBHReadUnbuffered)"], ["", "lemma SBHWriteNonVolatile':\n  \"\\<lbrakk> sb'= sb@ [Write\\<^sub>s\\<^sub>b False a (D,f) (f \\<theta>) A L R W]\\<rbrakk> \n   \\<Longrightarrow>\n   (Write False a (D,f) A L R W#is,\\<theta>, sb, m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n          (is, \\<theta>, sb', m, ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sb' =\n    sb @\n    [Write\\<^sub>s\\<^sub>b False a (D, f) (f \\<theta>) A L R\n      W] \\<Longrightarrow>\n    (Write False a (D, f) A L R W # is, \\<theta>, sb, m,\n     ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is, \\<theta>, sb', m,\n            ghst)", "by (cases ghst) (simp add: SBHWriteNonVolatile)"], ["", "lemma SBWriteNonVolatile':\n  \"\\<lbrakk> sb'= sb@ [Write\\<^sub>s\\<^sub>b False a (D,f) (f \\<theta>) A L R W]\\<rbrakk> \n   \\<Longrightarrow>\n   (Write False a (D,f) A L R W#is,\\<theta>, sb, m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n          (is, \\<theta>, sb', m, ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sb' =\n    sb @\n    [Write\\<^sub>s\\<^sub>b False a (D, f) (f \\<theta>) A L R\n      W] \\<Longrightarrow>\n    (Write False a (D, f) A L R W # is, \\<theta>, sb, m,\n     ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>, sb', m, ghst)", "by (cases ghst) (simp add: SBWriteNonVolatile)"], ["", "lemma SBHWriteVolatile':\n  \"\\<lbrakk>sb'= sb@[Write\\<^sub>s\\<^sub>b True a (D,f) (f \\<theta>) A L R W]; ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst' = (True, \\<O>,\\<R>, \\<S>)\\<rbrakk>\n   \\<Longrightarrow> \n   (Write True a (D,f) A L R W# is,\\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n         (is,\\<theta>, sb', m,ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sb' =\n             sb @\n             [Write\\<^sub>s\\<^sub>b True a (D, f) (f \\<theta>) A L R W];\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' = (True, \\<O>, \\<R>, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> (Write True a (D, f) A L R W # is, \\<theta>, sb, m,\n                       ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                              \\<theta>, sb', m, ghst')", "by (simp add: SBHWriteVolatile)"], ["", "lemma SBHGhost':\n  \"(Ghost A L R W# is, \\<theta>, sb, m, G) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n         (is, \\<theta>, sb@[Ghost\\<^sub>s\\<^sub>b A L R W], m, G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ghost A L R W # is, \\<theta>, sb, m,\n     G) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is, \\<theta>,\n         sb @ [Ghost\\<^sub>s\\<^sub>b A L R W], m, G)", "by (cases G) (simp add: SBHGhost)"], ["", "lemma SBWriteVolatile':\n  \"\\<lbrakk>sb'= sb@[Write\\<^sub>s\\<^sub>b True a (D,f) (f \\<theta>) A L R W]\\<rbrakk>\n   \\<Longrightarrow> \n   (Write True a (D,f) A L R W# is,\\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n         (is,\\<theta>, sb', m,ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sb' =\n    sb @\n    [Write\\<^sub>s\\<^sub>b True a (D, f) (f \\<theta>) A L R\n      W] \\<Longrightarrow>\n    (Write True a (D, f) A L R W # is, \\<theta>, sb, m,\n     ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>, sb', m, ghst)", "by (cases ghst) (simp add: SBWriteVolatile)"], ["", "lemma SBWrite':\n  \"\\<lbrakk>sb'= sb@[Write\\<^sub>s\\<^sub>b volatile a (D,f) (f \\<theta>) A L R W]\\<rbrakk>\n   \\<Longrightarrow> \n   (Write volatile a (D,f) A L R W# is,\\<theta>, sb, m,ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n         (is,\\<theta>, sb', m,ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sb' =\n    sb @\n    [Write\\<^sub>s\\<^sub>b volatile a (D, f) (f \\<theta>) A L R\n      W] \\<Longrightarrow>\n    (Write volatile a (D, f) A L R W # is, \\<theta>, sb, m,\n     ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>, sb', m, ghst)", "apply (cases volatile)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sb' =\n             sb @\n             [Write\\<^sub>s\\<^sub>b volatile a (D, f) (f \\<theta>) A L R W];\n     volatile\\<rbrakk>\n    \\<Longrightarrow> (Write volatile a (D, f) A L R W # is, \\<theta>, sb,\n                       m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>,\n                         sb', m, ghst)\n 2. \\<lbrakk>sb' =\n             sb @\n             [Write\\<^sub>s\\<^sub>b volatile a (D, f) (f \\<theta>) A L R W];\n     \\<not> volatile\\<rbrakk>\n    \\<Longrightarrow> (Write volatile a (D, f) A L R W # is, \\<theta>, sb,\n                       m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>,\n                         sb', m, ghst)", "apply (auto intro: SBWriteVolatile' SBWriteNonVolatile')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SBHRMWReadOnly':\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); ghst = (\\<D>, \\<O>, \\<R>, \\<S>); ghst' = (False, \\<O>, Map.empty,\\<S>)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is, \\<theta>(t\\<mapsto>m a),[], m, ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' = (False, \\<O>, Map.empty, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, [],\n                       m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                                 \\<theta>(t \\<mapsto> m a), [], m, ghst')", "by (simp add: SBHRMWReadOnly)"], ["", "lemma SBHRMWWrite':\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \\<theta>'=\\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));m'=m(a:= f(\\<theta>(t\\<mapsto>m a)));\n   ghst = (\\<D>, \\<O>,\\<R>, \\<S>); ghst'=(False, \\<O> \\<union> A - R, Map.empty,\\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h\n         (is, \\<theta>',[], m', ghst')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<theta>' = \\<theta>(t \\<mapsto>\n     ret (m a) (f (\\<theta>(t \\<mapsto> m a))));\n     m' = m(a := f (\\<theta>(t \\<mapsto> m a)));\n     ghst = (\\<D>, \\<O>, \\<R>, \\<S>);\n     ghst' =\n     (False, \\<O> \\<union> A - R, Map.empty,\n      \\<S> \\<oplus>\\<^bsub>W\\<^esub> R \\<ominus>\\<^bsub>A\\<^esub> L)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, [],\n                       m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (is,\n                                 \\<theta>', [], m', ghst')", "by (simp add: SBHRMWWrite)"], ["", "lemma SBRMWReadOnly':\n  \"\\<lbrakk>\\<not> cond (\\<theta>(t\\<mapsto>m a)); \\<theta>'=\\<theta>(t\\<mapsto>m a)\\<rbrakk> \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is, \\<theta>',[], m, ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cond (\\<theta>(t \\<mapsto> m a));\n     \\<theta>' = \\<theta>(t \\<mapsto> m a)\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, [],\n                       m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is,\n                         \\<theta>', [], m, ghst)", "by (cases ghst) (simp add: SBRMWReadOnly)"], ["", "lemma SBRMWWrite':\n  \"\\<lbrakk>cond (\\<theta>(t\\<mapsto>m a)); \\<theta>'=\\<theta>(t\\<mapsto>ret (m a) (f(\\<theta>(t\\<mapsto>m a))));m'=m(a:= f(\\<theta>(t\\<mapsto>m a)))\\<rbrakk> \n   \\<Longrightarrow> \n   (RMW a t (D,f) cond ret A L R W# is, \\<theta>, [], m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b\n         (is, \\<theta>',[], m', ghst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond (\\<theta>(t \\<mapsto> m a));\n     \\<theta>' = \\<theta>(t \\<mapsto>\n     ret (m a) (f (\\<theta>(t \\<mapsto> m a))));\n     m' = m(a := f (\\<theta>(t \\<mapsto> m a)))\\<rbrakk>\n    \\<Longrightarrow> (RMW a t (D, f) cond ret A L R W # is, \\<theta>, [],\n                       m, ghst) \\<rightarrow>\\<^sub>s\\<^sub>b (is,\n                         \\<theta>', [], m', ghst)", "by (cases ghst) (simp add: SBRMWWrite)"], ["", "lemma sim_config':\n  \"\\<lbrakk>m = flush_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h m\\<^sub>s\\<^sub>b\\<^sub>h;\n    \\<S> = share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n    length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts; \n    \\<forall>i < length ts\\<^sub>s\\<^sub>b\\<^sub>h. \n           let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h, \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb, \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\\<R>\\<^sub>s\\<^sub>b\\<^sub>h) = ts\\<^sub>s\\<^sub>b\\<^sub>h!i;\n               execs = takeWhile (Not \\<circ> is_volatile_Write\\<^sub>s\\<^sub>b) sb;\n               suspends = dropWhile (Not \\<circ> is_volatile_Write\\<^sub>s\\<^sub>b) sb\n            in  \\<exists>is \\<D>. instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h = is @ prog_instrs suspends \\<and>\n                    \\<D>\\<^sub>s\\<^sub>b\\<^sub>h = (\\<D> \\<or> outstanding_refs is_volatile_Write\\<^sub>s\\<^sub>b sb \\<noteq> {}) \\<and>\n                ts!i = (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, \n                        is,\n                        \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |` (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),(),\n                        \\<D>,  \n                        acquired True execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n                        release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\n   \\<rbrakk> \n    \\<Longrightarrow> \n     (ts\\<^sub>s\\<^sub>b\\<^sub>h,m\\<^sub>s\\<^sub>b\\<^sub>h,\\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts,m,\\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m =\n             exec_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n              m\\<^sub>s\\<^sub>b\\<^sub>h;\n     \\<S> =\n     share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n      \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n     length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts;\n     \\<forall>i<length ts\\<^sub>s\\<^sub>b\\<^sub>h.\n        let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb,\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<R>\\<^sub>s\\<^sub>b\\<^sub>h) =\n              ts\\<^sub>s\\<^sub>b\\<^sub>h ! i;\n            execs = takeWhile not_volatile_write sb;\n            suspends = dropWhile not_volatile_write sb\n        in \\<exists>is \\<D>.\n              instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h =\n              is @ prog_instrs suspends \\<and>\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h =\n              (\\<D> \\<or> refs volatile_Write sb \\<noteq> _emptyset) \\<and>\n              ts ! i =\n              (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, is,\n               \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |`\n               (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),\n               \\<D>, acquire execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n               release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h)\n                \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\\<rbrakk>\n    \\<Longrightarrow> (ts\\<^sub>s\\<^sub>b\\<^sub>h,\n                       m\\<^sub>s\\<^sub>b\\<^sub>h,\n                       \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>)", "apply (rule sim_config.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>m =\n             exec_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n              m\\<^sub>s\\<^sub>b\\<^sub>h;\n     \\<S> =\n     share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n      \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n     length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts;\n     \\<forall>i<length ts\\<^sub>s\\<^sub>b\\<^sub>h.\n        let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb,\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<R>\\<^sub>s\\<^sub>b\\<^sub>h) =\n              ts\\<^sub>s\\<^sub>b\\<^sub>h ! i;\n            execs = takeWhile not_volatile_write sb;\n            suspends = dropWhile not_volatile_write sb\n        in \\<exists>is \\<D>.\n              instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h =\n              is @ prog_instrs suspends \\<and>\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h =\n              (\\<D> \\<or> refs volatile_Write sb \\<noteq> _emptyset) \\<and>\n              ts ! i =\n              (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, is,\n               \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |`\n               (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),\n               \\<D>, acquire execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n               release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h)\n                \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\\<rbrakk>\n    \\<Longrightarrow> m =\n                      exec_all_until_volatile_write\n                       ts\\<^sub>s\\<^sub>b\\<^sub>h m\\<^sub>s\\<^sub>b\\<^sub>h\n 2. \\<lbrakk>m =\n             exec_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n              m\\<^sub>s\\<^sub>b\\<^sub>h;\n     \\<S> =\n     share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n      \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n     length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts;\n     \\<forall>i<length ts\\<^sub>s\\<^sub>b\\<^sub>h.\n        let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb,\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<R>\\<^sub>s\\<^sub>b\\<^sub>h) =\n              ts\\<^sub>s\\<^sub>b\\<^sub>h ! i;\n            execs = takeWhile not_volatile_write sb;\n            suspends = dropWhile not_volatile_write sb\n        in \\<exists>is \\<D>.\n              instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h =\n              is @ prog_instrs suspends \\<and>\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h =\n              (\\<D> \\<or> refs volatile_Write sb \\<noteq> _emptyset) \\<and>\n              ts ! i =\n              (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, is,\n               \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |`\n               (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),\n               \\<D>, acquire execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n               release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h)\n                \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\\<rbrakk>\n    \\<Longrightarrow> \\<S> =\n                      share_all_until_volatile_write\n                       ts\\<^sub>s\\<^sub>b\\<^sub>h\n                       \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n 3. \\<lbrakk>m =\n             exec_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n              m\\<^sub>s\\<^sub>b\\<^sub>h;\n     \\<S> =\n     share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n      \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n     length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts;\n     \\<forall>i<length ts\\<^sub>s\\<^sub>b\\<^sub>h.\n        let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb,\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<R>\\<^sub>s\\<^sub>b\\<^sub>h) =\n              ts\\<^sub>s\\<^sub>b\\<^sub>h ! i;\n            execs = takeWhile not_volatile_write sb;\n            suspends = dropWhile not_volatile_write sb\n        in \\<exists>is \\<D>.\n              instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h =\n              is @ prog_instrs suspends \\<and>\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h =\n              (\\<D> \\<or> refs volatile_Write sb \\<noteq> _emptyset) \\<and>\n              ts ! i =\n              (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, is,\n               \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |`\n               (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),\n               \\<D>, acquire execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n               release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h)\n                \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\\<rbrakk>\n    \\<Longrightarrow> length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts\n 4. \\<lbrakk>m =\n             exec_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n              m\\<^sub>s\\<^sub>b\\<^sub>h;\n     \\<S> =\n     share_all_until_volatile_write ts\\<^sub>s\\<^sub>b\\<^sub>h\n      \\<S>\\<^sub>s\\<^sub>b\\<^sub>h;\n     length ts\\<^sub>s\\<^sub>b\\<^sub>h = length ts;\n     \\<forall>i<length ts\\<^sub>s\\<^sub>b\\<^sub>h.\n        let (p\\<^sub>s\\<^sub>b\\<^sub>h, is\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h, sb,\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h, \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<R>\\<^sub>s\\<^sub>b\\<^sub>h) =\n              ts\\<^sub>s\\<^sub>b\\<^sub>h ! i;\n            execs = takeWhile not_volatile_write sb;\n            suspends = dropWhile not_volatile_write sb\n        in \\<exists>is \\<D>.\n              instrs suspends @ is\\<^sub>s\\<^sub>b\\<^sub>h =\n              is @ prog_instrs suspends \\<and>\n              \\<D>\\<^sub>s\\<^sub>b\\<^sub>h =\n              (\\<D> \\<or> refs volatile_Write sb \\<noteq> _emptyset) \\<and>\n              ts ! i =\n              (hd_prog p\\<^sub>s\\<^sub>b\\<^sub>h suspends, is,\n               \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h |`\n               (dom \\<theta>\\<^sub>s\\<^sub>b\\<^sub>h - read_tmps suspends),\n               \\<D>, acquire execs \\<O>\\<^sub>s\\<^sub>b\\<^sub>h,\n               release execs (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h)\n                \\<R>\\<^sub>s\\<^sub>b\\<^sub>h)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length ts\\<^sub>s\\<^sub>b\\<^sub>h.\n                         let (p, is\\<^sub>s\\<^sub>b, \\<theta>, sb,\n                               \\<D>\\<^sub>s\\<^sub>b, \\<O>, \\<R>) =\n                               ts\\<^sub>s\\<^sub>b\\<^sub>h ! i;\n                             suspends = dropWhile not_volatile_write sb\n                         in \\<exists>is \\<D>.\n                               instrs suspends @ is\\<^sub>s\\<^sub>b =\n                               is @ prog_instrs suspends \\<and>\n                               \\<D>\\<^sub>s\\<^sub>b =\n                               (\\<D> \\<or>\n                                refs volatile_Write sb \\<noteq>\n                                _emptyset) \\<and>\n                               ts ! i =\n                               (hd_prog p suspends, is,\n                                \\<theta> |`\n                                (dom \\<theta> - read_tmps suspends),\n                                \\<D>,\n                                acquire (takeWhile not_volatile_write sb)\n                                 \\<O>,\n                                release (takeWhile not_volatile_write sb)\n                                 (dom \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<R>)", "apply (simp_all add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  AssignAddr':\n  \"\\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop; a'=Tmp (eval_expr t a); t'= t + used_tmps a; is=issue_expr t a \\<rbrakk> \\<Longrightarrow>\n   \\<theta>\\<turnstile> (Assign volatile a e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((Assign volatile a' e A L R W, t'),is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop; a' = Tmp (eval_expr t a);\n     t' = t + used_tmps a; is = issue_expr t a\\<rbrakk>\n    \\<Longrightarrow> \\<theta>\\<turnstile> (Assign volatile a e A L R W,\n      t) \\<rightarrow>\\<^sub>p ((Assign volatile a' e A L R W, t'), is)", "by (simp add: AssignAddr)"], ["", "lemma  Assign':\n  \"\\<lbrakk>D \\<subseteq> dom \\<theta>; is= issue_expr t e@[Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>)]\\<rbrakk> \\<Longrightarrow> \n   \\<theta>\\<turnstile> (Assign volatile (Tmp (D,a)) e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((Skip, t + used_tmps e), is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<subseteq> dom \\<theta>;\n     is =\n     issue_expr t e @\n     [Write volatile (a \\<theta>) (eval_expr t e) (A \\<theta>) (L \\<theta>)\n       (R \\<theta>) (W \\<theta>)]\\<rbrakk>\n    \\<Longrightarrow> \\<theta>\\<turnstile> (Assign volatile (Tmp (D, a)) e A\n       L R W,\n      t) \\<rightarrow>\\<^sub>p ((Skip, t + used_tmps e), is)", "by (simp add: Assign)"], ["", "lemma CASAddr':\n  \"\\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop; a'=(Tmp (eval_expr t a));t'=t + used_tmps a; is=issue_expr t a \\<rbrakk> \\<Longrightarrow>\n   \\<theta>\\<turnstile> (CAS a c\\<^sub>e s\\<^sub>e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((CAS a' c\\<^sub>e s\\<^sub>e A L R W, t'), is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sop. a \\<noteq> Tmp sop; a' = Tmp (eval_expr t a);\n     t' = t + used_tmps a; is = issue_expr t a\\<rbrakk>\n    \\<Longrightarrow> \\<theta>\\<turnstile> (CAS a c\\<^sub>e s\\<^sub>e A L R\n       W,\n      t) \\<rightarrow>\\<^sub>p ((CAS a' c\\<^sub>e s\\<^sub>e A L R W, t'),\n                                is)", "by (simp add: CASAddr)"], ["", "lemma CASComp':\n  \"\\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;c\\<^sub>e'=(Tmp (eval_expr t c\\<^sub>e));t'=t + used_tmps c\\<^sub>e; is= issue_expr t c\\<^sub>e \\<rbrakk> \\<Longrightarrow>\n   \\<theta>\\<turnstile> (CAS (Tmp a) c\\<^sub>e s\\<^sub>e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((CAS (Tmp a) c\\<^sub>e' s\\<^sub>e A L R W, t'), is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sop. c\\<^sub>e \\<noteq> Tmp sop;\n     c\\<^sub>e' = Tmp (eval_expr t c\\<^sub>e); t' = t + used_tmps c\\<^sub>e;\n     is = issue_expr t c\\<^sub>e\\<rbrakk>\n    \\<Longrightarrow> \\<theta>\\<turnstile> (CAS (Tmp a) c\\<^sub>e s\\<^sub>e\n       A L R W,\n      t) \\<rightarrow>\\<^sub>p ((CAS (Tmp a) c\\<^sub>e' s\\<^sub>e A L R W,\n                                 t'),\n                                is)", "by (cases a) (simp add: CASComp)"], ["", "lemma CAS':\n  \"\\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>; D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e  = (D,f);t'=(t + used_tmps s\\<^sub>e); \n   cond = (\\<lambda>\\<theta>. the (\\<theta> t') = c \\<theta>);\n   ret = (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1);\n   is = issue_expr t s\\<^sub>e@\n           [RMW (a \\<theta>) t' (D,f) cond ret \n            (A \\<theta>) (L \\<theta>) (R \\<theta>) (W \\<theta>) ]\\<rbrakk>  \n   \\<Longrightarrow>\n   \\<theta>\\<turnstile> (CAS (Tmp (D\\<^sub>a,a)) (Tmp (D\\<^sub>c,c)) s\\<^sub>e A L R W, t) \\<rightarrow>\\<^sub>s \n         ((Skip, Suc t'),is )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D\\<^sub>a \\<subseteq> dom \\<theta>;\n     D\\<^sub>c \\<subseteq> dom \\<theta>; eval_expr t s\\<^sub>e = (D, f);\n     t' = t + used_tmps s\\<^sub>e;\n     cond = (\\<lambda>\\<theta>. the (\\<theta> t') = c \\<theta>);\n     ret = (\\<lambda>v\\<^sub>1 v\\<^sub>2. v\\<^sub>1);\n     is =\n     issue_expr t s\\<^sub>e @\n     [RMW (a \\<theta>) t' (D, f) cond ret (A \\<theta>) (L \\<theta>)\n       (R \\<theta>) (W \\<theta>)]\\<rbrakk>\n    \\<Longrightarrow> \\<theta>\\<turnstile> (CAS (Tmp (D\\<^sub>a, a))\n       (Tmp (D\\<^sub>c, c)) s\\<^sub>e A L R W,\n      t) \\<rightarrow>\\<^sub>p ((Skip, Suc t'), is)", "by (simp add: CAS)"], ["", "lemma SCond':\n  \"\\<forall>sop. e \\<noteq> Tmp sop \\<Longrightarrow> e'= (Tmp (eval_expr t e)) \\<Longrightarrow> t'=t + used_tmps e \\<Longrightarrow> is=issue_expr t e\n   \\<Longrightarrow>\n   \\<theta>\\<turnstile> (Cond e s\\<^sub>1 s\\<^sub>2, t) \\<rightarrow>\\<^sub>s \n    ((Cond e' s\\<^sub>1 s\\<^sub>2, t'), is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sop. e \\<noteq> Tmp sop; e' = Tmp (eval_expr t e);\n     t' = t + used_tmps e; is = issue_expr t e\\<rbrakk>\n    \\<Longrightarrow> \\<theta>\\<turnstile> (Cond e s\\<^sub>1 s\\<^sub>2,\n      t) \\<rightarrow>\\<^sub>p ((Cond e' s\\<^sub>1 s\\<^sub>2, t'), is)", "by (simp add: Cond)"], ["", "lemma SWhile':\n  \"s'= (Cond e (Seq s (While e s)) Skip) \\<Longrightarrow>\n   \\<theta>\\<turnstile> (While e s, t) \\<rightarrow>\\<^sub>s ((s', t),[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = Cond e (Seq s (While e s)) Skip \\<Longrightarrow>\n    \\<theta>\\<turnstile> (While e s, t) \\<rightarrow>\\<^sub>p ((s', t), [])", "by (simp add: stmt_step.While)"], ["", "theorem (in xvalid_program) simulation_hol:\n  \"(ts\\<^sub>s\\<^sub>b\\<^sub>h,m\\<^sub>s\\<^sub>b\\<^sub>h,\\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (ts\\<^sub>s\\<^sub>b\\<^sub>h',m\\<^sub>s\\<^sub>b\\<^sub>h',\\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<and>\n   (ts\\<^sub>s\\<^sub>b\\<^sub>h,m\\<^sub>s\\<^sub>b\\<^sub>h,\\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts,m,\\<S>) \\<and> safe_reach_direct safe_delayed (ts, m, \\<S>) \\<and>\n   invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h m\\<^sub>s\\<^sub>b\\<^sub>h \\<longrightarrow>\n  invariant ts\\<^sub>s\\<^sub>b\\<^sub>h' \\<S>\\<^sub>s\\<^sub>b\\<^sub>h' m\\<^sub>s\\<^sub>b\\<^sub>h' \\<and>\n           (\\<exists>ts' \\<S>' m'. (ts,m,\\<S>) \\<Rightarrow>\\<^sub>d\\<^sup>* (ts',m',\\<S>') \\<and> (ts\\<^sub>s\\<^sub>b\\<^sub>h',m\\<^sub>s\\<^sub>b\\<^sub>h',\\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<sim> (ts',m',\\<S>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n     \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (ts\\<^sub>s\\<^sub>b\\<^sub>h',\n                                    m\\<^sub>s\\<^sub>b\\<^sub>h',\n                                    \\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<and>\n    (ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n     \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>) \\<and>\n    safe_reach_direct safe_delayed (ts, m, \\<S>) \\<and>\n    invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n     m\\<^sub>s\\<^sub>b\\<^sub>h \\<longrightarrow>\n    invariant ts\\<^sub>s\\<^sub>b\\<^sub>h' \\<S>\\<^sub>s\\<^sub>b\\<^sub>h'\n     m\\<^sub>s\\<^sub>b\\<^sub>h' \\<and>\n    (\\<exists>ts' \\<S>' m'.\n        (ts, m, \\<S>) \\<Rightarrow>\\<^sub>d\\<^sup>* (ts', m', \\<S>') \\<and>\n        (ts\\<^sub>s\\<^sub>b\\<^sub>h', m\\<^sub>s\\<^sub>b\\<^sub>h',\n         \\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<sim> (ts', m', \\<S>'))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sub>h (ts\\<^sub>s\\<^sub>b\\<^sub>h',\n       m\\<^sub>s\\<^sub>b\\<^sub>h', \\<S>\\<^sub>s\\<^sub>b\\<^sub>h');\n     (ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n      \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>);\n     safe_reach_direct safe_delayed (ts, m, \\<S>);\n     invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n      m\\<^sub>s\\<^sub>b\\<^sub>h\\<rbrakk>\n    \\<Longrightarrow> invariant ts\\<^sub>s\\<^sub>b\\<^sub>h'\n                       \\<S>\\<^sub>s\\<^sub>b\\<^sub>h'\n                       m\\<^sub>s\\<^sub>b\\<^sub>h' \\<and>\n                      (\\<exists>ts' \\<S>' m'.\n                          (ts, m,\n                           \\<S>) \\<Rightarrow>\\<^sub>d\\<^sup>* (ts', m',\n                          \\<S>') \\<and>\n                          (ts\\<^sub>s\\<^sub>b\\<^sub>h',\n                           m\\<^sub>s\\<^sub>b\\<^sub>h',\n                           \\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<sim> (ts', m',\n                            \\<S>'))", "apply (drule simulation')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>);\n     safe_reach_direct safe_delayed (ts, m, \\<S>);\n     invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n      m\\<^sub>s\\<^sub>b\\<^sub>h\\<rbrakk>\n    \\<Longrightarrow> (ts\\<^sub>s\\<^sub>b\\<^sub>h,\n                       m\\<^sub>s\\<^sub>b\\<^sub>h,\n                       \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (?ts4, ?m4,\n                       ?\\<S>4)\n 2. \\<lbrakk>(ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>);\n     safe_reach_direct safe_delayed (ts, m, \\<S>);\n     invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n      m\\<^sub>s\\<^sub>b\\<^sub>h\\<rbrakk>\n    \\<Longrightarrow> invariant ts\\<^sub>s\\<^sub>b\\<^sub>h\n                       \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n                       m\\<^sub>s\\<^sub>b\\<^sub>h\n 3. \\<lbrakk>(ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>);\n     safe_reach_direct safe_delayed (ts, m, \\<S>);\n     invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n      m\\<^sub>s\\<^sub>b\\<^sub>h\\<rbrakk>\n    \\<Longrightarrow> safe_reach_direct safe_delayed (?ts4, ?m4, ?\\<S>4)\n 4. \\<lbrakk>(ts\\<^sub>s\\<^sub>b\\<^sub>h, m\\<^sub>s\\<^sub>b\\<^sub>h,\n              \\<S>\\<^sub>s\\<^sub>b\\<^sub>h) \\<sim> (ts, m, \\<S>);\n     safe_reach_direct safe_delayed (ts, m, \\<S>);\n     invariant ts\\<^sub>s\\<^sub>b\\<^sub>h \\<S>\\<^sub>s\\<^sub>b\\<^sub>h\n      m\\<^sub>s\\<^sub>b\\<^sub>h;\n     invariant ts\\<^sub>s\\<^sub>b\\<^sub>h' \\<S>\\<^sub>s\\<^sub>b\\<^sub>h'\n      m\\<^sub>s\\<^sub>b\\<^sub>h' \\<and>\n     (\\<exists>ts' \\<S>' m'.\n         (?ts4, ?m4,\n          ?\\<S>4) \\<Rightarrow>\\<^sub>d\\<^sup>* (ts', m', \\<S>') \\<and>\n         (ts\\<^sub>s\\<^sub>b\\<^sub>h', m\\<^sub>s\\<^sub>b\\<^sub>h',\n          \\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<sim> (ts', m', \\<S>'))\\<rbrakk>\n    \\<Longrightarrow> invariant ts\\<^sub>s\\<^sub>b\\<^sub>h'\n                       \\<S>\\<^sub>s\\<^sub>b\\<^sub>h'\n                       m\\<^sub>s\\<^sub>b\\<^sub>h' \\<and>\n                      (\\<exists>ts' \\<S>' m'.\n                          (ts, m,\n                           \\<S>) \\<Rightarrow>\\<^sub>d\\<^sup>* (ts', m',\n                          \\<S>') \\<and>\n                          (ts\\<^sub>s\\<^sub>b\\<^sub>h',\n                           m\\<^sub>s\\<^sub>b\\<^sub>h',\n                           \\<S>\\<^sub>s\\<^sub>b\\<^sub>h') \\<sim> (ts', m',\n                            \\<S>'))", "by auto"], ["", "theorem (in xvalid_program_progress) store_buffer_execution_result_sequential_consistent'_hol:\n\"(ts\\<^sub>s\\<^sub>b,m,x) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sup>* (ts\\<^sub>s\\<^sub>b',m',x') \\<and>\nempty_store_buffers ts\\<^sub>s\\<^sub>b' \\<and>\nts\\<^sub>s\\<^sub>b \\<sim>\\<^sub>d ts \\<and>\ninitial\\<^sub>v ts \\<S> valid \\<and>\nsafe_reach_virtual safe_free_flowing (ts,m,\\<S>) \n\\<longrightarrow>\n(\\<exists>ts' \\<S>'. \n          (ts,m,\\<S>) \\<Rightarrow>\\<^sub>v\\<^sup>* (ts',m',\\<S>') \\<and> ts\\<^sub>s\\<^sub>b' \\<sim>\\<^sub>d ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts\\<^sub>s\\<^sub>b, m,\n     x) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sup>* (ts\\<^sub>s\\<^sub>b', m',\n         x') \\<and>\n    empty_store_buffers ts\\<^sub>s\\<^sub>b' \\<and>\n    ts\\<^sub>s\\<^sub>b \\<sim> ts  \\<and>\n    initial\\<^sub>v ts \\<S> \\<and>\n    safe_reach_virtual_free_flowing (ts, m, \\<S>) \\<longrightarrow>\n    (\\<exists>ts' \\<S>'.\n        (ts, m, \\<S>) \\<Rightarrow>\\<^sub>v\\<^sup>* (ts', m', \\<S>') \\<and>\n        ts\\<^sub>s\\<^sub>b' \\<sim> ts' )", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ts\\<^sub>s\\<^sub>b, m,\n              x) \\<Rightarrow>\\<^sub>s\\<^sub>b\\<^sup>* (ts\\<^sub>s\\<^sub>b',\n                  m', x');\n     empty_store_buffers ts\\<^sub>s\\<^sub>b'; ts\\<^sub>s\\<^sub>b \\<sim> ts ;\n     initial\\<^sub>v ts \\<S>;\n     safe_reach_virtual_free_flowing (ts, m, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts' \\<S>'.\n                         (ts, m,\n                          \\<S>) \\<Rightarrow>\\<^sub>v\\<^sup>* (ts', m',\n                         \\<S>') \\<and>\n                         ts\\<^sub>s\\<^sub>b' \\<sim> ts'", "apply (drule store_buffer_execution_result_sequential_consistent')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>empty_store_buffers ts\\<^sub>s\\<^sub>b';\n     ts\\<^sub>s\\<^sub>b \\<sim> ts ; initial\\<^sub>v ts \\<S>;\n     safe_reach_virtual_free_flowing (ts, m, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> empty_store_buffers ts\\<^sub>s\\<^sub>b'\n 2. \\<lbrakk>empty_store_buffers ts\\<^sub>s\\<^sub>b';\n     ts\\<^sub>s\\<^sub>b \\<sim> ts ; initial\\<^sub>v ts \\<S>;\n     safe_reach_virtual_free_flowing (ts, m, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> ts\\<^sub>s\\<^sub>b \\<sim> ?ts5 \n 3. \\<lbrakk>empty_store_buffers ts\\<^sub>s\\<^sub>b';\n     ts\\<^sub>s\\<^sub>b \\<sim> ts ; initial\\<^sub>v ts \\<S>;\n     safe_reach_virtual_free_flowing (ts, m, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> initial\\<^sub>v ?ts5 ?\\<S>5\n 4. \\<lbrakk>empty_store_buffers ts\\<^sub>s\\<^sub>b';\n     ts\\<^sub>s\\<^sub>b \\<sim> ts ; initial\\<^sub>v ts \\<S>;\n     safe_reach_virtual_free_flowing (ts, m, \\<S>)\\<rbrakk>\n    \\<Longrightarrow> safe_reach_virtual_free_flowing (?ts5, m, ?\\<S>5)\n 5. \\<lbrakk>empty_store_buffers ts\\<^sub>s\\<^sub>b';\n     ts\\<^sub>s\\<^sub>b \\<sim> ts ; initial\\<^sub>v ts \\<S>;\n     safe_reach_virtual_free_flowing (ts, m, \\<S>);\n     \\<exists>ts' \\<S>'.\n        (?ts5, m,\n         ?\\<S>5) \\<Rightarrow>\\<^sub>v\\<^sup>* (ts', m', \\<S>') \\<and>\n        ts\\<^sub>s\\<^sub>b' \\<sim> ts' \\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts' \\<S>'.\n                         (ts, m,\n                          \\<S>) \\<Rightarrow>\\<^sub>v\\<^sup>* (ts', m',\n                         \\<S>') \\<and>\n                         ts\\<^sub>s\\<^sub>b' \\<sim> ts'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(*>*)"]]}