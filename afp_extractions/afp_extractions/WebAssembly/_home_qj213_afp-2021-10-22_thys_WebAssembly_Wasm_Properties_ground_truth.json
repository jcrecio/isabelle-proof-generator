{"file_name": "/home/qj213/afp-2021-10-22/thys/WebAssembly/Wasm_Properties.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WebAssembly", "problem_names": ["lemma t_cvt: assumes \"cvt t sx v = Some v'\" shows \"t = typeof v'\"", "lemma store_preserved1:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n          \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := local ((s_inst \\<S>)!i) @ (map typeof vs), label := arb_label, return := arb_return\\<rparr>\"\n          \"i < length (s_inst \\<S>)\"\n  shows \"store_typing s' \\<S>\"", "lemma store_preserved:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"store_typing s' \\<S>\"", "lemma typeof_unop_testop:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"(e = (Unop_i t iop)) \\<or> (e = (Unop_f t fop)) \\<or> (e = (Testop t testop))\"\n  shows \"(typeof v) = t\"\n        \"e = (Unop_f t fop) \\<Longrightarrow> is_float_t t\"", "lemma typeof_cvtop:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"e = Cvtop t1 cvtop t sx\"\n  shows \"(typeof v) = t\"\n        \"cvtop = Convert \\<Longrightarrow> (t1 \\<noteq> t) \\<and> ((sx = None) = ((is_float_t t1 \\<and> is_float_t t) \\<or> (is_int_t t1 \\<and> is_int_t t \\<and> (t_length t1 < t_length t))))\"\n        \"cvtop = Reinterpret \\<Longrightarrow> (t1 \\<noteq> t) \\<and> t_length t1 = t_length t\"", "lemma types_preserved_unop_testop_cvtop:\n  assumes \"\\<lparr>[$C v, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"(e = (Unop_i t iop)) \\<or> (e = (Unop_f t fop)) \\<or> (e = (Testop t testop))  \\<or> (e = (Cvtop t2 cvtop t sx))\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : (ts _> ts')\"", "lemma typeof_binop_relop:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $e] : (ts _> ts')\"\n          \"e = Binop_i t iop \\<or> e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\"\n  shows \"typeof v1 = t\"\n        \"typeof v2 = t\"\n        \"e = Binop_f t fop \\<Longrightarrow> is_float_t t\"\n        \"e = Relop_f t frop \\<Longrightarrow> is_float_t t\"", "lemma types_preserved_binop_relop:\n  assumes \"\\<lparr>[$C v1, $C v2, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $e] : (ts _> ts')\"\n          \"e = Binop_i t iop \\<or> e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : (ts _> ts')\"", "lemma types_preserved_drop:\n  assumes \"\\<lparr>[$C v, $e]\\<rparr> \\<leadsto> \\<lparr>[]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"(e = (Drop))\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\"", "lemma types_preserved_select:\n  assumes \"\\<lparr>[$C v1, $C v2, $C vn, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v3]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $C vn, $e] : (ts _> ts')\"\n          \"(e = Select)\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : (ts _> ts')\"", "lemma types_preserved_block:\n  assumes \"\\<lparr>vs @ [$Block (tn _> tm) es]\\<rparr> \\<leadsto> \\<lparr>[Label m [] (vs @ ($* es))]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Block (tn _> tm) es] : (ts _> ts')\"\n          \"const_list vs\"\n          \"length vs = n\"\n          \"length tn = n\"\n          \"length tm = m\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : (ts _> ts')\"", "lemma types_preserved_if:\n  assumes \"\\<lparr>[$C ConstInt32 n, $If tf e1s e2s]\\<rparr> \\<leadsto> \\<lparr>[$Block tf es']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 n, $If tf e1s e2s] : (ts _> ts')\"\n  shows   \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : (ts _> ts')\"", "lemma types_preserved_tee_local:\n  assumes \"\\<lparr>[v, $Tee_local i]\\<rparr> \\<leadsto> \\<lparr>[v, v, $Set_local i]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [v, $Tee_local i] : (ts _> ts')\"\n          \"is_const v\"\n  shows   \"\\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : (ts _> ts')\"", "lemma types_preserved_loop:\n  assumes \"\\<lparr>vs @ [$Loop (t1s _> t2s) es]\\<rparr> \\<leadsto> \\<lparr>[Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Loop (t1s _> t2s) es] : (ts _> ts')\"\n          \"const_list vs\"\n          \"length vs = n\"\n          \"length t1s = n\"\n          \"length t2s = m\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))] : (ts _> ts')\"", "lemma types_preserved_label_value:\n  assumes \"\\<lparr>[Label n es0 vs]\\<rparr> \\<leadsto> \\<lparr>vs\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0 vs] : (ts _> ts')\"\n          \"const_list vs\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> ts')\"", "lemma types_preserved_br_if:\n  assumes \"\\<lparr>[$C ConstInt32 n, $Br_if i]\\<rparr> \\<leadsto> \\<lparr>e\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 n, $Br_if i] : (ts _> ts')\"\n          \"e = [$Br i] \\<or> e = []\"\n  shows   \"\\<S>\\<bullet>\\<C> \\<turnstile> e : (ts _> ts')\"", "lemma types_preserved_br_table:\n  assumes \"\\<lparr>[$C ConstInt32 c, $Br_table is i]\\<rparr> \\<leadsto> \\<lparr>[$Br i']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Br_table is i] : (ts _> ts')\"\n          \"(i' = (is ! nat_of_int c) \\<and> length is > nat_of_int c) \\<or> i' = i\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : (ts _> ts')\"", "lemma types_preserved_local_const:\n  assumes \"\\<lparr>[Local n i vs es]\\<rparr> \\<leadsto> \\<lparr>es\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs es] : (ts _> ts')\"\n          \"const_list es\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> es: (ts _> ts')\"", "lemma typing_map_typeof:\n  assumes \"ves = $$* vs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : ([] _> tvs)\"\n  shows \"tvs = map typeof vs\"", "lemma types_preserved_call_indirect_Some:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Call_indirect j] : (ts _> ts')\"\n          \"stab s i' (nat_of_int c) = Some cl\"\n          \"stypes s i' j = tf\"\n          \"cl_type cl = tf\"\n          \"store_typing s \\<S>\"\n          \"i' < length (inst s)\"\n          \"\\<C> = (s_inst \\<S> ! i') \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs, return := arb_return\\<rparr>\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts _> ts')\"", "lemma types_preserved_call_indirect_None:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Call_indirect j] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : (ts _> ts')\"", "lemma types_preserved_callcl_native:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : (ts _> ts')\"\n          \"cl = Func_native i (t1s _> t2s) tfs es\"\n          \"ves = $$* vs\"\n          \"length vs = n\"\n          \"length tfs = k\"\n          \"length t1s = n\"\n          \"length t2s = m\"\n          \"n_zeros tfs = zs\"\n          \"store_typing s \\<S>\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs) [$Block ([] _> t2s) es]] : (ts _> ts')\"", "lemma types_preserved_callcl_host_some:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : (ts _> ts')\"\n          \"cl = Func_host (t1s _> t2s) f\"\n          \"ves = $$* vcs\"\n          \"length vcs = n\"\n          \"length t1s = n\"\n          \"length t2s = m\"\n          \"host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\"\n          \"store_typing s \\<S>\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : (ts _> ts')\"", "lemma types_imp_concat:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> es @ [e] @ es' : (ts _> ts')\"\n          \"\\<And>tes tes'. ((\\<S>\\<bullet>\\<C> \\<turnstile> [e] : (tes _> tes')) \\<Longrightarrow> (\\<S>\\<bullet>\\<C> \\<turnstile> [e'] : (tes _> tes')))\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : (ts _> ts')\"", "lemma type_const_return:\n  assumes \"Lfilled i lholed (vs @ [$Return]) LI\"\n          \"(return \\<C>) = Some tcs\"\n          \"length tcs = length vs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> LI : (ts _> ts')\"\n          \"const_list vs\"\n  shows \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tcs)\"", "lemma types_preserved_return:\n  assumes \"\\<lparr>[Local n i vls LI]\\<rparr> \\<leadsto> \\<lparr>ves\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vls LI] : (ts _> ts')\"\n          \"const_list ves\"\n          \"length ves = n\"\n          \"Lfilled j lholed (ves @ [$Return]) LI\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : (ts _> ts')\"", "lemma type_const_br:\n  assumes \"Lfilled i lholed (vs @ [$Br (i+k)]) LI\"\n          \"length (label \\<C>) > k\"\n          \"(label \\<C>)!k = tcs\"\n          \"length tcs = length vs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> LI : (ts _> ts')\"\n          \"const_list vs\"\n  shows \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tcs)\"", "lemma types_preserved_br:\n  assumes \"\\<lparr>[Label n es0 LI]\\<rparr> \\<leadsto> \\<lparr>vs @ es0\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0 LI] : (ts _> ts')\"\n          \"const_list vs\"\n          \"length vs = n\"\n          \"Lfilled i lholed (vs @ [$Br i]) LI\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> (vs @ es0) : (ts _> ts')\"", "lemma store_local_label_empty:\n  assumes \"i < length (s_inst \\<S>)\"\n          \"store_typing s \\<S>\"\n  shows \"label ((s_inst \\<S>)!i) = []\" \"local ((s_inst \\<S>)!i) = []\"", "lemma types_preserved_b_e1:\n  assumes \"\\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts _> ts')\"", "lemma types_preserved_b_e:\n  assumes \"\\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es' : ts\"", "lemma types_preserved_store:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v, $Store t tp a off] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\"\n        \"types_agree t v\"", "lemma types_preserved_current_memory:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : (ts _> ts')\"", "lemma types_preserved_grow_memory:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : (ts _> ts')\"", "lemma types_preserved_set_global:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\"\n        \"tg_t (global \\<C> ! j) = typeof v\"", "lemma types_preserved_load:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $Load t tp a off] : (ts _> ts')\"\n          \"typeof v = t\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts _> ts')\"", "lemma types_preserved_get_local:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local i] : (ts _> ts')\"\n          \"length vi = i\"\n          \"(local \\<C>) = map typeof (vi @ [v] @ vs)\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts _> ts')\"", "lemma types_preserved_set_local:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local i] : (ts _> ts')\"\n          \"length vi = i\"\n          \"(local \\<C>) = map typeof (vi @ [v] @ vs)\"\n  shows \"(\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')) \\<and> map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)\"", "lemma types_preserved_get_global:\n  assumes \"typeof (sglob_val s i j) = tg_t (global \\<C> ! j)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : (ts _> ts')\"", "lemma lholed_same_type:\n  assumes \"Lfilled k lholed es les\"\n          \"Lfilled k lholed es' les'\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> les : (ts _> ts')\"\n          \"\\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>(\\<C>\\<lparr>label := arb_labs@(label \\<C>)\\<rparr>) \\<turnstile> es : (ts _> ts')\n             \\<Longrightarrow> \\<S>\\<bullet>(\\<C>\\<lparr>label := arb_labs@(label \\<C>)\\<rparr>) \\<turnstile> es' : (ts _> ts')\"\n  shows \"(\\<S>\\<bullet>\\<C> \\<turnstile> les' : (ts _> ts'))\"", "lemma types_preserved_e1:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"tvs = map typeof vs\"\n          \"i < length (inst s)\"\n          \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i) @ tvs), label := arb_labs, return := arb_return\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n  shows \"(\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts _> ts')) \\<and> (map typeof vs = map typeof vs')\"", "lemma types_preserved_e:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"\\<S>\\<bullet>None \\<tturnstile>_i vs';es' : ts\"", "lemma const_list_no_progress:\n  assumes \"const_list es\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"", "lemma empty_no_progress:\n  assumes \"es = []\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"", "lemma trap_no_progress:\n  assumes \"es = [Trap]\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"", "lemma terminal_no_progress:\n  assumes \"const_list es \\<or> es = [Trap]\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"", "lemma progress_L0:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"\n          \"const_list cs\"\n  shows \"\\<lparr>s;vs;cs@es@es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs@es'@es_c\\<rparr>\"", "lemma progress_L0_left:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"\n          \"const_list cs\"\n  shows \"\\<lparr>s;vs;cs@es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs@es'\\<rparr>\"", "lemma progress_L0_trap:\n  assumes \"const_list cs\"\n          \"cs \\<noteq> [] \\<or> es \\<noteq> []\"\n  shows \"\\<exists>a. \\<lparr>s;vs;cs@[Trap]@es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\"", "lemma progress_LN:\n  assumes \"(Lfilled j lholed [$Br (j+k)] es)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts)\"\n          \"(label \\<C>)!k = tvs\"\n  shows \"\\<exists>lholed' vs \\<C>'. (Lfilled j lholed' (vs@[$Br (j+k)]) es)\n                    \\<and> (\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tvs))\n                    \\<and> const_list vs\"", "lemma progress_LN_return:\n  assumes \"(Lfilled j lholed [$Return] es)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts)\"\n          \"(return \\<C>) = Some tvs\"\n  shows \"\\<exists>lholed' vs \\<C>'. (Lfilled j lholed' (vs@[$Return]) es)\n                    \\<and> (\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tvs))\n                    \\<and> const_list vs\"", "lemma progress_LN1:\n  assumes \"(Lfilled j lholed [$Br (j+k)] es)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n  shows \"length (label \\<C>) > k\"", "lemma progress_LN2:\n  assumes \"(Lfilled j lholed e1s lfilled)\"\n  shows \"\\<exists>lfilled'. (Lfilled j lholed e2s lfilled')\"", "lemma const_of_const_list:\n  assumes \"length cs = 1\"\n          \"const_list cs\"\n  shows \"\\<exists>v. cs = [$C v]\"", "lemma const_of_i32:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [(T_i32)])\"\n  shows \"\\<exists>c. cs = [$C ConstInt32 c]\"", "lemma const_of_i64:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [(T_i64)])\"\n  shows \"\\<exists>c. cs = [$C ConstInt64 c]\"", "lemma const_of_f32:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [T_f32])\"\n  shows \"\\<exists>c. cs = [$C ConstFloat32 c]\"", "lemma const_of_f64:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [T_f64])\"\n  shows \"\\<exists>c. cs = [$C ConstFloat64 c]\"", "lemma progress_unop_testop_i:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t])\"\n          \"is_int_t t\"\n          \"const_list cs\"\n          \"e = Unop_i t iop \\<or> e = Testop t testop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"", "lemma progress_unop_f:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t])\"\n          \"is_float_t t\"\n          \"const_list cs\"\n          \"e = Unop_f t iop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"", "lemma const_list_split_2:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t1, t2])\"\n  shows \"\\<exists>c1 c2. (\\<S>\\<bullet>\\<C> \\<turnstile> [c1] : ([] _> [t1]))\n                 \\<and> (\\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ([] _> [t2]))\n                 \\<and> cs = [c1, c2]\n                 \\<and> const_list [c1]\n                 \\<and> const_list [c2]\"", "lemma const_list_split_3:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t1, t2, t3])\"\n  shows \"\\<exists>c1 c2 c3. (\\<S>\\<bullet>\\<C> \\<turnstile> [c1] : ([] _> [t1]))\n                    \\<and> (\\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ([] _> [t2]))\n                    \\<and> (\\<S>\\<bullet>\\<C> \\<turnstile> [c3] : ([] _> [t3]))\n                    \\<and> cs = [c1, c2, c3]\"", "lemma progress_binop_relop_i:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t, t])\"\n          \"is_int_t t\"\n          \"const_list cs\"\n          \"e = Binop_i t iop \\<or> e = Relop_i t irop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"", "lemma progress_binop_relop_f:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t, t])\"\n          \"is_float_t t\"\n          \"const_list cs\"\n          \"e = Binop_f t fop \\<or> e = Relop_f t frop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"", "lemma progress_b_e:\n  assumes \"\\<C> \\<turnstile> b_es : (ts _> ts')\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> ts)\"\n          \"(\\<And>lholed. \\<not>(Lfilled 0 lholed [$Return] (cs@($*b_es))))\"\n          \"\\<And> i lholed. \\<not>(Lfilled 0 lholed [$Br (i)] (cs@($*b_es)))\"\n          \"const_list cs\"\n          \"\\<not> const_list ($* b_es)\"\n          \"i < length (s_inst \\<S>)\"\n          \"length (local \\<C>) = length (vs)\"\n          \"Option.is_none (memory \\<C>) = Option.is_none (inst.mem ((inst s)!i))\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@($*b_es)\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"", "lemma progress_e:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;cs_es : ts'\"\n          \"\\<And> k lholed. \\<not>(Lfilled k lholed [$Return] cs_es)\"\n          \"\\<And> i k lholed. (Lfilled k lholed [$Br (i)] cs_es) \\<Longrightarrow> i < k\"\n          \"cs_es \\<noteq> [Trap]\"\n          \"\\<not> const_list (cs_es)\"\n          \"store_typing s \\<S>\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"", "lemma progress_e1:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"\\<not>(Lfilled k lholed [$Return] es)\"", "lemma progress_e2:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n          \"store_typing s \\<S>\"\n  shows \"(Lfilled k lholed [$Br (j)] es) \\<Longrightarrow> j < k\"", "lemma progress_e3:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;cs_es : ts'\"\n          \"cs_es \\<noteq> [Trap]\"\n          \"\\<not> const_list (cs_es)\"\n          \"store_typing s \\<S>\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], "translations": [["", "lemma t_cvt: assumes \"cvt t sx v = Some v'\" shows \"t = typeof v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = typeof v'", "using assms"], ["proof (prove)\nusing this:\n  cvt t sx v = Some v'\n\ngoal (1 subgoal):\n 1. t = typeof v'", "unfolding cvt_def typeof_def"], ["proof (prove)\nusing this:\n  (case t of\n   T_i32 \\<Rightarrow>\n     case cvt_i32 sx v of None \\<Rightarrow> None\n     | Some c \\<Rightarrow> Some (ConstInt32 c)\n   | T_i64 \\<Rightarrow>\n       case cvt_i64 sx v of None \\<Rightarrow> None\n       | Some c \\<Rightarrow> Some (ConstInt64 c)\n   | T_f32 \\<Rightarrow>\n       case cvt_f32 sx v of None \\<Rightarrow> None\n       | Some c \\<Rightarrow> Some (ConstFloat32 c)\n   | T_f64 \\<Rightarrow>\n       case cvt_f64 sx v of None \\<Rightarrow> None\n       | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n  Some v'\n\ngoal (1 subgoal):\n 1. t =\n    (case v' of ConstInt32 x \\<Rightarrow> T_i32\n     | ConstInt64 x \\<Rightarrow> T_i64 | ConstFloat32 x \\<Rightarrow> T_f32\n     | ConstFloat64 x \\<Rightarrow> T_f64)", "apply (cases t)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_i32\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)\n 2. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_i64\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)\n 3. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f32\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)\n 4. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f64\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)", "apply (simp add: option.case_eq_if, metis option.discI option.inject v.simps(17))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_i64\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)\n 2. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f32\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)\n 3. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f64\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)", "apply (simp add: option.case_eq_if, metis option.discI option.inject v.simps(18))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f32\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)\n 2. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f64\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)", "apply (simp add: option.case_eq_if, metis option.discI option.inject v.simps(19))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case t of\n              T_i32 \\<Rightarrow>\n                case cvt_i32 sx v of None \\<Rightarrow> None\n                | Some c \\<Rightarrow> Some (ConstInt32 c)\n              | T_i64 \\<Rightarrow>\n                  case cvt_i64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstInt64 c)\n              | T_f32 \\<Rightarrow>\n                  case cvt_f32 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat32 c)\n              | T_f64 \\<Rightarrow>\n                  case cvt_f64 sx v of None \\<Rightarrow> None\n                  | Some c \\<Rightarrow> Some (ConstFloat64 c)) =\n             Some v';\n     t = T_f64\\<rbrakk>\n    \\<Longrightarrow> t =\n                      (case v' of ConstInt32 x \\<Rightarrow> T_i32\n                       | ConstInt64 x \\<Rightarrow> T_i64\n                       | ConstFloat32 x \\<Rightarrow> T_f32\n                       | ConstFloat64 x \\<Rightarrow> T_f64)", "apply (simp add: option.case_eq_if, metis option.discI option.inject v.simps(20))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma store_preserved1:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n          \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := local ((s_inst \\<S>)!i) @ (map typeof vs), label := arb_label, return := arb_return\\<rparr>\"\n          \"i < length (s_inst \\<S>)\"\n  shows \"store_typing s' \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "proof (induction arbitrary: \\<C> arb_label arb_return ts ts' rule: reduce.induct)"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "case (callcl_host_Some cl t1s t2s f ves vcs n m s hs s' vcs' vs i)"], ["proof (state)\nthis:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> ves : (ts _> ts'')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using callcl_host_Some(8) e_type_comp"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "have ves_c:\"const_list ves\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_list ves", "using is_const_list[OF callcl_host_Some(2)]"], ["proof (prove)\nusing this:\n  const_list ves\n\ngoal (1 subgoal):\n 1. const_list ves", "by simp"], ["proof (state)\nthis:\n  const_list ves\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  const_list ves", "obtain tvs where tvs_def:\"ts'' = ts @ tvs\"\n                                \"length t1s = length tvs\"\n                                \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : ([] _> tvs)\""], ["proof (prove)\nusing this:\n  const_list ves\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length t1s = length tvs;\n         \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ts''_def(1) e_type_const_list[of ves \\<S> \\<C> ts ts''] callcl_host_Some"], ["proof (prove)\nusing this:\n  const_list ves\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\n  \\<lbrakk>const_list ves;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ts'' = ts @ tvs \\<and>\n                       length ves = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ves : [] _> tvs\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length t1s = length tvs;\n         \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "hence \"ts'' = ts @ t1s\"\n        \"ts' = ts @ t2s\""], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. ts'' = ts @ t1s &&& ts' = ts @ t2s", "using e_type_callcl_host[OF ts''_def(2) callcl_host_Some(1)]"], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n  \\<exists>t1sa t2sa ts_c.\n     ts'' = ts_c @ t1sa \\<and>\n     ts' = ts_c @ t2sa \\<and> t1s _> t2s = t1sa _> t2sa\n\ngoal (1 subgoal):\n 1. ts'' = ts @ t1s &&& ts' = ts @ t2s", "by auto"], ["proof (state)\nthis:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "moreover"], ["proof (state)\nthis:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "hence \"list_all2 types_agree t1s vcs\""], ["proof (prove)\nusing this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n\ngoal (1 subgoal):\n 1. list_all2 types_agree t1s vcs", "using e_typing_imp_list_types_agree[where ?ts' = \"[]\"] callcl_host_Some(2) tvs_def(1,3)"], ["proof (prove)\nusing this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $$* ?vs : [] _> [] @\n             ?ts \\<Longrightarrow>\n  list_all2 types_agree ?ts ?vs\n  ves = $$* vcs\n  ts'' = ts @ tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. list_all2 types_agree t1s vcs", "by fastforce"], ["proof (state)\nthis:\n  list_all2 types_agree t1s vcs\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i \\<C> arb_label\n       arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s' \\<S>\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 types_agree t1s vcs\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "using store_extension_imp_store_typing\n          host_apply_preserve_store[OF _ callcl_host_Some(6)] callcl_host_Some(7)"], ["proof (prove)\nusing this:\n  list_all2 types_agree t1s vcs\n  \\<lbrakk>store_extension ?s ?s'; store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> store_typing ?s' ?\\<S>\n  list_all2 types_agree t1s vcs \\<Longrightarrow> store_extension s s'\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "by fastforce"], ["proof (state)\nthis:\n  store_typing s' \\<S>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "case (set_global s i j v s' vs)"], ["proof (state)\nthis:\n  supdate_glob s i j v = s'\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "obtain insts fs clss bss gs where \"s = \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss, globs = gs\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>insts fs clss bss gs.\n        s =\n        \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n           globs = gs\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using s.cases"], ["proof (prove)\nusing this:\n  (\\<And>inst funcs tab mem globs.\n      ?r =\n      \\<lparr>inst = inst, funcs = funcs, tab = tab, mem = mem,\n         globs = globs\\<rparr> \\<Longrightarrow>\n      ?C) \\<Longrightarrow>\n  ?C\n\ngoal (1 subgoal):\n 1. (\\<And>insts fs clss bss gs.\n        s =\n        \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n           globs = gs\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "moreover"], ["proof (state)\nthis:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "obtain insts' fs' clss' bss' gs' where \"s' = \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss', globs = gs'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>insts' fs' clss' bss' gs'.\n        s' =\n        \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n           globs = gs'\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using s.cases"], ["proof (prove)\nusing this:\n  (\\<And>inst funcs tab mem globs.\n      ?r =\n      \\<lparr>inst = inst, funcs = funcs, tab = tab, mem = mem,\n         globs = globs\\<rparr> \\<Longrightarrow>\n      ?C) \\<Longrightarrow>\n  ?C\n\ngoal (1 subgoal):\n 1. (\\<And>insts' fs' clss' bss' gs'.\n        s' =\n        \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n           globs = gs'\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "moreover"], ["proof (state)\nthis:\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "obtain \\<C>s tfs ns ms tgs where \"\\<S> = \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms, s_globs = tgs\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>s tfs ns ms tgs.\n        \\<S> =\n        \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n           s_globs = tgs\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using s_context.cases"], ["proof (prove)\nusing this:\n  (\\<And>s_inst s_funcs s_tab s_mem s_globs.\n      ?r =\n      \\<lparr>s_inst = s_inst, s_funcs = s_funcs, s_tab = s_tab,\n         s_mem = s_mem, s_globs = s_globs\\<rparr> \\<Longrightarrow>\n      ?C) \\<Longrightarrow>\n  ?C\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>s tfs ns ms tgs.\n        \\<S> =\n        \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n           s_globs = tgs\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "note s_S_defs = calculation"], ["proof (state)\nthis:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "(* Prove that inst, tab and mem are not altered. *)"], ["proof (state)\nthis:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "have\n  \"insts = insts'\"\n  \"fs = fs'\"\n  \"clss = clss'\"\n  \"bss = bss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insts = insts' &&& fs = fs') &&& clss = clss' &&& bss = bss'", "using set_global(1) s_S_defs(1,2)"], ["proof (prove)\nusing this:\n  supdate_glob s i j v = s'\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n\ngoal (1 subgoal):\n 1. (insts = insts' &&& fs = fs') &&& clss = clss' &&& bss = bss'", "unfolding supdate_glob_def supdate_glob_s_def"], ["proof (prove)\nusing this:\n  (let k = sglob_ind s i j\n   in s\\<lparr>s.globs := (s.globs s)\n                 [k := (s.globs s ! k)\\<lparr>g_val := v\\<rparr>]\\<rparr>) =\n  s'\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n\ngoal (1 subgoal):\n 1. (insts = insts' &&& fs = fs') &&& clss = clss' &&& bss = bss'", "by (metis s.ext_inject s.update_convs(5))+"], ["proof (state)\nthis:\n  insts = insts'\n  fs = fs'\n  clss = clss'\n  bss = bss'\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "hence\n  \"list_all2 (inst_typing \\<S>) insts' \\<C>s\"\n  \"list_all2 (cl_typing \\<S>) fs' tfs\"\n  \"list_all (tab_agree \\<S>) (concat clss')\"\n  \"list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns\"\n  \"list_all2 mem_agree bss' ms\""], ["proof (prove)\nusing this:\n  insts = insts'\n  fs = fs'\n  clss = clss'\n  bss = bss'\n\ngoal (1 subgoal):\n 1. (list_all2 (inst_typing \\<S>) insts' \\<C>s &&&\n     list_all2 (cl_typing \\<S>) fs' tfs) &&&\n    list_all (tab_agree \\<S>) (concat clss') &&&\n    list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns &&&\n    list_all2 mem_agree bss' ms", "using set_global(2) s_S_defs"], ["proof (prove)\nusing this:\n  insts = insts'\n  fs = fs'\n  clss = clss'\n  bss = bss'\n  store_typing s \\<S>\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (1 subgoal):\n 1. (list_all2 (inst_typing \\<S>) insts' \\<C>s &&&\n     list_all2 (cl_typing \\<S>) fs' tfs) &&&\n    list_all (tab_agree \\<S>) (concat clss') &&&\n    list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns &&&\n    list_all2 mem_agree bss' ms", "unfolding store_typing.simps"], ["proof (prove)\nusing this:\n  insts = insts'\n  fs = fs'\n  clss = clss'\n  bss = bss'\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     list_all2 (inst_typing \\<S>') insts \\<C>s \\<and>\n     list_all2 (cl_typing \\<S>') fs tfs \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     list_all2 (\\<lambda>tcls n. n \\<le> length tcls) tclss ns \\<and>\n     list_all2 mem_agree bss ms \\<and> list_all2 glob_agree gs tgs\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (1 subgoal):\n 1. (list_all2 (inst_typing \\<S>) insts' \\<C>s &&&\n     list_all2 (cl_typing \\<S>) fs' tfs) &&&\n    list_all (tab_agree \\<S>) (concat clss') &&&\n    list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns &&&\n    list_all2 mem_agree bss' ms", "by auto"], ["proof (state)\nthis:\n  list_all2 (inst_typing \\<S>) insts' \\<C>s\n  list_all2 (cl_typing \\<S>) fs' tfs\n  list_all (tab_agree \\<S>) (concat clss')\n  list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns\n  list_all2 mem_agree bss' ms\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "moreover"], ["proof (state)\nthis:\n  list_all2 (inst_typing \\<S>) insts' \\<C>s\n  list_all2 (cl_typing \\<S>) fs' tfs\n  list_all (tab_agree \\<S>) (concat clss')\n  list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns\n  list_all2 mem_agree bss' ms\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "have \"list_all2 glob_agree gs' tgs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "have gs_agree:\"list_all2 glob_agree gs tgs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs tgs", "using set_global(2) s_S_defs"], ["proof (prove)\nusing this:\n  store_typing s \\<S>\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs tgs", "unfolding store_typing.simps"], ["proof (prove)\nusing this:\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     list_all2 (inst_typing \\<S>') insts \\<C>s \\<and>\n     list_all2 (cl_typing \\<S>') fs tfs \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     list_all2 (\\<lambda>tcls n. n \\<le> length tcls) tclss ns \\<and>\n     list_all2 mem_agree bss ms \\<and> list_all2 glob_agree gs tgs\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs tgs", "by auto"], ["proof (state)\nthis:\n  list_all2 glob_agree gs tgs\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "have \"length gs = length gs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length gs = length gs'", "using s_S_defs(1,2) set_global(1)"], ["proof (prove)\nusing this:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  supdate_glob s i j v = s'\n\ngoal (1 subgoal):\n 1. length gs = length gs'", "unfolding supdate_glob_def supdate_glob_s_def"], ["proof (prove)\nusing this:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  (let k = sglob_ind s i j\n   in s\\<lparr>s.globs := (s.globs s)\n                 [k := (s.globs s ! k)\\<lparr>g_val := v\\<rparr>]\\<rparr>) =\n  s'\n\ngoal (1 subgoal):\n 1. length gs = length gs'", "by (metis length_list_update s.select_convs(5) s.update_convs(5))"], ["proof (state)\nthis:\n  length gs = length gs'\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "moreover"], ["proof (state)\nthis:\n  length gs = length gs'\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "obtain k where k_def:\"(sglob_ind s i j) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        sglob_ind s i j = k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sglob_ind s i j = k\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "hence \"\\<And>j'. \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk> \\<Longrightarrow> gs!j' = gs'!j'\""], ["proof (prove)\nusing this:\n  sglob_ind s i j = k\n\ngoal (1 subgoal):\n 1. \\<And>j'.\n       \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk>\n       \\<Longrightarrow> gs ! j' = gs' ! j'", "using s_S_defs(1,2) set_global(1)"], ["proof (prove)\nusing this:\n  sglob_ind s i j = k\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  supdate_glob s i j v = s'\n\ngoal (1 subgoal):\n 1. \\<And>j'.\n       \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk>\n       \\<Longrightarrow> gs ! j' = gs' ! j'", "unfolding supdate_glob_def supdate_glob_s_def"], ["proof (prove)\nusing this:\n  sglob_ind s i j = k\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  (let k = sglob_ind s i j\n   in s\\<lparr>s.globs := (s.globs s)\n                 [k := (s.globs s ! k)\\<lparr>g_val := v\\<rparr>]\\<rparr>) =\n  s'\n\ngoal (1 subgoal):\n 1. \\<And>j'.\n       \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk>\n       \\<Longrightarrow> gs ! j' = gs' ! j'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> gs ! ?j' = gs' ! ?j'\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "hence \"\\<And>j'. \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk> \\<Longrightarrow> glob_agree (gs'!j') (tgs!j')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> gs ! ?j' = gs' ! ?j'\n\ngoal (1 subgoal):\n 1. \\<And>j'.\n       \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk>\n       \\<Longrightarrow> glob_agree (gs' ! j') (tgs ! j')", "using gs_agree"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> gs ! ?j' = gs' ! ?j'\n  list_all2 glob_agree gs tgs\n\ngoal (1 subgoal):\n 1. \\<And>j'.\n       \\<lbrakk>j' \\<noteq> k; j' < length gs\\<rbrakk>\n       \\<Longrightarrow> glob_agree (gs' ! j') (tgs ! j')", "by (metis list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> glob_agree (gs' ! ?j') (tgs ! ?j')\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> glob_agree (gs' ! ?j') (tgs ! ?j')\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "have \"glob_agree (gs'!k) (tgs!k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v] : (ts _> ts'')\" \"\\<C> \\<turnstile> [Set_global j] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [Set_global j] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis b_e_type_comp2_unlift set_global.prems(2))"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [Set_global j] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "have b_es:\"ts'' = ts@[typeof v]\"\n                \"ts = ts'\"\n                \"global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\"\n                \"j < length (global \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts'' = ts @ [typeof v] &&& ts = ts') &&&\n    global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr> &&&\n    j < length (global \\<C>)", "using b_e_type_value[OF ts''_def(1)] b_e_type_set_global[OF ts''_def(2)]"], ["proof (prove)\nusing this:\n  C v = C ?v \\<Longrightarrow> ts'' = ts @ [typeof ?v]\n  Set_global j = Set_global ?i \\<Longrightarrow>\n  \\<exists>t.\n     ts'' = ts' @ [t] \\<and>\n     global \\<C> ! ?i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr> \\<and>\n     ?i < length (global \\<C>)\n\ngoal (1 subgoal):\n 1. (ts'' = ts @ [typeof v] &&& ts = ts') &&&\n    global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr> &&&\n    j < length (global \\<C>)", "by auto"], ["proof (state)\nthis:\n  ts'' = ts @ [typeof v]\n  ts = ts'\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n  j < length (global \\<C>)\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "hence \"j < length (global ((s_inst \\<S>)!i))\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v]\n  ts = ts'\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n  j < length (global \\<C>)\n\ngoal (1 subgoal):\n 1. j < length (global (s_inst \\<S> ! i))", "using set_global(4)"], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v]\n  ts = ts'\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n  j < length (global \\<C>)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. j < length (global (s_inst \\<S> ! i))", "by fastforce"], ["proof (state)\nthis:\n  j < length (global (s_inst \\<S> ! i))\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "hence globs_agree:\"k < length (s_globs \\<S>)\"\n                        \"glob_agree (gs!k) (tgs!k)\"\n                        \"(tgs!k) = (global \\<C>)!j\""], ["proof (prove)\nusing this:\n  j < length (global (s_inst \\<S> ! i))\n\ngoal (1 subgoal):\n 1. k < length (s_globs \\<S>) &&&\n    glob_agree (gs ! k) (tgs ! k) &&& tgs ! k = global \\<C> ! j", "using store_typing_imp_glob_agree[OF set_global(2,5)] b_es(4) s_S_defs(1,3) k_def set_global(4)"], ["proof (prove)\nusing this:\n  j < length (global (s_inst \\<S> ! i))\n  ?j < length (global (s_inst \\<S> ! i)) \\<Longrightarrow>\n  sglob_ind s i ?j < length (s_globs \\<S>)\n  ?j < length (global (s_inst \\<S> ! i)) \\<Longrightarrow>\n  glob_agree (sglob s i ?j) (s_globs \\<S> ! sglob_ind s i ?j)\n  ?j < length (global (s_inst \\<S> ! i)) \\<Longrightarrow>\n  s_globs \\<S> ! sglob_ind s i ?j = global (s_inst \\<S> ! i) ! ?j\n  j < length (global \\<C>)\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n  sglob_ind s i j = k\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. k < length (s_globs \\<S>) &&&\n    glob_agree (gs ! k) (tgs ! k) &&& tgs ! k = global \\<C> ! j", "unfolding sglob_def"], ["proof (prove)\nusing this:\n  j < length (global (s_inst \\<S> ! i))\n  ?j < length (global (s_inst \\<S> ! i)) \\<Longrightarrow>\n  sglob_ind s i ?j < length (s_globs \\<S>)\n  ?j < length (global (s_inst \\<S> ! i)) \\<Longrightarrow>\n  glob_agree (s.globs s ! sglob_ind s i ?j)\n   (s_globs \\<S> ! sglob_ind s i ?j)\n  ?j < length (global (s_inst \\<S> ! i)) \\<Longrightarrow>\n  s_globs \\<S> ! sglob_ind s i ?j = global (s_inst \\<S> ! i) ! ?j\n  j < length (global \\<C>)\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n  sglob_ind s i j = k\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. k < length (s_globs \\<S>) &&&\n    glob_agree (gs ! k) (tgs ! k) &&& tgs ! k = global \\<C> ! j", "by auto"], ["proof (state)\nthis:\n  k < length (s_globs \\<S>)\n  glob_agree (gs ! k) (tgs ! k)\n  tgs ! k = global \\<C> ! j\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "hence \"g_mut (gs!k) = T_mut\"\n            \"typeof (g_val (gs!k)) = typeof v\""], ["proof (prove)\nusing this:\n  k < length (s_globs \\<S>)\n  glob_agree (gs ! k) (tgs ! k)\n  tgs ! k = global \\<C> ! j\n\ngoal (1 subgoal):\n 1. g_mut (gs ! k) = T_mut &&& typeof (g_val (gs ! k)) = typeof v", "using b_es(3)"], ["proof (prove)\nusing this:\n  k < length (s_globs \\<S>)\n  glob_agree (gs ! k) (tgs ! k)\n  tgs ! k = global \\<C> ! j\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n\ngoal (1 subgoal):\n 1. g_mut (gs ! k) = T_mut &&& typeof (g_val (gs ! k)) = typeof v", "unfolding glob_agree_def"], ["proof (prove)\nusing this:\n  k < length (s_globs \\<S>)\n  tg_mut (tgs ! k) = g_mut (gs ! k) \\<and>\n  tg_t (tgs ! k) = typeof (g_val (gs ! k))\n  tgs ! k = global \\<C> ! j\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n\ngoal (1 subgoal):\n 1. g_mut (gs ! k) = T_mut &&& typeof (g_val (gs ! k)) = typeof v", "by auto"], ["proof (state)\nthis:\n  g_mut (gs ! k) = T_mut\n  typeof (g_val (gs ! k)) = typeof v\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "hence \"g_mut (gs'!k) = T_mut\"\n            \"typeof (g_val (gs'!k)) = typeof v\""], ["proof (prove)\nusing this:\n  g_mut (gs ! k) = T_mut\n  typeof (g_val (gs ! k)) = typeof v\n\ngoal (1 subgoal):\n 1. g_mut (gs' ! k) = T_mut &&& typeof (g_val (gs' ! k)) = typeof v", "using set_global(1) k_def globs_agree(1) store_typing_imp_glob_length_eq[OF set_global(2)] s_S_defs(1,2)"], ["proof (prove)\nusing this:\n  g_mut (gs ! k) = T_mut\n  typeof (g_val (gs ! k)) = typeof v\n  supdate_glob s i j v = s'\n  sglob_ind s i j = k\n  k < length (s_globs \\<S>)\n  length (s.globs s) = length (s_globs \\<S>)\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n\ngoal (1 subgoal):\n 1. g_mut (gs' ! k) = T_mut &&& typeof (g_val (gs' ! k)) = typeof v", "unfolding supdate_glob_def supdate_glob_s_def"], ["proof (prove)\nusing this:\n  g_mut (gs ! k) = T_mut\n  typeof (g_val (gs ! k)) = typeof v\n  (let k = sglob_ind s i j\n   in s\\<lparr>s.globs := (s.globs s)\n                 [k := (s.globs s ! k)\\<lparr>g_val := v\\<rparr>]\\<rparr>) =\n  s'\n  sglob_ind s i j = k\n  k < length (s_globs \\<S>)\n  length (s.globs s) = length (s_globs \\<S>)\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n\ngoal (1 subgoal):\n 1. g_mut (gs' ! k) = T_mut &&& typeof (g_val (gs' ! k)) = typeof v", "by auto"], ["proof (state)\nthis:\n  g_mut (gs' ! k) = T_mut\n  typeof (g_val (gs' ! k)) = typeof v\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  g_mut (gs' ! k) = T_mut\n  typeof (g_val (gs' ! k)) = typeof v\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "using globs_agree(3) b_es(3)"], ["proof (prove)\nusing this:\n  g_mut (gs' ! k) = T_mut\n  typeof (g_val (gs' ! k)) = typeof v\n  tgs ! k = global \\<C> ! j\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n\ngoal (1 subgoal):\n 1. glob_agree (gs' ! k) (tgs ! k)", "unfolding glob_agree_def"], ["proof (prove)\nusing this:\n  g_mut (gs' ! k) = T_mut\n  typeof (g_val (gs' ! k)) = typeof v\n  tgs ! k = global \\<C> ! j\n  global \\<C> ! j = \\<lparr>tg_mut = T_mut, tg_t = typeof v\\<rparr>\n\ngoal (1 subgoal):\n 1. tg_mut (tgs ! k) = g_mut (gs' ! k) \\<and>\n    tg_t (tgs ! k) = typeof (g_val (gs' ! k))", "by fastforce"], ["proof (state)\nthis:\n  glob_agree (gs' ! k) (tgs ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  glob_agree (gs' ! k) (tgs ! k)\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "ultimately"], ["proof (chain)\npicking this:\n  length gs = length gs'\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> glob_agree (gs' ! ?j') (tgs ! ?j')\n  glob_agree (gs' ! k) (tgs ! k)", "show ?thesis"], ["proof (prove)\nusing this:\n  length gs = length gs'\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> glob_agree (gs' ! ?j') (tgs ! ?j')\n  glob_agree (gs' ! k) (tgs ! k)\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "using gs_agree"], ["proof (prove)\nusing this:\n  length gs = length gs'\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> glob_agree (gs' ! ?j') (tgs ! ?j')\n  glob_agree (gs' ! k) (tgs ! k)\n  list_all2 glob_agree gs tgs\n\ngoal (1 subgoal):\n 1. list_all2 glob_agree gs' tgs", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length gs = length gs'\n  \\<lbrakk>?j' \\<noteq> k; ?j' < length gs\\<rbrakk>\n  \\<Longrightarrow> glob_agree (gs' ! ?j') (tgs ! ?j')\n  glob_agree (gs' ! k) (tgs ! k)\n  length gs = length tgs \\<and>\n  (\\<forall>i<length gs. glob_agree (gs ! i) (tgs ! i))\n\ngoal (1 subgoal):\n 1. length gs' = length tgs \\<and>\n    (\\<forall>i<length gs'. glob_agree (gs' ! i) (tgs ! i))", "by fastforce"], ["proof (state)\nthis:\n  list_all2 glob_agree gs' tgs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 glob_agree gs' tgs\n\ngoal (23 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j v s' vs \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s' \\<S>\nA total of 23 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n  list_all2 (inst_typing \\<S>) insts' \\<C>s\n  list_all2 (cl_typing \\<S>) fs' tfs\n  list_all (tab_agree \\<S>) (concat clss')\n  list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns\n  list_all2 mem_agree bss' ms\n  list_all2 glob_agree gs' tgs", "show ?case"], ["proof (prove)\nusing this:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n  list_all2 (inst_typing \\<S>) insts' \\<C>s\n  list_all2 (cl_typing \\<S>) fs' tfs\n  list_all (tab_agree \\<S>) (concat clss')\n  list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns\n  list_all2 mem_agree bss' ms\n  list_all2 glob_agree gs' tgs\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "using store_typing.intros"], ["proof (prove)\nusing this:\n  s =\n  \\<lparr>inst = insts, funcs = fs, tab = clss, mem = bss,\n     globs = gs\\<rparr>\n  s' =\n  \\<lparr>inst = insts', funcs = fs', tab = clss', mem = bss',\n     globs = gs'\\<rparr>\n  \\<S> =\n  \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n     s_globs = tgs\\<rparr>\n  list_all2 (inst_typing \\<S>) insts' \\<C>s\n  list_all2 (cl_typing \\<S>) fs' tfs\n  list_all (tab_agree \\<S>) (concat clss')\n  list_all2 (\\<lambda>cls n. n \\<le> length cls) clss' ns\n  list_all2 mem_agree bss' ms\n  list_all2 glob_agree gs' tgs\n  \\<lbrakk>?\\<S> =\n           \\<lparr>s_inst = ?\\<C>s, s_funcs = ?tfs, s_tab = ?ns,\n              s_mem = ?ms, s_globs = ?tgs\\<rparr>;\n   list_all2 (inst_typing ?\\<S>) ?insts ?\\<C>s;\n   list_all2 (cl_typing ?\\<S>) ?fs ?tfs;\n   list_all (tab_agree ?\\<S>) (concat ?tclss);\n   list_all2 (\\<lambda>tcls n. n \\<le> length tcls) ?tclss ?ns;\n   list_all2 mem_agree ?bss ?ms; list_all2 glob_agree ?gs ?tgs\\<rbrakk>\n  \\<Longrightarrow> store_typing\n                     \\<lparr>inst = ?insts, funcs = ?fs, tab = ?tclss,\n                        mem = ?bss, globs = ?gs\\<rparr>\n                     ?\\<S>\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "by simp"], ["proof (state)\nthis:\n  store_typing s' \\<S>\n\ngoal (22 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 22 subgoals...", "(* The following are all special cases of store_preserved_mem. *)"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 22 subgoals...", "case (store_Some t v s i j m k off mem' vs a)"], ["proof (state)\nthis:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = Some mem'\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (22 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 22 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>", "using store_preserved_mem[OF store_Some(5) _ _ store_Some(3)] store_size[OF store_Some(4)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s' = s\\<lparr>s.mem := (s.mem s)[j := ?mem']\\<rparr>;\n   mem_size m \\<le> mem_size ?mem'\\<rbrakk>\n  \\<Longrightarrow> store_typing ?s' \\<S>\n  mem_size m = mem_size mem'\n\ngoal (1 subgoal):\n 1. store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>", "by fastforce"], ["proof (state)\nthis:\n  store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>\n\ngoal (21 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 21 subgoals...", "case (store_packed_Some t v s i j m k off tp mem' vs a)"], ["proof (state)\nthis:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (21 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 21 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>", "using store_preserved_mem[OF store_packed_Some(5) _ _ store_packed_Some(3)] store_packed_size[OF store_packed_Some(4)]"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n  \\<lbrakk>?s' = s\\<lparr>s.mem := (s.mem s)[j := ?mem']\\<rparr>;\n   mem_size m \\<le> mem_size ?mem'\\<rbrakk>\n  \\<Longrightarrow> store_typing ?s' \\<S>\n  mem_size m = mem_size mem'\n\ngoal (1 subgoal):\n 1. store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>", "by simp"], ["proof (state)\nthis:\n  store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>\n\ngoal (20 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 20 subgoals...", "case (grow_memory s i j n mem c mem' vs)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = n\n  mem_size n = mem\n  mem_grow n (nat_of_int c) = mem'\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (20 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 20 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>", "using store_preserved_mem[OF grow_memory(5)_ _ grow_memory(2)] mem_grow_size[OF grow_memory(4)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s' = s\\<lparr>s.mem := (s.mem s)[j := ?mem']\\<rparr>;\n   mem_size n \\<le> mem_size ?mem'\\<rbrakk>\n  \\<Longrightarrow> store_typing ?s' \\<S>\n  mem_size n + 64000 * nat_of_int c = mem_size mem'\n\ngoal (1 subgoal):\n 1. store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>", "by simp"], ["proof (state)\nthis:\n  store_typing (s\\<lparr>s.mem := (s.mem s)[j := mem']\\<rparr>) \\<S>\n\ngoal (19 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 19 subgoals...", "case (label s vs es i s' vs' es' k lholed les les')"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  \\<lbrakk>store_typing s \\<S>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts';\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n      label := ?arb_label, return := ?arb_return\\<rparr>;\n   i < length (s_inst \\<S>)\\<rbrakk>\n  \\<Longrightarrow> store_typing s' \\<S>\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n  i < length (s_inst \\<S>)\n\ngoal (19 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 19 subgoals...", "obtain \\<C>' t1s t2s arb_label' arb_return' where es_def:\"\\<C>' = \\<C>\\<lparr>label := arb_label', return := arb_return'\\<rparr>\" \"\\<S>\\<bullet>\\<C>' \\<turnstile> es : (t1s _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>'' arb_return' arb_label' t1s t2s.\n        \\<lbrakk>\\<C>'' = \\<C>\n                 \\<lparr>label := arb_label', return := arb_return'\\<rparr>;\n         \\<S>\\<bullet>\\<C>'' \\<turnstile> es : t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using types_exist_lfilled_weak[OF label(2,6)]"], ["proof (prove)\nusing this:\n  \\<exists>t1s t2s \\<C>'' arb_label arb_return. \\<S>\\<bullet>\\<C>\n     \\<lparr>label := arb_label,\n        return := arb_return\\<rparr> \\<turnstile> es : t1s _> t2s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>'' arb_return' arb_label' t1s t2s.\n        \\<lbrakk>\\<C>'' = \\<C>\n                 \\<lparr>label := arb_label', return := arb_return'\\<rparr>;\n         \\<S>\\<bullet>\\<C>'' \\<turnstile> es : t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C>' = \\<C>\\<lparr>label := arb_label', return := arb_return'\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : t1s _> t2s\n\ngoal (19 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<C>' = \\<C>\\<lparr>label := arb_label', return := arb_return'\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : t1s _> t2s\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "using label(4)[OF label(5) es_def(2) _ label(8)] label(7)"], ["proof (prove)\nusing this:\n  \\<C>' = \\<C>\\<lparr>label := arb_label', return := arb_return'\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : t1s _> t2s\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := ?arb_label, return := ?arb_return\\<rparr> \\<Longrightarrow>\n  store_typing s' \\<S>\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := arb_label, return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "by fastforce"], ["proof (state)\nthis:\n  store_typing s' \\<S>\n\ngoal (18 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 18 subgoals...", "case (local s vs es i s' vs' es' v0s n j)"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  \\<lbrakk>store_typing s \\<S>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts';\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n      label := ?arb_label, return := ?arb_return\\<rparr>;\n   i < length (s_inst \\<S>)\\<rbrakk>\n  \\<Longrightarrow> store_typing s' \\<S>\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs es] : ts _> ts'\n  \\<C> = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof v0s,\n     label := arb_label, return := arb_return\\<rparr>\n  j < length (s_inst \\<S>)\n\ngoal (18 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 18 subgoals...", "obtain tls where t_local:\"(\\<S>\\<bullet>((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i)) @ (map typeof vs), return := Some tls\\<rparr> \\<turnstile> es : ([] _> tls))\"\n                           \"ts' = ts @ tls\" \"i < length (s_inst \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        \\<lbrakk>\\<S>\\<bullet>(s_inst \\<S> ! i)\n                 \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n                    return := Some tls\\<rparr> \\<turnstile> es : [] _> tls;\n         ts' = ts @ tls; i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_local[OF local(4)]"], ["proof (prove)\nusing this:\n  \\<exists>tls.\n     i < length (s_inst \\<S>) \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>(s_inst \\<S> ! i)\n     \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n        return := Some tls\\<rparr> \\<turnstile> es : [] _> tls \\<and>\n     ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        \\<lbrakk>\\<S>\\<bullet>(s_inst \\<S> ! i)\n                 \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n                    return := Some tls\\<rparr> \\<turnstile> es : [] _> tls;\n         ts' = ts @ tls; i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  i < length (s_inst \\<S>)\n\ngoal (18 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 18 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "using local(2)[OF local(3) t_local(1) _ t_local(3), of \"(Some tls)\" \"label ((s_inst \\<S>)!i)\" ]"], ["proof (prove)\nusing this:\n  (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> =\n  (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     label := label (s_inst \\<S> ! i),\n     return := Some tls\\<rparr> \\<Longrightarrow>\n  store_typing s' \\<S>\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "by fastforce"], ["proof (state)\nthis:\n  store_typing s' \\<S>\n\ngoal (17 subgoals):\n 1. \\<And>e e' s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 2. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 3. \\<And>s i c cl j tf vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 4. \\<And>s i c cl j vs \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i \\<C> arb_label\n       arb_return tsa ts'.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : tsa _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 7. \\<And>vi j s v vs i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 8. \\<And>vi j s v vs v' i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local :=\n                  local (s_inst \\<S> ! i) @ map typeof (vi @ [v] @ vs),\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 9. \\<And>s vs j i \\<C> arb_label arb_return ts ts'.\n       \\<lbrakk>store_typing s \\<S>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts';\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n           label := arb_label, return := arb_return\\<rparr>;\n        i < length (s_inst \\<S>)\\<rbrakk>\n       \\<Longrightarrow> store_typing s \\<S>\n 10. \\<And>s i j m k off t bs vs a \\<C> arb_label arb_return ts ts'.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts';\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n            label := arb_label, return := arb_return\\<rparr>;\n         i < length (s_inst \\<S>)\\<rbrakk>\n        \\<Longrightarrow> store_typing s \\<S>\nA total of 17 subgoals...", "qed (simp_all)"], ["", "lemma store_preserved:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"store_typing s' \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "using store_preserved1[OF assms(1,2), of _ \"[]\" \"ts\" None \"label (s_inst \\<S>!i)\"]\n          s_type_unfold[OF assms(3)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<S>\\<bullet>?\\<C> \\<turnstile> es : [] _> ts;\n   ?\\<C> =\n   return_update Map.empty\n    ((s_inst \\<S> ! i)\n     \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n        label := label (s_inst \\<S> ! i)\\<rparr>);\n   i < length (s_inst \\<S>)\\<rbrakk>\n  \\<Longrightarrow> store_typing s' \\<S>\n  i < length (s_inst \\<S>)\n  None = Some ts \\<or> None = None\n  \\<S>\\<bullet>return_update Map.empty\n                ((s_inst \\<S> ! i)\n                 \\<lparr>local :=\n                           local (s_inst \\<S> ! i) @\n                           map typeof vs\\<rparr>) \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. store_typing s' \\<S>", "by fastforce"], ["proof (state)\nthis:\n  store_typing s' \\<S>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typeof_unop_testop:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"(e = (Unop_i t iop)) \\<or> (e = (Unop_f t fop)) \\<or> (e = (Testop t testop))\"\n  shows \"(typeof v) = t\"\n        \"e = (Unop_f t fop) \\<Longrightarrow> is_float_t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = t &&& (e = Unop_f t fop \\<Longrightarrow> is_float_t t)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. typeof v = t\n 2. e = Unop_f t fop \\<Longrightarrow> is_float_t t", "have  \"\\<C> \\<turnstile> [C v, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "using unlift_b_e assms(1)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (2 subgoals):\n 1. typeof v = t\n 2. e = Unop_f t fop \\<Longrightarrow> is_float_t t", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v] : (ts _> ts'')\" \"\\<C> \\<turnstile> [e] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v] @ [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (2 subgoals):\n 1. typeof v = t\n 2. e = Unop_f t fop \\<Longrightarrow> is_float_t t", "show \"(typeof v) = t\" \"e = (Unop_f t fop) \\<Longrightarrow> is_float_t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = t &&& (e = Unop_f t fop \\<Longrightarrow> is_float_t t)", "using b_e_type_value[OF ts''_def(1)] assms(2) b_e_type_unop_testop[OF ts''_def(2)]"], ["proof (prove)\nusing this:\n  C v = C ?v \\<Longrightarrow> ts'' = ts @ [typeof ?v]\n  e = Unop_i t iop \\<or> e = Unop_f t fop \\<or> e = Testop t testop\n  e = Unop_i ?t ?iop \\<or>\n  e = Unop_f ?t ?fop \\<or> e = Testop ?t ?testop \\<Longrightarrow>\n  \\<exists>ts''a.\n     ts'' = ts''a @ [?t] \\<and> ts' = ts''a @ [arity_1_result e]\n  \\<lbrakk>e = Unop_i ?t ?iop \\<or>\n           e = Unop_f ?t ?fop \\<or> e = Testop ?t ?testop;\n   e = Unop_f ?t ?fop\\<rbrakk>\n  \\<Longrightarrow> is_float_t ?t\n\ngoal (1 subgoal):\n 1. typeof v = t &&& (e = Unop_f t fop \\<Longrightarrow> is_float_t t)", "by simp_all"], ["proof (state)\nthis:\n  typeof v = t\n  e = Unop_f t fop \\<Longrightarrow> is_float_t t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typeof_cvtop:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"e = Cvtop t1 cvtop t sx\"\n  shows \"(typeof v) = t\"\n        \"cvtop = Convert \\<Longrightarrow> (t1 \\<noteq> t) \\<and> ((sx = None) = ((is_float_t t1 \\<and> is_float_t t) \\<or> (is_int_t t1 \\<and> is_int_t t \\<and> (t_length t1 < t_length t))))\"\n        \"cvtop = Reinterpret \\<Longrightarrow> (t1 \\<noteq> t) \\<and> t_length t1 = t_length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = t &&&\n    (cvtop = Convert \\<Longrightarrow>\n     t1 \\<noteq> t \\<and>\n     (sx = None) =\n     (is_float_t t1 \\<and> is_float_t t \\<or>\n      is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)) &&&\n    (cvtop = Reinterpret \\<Longrightarrow>\n     t1 \\<noteq> t \\<and> t_length t1 = t_length t)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. typeof v = t\n 2. cvtop = Convert \\<Longrightarrow>\n    t1 \\<noteq> t \\<and>\n    (sx = None) =\n    (is_float_t t1 \\<and> is_float_t t \\<or>\n     is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)\n 3. cvtop = Reinterpret \\<Longrightarrow>\n    t1 \\<noteq> t \\<and> t_length t1 = t_length t", "have  \"\\<C> \\<turnstile> [C v, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "using unlift_b_e assms(1)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (3 subgoals):\n 1. typeof v = t\n 2. cvtop = Convert \\<Longrightarrow>\n    t1 \\<noteq> t \\<and>\n    (sx = None) =\n    (is_float_t t1 \\<and> is_float_t t \\<or>\n     is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)\n 3. cvtop = Reinterpret \\<Longrightarrow>\n    t1 \\<noteq> t \\<and> t_length t1 = t_length t", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v] : (ts _> ts'')\" \"\\<C> \\<turnstile> [e] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v] @ [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (3 subgoals):\n 1. typeof v = t\n 2. cvtop = Convert \\<Longrightarrow>\n    t1 \\<noteq> t \\<and>\n    (sx = None) =\n    (is_float_t t1 \\<and> is_float_t t \\<or>\n     is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)\n 3. cvtop = Reinterpret \\<Longrightarrow>\n    t1 \\<noteq> t \\<and> t_length t1 = t_length t", "show \"(typeof v) = t\"\n       \"cvtop = Convert \\<Longrightarrow> (t1 \\<noteq> t) \\<and> (sx = None) = ((is_float_t t1 \\<and> is_float_t t) \\<or> (is_int_t t1 \\<and> is_int_t t \\<and> (t_length t1 < t_length t)))\"\n       \"cvtop = Reinterpret \\<Longrightarrow> (t1 \\<noteq> t) \\<and> t_length t1 = t_length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = t &&&\n    (cvtop = Convert \\<Longrightarrow>\n     t1 \\<noteq> t \\<and>\n     (sx = None) =\n     (is_float_t t1 \\<and> is_float_t t \\<or>\n      is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)) &&&\n    (cvtop = Reinterpret \\<Longrightarrow>\n     t1 \\<noteq> t \\<and> t_length t1 = t_length t)", "using b_e_type_value[OF ts''_def(1)] b_e_type_cvtop[OF ts''_def(2) assms(2)]"], ["proof (prove)\nusing this:\n  C v = C ?v \\<Longrightarrow> ts'' = ts @ [typeof ?v]\n  \\<exists>ts''a. ts'' = ts''a @ [t] \\<and> ts' = ts''a @ [arity_1_result e]\n  cvtop = Convert \\<Longrightarrow>\n  t1 \\<noteq> t \\<and>\n  (sx = None) =\n  (is_float_t t1 \\<and> is_float_t t \\<or>\n   is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)\n  cvtop = Reinterpret \\<Longrightarrow>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t\n\ngoal (1 subgoal):\n 1. typeof v = t &&&\n    (cvtop = Convert \\<Longrightarrow>\n     t1 \\<noteq> t \\<and>\n     (sx = None) =\n     (is_float_t t1 \\<and> is_float_t t \\<or>\n      is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)) &&&\n    (cvtop = Reinterpret \\<Longrightarrow>\n     t1 \\<noteq> t \\<and> t_length t1 = t_length t)", "by simp_all"], ["proof (state)\nthis:\n  typeof v = t\n  cvtop = Convert \\<Longrightarrow>\n  t1 \\<noteq> t \\<and>\n  (sx = None) =\n  (is_float_t t1 \\<and> is_float_t t \\<or>\n   is_int_t t1 \\<and> is_int_t t \\<and> t_length t1 < t_length t)\n  cvtop = Reinterpret \\<Longrightarrow>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_unop_testop_cvtop:\n  assumes \"\\<lparr>[$C v, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"(e = (Unop_i t iop)) \\<or> (e = (Unop_f t fop)) \\<or> (e = (Testop t testop))  \\<or> (e = (Cvtop t2 cvtop t sx))\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "have  \"\\<C> \\<turnstile> [C v, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v] : (ts _> ts'')\" \"\\<C> \\<turnstile> [e] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v] @ [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "have \"ts@[arity_1_result e] = ts'\" \"(typeof v) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts @ [arity_1_result e] = ts' &&& typeof v = t", "using b_e_type_value[OF ts''_def(1)] assms(3) b_e_type_unop_testop(1)[OF ts''_def(2)]\n          b_e_type_cvtop(1)[OF ts''_def(2)]"], ["proof (prove)\nusing this:\n  C v = C ?v \\<Longrightarrow> ts'' = ts @ [typeof ?v]\n  e = Unop_i t iop \\<or>\n  e = Unop_f t fop \\<or> e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx\n  e = Unop_i ?t ?iop \\<or>\n  e = Unop_f ?t ?fop \\<or> e = Testop ?t ?testop \\<Longrightarrow>\n  \\<exists>ts''a.\n     ts'' = ts''a @ [?t] \\<and> ts' = ts''a @ [arity_1_result e]\n  e = Cvtop ?t1.0 ?cvtop ?t ?sx \\<Longrightarrow>\n  \\<exists>ts''a.\n     ts'' = ts''a @ [?t] \\<and> ts' = ts''a @ [arity_1_result e]\n\ngoal (1 subgoal):\n 1. ts @ [arity_1_result e] = ts' &&& typeof v = t", "by (metis butlast_snoc, metis last_snoc)"], ["proof (state)\nthis:\n  ts @ [arity_1_result e] = ts'\n  typeof v = t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts @ [arity_1_result e] = ts'\n  typeof v = t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "have \"arity_1_result e = typeof (v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_1_result e = typeof v'", "using assms(1,3)"], ["proof (prove)\nusing this:\n  \\<lparr>[$C v, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v']\\<rparr>\n  e = Unop_i t iop \\<or>\n  e = Unop_f t fop \\<or> e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx\n\ngoal (1 subgoal):\n 1. arity_1_result e = typeof v'", "apply (cases rule: reduce_simple.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>c iopa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        v = ConstInt32 c; e = Unop_i T_i32 iopa;\n        v' = ConstInt32 (app_unop_i iopa c)\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 2. \\<And>c iopa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        v = ConstInt64 c; e = Unop_i T_i64 iopa;\n        v' = ConstInt64 (app_unop_i iopa c)\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 3. \\<And>c fopa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        v = ConstFloat32 c; e = Unop_f T_f32 fopa;\n        v' = ConstFloat32 (app_unop_f fopa c)\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 4. \\<And>c fopa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        v = ConstFloat64 c; e = Unop_f T_f64 fopa;\n        v' = ConstFloat64 (app_unop_f fopa c)\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 5. \\<And>c testopa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        v = ConstInt32 c; e = Testop T_i32 testopa;\n        v' = ConstInt32 (wasm_bool (app_testop_i testopa c))\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 6. \\<And>c testopa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        v = ConstInt64 c; e = Testop T_i64 testopa;\n        v' = ConstInt32 (wasm_bool (app_testop_i testopa c))\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 7. \\<And>t1 t2a sxa.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        e = Cvtop t2a Convert t1 sxa; types_agree t1 v;\n        cvt t2a sxa v = Some v'\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'\n 8. \\<And>t1 t2a.\n       \\<lbrakk>e = Unop_i t iop \\<or>\n                e = Unop_f t fop \\<or>\n                e = Testop t testop \\<or> e = Cvtop t2 cvtop t sx;\n        e = Cvtop t2a Reinterpret t1 None;\n        v' = wasm_deserialise (bits v) t2a; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> arity_1_result e = typeof v'", "apply (simp_all add: arity_1_result_def wasm_deserialise_type t_cvt)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>T_i32 = t; v = ConstInt32 c; e = Unop_i T_i32 iop;\n        v' = ConstInt32 (app_unop_i iop c)\\<rbrakk>\n       \\<Longrightarrow> T_i32 = typeof (ConstInt32 (app_unop_i iop c))\n 2. \\<And>c.\n       \\<lbrakk>T_i64 = t; v = ConstInt64 c; e = Unop_i T_i64 iop;\n        v' = ConstInt64 (app_unop_i iop c)\\<rbrakk>\n       \\<Longrightarrow> T_i64 = typeof (ConstInt64 (app_unop_i iop c))\n 3. \\<And>c.\n       \\<lbrakk>T_f32 = t; v = ConstFloat32 c; e = Unop_f T_f32 fop;\n        v' = ConstFloat32 (app_unop_f fop c)\\<rbrakk>\n       \\<Longrightarrow> T_f32 = typeof (ConstFloat32 (app_unop_f fop c))\n 4. \\<And>c.\n       \\<lbrakk>T_f64 = t; v = ConstFloat64 c; e = Unop_f T_f64 fop;\n        v' = ConstFloat64 (app_unop_f fop c)\\<rbrakk>\n       \\<Longrightarrow> T_f64 = typeof (ConstFloat64 (app_unop_f fop c))\n 5. \\<And>c.\n       \\<lbrakk>T_i32 = t; v = ConstInt32 c; e = Testop T_i32 testop;\n        v' = ConstInt32 (wasm_bool (app_testop_i testop c))\\<rbrakk>\n       \\<Longrightarrow> T_i32 =\n                         typeof\n                          (ConstInt32 (wasm_bool (app_testop_i testop c)))\n 6. \\<And>c.\n       \\<lbrakk>T_i64 = t; v = ConstInt64 c; e = Testop T_i64 testop;\n        v' = ConstInt32 (wasm_bool (app_testop_i testop c))\\<rbrakk>\n       \\<Longrightarrow> T_i32 =\n                         typeof\n                          (ConstInt32 (wasm_bool (app_testop_i testop c)))", "apply (auto simp add: typeof_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  arity_1_result e = typeof v'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C v'] : ([] _> [arity_1_result e])\""], ["proof (prove)\nusing this:\n  arity_1_result e = typeof v'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e]", "using b_e_typing.const"], ["proof (prove)\nusing this:\n  arity_1_result e = typeof v'\n  ?\\<C> \\<turnstile> [C ?v] : [] _> [typeof ?v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e]", "by metis"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts @ [arity_1_result e] = ts'\n  typeof v = t\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e]", "show \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  ts @ [arity_1_result e] = ts'\n  typeof v = t\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "using e_typing_s_typing.intros(1)\n          b_e_typing.weakening[of \\<C> \"[C v']\" \"[]\" \"[arity_1_result e]\" ts]"], ["proof (prove)\nusing this:\n  ts @ [arity_1_result e] = ts'\n  typeof v = t\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e]\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_1_result e] \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v'] : ts @ [] _> ts @ [arity_1_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typeof_binop_relop:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $e] : (ts _> ts')\"\n          \"e = Binop_i t iop \\<or> e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\"\n  shows \"typeof v1 = t\"\n        \"typeof v2 = t\"\n        \"e = Binop_f t fop \\<Longrightarrow> is_float_t t\"\n        \"e = Relop_f t frop \\<Longrightarrow> is_float_t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof v1 = t &&& typeof v2 = t) &&&\n    (e = Binop_f t fop \\<Longrightarrow> is_float_t t) &&&\n    (e = Relop_f t frop \\<Longrightarrow> is_float_t t)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. typeof v1 = t\n 2. typeof v2 = t\n 3. e = Binop_f t fop \\<Longrightarrow> is_float_t t\n 4. e = Relop_f t frop \\<Longrightarrow> is_float_t t", "have \"\\<C> \\<turnstile> [C v1, C v2, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'", "using unlift_b_e assms(1)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'\n\ngoal (4 subgoals):\n 1. typeof v1 = t\n 2. typeof v2 = t\n 3. e = Binop_f t fop \\<Longrightarrow> is_float_t t\n 4. e = Relop_f t frop \\<Longrightarrow> is_float_t t", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v1, C v2] : (ts _> ts'')\" \"\\<C> \\<turnstile> [e] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v1, C v2] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v1, C v2]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v1, C v2] @ [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v1, C v2] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v1, C v2] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (4 subgoals):\n 1. typeof v1 = t\n 2. typeof v2 = t\n 3. e = Binop_f t fop \\<Longrightarrow> is_float_t t\n 4. e = Relop_f t frop \\<Longrightarrow> is_float_t t", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'", "obtain ts_id where ts_id_def:\"ts_id@[t,t] = ts''\" \"ts' = ts_id @ [arity_2_result e]\"\n                                    \"e = Binop_f t fop \\<Longrightarrow> is_float_t t\"\n                                    \"e = Relop_f t frop \\<Longrightarrow> is_float_t t\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_id.\n        \\<lbrakk>ts_id @ [t, t] = ts''; ts' = ts_id @ [arity_2_result e];\n         e = Binop_f t fop \\<Longrightarrow> is_float_t t;\n         e = Relop_f t frop \\<Longrightarrow> is_float_t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) b_e_type_binop_relop[of \\<C> e ts'' ts' t]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n  e = Binop_i t iop \\<or>\n  e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\n  \\<lbrakk>\\<C> \\<turnstile> [e] : ts'' _> ts';\n   e = Binop_i t ?iop \\<or>\n   e = Binop_f t ?fop \\<or>\n   e = Relop_i t ?irop \\<or> e = Relop_f t ?frop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''a.\n                       ts'' = ts''a @ [t, t] \\<and>\n                       ts' = ts''a @ [arity_2_result e]\n  \\<lbrakk>\\<C> \\<turnstile> [e] : ts'' _> ts';\n   e = Binop_i t ?iop \\<or>\n   e = Binop_f t ?fop \\<or> e = Relop_i t ?irop \\<or> e = Relop_f t ?frop;\n   e = Binop_f t ?fop\\<rbrakk>\n  \\<Longrightarrow> is_float_t t\n  \\<lbrakk>\\<C> \\<turnstile> [e] : ts'' _> ts';\n   e = Binop_i t ?iop \\<or>\n   e = Binop_f t ?fop \\<or> e = Relop_i t ?irop \\<or> e = Relop_f t ?frop;\n   e = Relop_f t ?frop\\<rbrakk>\n  \\<Longrightarrow> is_float_t t\n\ngoal (1 subgoal):\n 1. (\\<And>ts_id.\n        \\<lbrakk>ts_id @ [t, t] = ts''; ts' = ts_id @ [arity_2_result e];\n         e = Binop_f t fop \\<Longrightarrow> is_float_t t;\n         e = Relop_f t frop \\<Longrightarrow> is_float_t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ts_id @ [t, t] = ts''\n  ts' = ts_id @ [arity_2_result e]\n  e = Binop_f t fop \\<Longrightarrow> is_float_t t\n  e = Relop_f t frop \\<Longrightarrow> is_float_t t\n\ngoal (4 subgoals):\n 1. typeof v1 = t\n 2. typeof v2 = t\n 3. e = Binop_f t fop \\<Longrightarrow> is_float_t t\n 4. e = Relop_f t frop \\<Longrightarrow> is_float_t t", "thus \"typeof v1 = t\"\n       \"typeof v2 = t\"\n       \"e = Binop_f t fop \\<Longrightarrow> is_float_t t\"\n       \"e = Relop_f t frop \\<Longrightarrow> is_float_t t\""], ["proof (prove)\nusing this:\n  ts_id @ [t, t] = ts''\n  ts' = ts_id @ [arity_2_result e]\n  e = Binop_f t fop \\<Longrightarrow> is_float_t t\n  e = Relop_f t frop \\<Longrightarrow> is_float_t t\n\ngoal (1 subgoal):\n 1. (typeof v1 = t &&& typeof v2 = t) &&&\n    (e = Binop_f t fop \\<Longrightarrow> is_float_t t) &&&\n    (e = Relop_f t frop \\<Longrightarrow> is_float_t t)", "using ts''_def b_e_type_comp[of \\<C> \"[C v1]\" \"C v2\" ts ts''] b_e_type_value2"], ["proof (prove)\nusing this:\n  ts_id @ [t, t] = ts''\n  ts' = ts_id @ [arity_2_result e]\n  e = Binop_f t fop \\<Longrightarrow> is_float_t t\n  e = Relop_f t frop \\<Longrightarrow> is_float_t t\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n  \\<C> \\<turnstile> [C v1] @ [C v2] : ts _> ts'' \\<Longrightarrow>\n  \\<exists>ts'.\n     \\<C> \\<turnstile> [C v1] : ts _> ts' \\<and>\n     \\<C> \\<turnstile> [C v2] : ts' _> ts''\n  ?\\<C> \\<turnstile> [C ?v1.0, C ?v2.0] : ?t1s _> ?t2s \\<Longrightarrow>\n  ?t2s = ?t1s @ [typeof ?v1.0, typeof ?v2.0]\n\ngoal (1 subgoal):\n 1. (typeof v1 = t &&& typeof v2 = t) &&&\n    (e = Binop_f t fop \\<Longrightarrow> is_float_t t) &&&\n    (e = Relop_f t frop \\<Longrightarrow> is_float_t t)", "by fastforce+"], ["proof (state)\nthis:\n  typeof v1 = t\n  typeof v2 = t\n  e = Binop_f t fop \\<Longrightarrow> is_float_t t\n  e = Relop_f t frop \\<Longrightarrow> is_float_t t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_binop_relop:\n  assumes \"\\<lparr>[$C v1, $C v2, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $e] : (ts _> ts')\"\n          \"e = Binop_i t iop \\<or> e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "have \"\\<C> \\<turnstile> [C v1, C v2, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v1, C v2] : (ts _> ts'')\" \"\\<C> \\<turnstile> [e] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v1, C v2] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v1, C v2]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v1, C v2] @ [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v1, C v2] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v1, C v2] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'", "obtain ts_id where ts_id_def:\"ts_id@[t,t] = ts''\" \"ts' = ts_id @ [arity_2_result e]\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_id.\n        \\<lbrakk>ts_id @ [t, t] = ts'';\n         ts' = ts_id @ [arity_2_result e]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) b_e_type_binop_relop[of \\<C> e ts'' ts' t]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n  e = Binop_i t iop \\<or>\n  e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\n  \\<lbrakk>\\<C> \\<turnstile> [e] : ts'' _> ts';\n   e = Binop_i t ?iop \\<or>\n   e = Binop_f t ?fop \\<or>\n   e = Relop_i t ?irop \\<or> e = Relop_f t ?frop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''a.\n                       ts'' = ts''a @ [t, t] \\<and>\n                       ts' = ts''a @ [arity_2_result e]\n  \\<lbrakk>\\<C> \\<turnstile> [e] : ts'' _> ts';\n   e = Binop_i t ?iop \\<or>\n   e = Binop_f t ?fop \\<or> e = Relop_i t ?irop \\<or> e = Relop_f t ?frop;\n   e = Binop_f t ?fop\\<rbrakk>\n  \\<Longrightarrow> is_float_t t\n  \\<lbrakk>\\<C> \\<turnstile> [e] : ts'' _> ts';\n   e = Binop_i t ?iop \\<or>\n   e = Binop_f t ?fop \\<or> e = Relop_i t ?irop \\<or> e = Relop_f t ?frop;\n   e = Relop_f t ?frop\\<rbrakk>\n  \\<Longrightarrow> is_float_t t\n\ngoal (1 subgoal):\n 1. (\\<And>ts_id.\n        \\<lbrakk>ts_id @ [t, t] = ts'';\n         ts' = ts_id @ [arity_2_result e]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ts_id @ [t, t] = ts''\n  ts' = ts_id @ [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C v1] : (ts _> ts_id@[t])\""], ["proof (prove)\nusing this:\n  ts_id @ [t, t] = ts''\n  ts' = ts_id @ [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1] : ts _> ts_id @ [t]", "using ts''_def b_e_type_comp[of \\<C> \"[C v1]\" \"C v2\" ts ts''] b_e_type_value"], ["proof (prove)\nusing this:\n  ts_id @ [t, t] = ts''\n  ts' = ts_id @ [arity_2_result e]\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n  \\<C> \\<turnstile> [C v1] @ [C v2] : ts _> ts'' \\<Longrightarrow>\n  \\<exists>ts'.\n     \\<C> \\<turnstile> [C v1] : ts _> ts' \\<and>\n     \\<C> \\<turnstile> [C v2] : ts' _> ts''\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1] : ts _> ts_id @ [t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1] : ts _> ts_id @ [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "hence \"ts@[arity_2_result e] = ts'\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1] : ts _> ts_id @ [t]\n\ngoal (1 subgoal):\n 1. ts @ [arity_2_result e] = ts'", "using b_e_type_value ts_id_def(2)"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1] : ts _> ts_id @ [t]\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n  ts' = ts_id @ [arity_2_result e]\n\ngoal (1 subgoal):\n 1. ts @ [arity_2_result e] = ts'", "by fastforce"], ["proof (state)\nthis:\n  ts @ [arity_2_result e] = ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts @ [arity_2_result e] = ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "have \"arity_2_result e = typeof (v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_2_result e = typeof v'", "using assms(1,3)"], ["proof (prove)\nusing this:\n  \\<lparr>[$C v1, $C v2, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v']\\<rparr>\n  e = Binop_i t iop \\<or>\n  e = Binop_f t fop \\<or> e = Relop_i t irop \\<or> e = Relop_f t frop\n\ngoal (1 subgoal):\n 1. arity_2_result e = typeof v'", "by (cases rule: reduce_simple.cases) (auto simp add: arity_2_result_def typeof_def)"], ["proof (state)\nthis:\n  arity_2_result e = typeof v'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C v'] : ([] _> [arity_2_result e])\""], ["proof (prove)\nusing this:\n  arity_2_result e = typeof v'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e]", "using b_e_typing.const"], ["proof (prove)\nusing this:\n  arity_2_result e = typeof v'\n  ?\\<C> \\<turnstile> [C ?v] : [] _> [typeof ?v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e]", "by metis"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts @ [arity_2_result e] = ts'\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e]", "show ?thesis"], ["proof (prove)\nusing this:\n  ts @ [arity_2_result e] = ts'\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "using e_typing_s_typing.intros(1)\n          b_e_typing.weakening[of \\<C> \"[C v']\" \"[]\" \"[arity_2_result e]\" ts]"], ["proof (prove)\nusing this:\n  ts @ [arity_2_result e] = ts'\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e]\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  \\<C> \\<turnstile> [C v'] : [] _> [arity_2_result e] \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v'] : ts @ [] _> ts @ [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_drop:\n  assumes \"\\<lparr>[$C v, $e]\\<rparr> \\<leadsto> \\<lparr>[]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : (ts _> ts')\"\n          \"(e = (Drop))\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "have \"\\<C> \\<turnstile> [C v, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C v] : (ts _> ts'')\" \"\\<C> \\<turnstile> [e] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v] @ [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C v] : ts _> ts'';\n         \\<C> \\<turnstile> [e] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "hence \"ts'' = ts@[typeof v]\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [typeof v]", "using b_e_type_value"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [typeof v]", "by blast"], ["proof (state)\nthis:\n  ts'' = ts @ [typeof v]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "hence \"ts = ts'\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v]\n\ngoal (1 subgoal):\n 1. ts = ts'", "using ts''_def assms(3) b_e_type_drop"], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v]\n  \\<C> \\<turnstile> [C v] : ts _> ts''\n  \\<C> \\<turnstile> [e] : ts'' _> ts'\n  e = Drop\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = Drop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t. ?ts = ?ts' @ [t]\n\ngoal (1 subgoal):\n 1. ts = ts'", "by blast"], ["proof (state)\nthis:\n  ts = ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "hence \"\\<C> \\<turnstile> [] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  ts = ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [] : ts _> ts'", "using b_e_type_empty"], ["proof (prove)\nusing this:\n  ts = ts'\n  ?\\<C> \\<turnstile> [] : ?ts _> ?ts' = (?ts = ?ts')\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "using e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [] : ts _> ts'\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_select:\n  assumes \"\\<lparr>[$C v1, $C v2, $C vn, $e]\\<rparr> \\<leadsto> \\<lparr>[$C v3]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $C vn, $e] : (ts _> ts')\"\n          \"(e = Select)\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "have \"\\<C> \\<turnstile> [C v1, C v2, C vn, e] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2, C vn, e] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $C vn, $e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2, C vn, e] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2, C vn, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v1, C v2, C vn, e] : ts _> ts'", "obtain t1s where t1s_def:\"\\<C> \\<turnstile> [C v1, C v2, C vn] : (ts _> t1s)\" \"\\<C> \\<turnstile> [e] : (t1s _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, C vn, e] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>t1s.\n        \\<lbrakk>\\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s;\n         \\<C> \\<turnstile> [e] : t1s _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[where ?e = e and ?es = \"[C v1, C v2, C vn]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, C vn, e] : ts _> ts'\n  ?\\<C> \\<turnstile> [C v1, C v2, C vn] @\n                     [e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C v1, C v2, C vn] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>t1s.\n        \\<lbrakk>\\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s;\n         \\<C> \\<turnstile> [e] : t1s _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s\n  \\<C> \\<turnstile> [e] : t1s _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s\n  \\<C> \\<turnstile> [e] : t1s _> ts'", "obtain t2s t where t2s_def:\"t1s = t2s @ [t, t, (T_i32)]\" \"ts' = t2s@[t]\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s\n  \\<C> \\<turnstile> [e] : t1s _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>t2s t.\n        \\<lbrakk>t1s = t2s @ [t, t, T_i32]; ts' = t2s @ [t]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_select[of \\<C> e t1s] assms"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s\n  \\<C> \\<turnstile> [e] : t1s _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [e] : t1s _> ?ts'; e = Select\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts'' t.\n                       t1s = ts'' @ [t, t, T_i32] \\<and> ?ts' = ts'' @ [t]\n  \\<lparr>[$C v1, $C v2, $C vn,\n           $e]\\<rparr> \\<leadsto> \\<lparr>[$C v3]\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v1, $C v2, $C vn, $e] : ts _> ts'\n  e = Select\n\ngoal (1 subgoal):\n 1. (\\<And>t2s t.\n        \\<lbrakk>t1s = t2s @ [t, t, T_i32]; ts' = t2s @ [t]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t1s = t2s @ [t, t, T_i32]\n  ts' = t2s @ [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C v1, C v2] : (ts _> t2s@[t,t])\""], ["proof (prove)\nusing this:\n  t1s = t2s @ [t, t, T_i32]\n  ts' = t2s @ [t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2] : ts _> t2s @ [t, t]", "using t1s_def t2s_def b_e_type_value_list[of \\<C> \"[C v1, C v2]\" \"vn\" ts \"t2s@[t,t]\"]"], ["proof (prove)\nusing this:\n  t1s = t2s @ [t, t, T_i32]\n  ts' = t2s @ [t]\n  \\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s\n  \\<C> \\<turnstile> [e] : t1s _> ts'\n  t1s = t2s @ [t, t, T_i32]\n  ts' = t2s @ [t]\n  \\<C> \\<turnstile> [C v1, C v2] @\n                    [C vn] : ts _> (t2s @ [t, t]) @ [?t] \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> t2s @ [t, t]\n  \\<C> \\<turnstile> [C v1, C v2] @\n                    [C vn] : ts _> (t2s @ [t, t]) @ [?t] \\<Longrightarrow>\n  typeof vn = ?t\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1, C v2] : ts _> t2s @ [t, t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> t2s @ [t, t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "hence v2_t_def:\"\\<C> \\<turnstile> [C v1] : (ts _> t2s@[t])\" \"typeof v2 = t\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> t2s @ [t, t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1] : ts _> t2s @ [t] &&& typeof v2 = t", "using t1s_def t2s_def b_e_type_value_list[of \\<C> \"[C v1]\" \"v2\" ts \"t2s@[t]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1, C v2] : ts _> t2s @ [t, t]\n  \\<C> \\<turnstile> [C v1, C v2, C vn] : ts _> t1s\n  \\<C> \\<turnstile> [e] : t1s _> ts'\n  t1s = t2s @ [t, t, T_i32]\n  ts' = t2s @ [t]\n  \\<C> \\<turnstile> [C v1] @\n                    [C v2] : ts _> (t2s @ [t]) @ [?t] \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v1] : ts _> t2s @ [t]\n  \\<C> \\<turnstile> [C v1] @\n                    [C v2] : ts _> (t2s @ [t]) @ [?t] \\<Longrightarrow>\n  typeof v2 = ?t\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v1] : ts _> t2s @ [t] &&& typeof v2 = t", "by fastforce+"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v1] : ts _> t2s @ [t]\n  typeof v2 = t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "hence v1_t_def:\"ts = t2s\" \"typeof v1 = t\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1] : ts _> t2s @ [t]\n  typeof v2 = t\n\ngoal (1 subgoal):\n 1. ts = t2s &&& typeof v1 = t", "using b_e_type_value"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v1] : ts _> t2s @ [t]\n  typeof v2 = t\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. ts = t2s &&& typeof v1 = t", "by fastforce+"], ["proof (state)\nthis:\n  ts = t2s\n  typeof v1 = t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "have \"typeof v3 = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v3 = t", "using assms(1) v2_t_def(2) v1_t_def(2)"], ["proof (prove)\nusing this:\n  \\<lparr>[$C v1, $C v2, $C vn,\n           $e]\\<rparr> \\<leadsto> \\<lparr>[$C v3]\\<rparr>\n  typeof v2 = t\n  typeof v1 = t\n\ngoal (1 subgoal):\n 1. typeof v3 = t", "by (cases rule: reduce_simple.cases, simp_all)"], ["proof (state)\nthis:\n  typeof v3 = t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C v3] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  typeof v3 = t\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v3] : ts _> ts'", "using b_e_typing.const b_e_typing.weakening t2s_def(2) v1_t_def(1)"], ["proof (prove)\nusing this:\n  typeof v3 = t\n  ?\\<C> \\<turnstile> [C ?v] : [] _> [typeof ?v]\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  ts' = t2s @ [t]\n  ts = t2s\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v3] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v3] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v3] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "using e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v3] : ts _> ts'\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_block:\n  assumes \"\\<lparr>vs @ [$Block (tn _> tm) es]\\<rparr> \\<leadsto> \\<lparr>[Label m [] (vs @ ($* es))]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Block (tn _> tm) es] : (ts _> ts')\"\n          \"const_list vs\"\n          \"length vs = n\"\n          \"length tn = n\"\n          \"length tm = m\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "obtain \\<C>' where c_def:\"\\<C>' = \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>'.\n        \\<C>' = \\<C>\n        \\<lparr>label := [tm] @ label \\<C>\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<C>' = \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> ts'')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm) es] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm)\n     es] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) e_type_comp[of \\<S> \\<C> vs \"$Block (tn _> tm) es\" ts ts']"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Block (tn _> tm) es] : ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [$Block (tn _> tm)\n                                    es] : ts _> ts' \\<Longrightarrow>\n  \\<exists>ts'a.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'a \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm) es] : ts'a _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm)\n     es] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "hence \"\\<C> \\<turnstile> [Block (tn _> tm) es] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts'", "using unlift_b_e"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm) es] : ts'' _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts'", "by auto"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts'", "obtain ts_c tfn tfm where ts_c_def:\"(tn _> tm) = (tfn _> tfm)\" \"ts'' = ts_c@tfn\" \"ts' = ts_c@tfm\" \" (\\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es : (tn _> tm))\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>tfn tfm ts_c.\n        \\<lbrakk>tn _> tm = tfn _> tfm; ts'' = ts_c @ tfn; ts' = ts_c @ tfm;\n         \\<C>\n         \\<lparr>label :=\n                   [tfm] @\n                   label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_block[of \\<C> \"Block (tn _> tm) es\" ts'' ts' \"(tn _> tm)\" es]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Block (tn _> tm) es] : ts'' _> ts';\n   Block (tn _> tm) es = Block (tn _> tm) es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''a tfn tfm.\n                       tn _> tm = tfn _> tfm \\<and>\n                       ts'' = ts''a @ tfn \\<and>\n                       ts' = ts''a @ tfm \\<and> \\<C>\n                       \\<lparr>label :=\n                                 [tfm] @\n                                 label\n                                  \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n\ngoal (1 subgoal):\n 1. (\\<And>tfn tfm ts_c.\n        \\<lbrakk>tn _> tm = tfn _> tfm; ts'' = ts_c @ tfn; ts' = ts_c @ tfm;\n         \\<C>\n         \\<lparr>label :=\n                   [tfm] @\n                   label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  tn _> tm = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "hence tfn_l:\"length tfn = n\""], ["proof (prove)\nusing this:\n  tn _> tm = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n\ngoal (1 subgoal):\n 1. length tfn = n", "using assms(5)"], ["proof (prove)\nusing this:\n  tn _> tm = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n  length tn = n\n\ngoal (1 subgoal):\n 1. length tfn = n", "by simp"], ["proof (state)\nthis:\n  length tfn = n\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "obtain tvs' where tvs'_def:\"ts'' = ts@tvs'\" \"length tvs' = n\" \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tvs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tvs'.\n        \\<lbrakk>ts'' = ts @ tvs'; length tvs' = n;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list assms(3,4) ts''_def(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  const_list vs\n  length vs = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n\ngoal (1 subgoal):\n 1. (\\<And>tvs'.\n        \\<lbrakk>ts'' = ts @ tvs'; length tvs' = n;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ tvs'\n  length tvs' = n\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tn)\" \"\\<S>\\<bullet>\\<C>' \\<turnstile> $*es : (tn _> tm)\""], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs'\n  length tvs' = n\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tn &&&\n    \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : tn _> tm", "using ts_c_def tvs'_def tfn_l ts''_def c_def e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs'\n  length tvs' = n\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\n  tn _> tm = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n  ts'' = ts @ tvs'\n  length tvs' = n\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\n  length tfn = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Block (tn _> tm) es] : ts'' _> ts'\n  \\<C>' = \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tn &&&\n    \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : tn _> tm", "by simp_all"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tn\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C>' \\<turnstile> (vs @ ($* es)) : ([] _> tm)\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tn\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm", "using e_type_comp_conc"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tn\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : tn _> tm\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n               ?es' : ?t1s _> ?t3s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "have \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (tm _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> tm", "using b_e_type_empty[of \\<C> \"[]\" \"[]\"]\n          e_typing_s_typing.intros(1)[where ?b_es = \"[]\"]\n          e_typing_s_typing.intros(3)[of \\<S> \\<C> \"[]\" \"[]\" \"[]\" \"tm\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [] : [] _> [] = ([] = [])\n  ?\\<C> \\<turnstile> [] : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* [] : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> [] \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm @ [] _> tm @ []\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> tm", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> tm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "using e_typing_s_typing.intros(7)[of \\<S> \\<C> \"[]\" tm _ \"vs @ ($* es)\" m]\n          ts_c_def tvs'_def assms(5,6) e_typing_s_typing.intros(3) c_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> tm\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> tm\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [] : tm _> ?t2s;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             [tm] @\n             label \\<C>\\<rparr> \\<turnstile> vs @ ($* es) : [] _> ?t2s;\n   length tm = m\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Label m []\n               (vs @ ($* es))] : [] _> ?t2s\n  tn _> tm = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n  ts'' = ts @ tvs'\n  length tvs' = n\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs'\n  length tn = n\n  length tm = m\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  \\<C>' = \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label m [] (vs @ ($* es))] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_if:\n  assumes \"\\<lparr>[$C ConstInt32 n, $If tf e1s e2s]\\<rparr> \\<leadsto> \\<lparr>[$Block tf es']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 n, $If tf e1s e2s] : (ts _> ts')\"\n  shows   \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "have \"\\<C> \\<turnstile> [C ConstInt32 n, If tf e1s e2s] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C ConstInt32 n, b_e.If tf e1s e2s] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 n,\n                                  $b_e.If tf e1s e2s] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C ConstInt32 n, b_e.If tf e1s e2s] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 n, b_e.If tf e1s e2s] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C ConstInt32 n, b_e.If tf e1s e2s] : ts _> ts'", "obtain ts_i where ts_i_def:\"\\<C> \\<turnstile> [C ConstInt32 n] : (ts _> ts_i)\" \"\\<C> \\<turnstile> [If tf e1s e2s] : (ts_i _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n, b_e.If tf e1s e2s] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_i.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i;\n         \\<C> \\<turnstile> [b_e.If tf e1s e2s] : ts_i _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n, b_e.If tf e1s e2s] : ts _> ts'\n  ?\\<C> \\<turnstile> ?es @ [?e] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [?e] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts_i.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i;\n         \\<C> \\<turnstile> [b_e.If tf e1s e2s] : ts_i _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Cons append_Nil)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i\n  \\<C> \\<turnstile> [b_e.If tf e1s e2s] : ts_i _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i\n  \\<C> \\<turnstile> [b_e.If tf e1s e2s] : ts_i _> ts'", "obtain ts'' tfn tfm where ts_def:\"tf = (tfn _> tfm)\"\n                                        \"ts_i = ts''@tfn @ [T_i32]\"\n                                        \"ts' = ts''@tfm\"\n                                        \"(\\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e1s : tf)\"\n                                        \"(\\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e2s : tf)\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i\n  \\<C> \\<turnstile> [b_e.If tf e1s e2s] : ts_i _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>tfn tfm ts''.\n        \\<lbrakk>tf = tfn _> tfm; ts_i = ts'' @ tfn @ [T_i32];\n         ts' = ts'' @ tfm;\n         \\<C>\n         \\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e1s : tf;\n         \\<C>\n         \\<lparr>label :=\n                   [tfm] @ label \\<C>\\<rparr> \\<turnstile> e2s : tf\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_if[of \\<C> \"If tf e1s e2s\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i\n  \\<C> \\<turnstile> [b_e.If tf e1s e2s] : ts_i _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [b_e.If tf e1s e2s] : ?ts _> ?ts';\n   b_e.If tf e1s e2s = b_e.If ?tf ?es1.0 ?es2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts'' tfn tfm.\n                       ?tf = tfn _> tfm \\<and>\n                       ?ts = ts'' @ tfn @ [T_i32] \\<and>\n                       ?ts' = ts'' @ tfm \\<and>\n                       \\<C>\n                       \\<lparr>label :=\n                                 [tfm] @\n                                 label\n                                  \\<C>\\<rparr> \\<turnstile> ?es1.0 : ?tf \\<and>\n                       \\<C>\n                       \\<lparr>label :=\n                                 [tfm] @\n                                 label\n                                  \\<C>\\<rparr> \\<turnstile> ?es2.0 : ?tf\n\ngoal (1 subgoal):\n 1. (\\<And>tfn tfm ts''.\n        \\<lbrakk>tf = tfn _> tfm; ts_i = ts'' @ tfn @ [T_i32];\n         ts' = ts'' @ tfm;\n         \\<C>\n         \\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e1s : tf;\n         \\<C>\n         \\<lparr>label :=\n                   [tfm] @ label \\<C>\\<rparr> \\<turnstile> e2s : tf\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  tf = tfn _> tfm\n  ts_i = ts'' @ tfn @ [T_i32]\n  ts' = ts'' @ tfm\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e1s : tf\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e2s : tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "have \"ts_i = ts @ [(T_i32)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_i = ts @ [T_i32]", "using ts_i_def(1) b_e_type_value"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. ts_i = ts @ [T_i32]", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts_i\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' =\n                    ?ts @\n                    [case ?v of ConstInt32 x \\<Rightarrow> T_i32\n                     | ConstInt64 x \\<Rightarrow> T_i64\n                     | ConstFloat32 x \\<Rightarrow> T_f32\n                     | ConstFloat64 x \\<Rightarrow> T_f64]\n\ngoal (1 subgoal):\n 1. ts_i = ts @ [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  ts_i = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts_i = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "have \"(\\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es' : (tfn _> tfm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C>\n    \\<lparr>label :=\n              [tfm] @ label \\<C>\\<rparr> \\<turnstile> es' : tfn _> tfm", "using assms(1) ts_def(4,5) ts_def(1)"], ["proof (prove)\nusing this:\n  \\<lparr>[$C ConstInt32 n,\n           $b_e.If tf e1s\n             e2s]\\<rparr> \\<leadsto> \\<lparr>[$Block tf es']\\<rparr>\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e1s : tf\n  \\<C>\\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> e2s : tf\n  tf = tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<C>\n    \\<lparr>label :=\n              [tfm] @ label \\<C>\\<rparr> \\<turnstile> es' : tfn _> tfm", "by (cases rule: reduce_simple.cases, simp_all)"], ["proof (state)\nthis:\n  \\<C>\n  \\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es' : tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "hence \"\\<C> \\<turnstile> [Block tf es'] : (tfn _> tfm)\""], ["proof (prove)\nusing this:\n  \\<C>\n  \\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es' : tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm", "using ts_def(1) b_e_typing.block[of tf tfn tfm \\<C> es']"], ["proof (prove)\nusing this:\n  \\<C>\n  \\<lparr>label := [tfm] @ label \\<C>\\<rparr> \\<turnstile> es' : tfn _> tfm\n  tf = tfn _> tfm\n  \\<lbrakk>tf = tfn _> tfm;\n   \\<C>\n   \\<lparr>label :=\n             [tfm] @\n             label \\<C>\\<rparr> \\<turnstile> es' : tfn _> tfm\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts_i = ts @ [T_i32]\n  \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm", "show ?thesis"], ["proof (prove)\nusing this:\n  ts_i = ts @ [T_i32]\n  \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "using ts_def(2,3) e_typing_s_typing.intros(1,3)"], ["proof (prove)\nusing this:\n  ts_i = ts @ [T_i32]\n  \\<C> \\<turnstile> [Block tf es'] : tfn _> tfm\n  ts_i = ts'' @ tfn @ [T_i32]\n  ts' = ts'' @ tfm\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Block tf es'] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_tee_local:\n  assumes \"\\<lparr>[v, $Tee_local i]\\<rparr> \\<leadsto> \\<lparr>[v, v, $Set_local i]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [v, $Tee_local i] : (ts _> ts')\"\n          \"is_const v\"\n  shows   \"\\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "obtain bv where bv_def:\"v = $C bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bv. v = $C bv \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using e_type_const_unwrap assms(3)"], ["proof (prove)\nusing this:\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n  is_const v\n\ngoal (1 subgoal):\n 1. (\\<And>bv. v = $C bv \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  v = $C bv\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C bv, Tee_local i] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  v = $C bv\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv, Tee_local i] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  v = $C bv\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [v, $Tee_local i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv, Tee_local i] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C bv, Tee_local i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C bv, Tee_local i] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C bv] : (ts _> ts'')\" \"\\<C> \\<turnstile> [Tee_local i] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv, Tee_local i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C bv] : ts _> ts'';\n         \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[of _ \"[C bv]\" \"Tee_local i\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv, Tee_local i] : ts _> ts'\n  ?\\<C> \\<turnstile> [C bv] @ [Tee_local i] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C bv] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [Tee_local i] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C bv] : ts _> ts'';\n         \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C bv] : ts _> ts''\n  \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C bv] : ts _> ts''\n  \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'", "obtain ts_c t where ts_c_def:\"ts'' = ts_c@[t]\" \"ts' = ts_c@[t]\" \"(local \\<C>)!i = t\" \"i < length(local \\<C>)\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv] : ts _> ts''\n  \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c t.\n        \\<lbrakk>ts'' = ts_c @ [t]; ts' = ts_c @ [t]; local \\<C> ! i = t;\n         i < length (local \\<C>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_tee_local[of \\<C> \"Tee_local i\" ts'' ts' i]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv] : ts _> ts''\n  \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Tee_local i] : ts'' _> ts';\n   Tee_local i = Tee_local i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''a t.\n                       ts'' = ts''a @ [t] \\<and>\n                       ts' = ts''a @ [t] \\<and> local \\<C> ! i = t\n  \\<lbrakk>\\<C> \\<turnstile> [Tee_local i] : ts'' _> ts';\n   Tee_local i = Tee_local i\\<rbrakk>\n  \\<Longrightarrow> i < length (local \\<C>)\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c t.\n        \\<lbrakk>ts'' = ts_c @ [t]; ts' = ts_c @ [t]; local \\<C> ! i = t;\n         i < length (local \\<C>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts_c @ [t]\n  ts' = ts_c @ [t]\n  local \\<C> ! i = t\n  i < length (local \\<C>)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "hence t_bv:\"t = typeof bv\" \"ts = ts_c\""], ["proof (prove)\nusing this:\n  ts'' = ts_c @ [t]\n  ts' = ts_c @ [t]\n  local \\<C> ! i = t\n  i < length (local \\<C>)\n\ngoal (1 subgoal):\n 1. t = typeof bv &&& ts = ts_c", "using b_e_type_value ts''_def"], ["proof (prove)\nusing this:\n  ts'' = ts_c @ [t]\n  ts' = ts_c @ [t]\n  local \\<C> ! i = t\n  i < length (local \\<C>)\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n  \\<C> \\<turnstile> [C bv] : ts _> ts''\n  \\<C> \\<turnstile> [Tee_local i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. t = typeof bv &&& ts = ts_c", "by fastforce+"], ["proof (state)\nthis:\n  t = typeof bv\n  ts = ts_c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "have \"\\<C> \\<turnstile> [Set_local i] : ([t,t] _> [t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]", "using ts_c_def(3,4) b_e_typing.set_local[of i \\<C> t]\n          b_e_typing.weakening[of \\<C> \"[Set_local i]\" \"[t]\" \"[]\" \"[t]\"]"], ["proof (prove)\nusing this:\n  local \\<C> ! i = t\n  i < length (local \\<C>)\n  \\<lbrakk>i < length (local \\<C>); local \\<C> ! i = t\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Set_local i] : [t] _> []\n  \\<C> \\<turnstile> [Set_local i] : [t] _> [] \\<Longrightarrow>\n  \\<C> \\<turnstile> [Set_local i] : [t] @ [t] _> [t] @ []\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "have \"\\<C> \\<turnstile> [C bv] : ([t] _> [t,t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv] : [t] _> [t, t]", "using t_bv b_e_typing.const[of \\<C> bv]  b_e_typing.weakening[of \\<C> \"[C bv]\" \"[]\" \"[t]\" \"[t]\"]"], ["proof (prove)\nusing this:\n  t = typeof bv\n  ts = ts_c\n  \\<C> \\<turnstile> [C bv] : [] _> [typeof bv]\n  \\<C> \\<turnstile> [C bv] : [] _> [t] \\<Longrightarrow>\n  \\<C> \\<turnstile> [C bv] : [t] @ [] _> [t] @ [t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv] : [t] _> [t, t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C bv] : [t] _> [t, t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C bv, C bv] : ([] _> [t,t])\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv] : [t] _> [t, t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv, C bv] : [] _> [t, t]", "using t_bv b_e_typing.const[of \\<C> bv]  b_e_typing.composition[of \\<C> \"[C bv]\" \"[]\" \"[t]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv] : [t] _> [t, t]\n  t = typeof bv\n  ts = ts_c\n  \\<C> \\<turnstile> [C bv] : [] _> [typeof bv]\n  \\<lbrakk>\\<C> \\<turnstile> [C bv] : [] _> [t];\n   \\<C> \\<turnstile> [?e] : [t] _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [C bv] @ [?e] : [] _> ?t3s\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv, C bv] : [] _> [t, t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C bv, C bv] : [] _> [t, t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]\n  \\<C> \\<turnstile> [C bv, C bv] : [] _> [t, t]", "have \"\\<C> \\<turnstile> [C bv, C bv, Set_local i] : (ts _> ts@[t])\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]\n  \\<C> \\<turnstile> [C bv, C bv] : [] _> [t, t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv, C bv, Set_local i] : ts _> ts @ [t]", "using b_e_typing.composition b_e_typing.weakening[of \\<C> \"[C bv, C bv, Set_local i]\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Set_local i] : [t, t] _> [t]\n  \\<C> \\<turnstile> [C bv, C bv] : [] _> [t, t]\n  \\<lbrakk>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<C> \\<turnstile> [?e] : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> ?es @ [?e] : ?t1s _> ?t3s\n  \\<C> \\<turnstile> [C bv, C bv,\n                     Set_local i] : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<C> \\<turnstile> [C bv, C bv, Set_local i] : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C bv, C bv, Set_local i] : ts _> ts @ [t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C bv, C bv, Set_local i] : ts _> ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv, C bv, Set_local i] : ts _> ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "using t_bv(2) ts_c_def(2) bv_def e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C bv, C bv, Set_local i] : ts _> ts @ [t]\n  ts = ts_c\n  ts' = ts_c @ [t]\n  v = $C bv\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [v, v, $Set_local i] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_loop:\n  assumes \"\\<lparr>vs @ [$Loop (t1s _> t2s) es]\\<rparr> \\<leadsto> \\<lparr>[Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))]\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Loop (t1s _> t2s) es] : (ts _> ts')\"\n          \"const_list vs\"\n          \"length vs = n\"\n          \"length t1s = n\"\n          \"length t2s = m\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> ts'')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s)\n     es] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) e_type_comp"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Loop (t1s _> t2s) es] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s)\n     es] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : ts'' _> ts'", "have \"\\<C> \\<turnstile> [Loop (t1s _> t2s) es] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : ts'' _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Loop (t1s _> t2s) es] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts'", "obtain ts_c tfn tfm \\<C>' where t_loop:\"(t1s _> t2s) = (tfn _> tfm)\"\n                                           \"(ts'' = ts_c@tfn)\"\n                                           \"(ts' = ts_c@tfm)\"\n                                           \"\\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>\"\n                                           \"(\\<C>' \\<turnstile> es : (tfn _> tfm))\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>tfn tfm ts_c \\<C>'.\n        \\<lbrakk>t1s _> t2s = tfn _> tfm; ts'' = ts_c @ tfn;\n         ts' = ts_c @ tfm;\n         \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>;\n         \\<C>' \\<turnstile> es : tfn _> tfm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_loop[of \\<C> \"Loop (t1s _> t2s) es\" ts'' ts']"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Loop (t1s _> t2s) es] : ts'' _> ts';\n   Loop (t1s _> t2s) es = Loop ?tf ?es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''a tfn tfm.\n                       ?tf = tfn _> tfm \\<and>\n                       ts'' = ts''a @ tfn \\<and>\n                       ts' = ts''a @ tfm \\<and> \\<C>\n                       \\<lparr>label :=\n                                 [tfn] @\n                                 label \\<C>\\<rparr> \\<turnstile> ?es : ?tf\n\ngoal (1 subgoal):\n 1. (\\<And>tfn tfm ts_c \\<C>'.\n        \\<lbrakk>t1s _> t2s = tfn _> tfm; ts'' = ts_c @ tfn;\n         ts' = ts_c @ tfm;\n         \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>;\n         \\<C>' \\<turnstile> es : tfn _> tfm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t1s _> t2s = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>\n  \\<C>' \\<turnstile> es : tfn _> tfm\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "obtain tvs where tvs_def:\"ts'' = ts @ tvs\" \"length vs = length tvs\" \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length vs = length tvs;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list assms(3) ts''_def(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  const_list vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length vs = length tvs;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ tvs\n  length vs = length tvs\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  ts'' = ts @ tvs\n  length vs = length tvs\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs", "have tvs_eq:\"tvs = t1s\" \"tfn = t1s\""], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length vs = length tvs\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. tvs = t1s &&& tfn = t1s", "using assms(4,5) t_loop(1,2)"], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length vs = length tvs\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs\n  length vs = n\n  length t1s = n\n  t1s _> t2s = tfn _> tfm\n  ts'' = ts_c @ tfn\n\ngoal (1 subgoal):\n 1. tvs = t1s &&& tfn = t1s", "by simp_all"], ["proof (state)\nthis:\n  tvs = t1s\n  tfn = t1s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "have \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : (t1s _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s", "using t_loop b_e_typing.loop e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  t1s _> t2s = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>\n  \\<C>' \\<turnstile> es : tfn _> tfm\n  \\<lbrakk>?tf = ?tn _> ?tm;\n   ?\\<C>\n   \\<lparr>label :=\n             [?tn] @\n             label ?\\<C>\\<rparr> \\<turnstile> ?es : ?tn _> ?tm\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Loop ?tf ?es] : ?tn _> ?tm\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "have \"\\<S>\\<bullet>\\<C>' \\<turnstile> $*es : (t1s _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : t1s _> t2s", "using t_loop e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  t1s _> t2s = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>\n  \\<C>' \\<turnstile> es : tfn _> tfm\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : t1s _> t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : t1s _> t2s", "have \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs@($*es) : ([] _> t2s)\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> t2s", "using tvs_eq tvs_def(3) e_type_comp_conc"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> $* es : t1s _> t2s\n  tvs = t1s\n  tfn = t1s\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n               ?es' : ?t1s _> ?t3s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> t2s", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> t2s", "have \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))] : ([] _> t2s)\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : [] _> t2s", "using e_typing_s_typing.intros(7)[of \\<S> \\<C> \"[$Loop (t1s _> t2s) es]\" t1s t2s \"vs @ ($* es)\"]\n          t_loop(4) assms(5)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s) es] : t1s _> t2s\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs @ ($* es) : [] _> t2s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$Loop (t1s _> t2s)\n       es] : t1s _> t2s;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             [t1s] @\n             label \\<C>\\<rparr> \\<turnstile> vs @ ($* es) : [] _> t2s;\n   length t1s = ?n\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Label ?n\n               [$Loop (t1s _> t2s) es] (vs @ ($* es))] : [] _> t2s\n  \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>\n  length t1s = n\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : [] _> t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                   (vs @ ($* es))] : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                   (vs @ ($* es))] : [] _> t2s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                   (vs @ ($* es))] : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "using t_loop e_typing_s_typing.intros(3) tvs_def(1) tvs_eq(1)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                   (vs @ ($* es))] : [] _> t2s\n  t1s _> t2s = tfn _> tfm\n  ts'' = ts_c @ tfn\n  ts' = ts_c @ tfm\n  \\<C>' = \\<C>\\<lparr>label := [t1s] @ label \\<C>\\<rparr>\n  \\<C>' \\<turnstile> es : tfn _> tfm\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  ts'' = ts @ tvs\n  tvs = t1s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                     (vs @ ($* es))] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n [$Loop (t1s _> t2s) es]\n                                   (vs @ ($* es))] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_label_value:\n  assumes \"\\<lparr>[Label n es0 vs]\\<rparr> \\<leadsto> \\<lparr>vs\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0 vs] : (ts _> ts')\"\n          \"const_list vs\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'", "obtain tls t2s where t2s_def:\"(ts' = (ts@t2s))\"\n                           \"(\\<S>\\<bullet>\\<C> \\<turnstile> es0 : (tls _> t2s))\"\n                           \"(\\<S>\\<bullet>\\<C>\\<lparr>label := [tls] @ (label \\<C>)\\<rparr> \\<turnstile> vs : ([] _> t2s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t2s tls.\n        \\<lbrakk>ts' = ts @ t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s;\n         \\<S>\\<bullet>\\<C>\n         \\<lparr>label :=\n                   [tls] @\n                   label \\<C>\\<rparr> \\<turnstile> vs : [] _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms e_type_label"], ["proof (prove)\nusing this:\n  \\<lparr>[Label n es0 vs]\\<rparr> \\<leadsto> \\<lparr>vs\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0 vs] : ts _> ts'\n  const_list vs\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Label ?n ?es0.0\n                                     ?es] : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>tls t2s.\n     ?ts' = ?ts @ t2s \\<and>\n     length tls = ?n \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es0.0 : tls _> t2s \\<and>\n     ?\\<S>\\<bullet>?\\<C>\n     \\<lparr>label :=\n               [tls] @ label ?\\<C>\\<rparr> \\<turnstile> ?es : [] _> t2s\n\ngoal (1 subgoal):\n 1. (\\<And>t2s tls.\n        \\<lbrakk>ts' = ts @ t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s;\n         \\<S>\\<bullet>\\<C>\n         \\<lparr>label :=\n                   [tls] @\n                   label \\<C>\\<rparr> \\<turnstile> vs : [] _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> vs : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> vs : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'", "using e_type_const_list[of vs \\<S> \"\\<C>\\<lparr>label := [tls] @ (label \\<C>)\\<rparr>\" \"[]\" t2s]\n          assms(3) e_typing_s_typing.intros(3)"], ["proof (prove)\nusing this:\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> vs : [] _> t2s\n  \\<lbrakk>const_list vs;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             [tls] @ label \\<C>\\<rparr> \\<turnstile> vs : [] _> t2s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       t2s = [] @ tvs \\<and>\n                       length vs = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> vs : [] _> tvs\n  const_list vs\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_br_if:\n  assumes \"\\<lparr>[$C ConstInt32 n, $Br_if i]\\<rparr> \\<leadsto> \\<lparr>e\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 n, $Br_if i] : (ts _> ts')\"\n          \"e = [$Br i] \\<or> e = []\"\n  shows   \"\\<S>\\<bullet>\\<C> \\<turnstile> e : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "have \"\\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 n, $Br_if i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C ConstInt32 n] : (ts _> ts'')\" \"\\<C> \\<turnstile> [Br_if i] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts'';\n         \\<C> \\<turnstile> [Br_if i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[of _ \"[C ConstInt32 n]\" \"Br_if i\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n, Br_if i] : ts _> ts'\n  ?\\<C> \\<turnstile> [C ConstInt32 n] @\n                     [Br_if i] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C ConstInt32 n] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [Br_if i] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts'';\n         \\<C> \\<turnstile> [Br_if i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts''\n  \\<C> \\<turnstile> [Br_if i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts''\n  \\<C> \\<turnstile> [Br_if i] : ts'' _> ts'", "obtain ts_c ts_b where ts_bc_def:\"i < length(label \\<C>)\"\n                                        \"ts'' = ts_c @ ts_b @ [T_i32]\"\n                                        \"ts' = ts_c @ ts_b\"\n                                        \"(label \\<C>)!i = ts_b\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts''\n  \\<C> \\<turnstile> [Br_if i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c ts_b.\n        \\<lbrakk>i < length (label \\<C>); ts'' = ts_c @ ts_b @ [T_i32];\n         ts' = ts_c @ ts_b; label \\<C> ! i = ts_b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_br_if[of \\<C> \"Br_if i\" ts'' ts' i]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts''\n  \\<C> \\<turnstile> [Br_if i] : ts'' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Br_if i] : ts'' _> ts';\n   Br_if i = Br_if i\\<rbrakk>\n  \\<Longrightarrow> i < length (label \\<C>)\n  \\<lbrakk>\\<C> \\<turnstile> [Br_if i] : ts'' _> ts';\n   Br_if i = Br_if i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''a.\n                       ts'' = ts_c @ ts''a @ [T_i32] \\<and>\n                       ts' = ts_c @ ts''a \\<and> label \\<C> ! i = ts''a\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c ts_b.\n        \\<lbrakk>i < length (label \\<C>); ts'' = ts_c @ ts_b @ [T_i32];\n         ts' = ts_c @ ts_b; label \\<C> ! i = ts_b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  i < length (label \\<C>)\n  ts'' = ts_c @ ts_b @ [T_i32]\n  ts' = ts_c @ ts_b\n  label \\<C> ! i = ts_b\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "hence ts_def:\"ts = ts_c @ ts_b\""], ["proof (prove)\nusing this:\n  i < length (label \\<C>)\n  ts'' = ts_c @ ts_b @ [T_i32]\n  ts' = ts_c @ ts_b\n  label \\<C> ! i = ts_b\n\ngoal (1 subgoal):\n 1. ts = ts_c @ ts_b", "using ts''_def(1) b_e_type_value"], ["proof (prove)\nusing this:\n  i < length (label \\<C>)\n  ts'' = ts_c @ ts_b @ [T_i32]\n  ts' = ts_c @ ts_b\n  label \\<C> ! i = ts_b\n  \\<C> \\<turnstile> [C ConstInt32 n] : ts _> ts''\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. ts = ts_c @ ts_b", "by fastforce"], ["proof (state)\nthis:\n  ts = ts_c @ ts_b\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "using assms(3)"], ["proof (prove)\nusing this:\n  e = [$Br i] \\<or> e = []\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. e = [$Br i] \\<Longrightarrow>\n    \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n 2. e = [] \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "assume \"e = [$Br i]\""], ["proof (state)\nthis:\n  e = [$Br i]\n\ngoal (2 subgoals):\n 1. e = [$Br i] \\<Longrightarrow>\n    \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n 2. e = [] \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = [$Br i]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "using ts_def e_typing_s_typing.intros(1) b_e_typing.br ts_bc_def"], ["proof (prove)\nusing this:\n  e = [$Br i]\n  ts = ts_c @ ts_b\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  \\<lbrakk>?i < length (label ?\\<C>); label ?\\<C> ! ?i = ?ts\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Br ?i] : ?t1s @ ?ts _> ?t2s\n  i < length (label \\<C>)\n  ts'' = ts_c @ ts_b @ [T_i32]\n  ts' = ts_c @ ts_b\n  label \\<C> ! i = ts_b\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n\ngoal (1 subgoal):\n 1. e = [] \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e = [] \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "assume \"e = []\""], ["proof (state)\nthis:\n  e = []\n\ngoal (1 subgoal):\n 1. e = [] \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = []\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "using ts_def b_e_type_empty ts_bc_def(3)\n      e_typing_s_typing.intros(1)[of _ \"[]\" \"(ts _> ts')\"]"], ["proof (prove)\nusing this:\n  e = []\n  ts = ts_c @ ts_b\n  ?\\<C> \\<turnstile> [] : ?ts _> ?ts' = (?ts = ?ts')\n  ts' = ts_c @ ts_b\n  ?\\<C> \\<turnstile> [] : ts _> ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* [] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_br_table:\n  assumes \"\\<lparr>[$C ConstInt32 c, $Br_table is i]\\<rparr> \\<leadsto> \\<lparr>[$Br i']\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Br_table is i] : (ts _> ts')\"\n          \"(i' = (is ! nat_of_int c) \\<and> length is > nat_of_int c) \\<or> i' = i\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "have \"\\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : ts _> ts'", "using unlift_b_e assms(2)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n                                  $Br_table is i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C ConstInt32 c] : (ts _> ts'')\" \"\\<C> \\<turnstile> [Br_table is i] : (ts'' _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts'';\n         \\<C> \\<turnstile> [Br_table is i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_comp[of _ \"[C ConstInt32 c]\" \"Br_table is i\"]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c, Br_table is i] : ts _> ts'\n  ?\\<C> \\<turnstile> [C ConstInt32 c] @\n                     [Br_table is i] : ?t1s _> ?t4s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<C> \\<turnstile> [C ConstInt32 c] : ?t1s _> ts' \\<and>\n     ?\\<C> \\<turnstile> [Br_table is i] : ts' _> ?t4s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts'';\n         \\<C> \\<turnstile> [Br_table is i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Br_table is i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Br_table is i] : ts'' _> ts'", "obtain ts_l ts_c where ts_c_def:\"list_all (\\<lambda>i. i < length(label \\<C>) \\<and> (label \\<C>)!i = ts_l) (is@[i])\"\n                                       \"ts'' = ts_c @ ts_l@[T_i32]\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Br_table is i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_l ts_c.\n        \\<lbrakk>list_all\n                  (\\<lambda>i.\n                      i < length (label \\<C>) \\<and> label \\<C> ! i = ts_l)\n                  (is @ [i]);\n         ts'' = ts_c @ ts_l @ [T_i32]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_br_table[of \\<C> \"Br_table is i\" ts'' ts']"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Br_table is i] : ts'' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Br_table is i] : ts'' _> ts';\n   Br_table is i = Br_table ?is ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''a.\n                       list_all\n                        (\\<lambda>i.\n                            i < length (label \\<C>) \\<and>\n                            label \\<C> ! i = ts''a)\n                        (?is @ [?i]) \\<and>\n                       ts'' = ts_c @ ts''a @ [T_i32]\n\ngoal (1 subgoal):\n 1. (\\<And>ts_l ts_c.\n        \\<lbrakk>list_all\n                  (\\<lambda>i.\n                      i < length (label \\<C>) \\<and> label \\<C> ! i = ts_l)\n                  (is @ [i]);\n         ts'' = ts_c @ ts_l @ [T_i32]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>i. i < length (label \\<C>) \\<and> label \\<C> ! i = ts_l)\n   (is @ [i])\n  ts'' = ts_c @ ts_l @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "hence ts_def:\"ts = ts_c @ ts_l\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>i. i < length (label \\<C>) \\<and> label \\<C> ! i = ts_l)\n   (is @ [i])\n  ts'' = ts_c @ ts_l @ [T_i32]\n\ngoal (1 subgoal):\n 1. ts = ts_c @ ts_l", "using ts''_def(1) b_e_type_value"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>i. i < length (label \\<C>) \\<and> label \\<C> ! i = ts_l)\n   (is @ [i])\n  ts'' = ts_c @ ts_l @ [T_i32]\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. ts = ts_c @ ts_l", "by fastforce"], ["proof (state)\nthis:\n  ts = ts_c @ ts_l\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "have \"\\<C> \\<turnstile> [Br i'] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Br i'] : ts _> ts'", "using assms(3) ts_c_def(1,2) b_e_typing.br[of i' \\<C> ts_l ts_c ts'] ts_def"], ["proof (prove)\nusing this:\n  i' = is ! nat_of_int c \\<and> nat_of_int c < length is \\<or> i' = i\n  list_all\n   (\\<lambda>i. i < length (label \\<C>) \\<and> label \\<C> ! i = ts_l)\n   (is @ [i])\n  ts'' = ts_c @ ts_l @ [T_i32]\n  \\<lbrakk>i' < length (label \\<C>); label \\<C> ! i' = ts_l\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Br i'] : ts_c @ ts_l _> ts'\n  ts = ts_c @ ts_l\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Br i'] : ts _> ts'", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  i' = is ! nat_of_int c \\<and> nat_of_int c < length is \\<or> i' = i\n  \\<forall>n<length (is @ [i]).\n     (is @ [i]) ! n < length (label \\<C>) \\<and>\n     label \\<C> ! ((is @ [i]) ! n) = ts_l\n  ts'' = ts_c @ ts_l @ [T_i32]\n  \\<lbrakk>i' < length (label \\<C>); label \\<C> ! i' = ts_l\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Br i'] : ts_c @ ts_l _> ts'\n  ts = ts_c @ ts_l\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Br i'] : ts _> ts'", "by (fastforce simp add: less_Suc_eq nth_append)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Br i'] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Br i'] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "using e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Br i'] : ts _> ts'\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br i'] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_local_const:\n  assumes \"\\<lparr>[Local n i vs es]\\<rparr> \\<leadsto> \\<lparr>es\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs es] : (ts _> ts')\"\n          \"const_list es\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> es: (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "obtain tls where \"(\\<S>\\<bullet>((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i)) @ (map typeof vs), return := Some tls\\<rparr> \\<turnstile> es : ([] _> tls))\"\n                   \"ts' = ts @ tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        \\<lbrakk>\\<S>\\<bullet>(s_inst \\<S> ! i)\n                 \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n                    return := Some tls\\<rparr> \\<turnstile> es : [] _> tls;\n         ts' = ts @ tls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_local[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<exists>tls.\n     i < length (s_inst \\<S>) \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>(s_inst \\<S> ! i)\n     \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n        return := Some tls\\<rparr> \\<turnstile> es : [] _> tls \\<and>\n     ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        \\<lbrakk>\\<S>\\<bullet>(s_inst \\<S> ! i)\n                 \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n                    return := Some tls\\<rparr> \\<turnstile> es : [] _> tls;\n         ts' = ts @ tls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls", "have \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> tls)\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> tls", "using assms(3) e_type_const_list"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  const_list es\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> tls", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> tls", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "using e_typing_s_typing.intros(3)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>(s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs,\n     return := Some tls\\<rparr> \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> tls\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typing_map_typeof:\n  assumes \"ves = $$* vs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : ([] _> tvs)\"\n  shows \"tvs = map typeof vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs = map typeof vs", "using assms"], ["proof (prove)\nusing this:\n  ves = $$* vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. tvs = map typeof vs", "proof (induction ves arbitrary: vs tvs rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs tvs.\n       \\<lbrakk>[] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs\n 2. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "case Nil"], ["proof (state)\nthis:\n  [] = $$* vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs tvs.\n       \\<lbrakk>[] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs\n 2. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "hence \"\\<C> \\<turnstile> [] : ([] _> tvs)\""], ["proof (prove)\nusing this:\n  [] = $$* vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [] : [] _> tvs", "using unlift_b_e"], ["proof (prove)\nusing this:\n  [] = $$* vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [] : [] _> tvs", "by auto"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [] : [] _> tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs tvs.\n       \\<lbrakk>[] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs\n 2. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [] : [] _> tvs\n\ngoal (1 subgoal):\n 1. tvs = map typeof vs", "using Nil"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [] : [] _> tvs\n  [] = $$* vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> tvs\n\ngoal (1 subgoal):\n 1. tvs = map typeof vs", "by auto"], ["proof (state)\nthis:\n  tvs = map typeof vs\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "case (snoc a ves)"], ["proof (state)\nthis:\n  \\<lbrakk>ves = $$* ?vs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> ?tvs\\<rbrakk>\n  \\<Longrightarrow> ?tvs = map typeof ?vs\n  ves @ [a] = $$* vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [a] : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "obtain vs' v' where vs'_def:\"ves @ [a] = $$* (vs'@[v'])\" \"vs = vs'@[v']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs' v'.\n        \\<lbrakk>ves @ [a] = $$* vs' @ [v']; vs = vs' @ [v']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc(2)"], ["proof (prove)\nusing this:\n  ves @ [a] = $$* vs\n\ngoal (1 subgoal):\n 1. (\\<And>vs' v'.\n        \\<lbrakk>ves @ [a] = $$* vs' @ [v']; vs = vs' @ [v']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Nil_is_map_conv append_is_Nil_conv list.distinct(1) rev_exhaust)"], ["proof (state)\nthis:\n  ves @ [a] = $$* vs' @ [v']\n  vs = vs' @ [v']\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "obtain tvs' where tvs'_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> ves: ([] _> tvs')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [a] : (tvs' _> tvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tvs'.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc(3) e_type_comp"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [a] : [] _> tvs\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n\ngoal (1 subgoal):\n 1. (\\<And>tvs'.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "hence \"tvs' = map typeof vs'\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\n\ngoal (1 subgoal):\n 1. tvs' = map typeof vs'", "using snoc(1) vs'_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\n  \\<lbrakk>ves = $$* ?vs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> ?tvs\\<rbrakk>\n  \\<Longrightarrow> ?tvs = map typeof ?vs\n  ves @ [a] = $$* vs' @ [v']\n  vs = vs' @ [v']\n\ngoal (1 subgoal):\n 1. tvs' = map typeof vs'", "by fastforce"], ["proof (state)\nthis:\n  tvs' = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "moreover"], ["proof (state)\nthis:\n  tvs' = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "have \"is_const a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const a", "using vs'_def"], ["proof (prove)\nusing this:\n  ves @ [a] = $$* vs' @ [v']\n  vs = vs' @ [v']\n\ngoal (1 subgoal):\n 1. is_const a", "unfolding is_const_def"], ["proof (prove)\nusing this:\n  ves @ [a] = $$* vs' @ [v']\n  vs = vs' @ [v']\n\ngoal (1 subgoal):\n 1. case a of $C xa \\<Rightarrow> True | $_ \\<Rightarrow> False\n    | _ \\<Rightarrow> False", "by auto"], ["proof (state)\nthis:\n  is_const a\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "then"], ["proof (chain)\npicking this:\n  is_const a", "obtain t where t_def:\"tvs = tvs' @ [t]\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [a] : ([] _> [t])\""], ["proof (prove)\nusing this:\n  is_const a\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>tvs = tvs' @ [t];\n         \\<S>\\<bullet>\\<C> \\<turnstile> [a] : [] _> [t]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using tvs'_def(2)  e_type_const[of a \\<S> \\<C> tvs' tvs]"], ["proof (prove)\nusing this:\n  is_const a\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\n  \\<lbrakk>is_const a;\n   \\<S>\\<bullet>\\<C> \\<turnstile> [a] : tvs' _> tvs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       tvs = tvs' @ [t] \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> [a] : [] _> [t]\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>tvs = tvs' @ [t];\n         \\<S>\\<bullet>\\<C> \\<turnstile> [a] : [] _> [t]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  tvs = tvs' @ [t]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : [] _> [t]\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "have \"a = $ C v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = $C v'", "using vs'_def(1)"], ["proof (prove)\nusing this:\n  ves @ [a] = $$* vs' @ [v']\n\ngoal (1 subgoal):\n 1. a = $C v'", "by auto"], ["proof (state)\nthis:\n  a = $C v'\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "hence \"t = typeof v'\""], ["proof (prove)\nusing this:\n  a = $C v'\n\ngoal (1 subgoal):\n 1. t = typeof v'", "using t_def unlift_b_e[of \\<S> \\<C> \"[C v']\" \"([] _> [t])\"] b_e_type_value[of \\<C> \"C v'\" \"[]\" \"[t]\" v']"], ["proof (prove)\nusing this:\n  a = $C v'\n  tvs = tvs' @ [t]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : [] _> [t]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C v'] : [] _> [t] \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v'] : [] _> [t]\n  \\<lbrakk>\\<C> \\<turnstile> [C v'] : [] _> [t]; C v' = C v'\\<rbrakk>\n  \\<Longrightarrow> [t] = [] @ [typeof v']\n\ngoal (1 subgoal):\n 1. t = typeof v'", "by fastforce"], ["proof (state)\nthis:\n  t = typeof v'\n\ngoal (1 subgoal):\n 1. \\<And>x xs vs tvs.\n       \\<lbrakk>\\<And>vs tvs.\n                   \\<lbrakk>xs = $$* vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> xs : [] _> tvs\\<rbrakk>\n                   \\<Longrightarrow> tvs = map typeof vs;\n        xs @ [x] = $$* vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> xs @ [x] : [] _> tvs\\<rbrakk>\n       \\<Longrightarrow> tvs = map typeof vs", "ultimately"], ["proof (chain)\npicking this:\n  tvs' = map typeof vs'\n  t = typeof v'", "show ?case"], ["proof (prove)\nusing this:\n  tvs' = map typeof vs'\n  t = typeof v'\n\ngoal (1 subgoal):\n 1. tvs = map typeof vs", "using vs'_def t_def"], ["proof (prove)\nusing this:\n  tvs' = map typeof vs'\n  t = typeof v'\n  ves @ [a] = $$* vs' @ [v']\n  vs = vs' @ [v']\n  tvs = tvs' @ [t]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [a] : [] _> [t]\n\ngoal (1 subgoal):\n 1. tvs = map typeof vs", "by simp"], ["proof (state)\nthis:\n  tvs = map typeof vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_call_indirect_Some:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Call_indirect j] : (ts _> ts')\"\n          \"stab s i' (nat_of_int c) = Some cl\"\n          \"stypes s i' j = tf\"\n          \"cl_type cl = tf\"\n          \"store_typing s \\<S>\"\n          \"i' < length (inst s)\"\n          \"\\<C> = (s_inst \\<S> ! i') \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs, return := arb_return\\<rparr>\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "obtain t1s t2s where tf_def:\"tf = (t1s _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        tf = t1s _> t2s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using tf.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = x1 _> x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        tf = t1s _> t2s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tf = t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<C> \\<turnstile> [C ConstInt32 c] : (ts _> ts'')\"\n                             \"\\<C> \\<turnstile> [Call_indirect j] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts'';\n         \\<C> \\<turnstile> [Call_indirect j] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp[of \\<S> \\<C> \"[$C ConstInt32 c]\" \"$Call_indirect j\" ts ts']\n          assms(1)\n          unlift_b_e[of \\<S> \\<C> \"[C ConstInt32 c]\"]\n          unlift_b_e[of \\<S> \\<C> \"[Call_indirect j]\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] @\n                                 [$Call_indirect\n                                    j] : ts _> ts' \\<Longrightarrow>\n  \\<exists>ts'a.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'a \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Call_indirect j] : ts'a _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n                                  $Call_indirect j] : ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32 c] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 c] : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Call_indirect\nj] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Call_indirect j] : ?tf\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts'';\n         \\<C> \\<turnstile> [Call_indirect j] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Call_indirect j] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "hence \"ts'' = ts@[(T_i32)]\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Call_indirect j] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "using b_e_type_value"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Call_indirect j] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts''\n  \\<C> \\<turnstile> [Call_indirect j] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' =\n                    ?ts @\n                    [case ?v of ConstInt32 x \\<Rightarrow> T_i32\n                     | ConstInt64 x \\<Rightarrow> T_i64\n                     | ConstFloat32 x \\<Rightarrow> T_f32\n                     | ConstFloat64 x \\<Rightarrow> T_f64]\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "have \"i' < length (s_inst \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < length (s_inst \\<S>)", "using assms(5,6) store_typing_imp_inst_length_eq"], ["proof (prove)\nusing this:\n  store_typing s \\<S>\n  i' < length (inst s)\n  store_typing ?s ?\\<S> \\<Longrightarrow>\n  length (inst ?s) = length (s_inst ?\\<S>)\n\ngoal (1 subgoal):\n 1. i' < length (s_inst \\<S>)", "by fastforce"], ["proof (state)\nthis:\n  i' < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "hence stypes_eq:\"types_t (s_inst \\<S> ! i') = types (inst s ! i')\""], ["proof (prove)\nusing this:\n  i' < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. types_t (s_inst \\<S> ! i') = types (inst s ! i')", "using store_typing_imp_inst_typing[OF assms(5)] store_typing_imp_inst_length_eq[OF assms(5)]"], ["proof (prove)\nusing this:\n  i' < length (s_inst \\<S>)\n  ?i < length (inst s) \\<Longrightarrow>\n  inst_typing \\<S> (inst s ! ?i) (s_inst \\<S> ! ?i)\n  length (inst s) = length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. types_t (s_inst \\<S> ! i') = types (inst s ! i')", "unfolding inst_typing.simps"], ["proof (prove)\nusing this:\n  i' < length (s_inst \\<S>)\n  ?i < length (inst s) \\<Longrightarrow>\n  \\<exists>\\<S>' fs tfs gs tgs i i' n j m ts.\n     \\<S> = \\<S>' \\<and>\n     inst s ! ?i =\n     \\<lparr>types = ts, funcs = fs, tab = i, mem = j,\n        globs = gs\\<rparr> \\<and>\n     s_inst \\<S> ! ?i =\n     \\<lparr>types_t = ts, func_t = tfs, global = tgs, table = n,\n        memory = m, local = [], label = [], return = None\\<rparr> \\<and>\n     list_all2 (funci_agree (s_funcs \\<S>')) fs tfs \\<and>\n     list_all2 (globi_agree (s_globs \\<S>')) gs tgs \\<and>\n     (i = Some i' \\<and>\n      i' < length (s_tab \\<S>') \\<and> s_tab \\<S>' ! i' = the n \\<or>\n      i = None \\<and> n = None) \\<and>\n     memi_agree (s_mem \\<S>') j m\n  length (inst s) = length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. types_t (s_inst \\<S> ! i') = types (inst s ! i')", "by fastforce"], ["proof (state)\nthis:\n  types_t (s_inst \\<S> ! i') = types (inst s ! i')\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "obtain ts''a where ts''a_def:\"j < length (types_t \\<C>)\"\n                               \"ts'' = ts''a @ t1s @ [T_i32]\"\n                               \"ts' = ts''a @ t2s\"\n                               \"types_t \\<C> ! j = (t1s _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''a.\n        \\<lbrakk>j < length (types_t \\<C>); ts'' = ts''a @ t1s @ [T_i32];\n         ts' = ts''a @ t2s; types_t \\<C> ! j = t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_call_indirect[OF ts''_def(2), of j] tf_def assms(3,7) stypes_eq"], ["proof (prove)\nusing this:\n  Call_indirect j = Call_indirect j \\<Longrightarrow>\n  j < length (types_t \\<C>)\n  Call_indirect j = Call_indirect j \\<Longrightarrow>\n  \\<exists>ts''a tf1 tf2.\n     ts'' = ts''a @ tf1 @ [T_i32] \\<and>\n     ts' = ts''a @ tf2 \\<and> types_t \\<C> ! j = tf1 _> tf2\n  tf = t1s _> t2s\n  stypes s i' j = tf\n  \\<C> = (s_inst \\<S> ! i')\n  \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  types_t (s_inst \\<S> ! i') = types (inst s ! i')\n\ngoal (1 subgoal):\n 1. (\\<And>ts''a.\n        \\<lbrakk>j < length (types_t \\<C>); ts'' = ts''a @ t1s @ [T_i32];\n         ts' = ts''a @ t2s; types_t \\<C> ! j = t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding stypes_def"], ["proof (prove)\nusing this:\n  Call_indirect j = Call_indirect j \\<Longrightarrow>\n  j < length (types_t \\<C>)\n  Call_indirect j = Call_indirect j \\<Longrightarrow>\n  \\<exists>ts''a tf1 tf2.\n     ts'' = ts''a @ tf1 @ [T_i32] \\<and>\n     ts' = ts''a @ tf2 \\<and> types_t \\<C> ! j = tf1 _> tf2\n  tf = t1s _> t2s\n  types (inst s ! i') ! j = tf\n  \\<C> = (s_inst \\<S> ! i')\n  \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  types_t (s_inst \\<S> ! i') = types (inst s ! i')\n\ngoal (1 subgoal):\n 1. (\\<And>ts''a.\n        \\<lbrakk>j < length (types_t \\<C>); ts'' = ts''a @ t1s @ [T_i32];\n         ts' = ts''a @ t2s; types_t \\<C> ! j = t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  j < length (types_t \\<C>)\n  ts'' = ts''a @ t1s @ [T_i32]\n  ts' = ts''a @ t2s\n  types_t \\<C> ! j = t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  j < length (types_t \\<C>)\n  ts'' = ts''a @ t1s @ [T_i32]\n  ts' = ts''a @ t2s\n  types_t \\<C> ! j = t1s _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "obtain tf' where tf'_def:\"cl_typing \\<S> cl tf'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tf'.\n        cl_typing \\<S> cl tf' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2,5,6) stab_typed_some_imp_cl_typed"], ["proof (prove)\nusing this:\n  stab s i' (nat_of_int c) = Some cl\n  store_typing s \\<S>\n  i' < length (inst s)\n  \\<lbrakk>stab ?s ?i ?c = Some ?cl; store_typing ?s ?\\<S>;\n   ?i < length (inst ?s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tf. cl_typing ?\\<S> ?cl tf\n\ngoal (1 subgoal):\n 1. (\\<And>tf'.\n        cl_typing \\<S> cl tf' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cl_typing \\<S> cl tf'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "hence \"cl_typing \\<S> cl tf\""], ["proof (prove)\nusing this:\n  cl_typing \\<S> cl tf'\n\ngoal (1 subgoal):\n 1. cl_typing \\<S> cl tf", "using assms(4)"], ["proof (prove)\nusing this:\n  cl_typing \\<S> cl tf'\n  cl_type cl = tf\n\ngoal (1 subgoal):\n 1. cl_typing \\<S> cl tf", "unfolding cl_typing.simps cl_type_def"], ["proof (prove)\nusing this:\n  (\\<exists>i \\<S>' \\<C> tf t1s t2s ts es.\n      \\<S> = \\<S>' \\<and>\n      cl = Func_native i tf ts es \\<and>\n      tf' = t1s _> t2s \\<and>\n      i < length (s_inst \\<S>') \\<and>\n      s_inst \\<S>' ! i = \\<C> \\<and>\n      tf = t1s _> t2s \\<and> \\<C>\n      \\<lparr>local := local \\<C> @ t1s @ ts, label := [t2s] @ label \\<C>,\n         return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s) \\<or>\n  (\\<exists>\\<S>' tf h.\n      \\<S> = \\<S>' \\<and> cl = Func_host tf h \\<and> tf' = tf)\n  (case cl of Func_native x tf xa xb \\<Rightarrow> tf\n   | Func_host tf x \\<Rightarrow> tf) =\n  tf\n\ngoal (1 subgoal):\n 1. (\\<exists>i \\<S>' \\<C> tfa t1s t2s ts es.\n        \\<S> = \\<S>' \\<and>\n        cl = Func_native i tfa ts es \\<and>\n        tf = t1s _> t2s \\<and>\n        i < length (s_inst \\<S>') \\<and>\n        s_inst \\<S>' ! i = \\<C> \\<and>\n        tfa = t1s _> t2s \\<and> \\<C>\n        \\<lparr>local := local \\<C> @ t1s @ ts, label := [t2s] @ label \\<C>,\n           return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s) \\<or>\n    (\\<exists>\\<S>' tfa h.\n        \\<S> = \\<S>' \\<and> cl = Func_host tfa h \\<and> tf = tfa)", "by auto"], ["proof (state)\nthis:\n  cl_typing \\<S> cl tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf\""], ["proof (prove)\nusing this:\n  cl_typing \\<S> cl tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf", "using e_typing_s_typing.intros(6) assms(6,7) ts''a_def(1)"], ["proof (prove)\nusing this:\n  cl_typing \\<S> cl tf\n  cl_typing ?\\<S> ?cl ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Callcl ?cl] : ?tf\n  i' < length (inst s)\n  \\<C> = (s_inst \\<S> ! i')\n  \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  j < length (types_t \\<C>)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts'' = ts @ [T_i32]\n  j < length (types_t \\<C>)\n  ts'' = ts''a @ t1s @ [T_i32]\n  ts' = ts''a @ t2s\n  types_t \\<C> ! j = t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf", "show \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  j < length (types_t \\<C>)\n  ts'' = ts''a @ t1s @ [T_i32]\n  ts' = ts''a @ t2s\n  types_t \\<C> ! j = t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "using tf_def e_typing_s_typing.intros(3)"], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  j < length (types_t \\<C>)\n  ts'' = ts''a @ t1s @ [T_i32]\n  ts' = ts''a @ t2s\n  types_t \\<C> ! j = t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : tf\n  tf = t1s _> t2s\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'", "by auto"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_call_indirect_None:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Call_indirect j] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts'", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts'", "by blast"], ["", "lemma types_preserved_callcl_native:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : (ts _> ts')\"\n          \"cl = Func_native i (t1s _> t2s) tfs es\"\n          \"ves = $$* vs\"\n          \"length vs = n\"\n          \"length tfs = k\"\n          \"length t1s = n\"\n          \"length t2s = m\"\n          \"n_zeros tfs = zs\"\n          \"store_typing s \\<S>\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs) [$Block ([] _> t2s) es]] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> ves : (ts _> ts'')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) e_type_comp"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "have ves_c:\"const_list ves\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_list ves", "using is_const_list[OF assms(3)]"], ["proof (prove)\nusing this:\n  const_list ves\n\ngoal (1 subgoal):\n 1. const_list ves", "by simp"], ["proof (state)\nthis:\n  const_list ves\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  const_list ves", "obtain tvs where tvs_def:\"ts'' = ts @ tvs\"\n                                \"length t1s = length tvs\"\n                                \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : ([] _> tvs)\""], ["proof (prove)\nusing this:\n  const_list ves\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length t1s = length tvs;\n         \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ts''_def(1) e_type_const_list[of ves \\<S> \\<C> ts ts''] assms"], ["proof (prove)\nusing this:\n  const_list ves\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\n  \\<lbrakk>const_list ves;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ts'' = ts @ tvs \\<and>\n                       length ves = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ves : [] _> tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  cl = Func_native i (t1s _> t2s) tfs es\n  ves = $$* vs\n  length vs = n\n  length tfs = k\n  length t1s = n\n  length t2s = m\n  n_zeros tfs = zs\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length t1s = length tvs;\n         \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "obtain ts_c \\<C>' where ts_c_def:\"(ts'' = ts_c @ t1s)\"\n                                \"(ts' = ts_c @ t2s)\"\n                                \"i < length (s_inst \\<S>)\"\n                                \"\\<C>' = ((s_inst \\<S>)!i)\"\n                                \"(\\<C>'\\<lparr>local := (local \\<C>') @ t1s @ tfs, label := ([t2s] @ (label \\<C>')), return := Some t2s\\<rparr>  \\<turnstile> es : ([] _> t2s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts_c \\<C>'.\n        \\<lbrakk>ts'' = ts_c @ t1s; ts' = ts_c @ t2s;\n         i < length (s_inst \\<S>); \\<C>' = s_inst \\<S> ! i;\n         \\<C>'\n         \\<lparr>local := local \\<C>' @ t1s @ tfs,\n            label := [t2s] @ label \\<C>',\n            return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_callcl_native[OF ts''_def(2) assms(2)]"], ["proof (prove)\nusing this:\n  \\<exists>t1sa t2sa ts_c.\n     ts'' = ts_c @ t1sa \\<and>\n     ts' = ts_c @ t2sa \\<and>\n     t1s _> t2s = t1sa _> t2sa \\<and>\n     i < length (s_inst \\<S>) \\<and> (s_inst \\<S> ! i)\n     \\<lparr>local := local (s_inst \\<S> ! i) @ t1sa @ tfs,\n        label := [t2sa] @ label (s_inst \\<S> ! i),\n        return := Some t2sa\\<rparr> \\<turnstile> es : [] _> t2sa\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c \\<C>'.\n        \\<lbrakk>ts'' = ts_c @ t1s; ts' = ts_c @ t2s;\n         i < length (s_inst \\<S>); \\<C>' = s_inst \\<S> ! i;\n         \\<C>'\n         \\<lparr>local := local \\<C>' @ t1s @ tfs,\n            label := [t2s] @ label \\<C>',\n            return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts_c @ t1s\n  ts' = ts_c @ t2s\n  i < length (s_inst \\<S>)\n  \\<C>' = s_inst \\<S> ! i\n  \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "have \"inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)", "using store_typing_imp_inst_length_eq[OF assms(9)] store_typing_imp_inst_typing[OF assms(9)]\n          ts_c_def(3)"], ["proof (prove)\nusing this:\n  length (inst s) = length (s_inst \\<S>)\n  ?i < length (inst s) \\<Longrightarrow>\n  inst_typing \\<S> (inst s ! ?i) (s_inst \\<S> ! ?i)\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)", "by simp"], ["proof (state)\nthis:\n  inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "obtain \\<C>'' where c''_def:\"\\<C>'' = \\<C>'\\<lparr>local := (local \\<C>') @ t1s @ tfs, return := Some t2s\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>''.\n        \\<C>'' = \\<C>'\n        \\<lparr>local := local \\<C>' @ t1s @ tfs,\n           return := Some t2s\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<C>'' = \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, return := Some t2s\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "hence \"\\<C>''\\<lparr>label := ([t2s] @ (label \\<C>''))\\<rparr>  = \\<C>'\\<lparr>local := (local \\<C>') @ t1s @ tfs, label := ([t2s] @ (label \\<C>')), return := Some t2s\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<C>'' = \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, return := Some t2s\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<C>''\\<lparr>label := [t2s] @ label \\<C>''\\<rparr> = \\<C>'\n    \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n       return := Some t2s\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<C>''\\<lparr>label := [t2s] @ label \\<C>''\\<rparr> = \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : ([] _> t2s)\""], ["proof (prove)\nusing this:\n  \\<C>''\\<lparr>label := [t2s] @ label \\<C>''\\<rparr> = \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s", "using ts_c_def b_e_typing.block[of \"([] _> t2s)\" \"[]\" \"t2s\" _ es] e_typing_s_typing.intros(1)[of _ \"[Block ([] _> t2s) es]\"]"], ["proof (prove)\nusing this:\n  \\<C>''\\<lparr>label := [t2s] @ label \\<C>''\\<rparr> = \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr>\n  ts'' = ts_c @ t1s\n  ts' = ts_c @ t2s\n  i < length (s_inst \\<S>)\n  \\<C>' = s_inst \\<S> ! i\n  \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s\n  \\<lbrakk>[] _> t2s = [] _> t2s;\n   ?\\<C>\n   \\<lparr>label :=\n             [t2s] @\n             label ?\\<C>\\<rparr> \\<turnstile> es : [] _> t2s\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Block ([] _> t2s) es] : [] _> t2s\n  ?\\<C> \\<turnstile> [Block ([] _> t2s) es] : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* [Block ([] _> t2s) es] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "have t_eqs:\"ts = ts_c\" \"t1s = tvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts = ts_c &&& t1s = tvs", "using tvs_def(1,2) ts_c_def(1)"], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  ts'' = ts_c @ t1s\n\ngoal (1 subgoal):\n 1. ts = ts_c &&& t1s = tvs", "by simp_all"], ["proof (state)\nthis:\n  ts = ts_c\n  t1s = tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "have 1:\"tfs = map typeof zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfs = map typeof zs", "using n_zeros_typeof assms(8)"], ["proof (prove)\nusing this:\n  n_zeros ?ts = ?vs \\<Longrightarrow> ?ts = map typeof ?vs\n  n_zeros tfs = zs\n\ngoal (1 subgoal):\n 1. tfs = map typeof zs", "by auto"], ["proof (state)\nthis:\n  tfs = map typeof zs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "have \"t1s = map typeof vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t1s = map typeof vs", "using typing_map_typeof assms(3) tvs_def t_eqs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ves = $$* ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?ves : [] _> ?tvs\\<rbrakk>\n  \\<Longrightarrow> ?tvs = map typeof ?vs\n  ves = $$* vs\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n  ts = ts_c\n  t1s = tvs\n\ngoal (1 subgoal):\n 1. t1s = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  t1s = map typeof vs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "hence \"(t1s @ tfs) = map typeof (vs @ zs)\""], ["proof (prove)\nusing this:\n  t1s = map typeof vs\n\ngoal (1 subgoal):\n 1. t1s @ tfs = map typeof (vs @ zs)", "using 1"], ["proof (prove)\nusing this:\n  t1s = map typeof vs\n  tfs = map typeof zs\n\ngoal (1 subgoal):\n 1. t1s @ tfs = map typeof (vs @ zs)", "by simp"], ["proof (state)\nthis:\n  t1s @ tfs = map typeof (vs @ zs)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s\n  t1s @ tfs = map typeof (vs @ zs)", "have \"\\<S>\\<bullet>Some t2s \\<tturnstile>_i (vs @ zs);([$Block ([] _> t2s) es]) : t2s\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s\n  t1s @ tfs = map typeof (vs @ zs)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>Some\n                  t2s \\<tturnstile>_ i vs @ zs;[$Block ([] _> t2s) es] : t2s", "using e_typing_s_typing.intros(8) ts_c_def c''_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> [$Block ([] _> t2s) es] : [] _> t2s\n  t1s @ tfs = map typeof (vs @ zs)\n  \\<lbrakk>?i < length (s_inst ?\\<S>); ?tvs = map typeof ?vs;\n   ?\\<C> = (s_inst ?\\<S> ! ?i)\n   \\<lparr>local := local (s_inst ?\\<S> ! ?i) @ ?tvs, return := ?rs\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : [] _> ?ts;\n   ?rs = Some ?ts \\<or> ?rs = None\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts\n  ts'' = ts_c @ t1s\n  ts' = ts_c @ t2s\n  i < length (s_inst \\<S>)\n  \\<C>' = s_inst \\<S> ! i\n  \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s\n  \\<C>'' = \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, return := Some t2s\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>Some\n                  t2s \\<tturnstile>_ i vs @ zs;[$Block ([] _> t2s) es] : t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>Some\n                t2s \\<tturnstile>_ i vs @ zs;[$Block ([] _> t2s) es] : t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>Some\n                t2s \\<tturnstile>_ i vs @ zs;[$Block ([] _> t2s) es] : t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "using e_typing_s_typing.intros(3,5) ts_c_def t_eqs(1) assms(2,7)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>Some\n                t2s \\<tturnstile>_ i vs @ zs;[$Block ([] _> t2s) es] : t2s\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  \\<lbrakk>?\\<S>\\<bullet>Some ?ts \\<tturnstile>_ ?i ?vs;?es : ?ts;\n   length ?ts = ?n\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Local ?n ?i ?vs\n                 ?es] : [] _> ?ts\n  ts'' = ts_c @ t1s\n  ts' = ts_c @ t2s\n  i < length (s_inst \\<S>)\n  \\<C>' = s_inst \\<S> ! i\n  \\<C>'\n  \\<lparr>local := local \\<C>' @ t1s @ tfs, label := [t2s] @ label \\<C>',\n     return := Some t2s\\<rparr> \\<turnstile> es : [] _> t2s\n  ts = ts_c\n  cl = Func_native i (t1s _> t2s) tfs es\n  length t2s = m\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                     [$Block ([] _> t2s) es]] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local m i (vs @ zs)\n                                   [$Block ([] _> t2s) es]] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_callcl_host_some:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : (ts _> ts')\"\n          \"cl = Func_host (t1s _> t2s) f\"\n          \"ves = $$* vcs\"\n          \"length vcs = n\"\n          \"length t1s = n\"\n          \"length t2s = m\"\n          \"host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\"\n          \"store_typing s \\<S>\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> ves : (ts _> ts'')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) e_type_comp"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "have ves_c:\"const_list ves\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_list ves", "using is_const_list[OF assms(3)]"], ["proof (prove)\nusing this:\n  const_list ves\n\ngoal (1 subgoal):\n 1. const_list ves", "by simp"], ["proof (state)\nthis:\n  const_list ves\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  const_list ves", "obtain tvs where tvs_def:\"ts'' = ts @ tvs\"\n                                \"length t1s = length tvs\"\n                                \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : ([] _> tvs)\""], ["proof (prove)\nusing this:\n  const_list ves\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length t1s = length tvs;\n         \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ts''_def(1) e_type_const_list[of ves \\<S> \\<C> ts ts''] assms"], ["proof (prove)\nusing this:\n  const_list ves\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\n  \\<lbrakk>const_list ves;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ts'' = ts @ tvs \\<and>\n                       length ves = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ves : [] _> tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. (\\<And>tvs.\n        \\<lbrakk>ts'' = ts @ tvs; length t1s = length tvs;\n         \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "hence \"ts'' = ts @ t1s\"\n        \"ts' = ts @ t2s\""], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. ts'' = ts @ t1s &&& ts' = ts @ t2s", "using e_type_callcl_host[OF ts''_def(2) assms(2)]"], ["proof (prove)\nusing this:\n  ts'' = ts @ tvs\n  length t1s = length tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n  \\<exists>t1sa t2sa ts_c.\n     ts'' = ts_c @ t1sa \\<and>\n     ts' = ts_c @ t2sa \\<and> t1s _> t2s = t1sa _> t2sa\n\ngoal (1 subgoal):\n 1. ts'' = ts @ t1s &&& ts' = ts @ t2s", "by auto"], ["proof (state)\nthis:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "hence \"list_all2 types_agree t1s vcs\""], ["proof (prove)\nusing this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n\ngoal (1 subgoal):\n 1. list_all2 types_agree t1s vcs", "using e_typing_imp_list_types_agree[where ?ts' = \"[]\"] assms(3) tvs_def(1,3)"], ["proof (prove)\nusing this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $$* ?vs : [] _> [] @\n             ?ts \\<Longrightarrow>\n  list_all2 types_agree ?ts ?vs\n  ves = $$* vcs\n  ts'' = ts @ tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tvs\n\ngoal (1 subgoal):\n 1. list_all2 types_agree t1s vcs", "by fastforce"], ["proof (state)\nthis:\n  list_all2 types_agree t1s vcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ([] _> t2s)\""], ["proof (prove)\nusing this:\n  list_all2 types_agree t1s vcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : [] _> t2s", "using list_types_agree_imp_e_typing host_apply_respect_type[OF _ assms(7)]"], ["proof (prove)\nusing this:\n  list_all2 types_agree t1s vcs\n  list_all2 types_agree ?ts ?vs \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $$* ?vs : [] _> ?ts\n  list_all2 types_agree t1s vcs \\<Longrightarrow>\n  list_all2 types_agree t2s vcs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : [] _> t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : [] _> t2s", "show ?thesis"], ["proof (prove)\nusing this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "using e_typing_s_typing.intros(3)"], ["proof (prove)\nusing this:\n  ts'' = ts @ t1s\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : [] _> t2s\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_imp_concat:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> es @ [e] @ es' : (ts _> ts')\"\n          \"\\<And>tes tes'. ((\\<S>\\<bullet>\\<C> \\<turnstile> [e] : (tes _> tes')) \\<Longrightarrow> (\\<S>\\<bullet>\\<C> \\<turnstile> [e'] : (tes _> tes')))\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "obtain ts'' where \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts'')\"\n                    \"\\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc1[of _ _ es \"[e] @ es'\"] assms(1)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> es @\n                                   [e] @ es' : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>ts''.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ts'' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [e] @ es' : ts'' _> ?ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e] @ es' : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'", "obtain ts''' where \"\\<S>\\<bullet>\\<C> \\<turnstile> [e] : (ts'' _> ts''')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts''' _> ts')\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [e] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc1[of _ _ \"[e]\" es' ts'' ts'] assms"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [e] @ es' : ts'' _> ts' \\<Longrightarrow>\n  \\<exists>ts''a.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [e] : ts'' _> ts''a \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> es' : ts''a _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e] @ es' : ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : ?tes _> ?tes' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e'] : ?tes _> ?tes'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [e] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "using assms(2) e_type_comp_conc[of _ _ es ts ts'' \"[e']\" ts''']\n                   e_type_comp_conc[of _ _ \"es @ [e']\" ts ts''']"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] @ es' : ts'' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : ?tes _> ?tes' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e'] : ?tes _> ?tes'\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> es : ts _> ts'';\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [e'] : ts'' _> ts'''\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> es @ [e'] : ts _> ts'''\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> es @ [e'] : ts _> ts''';\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ts''' _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> (es @ [e']) @\n               ?es' : ts _> ?t3s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es @ [e'] @ es' : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_const_return:\n  assumes \"Lfilled i lholed (vs @ [$Return]) LI\"\n          \"(return \\<C>) = Some tcs\"\n          \"length tcs = length vs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> LI : (ts _> ts')\"\n          \"const_list vs\"\n  shows \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tcs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "using assms"], ["proof (prove)\nusing this:\n  Lfilled i lholed (vs @ [$Return]) LI\n  return \\<C> = Some tcs\n  length tcs = length vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n  const_list vs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "proof (induction i arbitrary: ts ts' lholed \\<C> LI \\<C>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "case 0"], ["proof (state)\nthis:\n  Lfilled 0 lholed (vs @ [$Return]) LI\n  return \\<C> = Some tcs\n  length tcs = length vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n  const_list vs\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "obtain vs' es' where \"LI = (vs' @ (vs @ [$Return]) @ es')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs' es'.\n        LI = vs' @ (vs @ [$Return]) @ es' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Lfilled.simps[of 0 lholed \"(vs @ [$Return])\" LI] 0(1)"], ["proof (prove)\nusing this:\n  Lfilled 0 lholed (vs @ [$Return]) LI =\n  ((\\<exists>vsa lholed es' es.\n       0 = 0 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Return] = es \\<and>\n       LI = vsa @ es @ es' \\<and>\n       const_list vsa \\<and> lholed = LBase vsa es') \\<or>\n   (\\<exists>vsa lholed n es' l es'' k es lfilledk.\n       0 = k + 1 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Return] = es \\<and>\n       LI = vsa @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vsa \\<and>\n       lholed = LRec vsa n es' l es'' \\<and> Lfilled k l es lfilledk))\n  Lfilled 0 lholed (vs @ [$Return]) LI\n\ngoal (1 subgoal):\n 1. (\\<And>vs' es'.\n        LI = vs' @ (vs @ [$Return]) @ es' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  LI = vs' @ (vs @ [$Return]) @ es'\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  LI = vs' @ (vs @ [$Return]) @ es'", "obtain ts'' ts''' where \"\\<S>\\<bullet>\\<C> \\<turnstile> vs' : (ts _> ts'')\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> (vs @ [$Return]) : (ts'' _> ts''')\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts''' _> ts')\""], ["proof (prove)\nusing this:\n  LI = vs' @ (vs @ [$Return]) @ es'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[of \\<S> \\<C> vs' \"(vs @ [$Return])\" es'] 0(4)"], ["proof (prove)\nusing this:\n  LI = vs' @ (vs @ [$Return]) @ es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' @\n                                 (vs @ [$Return]) @\n                                 es' : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ?t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'", "obtain ts_b where ts_b_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts'' _> ts_b)\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : (ts_b _> ts''')\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_b.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts_b _> ts'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc1"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   ?es' : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>ts''.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts _> ts'' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ts'' _> ?ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_b.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts_b _> ts'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts_b _> ts'''\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts_b _> ts'''", "obtain ts_c where ts_c_def:\"ts_b = ts_c @ tcs\" \"(return \\<C>) = Some tcs\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts_b _> ts'''\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        \\<lbrakk>ts_b = ts_c @ tcs; return \\<C> = Some tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 0(2) b_e_type_return[of \\<C>] unlift_b_e[of \\<S> \\<C> \"[Return]\" \"ts_b _> ts'''\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts_b _> ts'''\n  return \\<C> = Some tcs\n  \\<lbrakk>\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = Return\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''.\n                       ?ts = ts_c @ ts'' \\<and> return \\<C> = Some ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Return] : ts_b _> ts''' \\<Longrightarrow>\n  \\<C> \\<turnstile> [Return] : ts_b _> ts'''\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        \\<lbrakk>ts_b = ts_c @ tcs; return \\<C> = Some tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts_b = ts_c @ tcs\n  return \\<C> = Some tcs\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "obtain tcs' where \"ts_b = ts'' @ tcs'\" \"length vs = length tcs'\" \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tcs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tcs'.\n        \\<lbrakk>ts_b = ts'' @ tcs'; length vs = length tcs';\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ts_b_def(1) e_type_const_list 0(5)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  const_list vs\n\ngoal (1 subgoal):\n 1. (\\<And>tcs'.\n        \\<lbrakk>ts_b = ts'' @ tcs'; length vs = length tcs';\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts_b = ts'' @ tcs'\n  length vs = length tcs'\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Return]) LI;\n        return \\<C> = Some tcs; length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "thus ?case"], ["proof (prove)\nusing this:\n  ts_b = ts'' @ tcs'\n  length vs = length tcs'\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "using 0(3) ts_c_def"], ["proof (prove)\nusing this:\n  ts_b = ts'' @ tcs'\n  length vs = length tcs'\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\n  length tcs = length vs\n  ts_b = ts_c @ tcs\n  return \\<C> = Some tcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n\ngoal (1 subgoal):\n 1. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>Lfilled i ?lholed (vs @ [$Return]) ?LI; return ?\\<C> = Some tcs;\n   length tcs = length vs;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> ?LI : ?ts _> ?ts'; const_list vs\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> vs : [] _> tcs\n  Lfilled (Suc i) lholed (vs @ [$Return]) LI\n  return \\<C> = Some tcs\n  length tcs = length vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n  const_list vs\n\ngoal (1 subgoal):\n 1. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "obtain vs' n l les les' LK where es_def:\"lholed = (LRec vs' n les l les')\"\n                                           \"Lfilled i l (vs @ [$Return]) LK\"\n                                           \"LI = (vs' @ [Label n les LK] @ les')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs' n les l les' LK.\n        \\<lbrakk>lholed = LRec vs' n les l les';\n         Lfilled i l (vs @ [$Return]) LK;\n         LI = vs' @ [Label n les LK] @ les'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Lfilled.simps[of \"(Suc i)\" lholed \"(vs @ [$Return])\" LI] Suc(2)"], ["proof (prove)\nusing this:\n  Lfilled (Suc i) lholed (vs @ [$Return]) LI =\n  ((\\<exists>vsa lholed es' es.\n       Suc i = 0 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Return] = es \\<and>\n       LI = vsa @ es @ es' \\<and>\n       const_list vsa \\<and> lholed = LBase vsa es') \\<or>\n   (\\<exists>vsa lholed n es' l es'' k es lfilledk.\n       Suc i = k + 1 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Return] = es \\<and>\n       LI = vsa @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vsa \\<and>\n       lholed = LRec vsa n es' l es'' \\<and> Lfilled k l es lfilledk))\n  Lfilled (Suc i) lholed (vs @ [$Return]) LI\n\ngoal (1 subgoal):\n 1. (\\<And>vs' n les l les' LK.\n        \\<lbrakk>lholed = LRec vs' n les l les';\n         Lfilled i l (vs @ [$Return]) LK;\n         LI = vs' @ [Label n les LK] @ les'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Return]) LK\n  LI = vs' @ [Label n les LK] @ les'\n\ngoal (1 subgoal):\n 1. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Return]) LK\n  LI = vs' @ [Label n les LK] @ les'", "obtain ts'' ts''' where \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : (ts'' _> ts''')\""], ["proof (prove)\nusing this:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Return]) LK\n  LI = vs' @ [Label n les LK] @ les'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les\n   LK] : ts'' _> ts''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[of \\<S> \\<C> vs' \"[Label n les LK]\" les'] Suc(5)"], ["proof (prove)\nusing this:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Return]) LK\n  LI = vs' @ [Label n les LK] @ les'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' @\n                                 [Label n les LK] @\n                                 les' : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts'' _> ?t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les\n   LK] : ts'' _> ts''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''", "obtain tls t2s where\n       \"ts''' = ts'' @ t2s\"\n       \"length tls = n\"\n       \"\\<S>\\<bullet>\\<C> \\<turnstile> les : (tls _> t2s)\"\n       \"\\<S>\\<bullet>\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : ([] _> t2s)\"\n       \"return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) = Some tcs\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. (\\<And>t2s tls.\n        \\<lbrakk>ts''' = ts'' @ t2s; length tls = n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s;\n         \\<S>\\<bullet>\\<C>\n         \\<lparr>label :=\n                   [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s;\n         return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) =\n         Some tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[of \\<S> \\<C> n les LK ts'' ts'''] Suc(3)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les\n                                   LK] : ts'' _> ts''' \\<Longrightarrow>\n  \\<exists>tls t2s.\n     ts''' = ts'' @ t2s \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s\n  return \\<C> = Some tcs\n\ngoal (1 subgoal):\n 1. (\\<And>t2s tls.\n        \\<lbrakk>ts''' = ts'' @ t2s; length tls = n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s;\n         \\<S>\\<bullet>\\<C>\n         \\<lparr>label :=\n                   [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s;\n         return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) =\n         Some tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts''' = ts'' @ t2s\n  length tls = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s\n  return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) = Some tcs\n\ngoal (1 subgoal):\n 1. \\<And>i ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Return]) LI;\n                    return \\<C> = Some tcs; length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Return]) LI; return \\<C> = Some tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  ts''' = ts'' @ t2s\n  length tls = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s\n  return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) = Some tcs", "show ?case"], ["proof (prove)\nusing this:\n  ts''' = ts'' @ t2s\n  length tls = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s\n  return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) = Some tcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "using Suc(1)[OF es_def(2) _ assms(3) _ assms(5)]"], ["proof (prove)\nusing this:\n  ts''' = ts'' @ t2s\n  length tls = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s\n  return (\\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>) = Some tcs\n  \\<lbrakk>return ?\\<C> = Some tcs;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> LK : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> vs : [] _> tcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_return:\n  assumes \"\\<lparr>[Local n i vls LI]\\<rparr> \\<leadsto> \\<lparr>ves\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vls LI] : (ts _> ts')\"\n          \"const_list ves\"\n          \"length ves = n\"\n          \"Lfilled j lholed (ves @ [$Return]) LI\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'", "obtain tls \\<C>' where l_def:\"i < length (s_inst \\<S>)\"\n                        \"\\<C>' = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i)) @ (map typeof vls), return := Some tls\\<rparr>\"\n                        \"\\<S>\\<bullet>\\<C>' \\<turnstile> LI : ([] _> tls)\"\n                        \"ts' = ts @ tls\"\n                        \"length tls = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>' tls.\n        \\<lbrakk>i < length (s_inst \\<S>);\n         \\<C>' = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n            return := Some tls\\<rparr>;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> LI : [] _> tls; ts' = ts @ tls;\n         length tls = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_local[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<exists>tls.\n     i < length (s_inst \\<S>) \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>(s_inst \\<S> ! i)\n     \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n        return := Some tls\\<rparr> \\<turnstile> LI : [] _> tls \\<and>\n     ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>' tls.\n        \\<lbrakk>i < length (s_inst \\<S>);\n         \\<C>' = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n            return := Some tls\\<rparr>;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> LI : [] _> tls; ts' = ts @ tls;\n         length tls = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> LI : [] _> tls\n  ts' = ts @ tls\n  length tls = n\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C> \\<turnstile> ves : ([] _> tls)\""], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> LI : [] _> tls\n  ts' = ts @ tls\n  length tls = n\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tls", "using type_const_return[OF assms(5) _ _ l_def(3)] assms(3-5)"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> LI : [] _> tls\n  ts' = ts @ tls\n  length tls = n\n  \\<lbrakk>return \\<C>' = Some ?tcs; length ?tcs = length ves;\n   const_list ves\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> ves : [] _> ?tcs\n  const_list ves\n  length ves = n\n  Lfilled j lholed (ves @ [$Return]) LI\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tls", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'", "using e_typing_s_typing.intros(3) l_def(4)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : [] _> tls\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_const_br:\n  assumes \"Lfilled i lholed (vs @ [$Br (i+k)]) LI\"\n          \"length (label \\<C>) > k\"\n          \"(label \\<C>)!k = tcs\"\n          \"length tcs = length vs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> LI : (ts _> ts')\"\n          \"const_list vs\"\n  shows \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tcs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "using assms"], ["proof (prove)\nusing this:\n  Lfilled i lholed (vs @ [$Br (i + k)]) LI\n  k < length (label \\<C>)\n  label \\<C> ! k = tcs\n  length tcs = length vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n  const_list vs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "proof (induction i arbitrary: k ts ts' lholed \\<C> LI \\<C>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "case 0"], ["proof (state)\nthis:\n  Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI\n  k < length (label \\<C>)\n  label \\<C> ! k = tcs\n  length tcs = length vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n  const_list vs\n\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "obtain vs' es' where \"LI = (vs' @ (vs @ [$Br (0+k)]) @ es')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs' es'.\n        LI = vs' @ (vs @ [$Br (0 + k)]) @ es' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Lfilled.simps[of 0 lholed \"(vs @ [$Br (0 + k)])\" LI] 0(1)"], ["proof (prove)\nusing this:\n  Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI =\n  ((\\<exists>vsa lholed es' es.\n       0 = 0 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Br (0 + k)] = es \\<and>\n       LI = vsa @ es @ es' \\<and>\n       const_list vsa \\<and> lholed = LBase vsa es') \\<or>\n   (\\<exists>vsa lholed n es' l es'' k es lfilledk.\n       0 = k + 1 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Br (0 + k)] = es \\<and>\n       LI = vsa @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vsa \\<and>\n       lholed = LRec vsa n es' l es'' \\<and> Lfilled k l es lfilledk))\n  Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI\n\ngoal (1 subgoal):\n 1. (\\<And>vs' es'.\n        LI = vs' @ (vs @ [$Br (0 + k)]) @ es' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  LI = vs' @ (vs @ [$Br (0 + k)]) @ es'\n\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  LI = vs' @ (vs @ [$Br (0 + k)]) @ es'", "obtain ts'' ts''' where \"\\<S>\\<bullet>\\<C> \\<turnstile> vs' : (ts _> ts'')\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> (vs @ [$Br (0+k)]) : (ts'' _> ts''')\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts''' _> ts')\""], ["proof (prove)\nusing this:\n  LI = vs' @ (vs @ [$Br (0 + k)]) @ es'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[of \\<S> \\<C> vs' \"(vs @ [$Br (0+k)])\" es'] 0(5)"], ["proof (prove)\nusing this:\n  LI = vs' @ (vs @ [$Br (0 + k)]) @ es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' @\n                                 (vs @ [$Br (0 + k)]) @\n                                 es' : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ?t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'", "obtain ts_b where ts_b_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts'' _> ts_b)\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0+k)] : (ts_b _> ts''')\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_b.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Br\n     (0 + k)] : ts_b _> ts'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc1"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   ?es' : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>ts''.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts _> ts'' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ts'' _> ?ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts_b.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Br\n     (0 + k)] : ts_b _> ts'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0 + k)] : ts_b _> ts'''\n\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0 + k)] : ts_b _> ts'''", "obtain ts_c where ts_c_def:\"ts_b = ts_c @ tcs\" \"(label \\<C>)!k = tcs\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0 + k)] : ts_b _> ts'''\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        \\<lbrakk>ts_b = ts_c @ tcs; label \\<C> ! k = tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 0(3) b_e_type_br[of \\<C> \"Br (0 + k)\"] unlift_b_e[of \\<S> \\<C> \"[Br (0 + k)]\" \"ts_b _> ts'''\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0 + k)] : ts_b _> ts'''\n  label \\<C> ! k = tcs\n  \\<lbrakk>\\<C> \\<turnstile> [Br (0 + k)] : ?ts _> ?ts';\n   Br (0 + k) = Br ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (label \\<C>)\n  \\<lbrakk>\\<C> \\<turnstile> [Br (0 + k)] : ?ts _> ?ts';\n   Br (0 + k) = Br ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''.\n                       ?ts = ts_c @ ts'' \\<and> label \\<C> ! ?i = ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Br\n(0 + k)] : ts_b _> ts''' \\<Longrightarrow>\n  \\<C> \\<turnstile> [Br (0 + k)] : ts_b _> ts'''\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        \\<lbrakk>ts_b = ts_c @ tcs; label \\<C> ! k = tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts_b = ts_c @ tcs\n  label \\<C> ! k = tcs\n\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "obtain tcs' where \"ts_b = ts'' @ tcs'\" \"length vs = length tcs'\" \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tcs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tcs'.\n        \\<lbrakk>ts_b = ts'' @ tcs'; length vs = length tcs';\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ts_b_def(1) e_type_const_list 0(6)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts'' _> ts_b\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  const_list vs\n\ngoal (1 subgoal):\n 1. (\\<And>tcs'.\n        \\<lbrakk>ts_b = ts'' @ tcs'; length vs = length tcs';\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts_b = ts'' @ tcs'\n  length vs = length tcs'\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\n\ngoal (2 subgoals):\n 1. \\<And>k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>Lfilled 0 lholed (vs @ [$Br (0 + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n 2. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "thus ?case"], ["proof (prove)\nusing this:\n  ts_b = ts'' @ tcs'\n  length vs = length tcs'\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "using 0(4) ts_c_def"], ["proof (prove)\nusing this:\n  ts_b = ts'' @ tcs'\n  length vs = length tcs'\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs'\n  length tcs = length vs\n  ts_b = ts_c @ tcs\n  label \\<C> ! k = tcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "case (Suc i k ts ts' lholed \\<C> LI)"], ["proof (state)\nthis:\n  \\<lbrakk>Lfilled i ?lholed (vs @ [$Br (i + ?k)]) ?LI;\n   ?k < length (label ?\\<C>); label ?\\<C> ! ?k = tcs;\n   length tcs = length vs;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> ?LI : ?ts _> ?ts'; const_list vs\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> vs : [] _> tcs\n  Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI\n  k < length (label \\<C>)\n  label \\<C> ! k = tcs\n  length tcs = length vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n  const_list vs\n\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "obtain vs' n l les les' LK where es_def:\"lholed = (LRec vs' n les l les')\"\n                                           \"Lfilled i l (vs @ [$Br (i + (Suc k))]) LK\"\n                                           \"LI = (vs' @ [Label n les LK] @ les')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs' n les l les' LK.\n        \\<lbrakk>lholed = LRec vs' n les l les';\n         Lfilled i l (vs @ [$Br (i + Suc k)]) LK;\n         LI = vs' @ [Label n les LK] @ les'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Lfilled.simps[of \"(Suc i)\" lholed \"(vs @ [$Br ((Suc i) + k)])\" LI] Suc(2)"], ["proof (prove)\nusing this:\n  Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI =\n  ((\\<exists>vsa lholed es' es.\n       Suc i = 0 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Br (Suc i + k)] = es \\<and>\n       LI = vsa @ es @ es' \\<and>\n       const_list vsa \\<and> lholed = LBase vsa es') \\<or>\n   (\\<exists>vsa lholed n es' l es'' k es lfilledk.\n       Suc i = k + 1 \\<and>\n       lholed = lholed \\<and>\n       vs @ [$Br (Suc i + k)] = es \\<and>\n       LI = vsa @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vsa \\<and>\n       lholed = LRec vsa n es' l es'' \\<and> Lfilled k l es lfilledk))\n  Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI\n\ngoal (1 subgoal):\n 1. (\\<And>vs' n les l les' LK.\n        \\<lbrakk>lholed = LRec vs' n les l les';\n         Lfilled i l (vs @ [$Br (i + Suc k)]) LK;\n         LI = vs' @ [Label n les LK] @ les'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Br (i + Suc k)]) LK\n  LI = vs' @ [Label n les LK] @ les'\n\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Br (i + Suc k)]) LK\n  LI = vs' @ [Label n les LK] @ les'", "obtain ts'' ts''' where \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : (ts'' _> ts''')\""], ["proof (prove)\nusing this:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Br (i + Suc k)]) LK\n  LI = vs' @ [Label n les LK] @ les'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les\n   LK] : ts'' _> ts''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[of \\<S> \\<C> vs' \"[Label n les LK]\" les'] Suc(6)"], ["proof (prove)\nusing this:\n  lholed = LRec vs' n les l les'\n  Lfilled i l (vs @ [$Br (i + Suc k)]) LK\n  LI = vs' @ [Label n les LK] @ les'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs' @\n                                 [Label n les LK] @\n                                 les' : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs' : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts'' _> ?t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les\n   LK] : ts'' _> ts''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''", "obtain lts \\<C>'' ts'''' where \"\\<S>\\<bullet>\\<C>'' \\<turnstile> LK : ([] _> ts'''')\" \"\\<C>'' = \\<C>\\<lparr>label := [lts] @ (label \\<C>)\\<rparr>\"\n                             \"length (label \\<C>'') > (Suc k)\"\n                             \"(label \\<C>'')!(Suc k) = tcs\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>''' ts'''' lts.\n        \\<lbrakk>\\<S>\\<bullet>\\<C>''' \\<turnstile> LK : [] _> ts'''';\n         \\<C>''' = \\<C>\\<lparr>label := [lts] @ label \\<C>\\<rparr>;\n         Suc k < length (label \\<C>''');\n         label \\<C>''' ! Suc k = tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[of \\<S> \\<C> n les LK ts'' ts'''] Suc(3,4)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les LK] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n les\n                                   LK] : ts'' _> ts''' \\<Longrightarrow>\n  \\<exists>tls t2s.\n     ts''' = ts'' @ t2s \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> les : tls _> t2s \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LK : [] _> t2s\n  k < length (label \\<C>)\n  label \\<C> ! k = tcs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>''' ts'''' lts.\n        \\<lbrakk>\\<S>\\<bullet>\\<C>''' \\<turnstile> LK : [] _> ts'''';\n         \\<C>''' = \\<C>\\<lparr>label := [lts] @ label \\<C>\\<rparr>;\n         Suc k < length (label \\<C>''');\n         label \\<C>''' ! Suc k = tcs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> LK : [] _> ts''''\n  \\<C>'' = \\<C>\\<lparr>label := [lts] @ label \\<C>\\<rparr>\n  Suc k < length (label \\<C>'')\n  label \\<C>'' ! Suc k = tcs\n\ngoal (1 subgoal):\n 1. \\<And>i k ts ts' lholed \\<C> LI \\<C>'.\n       \\<lbrakk>\\<And>k ts ts' lholed \\<C> LI \\<C>'.\n                   \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + k)]) LI;\n                    k < length (label \\<C>); label \\<C> ! k = tcs;\n                    length tcs = length vs;\n                    \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n                    const_list vs\\<rbrakk>\n                   \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs;\n        Lfilled (Suc i) lholed (vs @ [$Br (Suc i + k)]) LI;\n        k < length (label \\<C>); label \\<C> ! k = tcs;\n        length tcs = length vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> LI : ts _> ts';\n        const_list vs\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> LK : [] _> ts''''\n  \\<C>'' = \\<C>\\<lparr>label := [lts] @ label \\<C>\\<rparr>\n  Suc k < length (label \\<C>'')\n  label \\<C>'' ! Suc k = tcs", "show ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> LK : [] _> ts''''\n  \\<C>'' = \\<C>\\<lparr>label := [lts] @ label \\<C>\\<rparr>\n  Suc k < length (label \\<C>'')\n  label \\<C>'' ! Suc k = tcs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "using Suc(1) es_def(2) assms(4,6)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> LK : [] _> ts''''\n  \\<C>'' = \\<C>\\<lparr>label := [lts] @ label \\<C>\\<rparr>\n  Suc k < length (label \\<C>'')\n  label \\<C>'' ! Suc k = tcs\n  \\<lbrakk>Lfilled i ?lholed (vs @ [$Br (i + ?k)]) ?LI;\n   ?k < length (label ?\\<C>); label ?\\<C> ! ?k = tcs;\n   length tcs = length vs;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> ?LI : ?ts _> ?ts'; const_list vs\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> vs : [] _> tcs\n  Lfilled i l (vs @ [$Br (i + Suc k)]) LK\n  length tcs = length vs\n  const_list vs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tcs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_br:\n  assumes \"\\<lparr>[Label n es0 LI]\\<rparr> \\<leadsto> \\<lparr>vs @ es0\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0 LI] : (ts _> ts')\"\n          \"const_list vs\"\n          \"length vs = n\"\n          \"Lfilled i lholed (vs @ [$Br i]) LI\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> (vs @ es0) : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'", "obtain tls t2s \\<C>' where l_def:\"(ts' = (ts@t2s))\"\n                            \"(\\<S>\\<bullet>\\<C> \\<turnstile> es0 : (tls _> t2s))\"\n                            \"\\<C>' = \\<C>\\<lparr>label := [tls] @ (label \\<C>)\\<rparr>\"\n                            \"length (label \\<C>') > 0\"\n                            \"(label \\<C>')!0 = tls\"\n                            \"length tls = n\"\n                            \"(\\<S>\\<bullet>\\<C>\\<lparr>label := [tls] @ (label \\<C>)\\<rparr> \\<turnstile> LI : ([] _> t2s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t2s tls \\<C>'.\n        \\<lbrakk>ts' = ts @ t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s;\n         \\<C>' = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>;\n         0 < length (label \\<C>'); label \\<C>' ! 0 = tls; length tls = n;\n         \\<S>\\<bullet>\\<C>\n         \\<lparr>label :=\n                   [tls] @\n                   label \\<C>\\<rparr> \\<turnstile> LI : [] _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[of \\<S> \\<C> n es0 LI ts ts'] assms(2)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0\n                                   LI] : ts _> ts' \\<Longrightarrow>\n  \\<exists>tls t2s.\n     ts' = ts @ t2s \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LI : [] _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es0 LI] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>t2s tls \\<C>'.\n        \\<lbrakk>ts' = ts @ t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s;\n         \\<C>' = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>;\n         0 < length (label \\<C>'); label \\<C>' ! 0 = tls; length tls = n;\n         \\<S>\\<bullet>\\<C>\n         \\<lparr>label :=\n                   [tls] @\n                   label \\<C>\\<rparr> \\<turnstile> LI : [] _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<C>' = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\n  0 < length (label \\<C>')\n  label \\<C>' ! 0 = tls\n  length tls = n\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LI : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'", "hence \"\\<S>\\<bullet>\\<C> \\<turnstile> vs : ([] _> tls)\""], ["proof (prove)\nusing this:\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<C>' = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\n  0 < length (label \\<C>')\n  label \\<C>' ! 0 = tls\n  length tls = n\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LI : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> tls", "using assms(3-5) type_const_br[of i lholed vs 0 LI \\<C>' tls]"], ["proof (prove)\nusing this:\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<C>' = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\n  0 < length (label \\<C>')\n  label \\<C>' ! 0 = tls\n  length tls = n\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [tls] @ label \\<C>\\<rparr> \\<turnstile> LI : [] _> t2s\n  const_list vs\n  length vs = n\n  Lfilled i lholed (vs @ [$Br i]) LI\n  \\<lbrakk>Lfilled i lholed (vs @ [$Br (i + 0)]) LI;\n   0 < length (label \\<C>'); label \\<C>' ! 0 = tls; length tls = length vs;\n   ?\\<S>\\<bullet>\\<C>' \\<turnstile> LI : ?ts _> ?ts'; const_list vs\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C>' \\<turnstile> vs : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> tls", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'", "using l_def(1,2) e_type_comp_conc e_typing_s_typing.intros(3)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> tls\n  ts' = ts @ t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es0 : tls _> t2s\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n               ?es' : ?t1s _> ?t3s\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es0 : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma store_local_label_empty:\n  assumes \"i < length (s_inst \\<S>)\"\n          \"store_typing s \\<S>\"\n  shows \"label ((s_inst \\<S>)!i) = []\" \"local ((s_inst \\<S>)!i) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. label (s_inst \\<S> ! i) = [] &&& local (s_inst \\<S> ! i) = []", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. label (s_inst \\<S> ! i) = []\n 2. local (s_inst \\<S> ! i) = []", "obtain insts where inst_typ:\"list_all2 (inst_typing \\<S>) insts (s_inst \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>insts.\n        list_all2 (inst_typing \\<S>) insts (s_inst \\<S>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. (\\<And>insts.\n        list_all2 (inst_typing \\<S>) insts (s_inst \\<S>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding store_typing.simps"], ["proof (prove)\nusing this:\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     list_all2 (inst_typing \\<S>') insts \\<C>s \\<and>\n     list_all2 (cl_typing \\<S>') fs tfs \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     list_all2 (\\<lambda>tcls n. n \\<le> length tcls) tclss ns \\<and>\n     list_all2 mem_agree bss ms \\<and> list_all2 glob_agree gs tgs\n\ngoal (1 subgoal):\n 1. (\\<And>insts.\n        list_all2 (inst_typing \\<S>) insts (s_inst \\<S>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  list_all2 (inst_typing \\<S>) insts (s_inst \\<S>)\n\ngoal (2 subgoals):\n 1. label (s_inst \\<S> ! i) = []\n 2. local (s_inst \\<S> ! i) = []", "thus \"label ((s_inst \\<S>)!i) = []\""], ["proof (prove)\nusing this:\n  list_all2 (inst_typing \\<S>) insts (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. label (s_inst \\<S> ! i) = []", "using assms(1)"], ["proof (prove)\nusing this:\n  list_all2 (inst_typing \\<S>) insts (s_inst \\<S>)\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. label (s_inst \\<S> ! i) = []", "unfolding inst_typing.simps List.list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  length insts = length (s_inst \\<S>) \\<and>\n  (\\<forall>i<length insts.\n      \\<exists>\\<S>' fs tfs gs tgs ia i' n j m ts.\n         \\<S> = \\<S>' \\<and>\n         insts ! i =\n         \\<lparr>types = ts, funcs = fs, tab = ia, mem = j,\n            globs = gs\\<rparr> \\<and>\n         s_inst \\<S> ! i =\n         \\<lparr>types_t = ts, func_t = tfs, global = tgs, table = n,\n            memory = m, local = [], label = [], return = None\\<rparr> \\<and>\n         (length fs = length tfs \\<and>\n          (\\<forall>i<length fs.\n              funci_agree (s_funcs \\<S>') (fs ! i) (tfs ! i))) \\<and>\n         (length gs = length tgs \\<and>\n          (\\<forall>i<length gs.\n              globi_agree (s_globs \\<S>') (gs ! i) (tgs ! i))) \\<and>\n         (ia = Some i' \\<and>\n          i' < length (s_tab \\<S>') \\<and> s_tab \\<S>' ! i' = the n \\<or>\n          ia = None \\<and> n = None) \\<and>\n         memi_agree (s_mem \\<S>') j m)\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. label (s_inst \\<S> ! i) = []", "by fastforce"], ["proof (state)\nthis:\n  label (s_inst \\<S> ! i) = []\n\ngoal (1 subgoal):\n 1. local (s_inst \\<S> ! i) = []", "show \"local ((s_inst \\<S>)!i) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local (s_inst \\<S> ! i) = []", "using assms(1) inst_typ"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  list_all2 (inst_typing \\<S>) insts (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. local (s_inst \\<S> ! i) = []", "unfolding inst_typing.simps List.list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  length insts = length (s_inst \\<S>) \\<and>\n  (\\<forall>i<length insts.\n      \\<exists>\\<S>' fs tfs gs tgs ia i' n j m ts.\n         \\<S> = \\<S>' \\<and>\n         insts ! i =\n         \\<lparr>types = ts, funcs = fs, tab = ia, mem = j,\n            globs = gs\\<rparr> \\<and>\n         s_inst \\<S> ! i =\n         \\<lparr>types_t = ts, func_t = tfs, global = tgs, table = n,\n            memory = m, local = [], label = [], return = None\\<rparr> \\<and>\n         (length fs = length tfs \\<and>\n          (\\<forall>i<length fs.\n              funci_agree (s_funcs \\<S>') (fs ! i) (tfs ! i))) \\<and>\n         (length gs = length tgs \\<and>\n          (\\<forall>i<length gs.\n              globi_agree (s_globs \\<S>') (gs ! i) (tgs ! i))) \\<and>\n         (ia = Some i' \\<and>\n          i' < length (s_tab \\<S>') \\<and> s_tab \\<S>' ! i' = the n \\<or>\n          ia = None \\<and> n = None) \\<and>\n         memi_agree (s_mem \\<S>') j m)\n\ngoal (1 subgoal):\n 1. local (s_inst \\<S> ! i) = []", "by fastforce"], ["proof (state)\nthis:\n  local (s_inst \\<S> ! i) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_b_e1:\n  assumes \"\\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "proof (cases rule: reduce_simple.cases)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Unop_i T_i32 iop];\n        es' = [$C ConstInt32 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Unop_i T_i64 iop];\n        es' = [$C ConstInt64 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>es =\n                 [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                  $Binop_f T_f32 fop];\n         es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 42 subgoals...", "case (unop_i32 c iop)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c, $Unop_i T_i32 iop]\n  es' = [$C ConstInt32 (app_unop_i iop c)]\n\ngoal (42 subgoals):\n 1. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Unop_i T_i32 iop];\n        es' = [$C ConstInt32 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Unop_i T_i64 iop];\n        es' = [$C ConstInt64 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>es =\n                 [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                  $Binop_f T_f32 fop];\n         es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 42 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Unop_i T_i32 iop]\n  es' = [$C ConstInt32 (app_unop_i iop c)]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1,3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Unop_i T_i32 iop]\n  es' = [$C ConstInt32 (app_unop_i iop c)]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (41 subgoals):\n 1. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Unop_i T_i64 iop];\n        es' = [$C ConstInt64 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2 c.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Binop_f T_f64 fop];\n         es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Unop_i T_i64 iop];\n        es' = [$C ConstInt64 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2 c.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Binop_f T_f64 fop];\n         es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 41 subgoals...", "case (unop_i64 c iop)"], ["proof (state)\nthis:\n  es = [$C ConstInt64 c, $Unop_i T_i64 iop]\n  es' = [$C ConstInt64 (app_unop_i iop c)]\n\ngoal (41 subgoals):\n 1. \\<And>c iop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Unop_i T_i64 iop];\n        es' = [$C ConstInt64 (app_unop_i iop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2 c.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Binop_f T_f64 fop];\n         es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 41 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c, $Unop_i T_i64 iop]\n  es' = [$C ConstInt64 (app_unop_i iop c)]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c, $Unop_i T_i64 iop]\n  es' = [$C ConstInt64 (app_unop_i iop c)]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (40 subgoals):\n 1. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Binop_f T_f64 fop];\n         es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Binop_f T_f64 fop];\n         es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 40 subgoals...", "case (unop_f32 c fop)"], ["proof (state)\nthis:\n  es = [$C ConstFloat32 c, $Unop_f T_f32 fop]\n  es' = [$C ConstFloat32 (app_unop_f fop c)]\n\ngoal (40 subgoals):\n 1. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat32 c, $Unop_f T_f32 fop];\n        es' = [$C ConstFloat32 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Binop_f T_f64 fop];\n         es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 40 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c, $Unop_f T_f32 fop]\n  es' = [$C ConstFloat32 (app_unop_f fop c)]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c, $Unop_f T_f32 fop]\n  es' = [$C ConstFloat32 (app_unop_f fop c)]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (39 subgoals):\n 1. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c testop.\n        \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n         es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c testop.\n        \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n         es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 39 subgoals...", "case (unop_f64 c fop)"], ["proof (state)\nthis:\n  es = [$C ConstFloat64 c, $Unop_f T_f64 fop]\n  es' = [$C ConstFloat64 (app_unop_f fop c)]\n\ngoal (39 subgoals):\n 1. \\<And>c fop.\n       \\<lbrakk>es = [$C ConstFloat64 c, $Unop_f T_f64 fop];\n        es' = [$C ConstFloat64 (app_unop_f fop c)]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c testop.\n        \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n         es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 39 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c, $Unop_f T_f64 fop]\n  es' = [$C ConstFloat64 (app_unop_f fop c)]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c, $Unop_f T_f64 fop]\n  es' = [$C ConstFloat64 (app_unop_f fop c)]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (38 subgoals):\n 1. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c testop.\n        \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n         es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 38 subgoals...", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c testop.\n        \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n         es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 38 subgoals...", "case (binop_i32_Some iop c1 c2 c)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\n  es' = [$C ConstInt32 c]\n  app_binop_i iop c1 c2 = Some c\n\ngoal (38 subgoals):\n 1. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [$C ConstInt32 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c testop.\n        \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n         es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 38 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\n  es' = [$C ConstInt32 c]\n  app_binop_i iop c1 c2 = Some c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\n  es' = [$C ConstInt32 c]\n  app_binop_i iop c1 c2 = Some c\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (37 subgoals):\n 1. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 iop.\n        \\<lbrakk>es =\n                 [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 iop.\n        \\<lbrakk>es =\n                 [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 37 subgoals...", "case (binop_i32_None iop c1 c2)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\n  es' = [Trap]\n  app_binop_i iop c1 c2 = None\n\ngoal (37 subgoals):\n 1. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 iop.\n        \\<lbrakk>es =\n                 [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 37 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\n  es' = [Trap]\n  app_binop_i iop c1 c2 = None\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (36 subgoals):\n 1. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 iop.\n        \\<lbrakk>es =\n                 [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 iop.\n        \\<lbrakk>es =\n                 [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 36 subgoals...", "case (binop_i64_Some iop c1 c2 c)"], ["proof (state)\nthis:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\n  es' = [$C ConstInt64 c]\n  app_binop_i iop c1 c2 = Some c\n\ngoal (36 subgoals):\n 1. \\<And>iop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [$C ConstInt64 c]; app_binop_i iop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 iop.\n        \\<lbrakk>es =\n                 [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 36 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\n  es' = [$C ConstInt64 c]\n  app_binop_i iop c1 c2 = Some c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\n  es' = [$C ConstInt64 c]\n  app_binop_i iop c1 c2 = Some c\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (35 subgoals):\n 1. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 fop.\n        \\<lbrakk>es =\n                 [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                  $Relop_f T_f32 fop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 fop.\n        \\<lbrakk>es =\n                 [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                  $Relop_f T_f32 fop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 35 subgoals...", "case (binop_i64_None iop c1 c2)"], ["proof (state)\nthis:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\n  es' = [Trap]\n  app_binop_i iop c1 c2 = None\n\ngoal (35 subgoals):\n 1. \\<And>iop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop];\n        es' = [Trap]; app_binop_i iop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 fop.\n        \\<lbrakk>es =\n                 [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                  $Relop_f T_f32 fop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 35 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\n  es' = [Trap]\n  app_binop_i iop c1 c2 = None\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (34 subgoals):\n 1. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 fop.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Relop_f T_f64 fop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 fop.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Relop_f T_f64 fop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 34 subgoals...", "case (binop_f32_Some fop c1 c2 c)"], ["proof (state)\nthis:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop]\n  es' = [$C ConstFloat32 c]\n  app_binop_f fop c1 c2 = Some c\n\ngoal (34 subgoals):\n 1. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [$C ConstFloat32 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>c1 c2 fop.\n        \\<lbrakk>es =\n                 [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                  $Relop_f T_f64 fop];\n         es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 34 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop]\n  es' = [$C ConstFloat32 c]\n  app_binop_f fop c1 c2 = Some c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop]\n  es' = [$C ConstFloat32 c]\n  app_binop_f fop c1 c2 = Some c\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (33 subgoals):\n 1. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2 sx v'.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n         types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2 sx v'.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n         types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 33 subgoals...", "case (binop_f32_None fop c1 c2)"], ["proof (state)\nthis:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop]\n  es' = [Trap]\n  app_binop_f fop c1 c2 = None\n\ngoal (33 subgoals):\n 1. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Binop_f T_f32 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2 sx v'.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n         types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 33 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop]\n  es' = [Trap]\n  app_binop_f fop c1 c2 = None\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (32 subgoals):\n 1. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2 sx.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n         types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2 sx.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n         types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 32 subgoals...", "case (binop_f64_Some fop c1 c2 c)"], ["proof (state)\nthis:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [$C ConstFloat64 c]\n  app_binop_f fop c1 c2 = Some c\n\ngoal (32 subgoals):\n 1. \\<And>fop c1 c2 c.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [$C ConstFloat64 c]; app_binop_f fop c1 c2 = Some c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2 sx.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n         types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [$C ConstFloat64 c]\n  app_binop_f fop c1 c2 = Some c", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [$C ConstFloat64 c]\n  app_binop_f fop c1 c2 = Some c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [$C ConstFloat64 c]\n  app_binop_f fop c1 c2 = Some c\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (31 subgoals):\n 1. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n         es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n         es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 31 subgoals...", "case (binop_f64_None fop c1 c2)"], ["proof (state)\nthis:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [Trap]\n  app_binop_f fop c1 c2 = None\n\ngoal (31 subgoals):\n 1. \\<And>fop c1 c2.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Binop_f T_f64 fop];\n        es' = [Trap]; app_binop_f fop c1 c2 = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>t1 v t2.\n        \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n         es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 31 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [Trap]\n  app_binop_f fop c1 c2 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Binop_f T_f64 fop]\n  es' = [Trap]\n  app_binop_f fop c1 c2 = None\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (30 subgoals):\n 1. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n     \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n     \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 30 subgoals...", "case (testop_i32 c testop)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c, $Testop T_i32 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\n\ngoal (30 subgoals):\n 1. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt32 c, $Testop T_i32 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n     \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 30 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 c, $Testop T_i32 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Testop T_i32 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Testop T_i32 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (29 subgoals):\n 1. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n     \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n     \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 29 subgoals...", "case (testop_i64 c testop)"], ["proof (state)\nthis:\n  es = [$C ConstInt64 c, $Testop T_i64 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\n\ngoal (29 subgoals):\n 1. \\<And>c testop.\n       \\<lbrakk>es = [$C ConstInt64 c, $Testop T_i64 testop];\n        es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n     \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 29 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt64 c, $Testop T_i64 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c, $Testop T_i64 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c, $Testop T_i64 testop]\n  es' = [$C ConstInt32 (wasm_bool (app_testop_i testop c))]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (28 subgoals):\n 1. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>v.\n        \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>v.\n        \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 28 subgoals...", "case (relop_i32 c1 c2 iop)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\n\ngoal (28 subgoals):\n 1. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>v.\n        \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 28 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c1, $C ConstInt32 c2, $Relop_i T_i32 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (27 subgoals):\n 1. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n v1 v2.\n        \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n         es' = [$C v2]; int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n v1 v2.\n        \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n         es' = [$C v2]; int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 27 subgoals...", "case (relop_i64 c1 c2 iop)"], ["proof (state)\nthis:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\n\ngoal (27 subgoals):\n 1. \\<And>c1 c2 iop.\n       \\<lbrakk>es =\n                [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n v1 v2.\n        \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n         es' = [$C v2]; int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 27 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstInt64 c1, $C ConstInt64 c2, $Relop_i T_i64 iop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_i iop c1 c2))]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (26 subgoals):\n 1. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n v1 v2.\n        \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n         es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n v1 v2.\n        \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n         es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 26 subgoals...", "case (relop_f32 c1 c2 fop)"], ["proof (state)\nthis:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Relop_f T_f32 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\n\ngoal (26 subgoals):\n 1. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat32 c1, $C ConstFloat32 c2,\n                 $Relop_f T_f32 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n v1 v2.\n        \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n         es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 26 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Relop_f T_f32 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Relop_f T_f32 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat32 c1, $C ConstFloat32 c2, $Relop_f T_f32 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (25 subgoals):\n 1. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n t1s t2s m esa.\n        \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n         es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n         length t1s = n; length t2s = m\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n t1s t2s m esa.\n        \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n         es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n         length t1s = n; length t2s = m\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 25 subgoals...", "case (relop_f64 c1 c2 fop)"], ["proof (state)\nthis:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Relop_f T_f64 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\n\ngoal (25 subgoals):\n 1. \\<And>c1 c2 fop.\n       \\<lbrakk>es =\n                [$C ConstFloat64 c1, $C ConstFloat64 c2,\n                 $Relop_f T_f64 fop];\n        es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n t1s t2s m esa.\n        \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n         es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n         length t1s = n; length t2s = m\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Relop_f T_f64 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Relop_f T_f64 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_binop_relop"], ["proof (prove)\nusing this:\n  es = [$C ConstFloat64 c1, $C ConstFloat64 c2, $Relop_f T_f64 fop]\n  es' = [$C ConstInt32 (wasm_bool (app_relop_f fop c1 c2))]\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $?e] : ?ts _> ?ts';\n   ?e = Binop_i ?t ?iop \\<or>\n   ?e = Binop_f ?t ?fop \\<or>\n   ?e = Relop_i ?t ?irop \\<or> ?e = Relop_f ?t ?frop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (24 subgoals):\n 1. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n t1s t2s m esa.\n        \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n         es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n         const_list vs; length vs = n; length t1s = n;\n         length t2s = m\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n t1s t2s m esa.\n        \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n         es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n         const_list vs; length vs = n; length t1s = n;\n         length t2s = m\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 24 subgoals...", "case (convert_Some t1 v t2 sx v')"], ["proof (state)\nthis:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [$C v']\n  types_agree t1 v\n  cvt t2 sx v = Some v'\n\ngoal (24 subgoals):\n 1. \\<And>t1 v t2 sx v'.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [$C v'];\n        types_agree t1 v; cvt t2 sx v = Some v'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n t1s t2s m esa.\n        \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n         es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n         const_list vs; length vs = n; length t1s = n;\n         length t2s = m\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [$C v']\n  types_agree t1 v\n  cvt t2 sx v = Some v'", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [$C v']\n  types_agree t1 v\n  cvt t2 sx v = Some v'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [$C v']\n  types_agree t1 v\n  cvt t2 sx v = Some v'\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (23 subgoals):\n 1. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n tf e1s e2s.\n        \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n         es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n tf e1s e2s.\n        \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n         es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 23 subgoals...", "case (convert_None t1 v t2 sx)"], ["proof (state)\nthis:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [Trap]\n  types_agree t1 v\n  cvt t2 sx v = None\n\ngoal (23 subgoals):\n 1. \\<And>t1 v t2 sx.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Convert t1 sx]; es' = [Trap];\n        types_agree t1 v; cvt t2 sx v = None\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n tf e1s e2s.\n        \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n         es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 23 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [Trap]\n  types_agree t1 v\n  cvt t2 sx v = None", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [Trap]\n  types_agree t1 v\n  cvt t2 sx v = None\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  es = [$C v, $Cvtop t2 Convert t1 sx]\n  es' = [Trap]\n  types_agree t1 v\n  cvt t2 sx v = None\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (22 subgoals):\n 1. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n tf e1s e2s.\n        \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n         es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n tf e1s e2s.\n        \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n         es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 22 subgoals...", "case (reinterpret t1 v t2)"], ["proof (state)\nthis:\n  es = [$C v, $Cvtop t2 Reinterpret t1 None]\n  es' = [$C wasm_deserialise (bits v) t2]\n  types_agree t1 v\n\ngoal (22 subgoals):\n 1. \\<And>t1 v t2.\n       \\<lbrakk>es = [$C v, $Cvtop t2 Reinterpret t1 None];\n        es' = [$C wasm_deserialise (bits v) t2]; types_agree t1 v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n tf e1s e2s.\n        \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n         es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 22 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C v, $Cvtop t2 Reinterpret t1 None]\n  es' = [$C wasm_deserialise (bits v) t2]\n  types_agree t1 v", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C v, $Cvtop t2 Reinterpret t1 None]\n  es' = [$C wasm_deserialise (bits v) t2]\n  types_agree t1 v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_unop_testop_cvtop"], ["proof (prove)\nusing this:\n  es = [$C v, $Cvtop t2 Reinterpret t1 None]\n  es' = [$C wasm_deserialise (bits v) t2]\n  types_agree t1 v\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Unop_i ?t ?iop \\<or>\n   ?e = Unop_f ?t ?fop \\<or>\n   ?e = Testop ?t ?testop \\<or> ?e = Cvtop ?t2.0 ?cvtop ?t ?sx\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (21 subgoals):\n 1. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 21 subgoals...", "case unreachable"], ["proof (state)\nthis:\n  es = [$Unreachable]\n  es' = [Trap]\n\ngoal (21 subgoals):\n 1. \\<lbrakk>es = [$Unreachable]; es' = [Trap]\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 21 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$Unreachable]\n  es' = [Trap]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$Unreachable]\n  es' = [Trap]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  es = [$Unreachable]\n  es' = [Trap]\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (20 subgoals):\n 1. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 20 subgoals...", "case nop"], ["proof (state)\nthis:\n  es = [$Nop]\n  es' = []\n\ngoal (20 subgoals):\n 1. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$Nop]\n  es' = []", "have \"\\<C> \\<turnstile> [Nop] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  es = [$Nop]\n  es' = []\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Nop] : ts _> ts'", "using assms(3) unlift_b_e"], ["proof (prove)\nusing this:\n  es = [$Nop]\n  es' = []\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Nop] : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Nop] : ts _> ts'\n\ngoal (20 subgoals):\n 1. \\<lbrakk>es = [$Nop]; es' = []\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n esa.\n        \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> [Nop] : ts _> ts'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Nop] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using nop b_e_typing.empty e_typing_s_typing.intros(1,3)"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Nop] : ts _> ts'\n  es = [$Nop]\n  es' = []\n  ?\\<C> \\<turnstile> [] : [] _> []\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "apply (induction \"[Nop]\" \"ts _> ts'\" arbitrary: ts ts')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       \\<lbrakk>es = [$Nop]; es' = [];\n        \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n        \\<And>\\<C> b_es tf \\<S>.\n           \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n        \\<And>\\<S> \\<C> es t1s t2s ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @ t1s _> ts @ t2s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> []\n 2. \\<And>\\<C> esa t1s t2s e t3s.\n       \\<lbrakk>\\<C> \\<turnstile> esa : t1s _> t2s;\n        \\<lbrakk>esa = [Nop]; es = [$Nop]; es' = [];\n         \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n         \\<And>\\<C> b_es tf \\<S>.\n            \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n            \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n         \\<And>\\<S> \\<C> es t1s t2s ts.\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @\n          t1s _> ts @ t2s\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : t1s _> t2s;\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<lbrakk>e = Nop; es = [$Nop]; es' = [];\n         \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n         \\<And>\\<C> b_es tf \\<S>.\n            \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n            \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n         \\<And>\\<S> \\<C> es t1s t2s ts.\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @\n          t1s _> ts @ t2s\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : t2s _> t3s;\n        esa @ [e] = [Nop]; es = [$Nop]; es' = [];\n        \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n        \\<And>\\<C> b_es tf \\<S>.\n           \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n        \\<And>\\<S> \\<C> es t1s t2s ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @ t1s _> ts @ t2s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : t1s _> t3s\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [Nop] : t1s _> t2s;\n        \\<lbrakk>es = [$Nop]; es' = [];\n         \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n         \\<And>\\<C> b_es tf \\<S>.\n            \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n            \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n         \\<And>\\<S> \\<C> es t1s t2s ts.\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @\n          t1s _> ts @ t2s\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : t1s _> t2s;\n        es = [$Nop]; es' = []; \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n        \\<And>\\<C> b_es tf \\<S>.\n           \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n        \\<And>\\<S> \\<C> es t1s t2s ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @ t1s _> ts @ t2s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts @\n                        t1s _> ts @ t2s", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<C>.\n       \\<lbrakk>es = [$Nop]; es' = [];\n        \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n        \\<And>\\<C> b_es tf \\<S>.\n           \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n        \\<And>\\<S> \\<C> es t1s t2s ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @ t1s _> ts @ t2s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : [] _> []\n 2. \\<And>\\<C> esa t1s t2s t3s.\n       \\<lbrakk>\\<C> \\<turnstile> [] : t1s _> t2s;\n        \\<C> \\<turnstile> [Nop] : t2s _> t3s;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [] : t2s _> t3s; esa = [];\n        es = [$Nop]; es' = []; \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n        \\<And>\\<C> b_es tf \\<S>.\n           \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n        \\<And>\\<S> \\<C> es t1s t2s ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @ t1s _> ts @ t2s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : t1s _> t3s", "apply (metis list.simps(8))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<C> esa t1s t2s t3s.\n       \\<lbrakk>\\<C> \\<turnstile> [] : t1s _> t2s;\n        \\<C> \\<turnstile> [Nop] : t2s _> t3s;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [] : t2s _> t3s; esa = [];\n        es = [$Nop]; es' = []; \\<And>\\<C>. \\<C> \\<turnstile> [] : [] _> [];\n        \\<And>\\<C> b_es tf \\<S>.\n           \\<C> \\<turnstile> b_es : tf \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : tf;\n        \\<And>\\<S> \\<C> es t1s t2s ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C> \\<turnstile> es : ts @ t1s _> ts @ t2s\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : t1s _> t3s", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (19 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n i lholed LI esa.\n        \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n         length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n i lholed LI esa.\n        \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n         length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 19 subgoals...", "case (drop v)"], ["proof (state)\nthis:\n  es = [$C v, $Drop]\n  es' = []\n\ngoal (19 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>es = [$C v, $Drop]; es' = []\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>vs n i lholed LI esa.\n        \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n         length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C v, $Drop]\n  es' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C v, $Drop]\n  es' = []\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_drop"], ["proof (prove)\nusing this:\n  es = [$C v, $Drop]\n  es' = []\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v, $?e]\\<rparr> \\<leadsto> \\<lparr>[]\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v, $?e] : ?ts _> ?ts';\n   ?e = Drop\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (18 subgoals):\n 1. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i.\n        \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n         int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i.\n        \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n         int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 18 subgoals...", "case (select_false v1 v2)"], ["proof (state)\nthis:\n  es = [$C v2, $C v2_, $C ConstInt32 v1, $Select]\n  es' = [$C v2_]\n  int_eq v1 0\n\ngoal (18 subgoals):\n 1. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v2]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i.\n        \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n         int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C v2, $C v2_, $C ConstInt32 v1, $Select]\n  es' = [$C v2_]\n  int_eq v1 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C v2, $C v2_, $C ConstInt32 v1, $Select]\n  es' = [$C v2_]\n  int_eq v1 0\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_select"], ["proof (prove)\nusing this:\n  es = [$C v2, $C v2_, $C ConstInt32 v1, $Select]\n  es' = [$C v2_]\n  int_eq v1 0\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0, $C ?vn,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v3.0]\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $C ?vn,\n                                     $?e] : ?ts _> ?ts';\n   ?e = Select\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v3.0] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (17 subgoals):\n 1. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i.\n        \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n         \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i.\n        \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n         \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 17 subgoals...", "case (select_true n v1 v2)"], ["proof (state)\nthis:\n  es = [$C v1, $C v2, $C ConstInt32 n, $Select]\n  es' = [$C v1]\n  \\<not> int_eq n 0\n\ngoal (17 subgoals):\n 1. \\<And>n v1 v2.\n       \\<lbrakk>es = [$C v1, $C v2, $C ConstInt32 n, $Select];\n        es' = [$C v1]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i.\n        \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n         \\<not> int_eq n 0\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C v1, $C v2, $C ConstInt32 n, $Select]\n  es' = [$C v1]\n  \\<not> int_eq n 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C v1, $C v2, $C ConstInt32 n, $Select]\n  es' = [$C v1]\n  \\<not> int_eq n 0\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_select"], ["proof (prove)\nusing this:\n  es = [$C v1, $C v2, $C ConstInt32 n, $Select]\n  es' = [$C v1]\n  \\<not> int_eq n 0\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ?v1.0, $C ?v2.0, $C ?vn,\n                    $?e]\\<rparr> \\<leadsto> \\<lparr>[$C ?v3.0]\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v1.0, $C ?v2.0, $C ?vn,\n                                     $?e] : ?ts _> ?ts';\n   ?e = Select\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v3.0] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (16 subgoals):\n 1. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>is c i.\n        \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n         es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>is c i.\n        \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n         es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 16 subgoals...", "case (block vs n t1s t2s m es)"], ["proof (state)\nthis:\n  es = vs @ [$Block (t1s _> t2s) es]\n  es' = [Label m [] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m\n\ngoal (16 subgoals):\n 1. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Block (t1s _> t2s) esa];\n        es' = [Label m [] (vs @ ($* esa))]; const_list vs; length vs = n;\n        length t1s = n; length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>is c i.\n        \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n         es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = vs @ [$Block (t1s _> t2s) es]\n  es' = [Label m [] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m", "show ?thesis"], ["proof (prove)\nusing this:\n  es = vs @ [$Block (t1s _> t2s) es]\n  es' = [Label m [] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_block"], ["proof (prove)\nusing this:\n  es = vs @ [$Block (t1s _> t2s) es]\n  es' = [Label m [] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>?vs @\n                   [$Block (?tn _> ?tm)\n                      ?es]\\<rparr> \\<leadsto> \\<lparr>[Label ?m []\n                  (?vs @ ($* ?es))]\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs @\n                                    [$Block (?tn _> ?tm) ?es] : ?ts _> ?ts';\n   const_list ?vs; length ?vs = ?n; length ?tn = ?n;\n   length ?tm = ?m\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Label ?m []\n                 (?vs @ ($* ?es))] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (15 subgoals):\n 1. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>is c i.\n        \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n         length is \\<le> nat_of_int c\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>is c i.\n        \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n         length is \\<le> nat_of_int c\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 15 subgoals...", "case (loop vs n t1s t2s m es)"], ["proof (state)\nthis:\n  es = vs @ [$Loop (t1s _> t2s) es]\n  es' = [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m\n\ngoal (15 subgoals):\n 1. \\<And>vs n t1s t2s m esa.\n       \\<lbrakk>es = vs @ [$Loop (t1s _> t2s) esa];\n        es' = [Label n [$Loop (t1s _> t2s) esa] (vs @ ($* esa))];\n        const_list vs; length vs = n; length t1s = n;\n        length t2s = m\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>is c i.\n        \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n         length is \\<le> nat_of_int c\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = vs @ [$Loop (t1s _> t2s) es]\n  es' = [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m", "show ?thesis"], ["proof (prove)\nusing this:\n  es = vs @ [$Loop (t1s _> t2s) es]\n  es' = [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_loop"], ["proof (prove)\nusing this:\n  es = vs @ [$Loop (t1s _> t2s) es]\n  es' = [Label n [$Loop (t1s _> t2s) es] (vs @ ($* es))]\n  const_list vs\n  length vs = n\n  length t1s = n\n  length t2s = m\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>?vs @\n                   [$Loop (?t1s _> ?t2s)\n                      ?es]\\<rparr> \\<leadsto> \\<lparr>[Label ?n\n                  [$Loop (?t1s _> ?t2s) ?es] (?vs @ ($* ?es))]\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs @\n                                    [$Loop (?t1s _> ?t2s)\n ?es] : ?ts _> ?ts';\n   const_list ?vs; length ?vs = ?n; length ?t1s = ?n;\n   length ?t2s = ?m\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Label ?n\n                 [$Loop (?t1s _> ?t2s) ?es] (?vs @ ($* ?es))] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (14 subgoals):\n 1. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i vs.\n        \\<lbrakk>es = [Local n i vs es']; const_list es';\n         length es' = n\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i vs.\n        \\<lbrakk>es = [Local n i vs es']; const_list es';\n         length es' = n\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 14 subgoals...", "case (if_false tf e1s e2s)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 tf, $b_e.If e1s e2s e2s_]\n  es' = [$Block e1s e2s_]\n  int_eq tf 0\n\ngoal (14 subgoals):\n 1. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e2s]; int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i vs.\n        \\<lbrakk>es = [Local n i vs es']; const_list es';\n         length es' = n\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 tf, $b_e.If e1s e2s e2s_]\n  es' = [$Block e1s e2s_]\n  int_eq tf 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 tf, $b_e.If e1s e2s e2s_]\n  es' = [$Block e1s e2s_]\n  int_eq tf 0\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_if"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 tf, $b_e.If e1s e2s e2s_]\n  es' = [$Block e1s e2s_]\n  int_eq tf 0\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ConstInt32 ?n,\n                    $b_e.If ?tf ?e1s\n                      ?e2s]\\<rparr> \\<leadsto> \\<lparr>[$Block ?tf\n                    ?es']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?n,\n                                     $b_e.If ?tf ?e1s\n ?e2s] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Block ?tf\n                  ?es'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (13 subgoals):\n 1. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i vs.\n        \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i vs.\n        \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 13 subgoals...", "case (if_true n tf e1s e2s)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 n, $b_e.If tf e1s e2s]\n  es' = [$Block tf e1s]\n  \\<not> int_eq n 0\n\ngoal (13 subgoals):\n 1. \\<And>n tf e1s e2s.\n       \\<lbrakk>es = [$C ConstInt32 n, $b_e.If tf e1s e2s];\n        es' = [$Block tf e1s]; \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n i vs.\n        \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 n, $b_e.If tf e1s e2s]\n  es' = [$Block tf e1s]\n  \\<not> int_eq n 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 n, $b_e.If tf e1s e2s]\n  es' = [$Block tf e1s]\n  \\<not> int_eq n 0\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_if"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 n, $b_e.If tf e1s e2s]\n  es' = [$Block tf e1s]\n  \\<not> int_eq n 0\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ConstInt32 ?n,\n                    $b_e.If ?tf ?e1s\n                      ?e2s]\\<rparr> \\<leadsto> \\<lparr>[$Block ?tf\n                    ?es']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?n,\n                                     $b_e.If ?tf ?e1s\n ?e2s] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Block ?tf\n                  ?es'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (12 subgoals):\n 1. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n j lholed esa i vls.\n        \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n         Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n j lholed esa i vls.\n        \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n         Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 12 subgoals...", "case (label_const ts es)"], ["proof (state)\nthis:\n  es = [Label ts es es']\n  const_list es'\n\ngoal (12 subgoals):\n 1. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa es']; const_list es'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>n j lholed esa i vls.\n        \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n         Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [Label ts es es']\n  const_list es'", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [Label ts es es']\n  const_list es'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_label_value"], ["proof (prove)\nusing this:\n  es = [Label ts es es']\n  const_list es'\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[Label ?n ?es0.0\n                     ?vs]\\<rparr> \\<leadsto> \\<lparr>?vs\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Label ?n ?es0.0 ?vs] : ?ts _> ?ts';\n   const_list ?vs\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (11 subgoals):\n 1. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>v i.\n        \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n         is_const v\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>v i.\n        \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n         is_const v\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 11 subgoals...", "case (label_trap ts es)"], ["proof (state)\nthis:\n  es = [Label ts es [Trap]]\n  es' = [Trap]\n\ngoal (11 subgoals):\n 1. \\<And>n esa.\n       \\<lbrakk>es = [Label n esa [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>v i.\n        \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n         is_const v\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = [Label ts es [Trap]]\n  es' = [Trap]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [Label ts es [Trap]]\n  es' = [Trap]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (10 subgoals):\n 1. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>lholed.\n        \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n         Lfilled 0 lholed [Trap] es\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>lholed.\n        \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n         Lfilled 0 lholed [Trap] es\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (br vs n i lholed LI es)"], ["proof (state)\nthis:\n  es = [Label n es LI]\n  es' = vs @ es\n  const_list vs\n  length vs = n\n  Lfilled i lholed (vs @ [$Br i]) LI\n\ngoal (10 subgoals):\n 1. \\<And>vs n i lholed LI esa.\n       \\<lbrakk>es = [Label n esa LI]; es' = vs @ esa; const_list vs;\n        length vs = n; Lfilled i lholed (vs @ [$Br i]) LI\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 10. \\<And>lholed.\n        \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n         Lfilled 0 lholed [Trap] es\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [Label n es LI]\n  es' = vs @ es\n  const_list vs\n  length vs = n\n  Lfilled i lholed (vs @ [$Br i]) LI", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [Label n es LI]\n  es' = vs @ es\n  const_list vs\n  length vs = n\n  Lfilled i lholed (vs @ [$Br i]) LI\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_br"], ["proof (prove)\nusing this:\n  es = [Label n es LI]\n  es' = vs @ es\n  const_list vs\n  length vs = n\n  Lfilled i lholed (vs @ [$Br i]) LI\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[Label ?n ?es0.0\n                     ?LI]\\<rparr> \\<leadsto> \\<lparr>?vs @ ?es0.0\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Label ?n ?es0.0 ?LI] : ?ts _> ?ts';\n   const_list ?vs; length ?vs = ?n;\n   Lfilled ?i ?lholed (?vs @ [$Br ?i]) ?LI\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs @\n               ?es0.0 : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (9 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (br_if_false n i)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = []\n  int_eq n 0\n\ngoal (9 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [];\n        int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 9. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = []\n  int_eq n 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = []\n  int_eq n 0\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_br_if"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = []\n  int_eq n 0\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ConstInt32 ?n,\n                    $Br_if ?i]\\<rparr> \\<leadsto> \\<lparr>?e\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?n,\n                                     $Br_if ?i] : ?ts _> ?ts';\n   ?e = [$Br ?i] \\<or> ?e = []\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?e : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (8 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (br_if_true n i)"], ["proof (state)\nthis:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = [$Br i]\n  \\<not> int_eq n 0\n\ngoal (8 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>es = [$C ConstInt32 n, $Br_if i]; es' = [$Br i];\n        \\<not> int_eq n 0\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 8. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = [$Br i]\n  \\<not> int_eq n 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = [$Br i]\n  \\<not> int_eq n 0\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_br_if"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 n, $Br_if i]\n  es' = [$Br i]\n  \\<not> int_eq n 0\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ConstInt32 ?n,\n                    $Br_if ?i]\\<rparr> \\<leadsto> \\<lparr>?e\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?n,\n                                     $Br_if ?i] : ?ts _> ?ts';\n   ?e = [$Br ?i] \\<or> ?e = []\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?e : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (7 subgoals):\n 1. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (br_table is' c i')"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br (is' ! nat_of_int c)]\n  nat_of_int c < length is'\n\ngoal (7 subgoals):\n 1. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i];\n        es' = [$Br (is ! nat_of_int c)]; nat_of_int c < length is\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 7. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br (is' ! nat_of_int c)]\n  nat_of_int c < length is'", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br (is' ! nat_of_int c)]\n  nat_of_int c < length is'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_br_table"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br (is' ! nat_of_int c)]\n  nat_of_int c < length is'\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ConstInt32 ?c,\n                    $Br_table ?is\n                      ?i]\\<rparr> \\<leadsto> \\<lparr>[$Br ?i']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c,\n                                     $Br_table ?is ?i] : ?ts _> ?ts';\n   ?i' = ?is ! nat_of_int ?c \\<and> nat_of_int ?c < length ?is \\<or>\n   ?i' = ?i\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Br ?i'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (6 subgoals):\n 1. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (br_table_length is' c i')"], ["proof (state)\nthis:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br i']\n  length is' \\<le> nat_of_int c\n\ngoal (6 subgoals):\n 1. \\<And>is c i.\n       \\<lbrakk>es = [$C ConstInt32 c, $Br_table is i]; es' = [$Br i];\n        length is \\<le> nat_of_int c\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 6. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br i']\n  length is' \\<le> nat_of_int c", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br i']\n  length is' \\<le> nat_of_int c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_br_table"], ["proof (prove)\nusing this:\n  es = [$C ConstInt32 c, $Br_table is' i']\n  es' = [$Br i']\n  length is' \\<le> nat_of_int c\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[$C ConstInt32 ?c,\n                    $Br_table ?is\n                      ?i]\\<rparr> \\<leadsto> \\<lparr>[$Br ?i']\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c,\n                                     $Br_table ?is ?i] : ?ts _> ?ts';\n   ?i' = ?is ! nat_of_int ?c \\<and> nat_of_int ?c < length ?is \\<or>\n   ?i' = ?i\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Br ?i'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (5 subgoals):\n 1. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (local_const i vs)"], ["proof (state)\nthis:\n  es = [Local i vs vs_ es']\n  const_list es'\n  length es' = i\n\ngoal (5 subgoals):\n 1. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs es']; const_list es';\n        length es' = n\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 5. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [Local i vs vs_ es']\n  const_list es'\n  length es' = i", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [Local i vs vs_ es']\n  const_list es'\n  length es' = i\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_local_const"], ["proof (prove)\nusing this:\n  es = [Local i vs vs_ es']\n  const_list es'\n  length es' = i\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[Local ?n ?i ?vs\n                     ?es]\\<rparr> \\<leadsto> \\<lparr>?es\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Local ?n ?i ?vs ?es] : ?ts _> ?ts';\n   const_list ?es\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (4 subgoals):\n 1. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (local_trap i vs)"], ["proof (state)\nthis:\n  es = [Local i vs vs_ [Trap]]\n  es' = [Trap]\n\ngoal (4 subgoals):\n 1. \\<And>n i vs.\n       \\<lbrakk>es = [Local n i vs [Trap]]; es' = [Trap]\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 4. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [Local i vs vs_ [Trap]]\n  es' = [Trap]", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [Local i vs vs_ [Trap]]\n  es' = [Trap]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (3 subgoals):\n 1. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (return n j lholed es i vls)"], ["proof (state)\nthis:\n  es = [Local n i vls es]\n  const_list es'\n  length es' = n\n  Lfilled j lholed (es' @ [$Return]) es\n\ngoal (3 subgoals):\n 1. \\<And>n j lholed esa i vls.\n       \\<lbrakk>es = [Local n i vls esa]; const_list es'; length es' = n;\n        Lfilled j lholed (es' @ [$Return]) esa\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 3. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [Local n i vls es]\n  const_list es'\n  length es' = n\n  Lfilled j lholed (es' @ [$Return]) es", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [Local n i vls es]\n  const_list es'\n  length es' = n\n  Lfilled j lholed (es' @ [$Return]) es\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_return"], ["proof (prove)\nusing this:\n  es = [Local n i vls es]\n  const_list es'\n  length es' = n\n  Lfilled j lholed (es' @ [$Return]) es\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[Local ?n ?i ?vls\n                     ?LI]\\<rparr> \\<leadsto> \\<lparr>?ves\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Local ?n ?i ?vls ?LI] : ?ts _> ?ts';\n   const_list ?ves; length ?ves = ?n;\n   Lfilled ?j ?lholed (?ves @ [$Return]) ?LI\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?ves : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (tee_local v i)"], ["proof (state)\nthis:\n  es = [v, $Tee_local i]\n  es' = [v, v, $Set_local i]\n  is_const v\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>es = [v, $Tee_local i]; es' = [v, v, $Set_local i];\n        is_const v\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n 2. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es = [v, $Tee_local i]\n  es' = [v, v, $Set_local i]\n  is_const v", "show ?thesis"], ["proof (prove)\nusing this:\n  es = [v, $Tee_local i]\n  es' = [v, v, $Set_local i]\n  is_const v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "using assms(1, 3) types_preserved_tee_local"], ["proof (prove)\nusing this:\n  es = [v, $Tee_local i]\n  es' = [v, v, $Set_local i]\n  is_const v\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n  \\<lbrakk>\\<lparr>[?v,\n                    $Tee_local\n                      ?i]\\<rparr> \\<leadsto> \\<lparr>[?v, ?v,\n                $Set_local ?i]\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?v, $Tee_local ?i] : ?ts _> ?ts';\n   is_const ?v\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?v, ?v,\n                $Set_local ?i] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "case (trap lholed)"], ["proof (state)\nthis:\n  es' = [Trap]\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es\n\ngoal (1 subgoal):\n 1. \\<And>lholed.\n       \\<lbrakk>es' = [Trap]; es \\<noteq> [Trap];\n        Lfilled 0 lholed [Trap] es\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "then"], ["proof (chain)\npicking this:\n  es' = [Trap]\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es", "show ?thesis"], ["proof (prove)\nusing this:\n  es' = [Trap]\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'", "by (simp add: e_typing_s_typing.intros(4))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_b_e:\n  assumes \"\\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es' : ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "have \"i < (length (s_inst \\<S>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "using assms(3) s_typing.cases"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n  \\<lbrakk>?a1.0\\<bullet>?a2.0 \\<tturnstile>_ ?a3.0 ?a4.0;?a5.0 : ?a6.0;\n   \\<And>i \\<S> tvs vs \\<C> rs es ts.\n      \\<lbrakk>?a1.0 = \\<S>; ?a2.0 = rs; ?a3.0 = i; ?a4.0 = vs; ?a5.0 = es;\n       ?a6.0 = ts; i < length (s_inst \\<S>); tvs = map typeof vs;\n       \\<C> = (s_inst \\<S> ! i)\n       \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, return := rs\\<rparr>;\n       \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n       rs = Some ts \\<or> rs = None\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "by blast"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "moreover"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "obtain tvs \\<C> where defs: \"tvs = map typeof vs\" \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i) @ tvs), return := None\\<rparr>\" \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tvs \\<C>.\n        \\<lbrakk>tvs = map typeof vs;\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n\ngoal (1 subgoal):\n 1. (\\<And>tvs \\<C>.\n        \\<lbrakk>tvs = map typeof vs;\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding s_typing.simps"], ["proof (prove)\nusing this:\n  \\<exists>ia \\<S>' tvs vsa \\<C> rs esa tsa.\n     \\<S> = \\<S>' \\<and>\n     None = rs \\<and>\n     i = ia \\<and>\n     vs = vsa \\<and>\n     es = esa \\<and>\n     ts = tsa \\<and>\n     ia < length (s_inst \\<S>') \\<and>\n     tvs = map typeof vsa \\<and>\n     \\<C> = (s_inst \\<S>' ! ia)\n     \\<lparr>local := local (s_inst \\<S>' ! ia) @ tvs,\n        return := rs\\<rparr> \\<and>\n     \\<S>'\\<bullet>\\<C> \\<turnstile> esa : [] _> tsa \\<and>\n     (rs = Some tsa \\<or> rs = None)\n\ngoal (1 subgoal):\n 1. (\\<And>tvs \\<C>.\n        \\<lbrakk>tvs = map typeof vs;\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tvs = map typeof vs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\\<lparr>local := local (s_inst \\<S> ! i) @ tvs\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "have \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : ([] _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts", "using assms(1,2) defs(3) types_preserved_b_e1"], ["proof (prove)\nusing this:\n  \\<lparr>es\\<rparr> \\<leadsto> \\<lparr>es'\\<rparr>\n  store_typing s \\<S>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n  \\<lbrakk>\\<lparr>?es\\<rparr> \\<leadsto> \\<lparr>?es'\\<rparr>;\n   store_typing ?s ?\\<S>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "ultimately"], ["proof (chain)\npicking this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "using defs"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts\n  tvs = map typeof vs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\\<lparr>local := local (s_inst \\<S> ! i) @ tvs\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts", "unfolding s_typing.simps"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts\n  tvs = map typeof vs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\\<lparr>local := local (s_inst \\<S> ! i) @ tvs\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<exists>ia \\<S>' tvs vsa \\<C> rs es tsa.\n       \\<S> = \\<S>' \\<and>\n       None = rs \\<and>\n       i = ia \\<and>\n       vs = vsa \\<and>\n       es' = es \\<and>\n       ts = tsa \\<and>\n       ia < length (s_inst \\<S>') \\<and>\n       tvs = map typeof vsa \\<and>\n       \\<C> = (s_inst \\<S>' ! ia)\n       \\<lparr>local := local (s_inst \\<S>' ! ia) @ tvs,\n          return := rs\\<rparr> \\<and>\n       \\<S>'\\<bullet>\\<C> \\<turnstile> es : [] _> tsa \\<and>\n       (rs = Some tsa \\<or> rs = None)", "by auto"], ["proof (state)\nthis:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es' : ts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_store:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v, $Store t tp a off] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\"\n        \"types_agree t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' &&& types_agree t v", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. types_agree t v", "obtain ts'' ts''' where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : (ts _> ts'')\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts'' _> ts''')\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : (ts''' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n               k] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a\n     off] : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms e_type_comp_conc2[of \\<S> \\<C> \"[$C ConstInt32 k]\" \"[$C v]\" \"[$Store t tp a off]\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t tp a off] : ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] @\n                                 [$C v] @\n                                 [$Store t tp a\n                                    off] : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts'' _> ?t2s\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n               k] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a\n     off] : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. types_agree t v", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'", "have \"ts'' = ts@[(T_i32)]\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "using b_e_type_value[of \\<C> \"C ConstInt32 k\" \"ts\" ts'']\n          unlift_b_e[of \\<S> \\<C> \"[C (ConstInt32 k)]\" \"(ts _> ts'')\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 k] : ts _> ts'';\n   C ConstInt32 k = C ?v\\<rbrakk>\n  \\<Longrightarrow> ts'' = ts @ [typeof ?v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32\n  k] : ts _> ts'' \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 k] : ts _> ts''\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 k] : ts _> ts'';\n   C ConstInt32 k = C ?v\\<rbrakk>\n  \\<Longrightarrow> ts'' =\n                    ts @\n                    [case ?v of ConstInt32 x \\<Rightarrow> T_i32\n                     | ConstInt64 x \\<Rightarrow> T_i64\n                     | ConstFloat32 x \\<Rightarrow> T_f32\n                     | ConstFloat64 x \\<Rightarrow> T_f64]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32\n  k] : ts _> ts'' \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 k] : ts _> ts''\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ [T_i32]\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. types_agree t v", "hence \"ts''' = ts@[(T_i32), (typeof v)]\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. ts''' = ts @ [T_i32, typeof v]", "using ts_def(2) b_e_type_value[of \\<C> \"C v\" ts'' ts''']\n          unlift_b_e[of \\<S> \\<C> \"[C v]\" \"(ts'' _> ts''')\"]"], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts'' _> ts'''\n  \\<lbrakk>\\<C> \\<turnstile> [C v] : ts'' _> ts'''; C v = C ?v\\<rbrakk>\n  \\<Longrightarrow> ts''' = ts'' @ [typeof ?v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C v] : ts'' _> ts''' \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v] : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. ts''' = ts @ [T_i32, typeof v]", "by fastforce"], ["proof (state)\nthis:\n  ts''' = ts @ [T_i32, typeof v]\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. types_agree t v", "hence \"ts = ts'\" \"types_agree t v\""], ["proof (prove)\nusing this:\n  ts''' = ts @ [T_i32, typeof v]\n\ngoal (1 subgoal):\n 1. ts = ts' &&& types_agree t v", "using ts_def(3) b_e_type_store[of \\<C> \"Store t tp a off\" ts''' ts']\n          unlift_b_e[of \\<S> \\<C> \"[Store t tp a off]\" \"(ts''' _> ts')\"]"], ["proof (prove)\nusing this:\n  ts''' = ts @ [T_i32, typeof v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts';\n   Store t tp a off = Store ?t ?tp ?a ?off\\<rbrakk>\n  \\<Longrightarrow> ts''' = ts' @ [T_i32, ?t]\n  \\<lbrakk>\\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts';\n   Store t tp a off = Store ?t ?tp ?a ?off\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sec n. memory \\<C> = Some n\n  \\<lbrakk>\\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts';\n   Store t tp a off = Store ?t ?tp ?a ?off\\<rbrakk>\n  \\<Longrightarrow> load_store_t_bounds ?a ?tp ?t\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Store t tp a\noff] : ts''' _> ts' \\<Longrightarrow>\n  \\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. ts = ts' &&& types_agree t v", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  ts''' = ts @ [T_i32, typeof v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Store t tp a off] : ts''' _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts';\n   Store t tp a off = Store ?t ?tp ?a ?off\\<rbrakk>\n  \\<Longrightarrow> ts''' = ts' @ [T_i32, ?t]\n  \\<lbrakk>\\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts';\n   Store t tp a off = Store ?t ?tp ?a ?off\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sec n. memory \\<C> = Some n\n  \\<lbrakk>\\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts';\n   Store t tp a off = Store ?t ?tp ?a ?off\\<rbrakk>\n  \\<Longrightarrow> load_store_t_bounds ?a ?tp ?t\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Store t tp a\noff] : ts''' _> ts' \\<Longrightarrow>\n  \\<C> \\<turnstile> [Store t tp a off] : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. ts = ts' &&& typeof v = t", "by fastforce+"], ["proof (state)\nthis:\n  ts = ts'\n  types_agree t v\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. types_agree t v", "thus \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\" \"types_agree t v\""], ["proof (prove)\nusing this:\n  ts = ts'\n  types_agree t v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' &&& types_agree t v", "using b_e_type_empty[of \\<C> \"ts\" \"ts'\"] e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  ts = ts'\n  types_agree t v\n  \\<C> \\<turnstile> [] : ts _> ts' = (ts = ts')\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' &&& types_agree t v", "by fastforce+"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n  types_agree t v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_current_memory:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'", "have \"ts' = ts@[T_i32]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts' = ts @ [T_i32]", "using assms b_e_type_current_memory unlift_b_e[of \\<S> \\<C> \"[Current_memory]\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Current_memory\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sec n.\n                       ?ts' = ?ts @ [T_i32] \\<and> memory ?\\<C> = Some n\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Current_memory] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Current_memory] : ?tf\n\ngoal (1 subgoal):\n 1. ts' = ts @ [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'", "using b_e_typing.const[of \\<C> \"ConstInt32 c\"] e_typing_s_typing.intros(1,3)"], ["proof (prove)\nusing this:\n  ts' = ts @ [T_i32]\n  \\<C> \\<turnstile> [C ConstInt32 c] : [] _> [typeof (ConstInt32 c)]\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  ts' = ts @ [T_i32]\n  \\<C> \\<turnstile> [C ConstInt32\n                        c] : [] _> [case ConstInt32 c of\n                                    ConstInt32 x \\<Rightarrow> T_i32\n                                    | ConstInt64 x \\<Rightarrow> T_i64\n                                    | ConstFloat32 x \\<Rightarrow> T_f32\n                                    | ConstFloat64 x \\<Rightarrow> T_f64]\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_grow_memory:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : (ts _> ts'')\" \n                             \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Grow_memory] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n               c] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Grow_memory] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp assms"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n               c] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Grow_memory] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id butlast.simps(2) last.simps list.distinct(1))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Grow_memory] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "have \"ts'' = ts@[(T_i32)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "using b_e_type_value[of \\<C> \"C ConstInt32 c\" ts ts'']\n          unlift_b_e[of \\<S> \\<C> \"[C ConstInt32 c]\"] ts''_def(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts'';\n   C ConstInt32 c = C ?v\\<rbrakk>\n  \\<Longrightarrow> ts'' = ts @ [typeof ?v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32 c] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 c] : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts''\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<C> \\<turnstile> [C ConstInt32 c] : ts _> ts'';\n   C ConstInt32 c = C ?v\\<rbrakk>\n  \\<Longrightarrow> ts'' =\n                    ts @\n                    [case ?v of ConstInt32 x \\<Rightarrow> T_i32\n                     | ConstInt64 x \\<Rightarrow> T_i64\n                     | ConstFloat32 x \\<Rightarrow> T_f32\n                     | ConstFloat64 x \\<Rightarrow> T_f64]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32 c] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 c] : ?tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts''\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "hence \"ts'' = ts'\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. ts'' = ts'", "using ts''_def b_e_type_grow_memory[of _ _ ts'' ts'] unlift_b_e[of \\<S> \\<C> \"[Grow_memory]\"]"], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Grow_memory] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ts'' _> ts'; ?e = Grow_memory\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''a.\n                       ts'' = ts''a @ [T_i32] \\<and>\n                       ts'' = ts' \\<and> (\\<exists>n. memory ?\\<C> = Some n)\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Grow_memory] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Grow_memory] : ?tf\n\ngoal (1 subgoal):\n 1. ts'' = ts'", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts'' = ts @ [T_i32]\n  ts'' = ts'", "show \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  ts'' = ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "using e_typing_s_typing.intros(1,3)\n          b_e_typing.const[of \\<C> \"ConstInt32 c'\"]"], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  ts'' = ts'\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  \\<C> \\<turnstile> [C ConstInt32 c'] : [] _> [typeof (ConstInt32 c')]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  ts'' = ts'\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  \\<C> \\<turnstile> [C ConstInt32\n                        c'] : [] _> [case ConstInt32 c' of\n                                     ConstInt32 x \\<Rightarrow> T_i32\n                                     | ConstInt64 x \\<Rightarrow> T_i64\n                                     | ConstFloat32 x \\<Rightarrow> T_f32\n                                     | ConstFloat64 x \\<Rightarrow> T_f64]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c'] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_set_global:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\"\n        \"tg_t (global \\<C> ! j) = typeof v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' &&&\n    tg_t (global \\<C> ! j) = typeof v", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. tg_t (global \\<C> ! j) = typeof v", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts _> ts'')\" \n                             \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global j] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global\n     j] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp assms"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global\n     j] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id butlast.simps(2) last.simps list.distinct(1))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global j] : ts'' _> ts'\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. tg_t (global \\<C> ! j) = typeof v", "hence \"ts'' = ts@[typeof v]\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global j] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [typeof v]", "using b_e_type_value unlift_b_e[of \\<S> \\<C> \"[C v]\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global j] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C v] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v] : ?tf\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [typeof v]", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ [typeof v]\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. tg_t (global \\<C> ! j) = typeof v", "hence \"ts = ts'\" \"tg_t (global \\<C> ! j) = typeof v\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v]\n\ngoal (1 subgoal):\n 1. ts = ts' &&& tg_t (global \\<C> ! j) = typeof v", "using b_e_type_set_global ts''_def(2) unlift_b_e[of \\<S> \\<C> \"[Set_global j]\"]"], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v]\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Set_global ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts = ?ts' @ [t] \\<and>\n                       global ?\\<C> ! ?i =\n                       \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr> \\<and>\n                       ?i < length (global ?\\<C>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_global j] : ts'' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Set_global j] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Set_global j] : ?tf\n\ngoal (1 subgoal):\n 1. ts = ts' &&& tg_t (global \\<C> ! j) = typeof v", "by fastforce+"], ["proof (state)\nthis:\n  ts = ts'\n  tg_t (global \\<C> ! j) = typeof v\n\ngoal (2 subgoals):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n 2. tg_t (global \\<C> ! j) = typeof v", "thus \"\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')\" \"tg_t (global \\<C> ! j) = typeof v\""], ["proof (prove)\nusing this:\n  ts = ts'\n  tg_t (global \\<C> ! j) = typeof v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' &&&\n    tg_t (global \\<C> ! j) = typeof v", "using b_e_type_empty[of \\<C> \"ts\" \"ts'\"] e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  ts = ts'\n  tg_t (global \\<C> ! j) = typeof v\n  \\<C> \\<turnstile> [] : ts _> ts' = (ts = ts')\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' &&&\n    tg_t (global \\<C> ! j) = typeof v", "by fastforce+"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts'\n  tg_t (global \\<C> ! j) = typeof v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_load:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $Load t tp a off] : (ts _> ts')\"\n          \"typeof v = t\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : (ts _> ts'')\" \n                             \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a off] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n               k] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a\n     off] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp assms"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t tp a off] : ts _> ts'\n  typeof v = t\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n               k] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a\n     off] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id butlast.simps(2) last.simps list.distinct(1))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a off] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "hence \"ts'' = ts@[(T_i32)]\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a off] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "using b_e_type_value unlift_b_e[of \\<S> \\<C> \"[C ConstInt32 k]\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a off] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32 k] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 k] : ?tf\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a off] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' =\n                    ?ts @\n                    [case ?v of ConstInt32 x \\<Rightarrow> T_i32\n                     | ConstInt64 x \\<Rightarrow> T_i64\n                     | ConstFloat32 x \\<Rightarrow> T_f32\n                     | ConstFloat64 x \\<Rightarrow> T_f64]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C ConstInt32 k] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C ConstInt32 k] : ?tf\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "hence ts_def:\"ts' = ts@[t]\" \"load_store_t_bounds a (option_projl tp) t\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n\ngoal (1 subgoal):\n 1. ts' = ts @ [t] &&& load_store_t_bounds a (option_projl tp) t", "using ts''_def(2) b_e_type_load unlift_b_e[of \\<S> \\<C> \"[Load t tp a off]\"]"], ["proof (prove)\nusing this:\n  ts'' = ts @ [T_i32]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Load t tp a off] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Load ?t ?tp_sx ?a ?off\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts'' sec n.\n                       ?ts = ts'' @ [T_i32] \\<and>\n                       ?ts' = ts'' @ [?t] \\<and> memory ?\\<C> = Some n\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Load ?t ?tp_sx ?a ?off\\<rbrakk>\n  \\<Longrightarrow> load_store_t_bounds ?a (option_projl ?tp_sx) ?t\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Load t tp a\noff] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Load t tp a off] : ?tf\n\ngoal (1 subgoal):\n 1. ts' = ts @ [t] &&& load_store_t_bounds a (option_projl tp) t", "by fastforce+"], ["proof (state)\nthis:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "hence \"\\<C> \\<turnstile> [C v] : (ts _> ts@[t])\""], ["proof (prove)\nusing this:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : ts _> ts @ [t]", "using assms(2) b_e_typing.const b_e_typing.weakening"], ["proof (prove)\nusing this:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n  typeof v = t\n  ?\\<C> \\<turnstile> [C ?v] : [] _> [typeof ?v]\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : ts _> ts @ [t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : ts _> ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n  \\<C> \\<turnstile> [C v] : ts _> ts @ [t]", "show \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts _> ts')\""], ["proof (prove)\nusing this:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n  \\<C> \\<turnstile> [C v] : ts _> ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "using e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  ts' = ts @ [t]\n  load_store_t_bounds a (option_projl tp) t\n  \\<C> \\<turnstile> [C v] : ts _> ts @ [t]\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_get_local:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local i] : (ts _> ts')\"\n          \"length vi = i\"\n          \"(local \\<C>) = map typeof (vi @ [v] @ vs)\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "have \"(local \\<C>)!i = typeof v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local \\<C> ! i = typeof v", "using assms(2,3)"], ["proof (prove)\nusing this:\n  length vi = i\n  local \\<C> = map typeof (vi @ [v] @ vs)\n\ngoal (1 subgoal):\n 1. local \\<C> ! i = typeof v", "by (metis (no_types, hide_lams) append_Cons length_map list.simps(9) map_append nth_append_length)"], ["proof (state)\nthis:\n  local \\<C> ! i = typeof v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "hence \"ts' = ts@[typeof v]\""], ["proof (prove)\nusing this:\n  local \\<C> ! i = typeof v\n\ngoal (1 subgoal):\n 1. ts' = ts @ [typeof v]", "using assms(1) unlift_b_e[of \\<S> \\<C> \"[Get_local i]\"] b_e_type_get_local"], ["proof (prove)\nusing this:\n  local \\<C> ! i = typeof v\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local i] : ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Get_local i] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Get_local i] : ?tf\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = Get_local ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t. ?ts' = ?ts @ [t] \\<and> local ?\\<C> ! ?i = t\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = Get_local ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (local ?\\<C>)\n\ngoal (1 subgoal):\n 1. ts' = ts @ [typeof v]", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts @ [typeof v]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts' = ts @ [typeof v]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "using b_e_typing.const e_typing_s_typing.intros(1,3)"], ["proof (prove)\nusing this:\n  ts' = ts @ [typeof v]\n  ?\\<C> \\<turnstile> [C ?v] : [] _> [typeof ?v]\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_set_local:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local i] : (ts _> ts')\"\n          \"length vi = i\"\n          \"(local \\<C>) = map typeof (vi @ [v] @ vs)\"\n  shows \"(\\<S>\\<bullet>\\<C> \\<turnstile> [] : (ts _> ts')) \\<and> map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "have v_type:\"(local \\<C>)!i = typeof v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local \\<C> ! i = typeof v", "using assms(2,3)"], ["proof (prove)\nusing this:\n  length vi = i\n  local \\<C> = map typeof (vi @ [v] @ vs)\n\ngoal (1 subgoal):\n 1. local \\<C> ! i = typeof v", "by (metis (no_types, hide_lams) append_Cons length_map list.simps(9) map_append nth_append_length)"], ["proof (state)\nthis:\n  local \\<C> ! i = typeof v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : (ts _> ts'')\" \n                             \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local i] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local\n     i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp assms"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   [?e] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> [?e] : ts' _> ?t3s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local i] : ts _> ts'\n  length vi = i\n  local \\<C> = map typeof (vi @ [v] @ vs)\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local\n     i] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id butlast.simps(2) last.simps list.distinct(1))"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "hence \"ts'' = ts@[typeof v']\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local i] : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [typeof v']", "using b_e_type_value unlift_b_e[of \\<S> \\<C> \"[C v']\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v'] : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local i] : ts'' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = C ?v\\<rbrakk>\n  \\<Longrightarrow> ?ts' = ?ts @ [typeof ?v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [C v'] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [C v'] : ?tf\n\ngoal (1 subgoal):\n 1. ts'' = ts @ [typeof v']", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts @ [typeof v']\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "hence \"typeof v = typeof v'\" \"ts' = ts\""], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v']\n\ngoal (1 subgoal):\n 1. typeof v = typeof v' &&& ts' = ts", "using v_type b_e_type_set_local[of \\<C> \"Set_local i\" ts'' ts'] ts''_def(2) unlift_b_e[of \\<S> \\<C> \"[Set_local i]\"]"], ["proof (prove)\nusing this:\n  ts'' = ts @ [typeof v']\n  local \\<C> ! i = typeof v\n  \\<lbrakk>\\<C> \\<turnstile> [Set_local i] : ts'' _> ts';\n   Set_local i = Set_local ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t. ts'' = ts' @ [t] \\<and> local \\<C> ! ?i = t\n  \\<lbrakk>\\<C> \\<turnstile> [Set_local i] : ts'' _> ts';\n   Set_local i = Set_local ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (local \\<C>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Set_local i] : ts'' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Set_local i] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Set_local i] : ?tf\n\ngoal (1 subgoal):\n 1. typeof v = typeof v' &&& ts' = ts", "by fastforce+"], ["proof (state)\nthis:\n  typeof v = typeof v'\n  ts' = ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  typeof v = typeof v'\n  ts' = ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "using b_e_type_empty[of \\<C> \"ts\" \"ts'\"] e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  typeof v = typeof v'\n  ts' = ts\n  \\<C> \\<turnstile> [] : ts _> ts' = (ts = ts')\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n  map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_get_global:\n  assumes \"typeof (sglob_val s i j) = tg_t (global \\<C> ! j)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : (ts _> ts')\"\n  shows \"\\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : (ts _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts'", "have \"ts' = ts@[tg_t (global \\<C> ! j)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts' = ts @ [tg_t (global \\<C> ! j)]", "using b_e_type_get_global assms(2) unlift_b_e[of _ _ \"[Get_global j]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Get_global ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and> tg_t (global ?\\<C> ! ?i) = t\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Get_global ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (global ?\\<C>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* [Get_global j] : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Get_global j] : ?tf\n\ngoal (1 subgoal):\n 1. ts' = ts @ [tg_t (global \\<C> ! j)]", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts @ [tg_t (global \\<C> ! j)]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts' = ts @ [tg_t (global \\<C> ! j)]\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts'", "using b_e_typing.const[of \\<C> \"sglob_val s i j\"] assms(1) e_typing_s_typing.intros(1,3)"], ["proof (prove)\nusing this:\n  ts' = ts @ [tg_t (global \\<C> ! j)]\n  \\<C> \\<turnstile> [C sglob_val s i j] : [] _> [typeof (sglob_val s i j)]\n  typeof (sglob_val s i j) = tg_t (global \\<C> ! j)\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lholed_same_type:\n  assumes \"Lfilled k lholed es les\"\n          \"Lfilled k lholed es' les'\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> les : (ts _> ts')\"\n          \"\\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>(\\<C>\\<lparr>label := arb_labs@(label \\<C>)\\<rparr>) \\<turnstile> es : (ts _> ts')\n             \\<Longrightarrow> \\<S>\\<bullet>(\\<C>\\<lparr>label := arb_labs@(label \\<C>)\\<rparr>) \\<turnstile> es' : (ts _> ts')\"\n  shows \"(\\<S>\\<bullet>\\<C> \\<turnstile> les' : (ts _> ts'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "using assms"], ["proof (prove)\nusing this:\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @ label \\<C>\\<rparr> \\<turnstile> es' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "proof (induction arbitrary: ts ts' es' \\<C> les' rule: Lfilled.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        Lfilled 0 lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "case (L0 vs lholed es' es ts ts' es'')"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LBase vs es'\n  Lfilled 0 lholed es'' les'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts'\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @ label \\<C>\\<rparr> \\<turnstile> es'' : ?ts _> ?ts'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        Lfilled 0 lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "obtain ts'' ts''' where \"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> ts'')\"\n                          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts'' _> ts''')\"\n                          \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts''' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2 L0(4)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   ?es' @\n                                   ?es'' : ?t1s _> ?t2s \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ts' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ts' _> ts'' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es'' : ts'' _> ?t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        Lfilled 0 lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "moreover"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        Lfilled 0 lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "hence \"(\\<S>\\<bullet>\\<C> \\<turnstile> es'' : (ts'' _> ts'''))\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'''", "using L0(5)[of \"[]\" ts'' ts''']"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            [] @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ts'' _> ts''' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [] @ label \\<C>\\<rparr> \\<turnstile> es'' : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'''", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'''\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        Lfilled 0 lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "ultimately"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'''", "have \"(\\<S>\\<bullet>\\<C> \\<turnstile> vs @ es'' @ es' : (ts _> ts'))\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'''\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es'' @ es' : ts _> ts'", "using e_type_comp_conc"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'''\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n               ?es' : ?t1s _> ?t3s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es'' @ es' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es'' @ es' : ts _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        Lfilled 0 lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es @ es' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es'' @ es' : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "using L0(2,3) Lfilled.simps[of 0 lholed es'' les']"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ es'' @ es' : ts _> ts'\n  lholed = LBase vs es'\n  Lfilled 0 lholed es'' les'\n  Lfilled 0 lholed es'' les' =\n  ((\\<exists>vs lholed es' es.\n       0 = 0 \\<and>\n       lholed = lholed \\<and>\n       es'' = es \\<and>\n       les' = vs @ es @ es' \\<and>\n       const_list vs \\<and> lholed = LBase vs es') \\<or>\n   (\\<exists>vs lholed n es' l es''a k es lfilledk.\n       0 = k + 1 \\<and>\n       lholed = lholed \\<and>\n       es'' = es \\<and>\n       les' = vs @ [Label n es' lfilledk] @ es''a \\<and>\n       const_list vs \\<and>\n       lholed = LRec vs n es' l es''a \\<and> Lfilled k l es lfilledk))\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "case (LN vs lholed n es' l es'' k es lfilledk t1s t2s es''' \\<C> les')"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  \\<lbrakk>Lfilled k l ?es' ?les';\n   \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : ?ts _> ?ts';\n   \\<And>arb_labs ts ts'.\n      \\<S>\\<bullet>?\\<C>\n      \\<lparr>label :=\n                arb_labs @\n                label\n                 ?\\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n      \\<S>\\<bullet>?\\<C>\n      \\<lparr>label :=\n                arb_labs @\n                label ?\\<C>\\<rparr> \\<turnstile> ?es' : ts _> ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> ?les' : ?ts _> ?ts'\n  Lfilled (k + 1) lholed es''' les'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label n es' lfilledk] @ es'' : t1s _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @ label \\<C>\\<rparr> \\<turnstile> es''' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "obtain lfilledk' where l'_def:\"Lfilled k l es''' lfilledk'\" \"les' = vs @ [Label n es' lfilledk'] @ es''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lfilledk'.\n        \\<lbrakk>Lfilled k l es''' lfilledk';\n         les' = vs @ [Label n es' lfilledk'] @ es''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using LN Lfilled.simps[of \"k+1\" lholed es''' les']"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  \\<lbrakk>Lfilled k l ?es' ?les';\n   \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : ?ts _> ?ts';\n   \\<And>arb_labs ts ts'.\n      \\<S>\\<bullet>?\\<C>\n      \\<lparr>label :=\n                arb_labs @\n                label\n                 ?\\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n      \\<S>\\<bullet>?\\<C>\n      \\<lparr>label :=\n                arb_labs @\n                label ?\\<C>\\<rparr> \\<turnstile> ?es' : ts _> ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> ?les' : ?ts _> ?ts'\n  Lfilled (k + 1) lholed es''' les'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label n es' lfilledk] @ es'' : t1s _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs @ label \\<C>\\<rparr> \\<turnstile> es''' : ?ts _> ?ts'\n  Lfilled (k + 1) lholed es''' les' =\n  ((\\<exists>vs lholed es' es.\n       k + 1 = 0 \\<and>\n       lholed = lholed \\<and>\n       es''' = es \\<and>\n       les' = vs @ es @ es' \\<and>\n       const_list vs \\<and> lholed = LBase vs es') \\<or>\n   (\\<exists>vs lholed n es' l es'' k es lfilledk.\n       k + 1 = k + 1 \\<and>\n       lholed = lholed \\<and>\n       es''' = es \\<and>\n       les' = vs @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vs \\<and>\n       lholed = LRec vs n es' l es'' \\<and> Lfilled k l es lfilledk))\n\ngoal (1 subgoal):\n 1. (\\<And>lfilledk'.\n        \\<lbrakk>Lfilled k l es''' lfilledk';\n         les' = vs @ [Label n es' lfilledk'] @ es''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Lfilled k l es''' lfilledk'\n  les' = vs @ [Label n es' lfilledk'] @ es''\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "obtain ts' ts'' where lab_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (t1s _> ts')\"\n                                \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : (ts' _> ts'')\"\n                                \"\\<S>\\<bullet>\\<C> \\<turnstile> es'' : (ts'' _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : t1s _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es'\n    lfilledk] : ts' _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF LN(6)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es'\nlfilledk] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> t2s\n\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : t1s _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es'\n    lfilledk] : ts' _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : t1s _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : ts' _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> t2s\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "obtain tls ts_c \\<C>_int where int_def:\" ts'' = ts' @ ts_c\"\n                                 \"length tls = n\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (tls _> ts_c)\"\n                                 \"\\<C>_int = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\"\n                                 \"\\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk : ([] _> ts_c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts_c tls \\<C>_int.\n        \\<lbrakk>ts'' = ts' @ ts_c; length tls = n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> ts_c;\n         \\<C>_int = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>;\n         \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk : [] _> ts_c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[OF lab_def(2)]"], ["proof (prove)\nusing this:\n  \\<exists>tls t2s.\n     ts'' = ts' @ t2s \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> t2s \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label :=\n               [tls] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> t2s\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c tls \\<C>_int.\n        \\<lbrakk>ts'' = ts' @ ts_c; length tls = n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> ts_c;\n         \\<C>_int = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>;\n         \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk : [] _> ts_c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ts'' = ts' @ ts_c\n  length tls = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> ts_c\n  \\<C>_int = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\n  \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk : [] _> ts_c\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "have \"(\\<And>\\<C>' arb_labs' ts ts'.\n        \\<C>' = \\<C>_int\\<lparr>label := arb_labs' @ label \\<C>_int\\<rparr> \\<Longrightarrow>\n        \\<S>\\<bullet>\\<C>' \\<turnstile> es : (ts _> ts') \\<Longrightarrow>\n        (\\<S>\\<bullet>\\<C>' \\<turnstile> es''' : (ts _> ts')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<C>' arb_labs' ts ts'.\n       \\<lbrakk>\\<C>' = \\<C>_int\n                \\<lparr>label := arb_labs' @ label \\<C>_int\\<rparr>;\n        \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> es''' : ts _> ts'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<C>' arb_labs' ts ts'.\n       \\<lbrakk>\\<C>' = \\<C>_int\n                \\<lparr>label := arb_labs' @ label \\<C>_int\\<rparr>;\n        \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> es''' : ts _> ts'", "fix \\<C>'' arb_labs'' tts tts'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<C>' arb_labs' ts ts'.\n       \\<lbrakk>\\<C>' = \\<C>_int\n                \\<lparr>label := arb_labs' @ label \\<C>_int\\<rparr>;\n        \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> es''' : ts _> ts'", "assume \"\\<C>'' = \\<C>_int\\<lparr>label := arb_labs'' @ label \\<C>_int\\<rparr>\"\n           \"\\<S>\\<bullet>\\<C>'' \\<turnstile> es : (tts _> tts')\""], ["proof (state)\nthis:\n  \\<C>'' = \\<C>_int\\<lparr>label := arb_labs'' @ label \\<C>_int\\<rparr>\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> es : tts _> tts'\n\ngoal (1 subgoal):\n 1. \\<And>\\<C>' arb_labs' ts ts'.\n       \\<lbrakk>\\<C>' = \\<C>_int\n                \\<lparr>label := arb_labs' @ label \\<C>_int\\<rparr>;\n        \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> es''' : ts _> ts'", "thus \"(\\<S>\\<bullet>\\<C>'' \\<turnstile> es''' : (tts _> tts'))\""], ["proof (prove)\nusing this:\n  \\<C>'' = \\<C>_int\\<lparr>label := arb_labs'' @ label \\<C>_int\\<rparr>\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> es : tts _> tts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>'' \\<turnstile> es''' : tts _> tts'", "using LN(7)[of \"arb_labs'' @ [tls]\" tts tts'] int_def(4)"], ["proof (prove)\nusing this:\n  \\<C>'' = \\<C>_int\\<lparr>label := arb_labs'' @ label \\<C>_int\\<rparr>\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> es : tts _> tts'\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            (arb_labs'' @ [tls]) @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : tts _> tts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            (arb_labs'' @ [tls]) @\n            label \\<C>\\<rparr> \\<turnstile> es''' : tts _> tts'\n  \\<C>_int = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>'' \\<turnstile> es''' : tts _> tts'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>'' \\<turnstile> es''' : tts _> tts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<C>' = \\<C>_int\n           \\<lparr>label := ?arb_labs' @ label \\<C>_int\\<rparr>;\n   \\<S>\\<bullet>?\\<C>' \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> es''' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "hence \"(\\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : ([] _> ts_c))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<C>' = \\<C>_int\n           \\<lparr>label := ?arb_labs' @ label \\<C>_int\\<rparr>;\n   \\<S>\\<bullet>?\\<C>' \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> es''' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : [] _> ts_c", "using LN(4)[OF l'_def(1) int_def(5)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<C>' = \\<C>_int\n           \\<lparr>label := ?arb_labs' @ label \\<C>_int\\<rparr>;\n   \\<S>\\<bullet>?\\<C>' \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C>' \\<turnstile> es''' : ?ts _> ?ts'\n  (\\<And>arb_labs ts ts'.\n      \\<S>\\<bullet>\\<C>_int\n      \\<lparr>label :=\n                arb_labs @\n                label\n                 \\<C>_int\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n      \\<S>\\<bullet>\\<C>_int\n      \\<lparr>label :=\n                arb_labs @\n                label\n                 \\<C>_int\\<rparr> \\<turnstile> es''' : ts _> ts') \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : [] _> ts_c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : [] _> ts_c", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : [] _> ts_c\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "hence \"(\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk'] : (ts' _> ts''))\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : [] _> ts_c\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk'] : ts' _> ts''", "using int_def e_typing_s_typing.intros(3,7)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk' : [] _> ts_c\n  ts'' = ts' @ ts_c\n  length tls = n\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> ts_c\n  \\<C>_int = \\<C>\\<lparr>label := [tls] @ label \\<C>\\<rparr>\n  \\<S>\\<bullet>\\<C>_int \\<turnstile> lfilledk : [] _> ts_c\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?e0s : ?ts _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C>\n   \\<lparr>label :=\n             [?ts] @ label ?\\<C>\\<rparr> \\<turnstile> ?es : [] _> ?t2s;\n   length ?ts = ?n\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Label ?n ?e0s\n                 ?es] : [] _> ?t2s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk'] : ts' _> ts''", "by (metis append.right_neutral)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk'] : ts' _> ts''\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk ts ts' es'a \\<C> les'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<And>ts ts' es' \\<C> les'.\n           \\<lbrakk>Lfilled k l es' les';\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts';\n            \\<And>arb_labs ts ts'.\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n               \\<S>\\<bullet>\\<C>\n               \\<lparr>label :=\n                         arb_labs @\n                         label\n                          \\<C>\\<rparr> \\<turnstile> es' : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts';\n        Lfilled (k + 1) lholed es'a les';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts';\n        \\<And>arb_labs ts ts'.\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n           \\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     arb_labs @\n                     label\n                      \\<C>\\<rparr> \\<turnstile> es'a : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk'] : ts' _> ts''\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : t1s _> t2s", "using lab_def e_type_comp_conc l'_def(2)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk'] : ts' _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : t1s _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : ts' _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> t2s\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n               ?es' : ?t1s _> ?t3s\n  les' = vs @ [Label n es' lfilledk'] @ es''\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : t1s _> t2s", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> les' : t1s _> t2s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_e1:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"tvs = map typeof vs\"\n          \"i < length (inst s)\"\n          \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i) @ tvs), label := arb_labs, return := arb_return\\<rparr>\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n  shows \"(\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts _> ts')) \\<and> (map typeof vs = map typeof vs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "proof (induction arbitrary: tvs \\<C> ts ts' arb_labs arb_return rule: reduce.induct)"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 9. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 10. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n         i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                        j] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 24 subgoals...", "case (basic e e' s vs i)"], ["proof (state)\nthis:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> e' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 9. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 10. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n         i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                        j] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_b_e1[OF basic(1,2)]"], ["proof (prove)\nusing this:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> e : ts _> ts'\n  \\<S>\\<bullet>?\\<C> \\<turnstile> e : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>?\\<C> \\<turnstile> e' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> e' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> e' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "case (call s vs j i)"], ["proof (state)\nthis:\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "obtain  ts'' tf1 tf2 where l_func_t: \"length (func_t \\<C>) > j\"\n                                       \"ts = ts''@tf1\"\n                                       \"ts' = ts''@tf2\"\n                                       \"((func_t \\<C>)!j) = (tf1 _> tf2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'' tf1 tf2.\n        \\<lbrakk>j < length (func_t \\<C>); ts = ts'' @ tf1;\n         ts' = ts'' @ tf2; func_t \\<C> ! j = tf1 _> tf2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_call[of \\<C> \"Call j\" ts ts' j] call(5)\n          unlift_b_e[of _ _ \"[Call j]\" \"(ts _> ts')\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<C> \\<turnstile> [Call j] : ts _> ts'; Call j = Call j\\<rbrakk>\n  \\<Longrightarrow> j < length (func_t \\<C>)\n  \\<lbrakk>\\<C> \\<turnstile> [Call j] : ts _> ts'; Call j = Call j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts'' tf1 tf2.\n                       ts = ts'' @ tf1 \\<and>\n                       ts' = ts'' @ tf2 \\<and> func_t \\<C> ! j = tf1 _> tf2\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* [Call j] : ts _> ts' \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Call j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' tf1 tf2.\n        \\<lbrakk>j < length (func_t \\<C>); ts = ts'' @ tf1;\n         ts' = ts'' @ tf2; func_t \\<C> ! j = tf1 _> tf2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  j < length (func_t \\<C>)\n  ts = ts'' @ tf1\n  ts' = ts'' @ tf2\n  func_t \\<C> ! j = tf1 _> tf2\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "have \"i < length (s_inst \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "using call(3) store_typing_imp_inst_length_eq[OF call(1)]"], ["proof (prove)\nusing this:\n  i < length (inst s)\n  length (inst s) = length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "by simp"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "moreover"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "have \"j < length (func_t (s_inst \\<S> ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (func_t (s_inst \\<S> ! i))", "using l_func_t(1) call(4)"], ["proof (prove)\nusing this:\n  j < length (func_t \\<C>)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. j < length (func_t (s_inst \\<S> ! i))", "by simp"], ["proof (state)\nthis:\n  j < length (func_t (s_inst \\<S> ! i))\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  i < length (s_inst \\<S>)\n  j < length (func_t (s_inst \\<S> ! i))", "have \"cl_typing \\<S> (sfunc s i j) (tf1 _> tf2)\""], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  j < length (func_t (s_inst \\<S> ! i))\n\ngoal (1 subgoal):\n 1. cl_typing \\<S> (sfunc s i j) (tf1 _> tf2)", "using store_typing_imp_func_agree[OF call(1)] l_func_t(4) call(4)"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  j < length (func_t (s_inst \\<S> ! i))\n  \\<lbrakk>?i < length (s_inst \\<S>);\n   ?j < length (func_t (s_inst \\<S> ! ?i))\\<rbrakk>\n  \\<Longrightarrow> sfunc_ind s ?i ?j < length (s_funcs \\<S>)\n  \\<lbrakk>?i < length (s_inst \\<S>);\n   ?j < length (func_t (s_inst \\<S> ! ?i))\\<rbrakk>\n  \\<Longrightarrow> cl_typing \\<S> (sfunc s ?i ?j)\n                     (s_funcs \\<S> ! sfunc_ind s ?i ?j)\n  \\<lbrakk>?i < length (s_inst \\<S>);\n   ?j < length (func_t (s_inst \\<S> ! ?i))\\<rbrakk>\n  \\<Longrightarrow> s_funcs \\<S> ! sfunc_ind s ?i ?j =\n                    func_t (s_inst \\<S> ! ?i) ! ?j\n  func_t \\<C> ! j = tf1 _> tf2\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. cl_typing \\<S> (sfunc s i j) (tf1 _> tf2)", "by fastforce"], ["proof (state)\nthis:\n  cl_typing \\<S> (sfunc s i j) (tf1 _> tf2)\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Call j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    (sfunc s i j)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 8. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 9. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n   $Set_global j] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cl_typing \\<S> (sfunc s i j) (tf1 _> tf2)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl (sfunc s i j)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using e_typing_s_typing.intros(3,6) l_func_t"], ["proof (prove)\nusing this:\n  cl_typing \\<S> (sfunc s i j) (tf1 _> tf2)\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  cl_typing ?\\<S> ?cl ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Callcl ?cl] : ?tf\n  j < length (func_t \\<C>)\n  ts = ts'' @ tf1\n  ts' = ts'' @ tf2\n  func_t \\<C> ! j = tf1 _> tf2\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl (sfunc s i j)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl (sfunc s i j)] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (22 subgoals):\n 1. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 7. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 8. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                        bs t] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 7. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 8. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                        bs t] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 22 subgoals...", "case (call_indirect_Some s i' c cl j tf vs)"], ["proof (state)\nthis:\n  stab s i' (nat_of_int c) = Some cl\n  stypes s i' j = tf\n  cl_type cl = tf\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i' < length (inst s)\n  \\<C> = (s_inst \\<S> ! i')\n  \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n                                  $Call_indirect j] : ts _> ts'\n\ngoal (22 subgoals):\n 1. \\<And>s i c cl j tf vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl\n                    cl] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 7. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 8. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = Some bs;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                        bs t] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 22 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_call_indirect_Some[OF call_indirect_Some(8,1)]\n          call_indirect_Some(2,3,4,6,7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>stypes s i' j = ?tf; cl_type cl = ?tf; store_typing s \\<S>;\n   i' < length (inst s);\n   \\<C> = (s_inst \\<S> ! i')\n   \\<lparr>local := local (s_inst \\<S> ! i') @ ?tvs, label := ?arb_labs,\n      return := ?arb_return\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts'\n  stypes s i' j = tf\n  cl_type cl = tf\n  store_typing s \\<S>\n  i' < length (inst s)\n  \\<C> = (s_inst \\<S> ! i')\n  \\<lparr>local := local (s_inst \\<S> ! i') @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (21 subgoals):\n 1. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 6. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 7. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 6. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 7. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 21 subgoals...", "case (call_indirect_None s i c cl j vs)"], ["proof (state)\nthis:\n  stab s i (nat_of_int c) = Some cl \\<and>\n  stypes s i j \\<noteq> cl_type cl \\<or>\n  stab s i (nat_of_int c) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n                                  $Call_indirect j] : ts _> ts'\n\ngoal (21 subgoals):\n 1. \\<And>s i c cl j vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Call_indirect j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 6. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 7. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 21 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  stab s i (nat_of_int c) = Some cl \\<and>\n  stypes s i j \\<noteq> cl_type cl \\<or>\n  stab s i (nat_of_int c) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n                                  $Call_indirect j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  stab s i (nat_of_int c) = Some cl \\<and>\n  stypes s i j \\<noteq> cl_type cl \\<or>\n  stab s i (nat_of_int c) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n                                  $Call_indirect j] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (20 subgoals):\n 1. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 5. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 6. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n         Some bs;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                        bs t] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 5. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 6. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n         Some bs;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                        bs t] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 20 subgoals...", "case (callcl_native cl j t1s t2s ts es ves vcs n k m zs s vs i)"], ["proof (state)\nthis:\n  cl = Func_native j (t1s _> t2s) tsa__ es\n  ves = $$* vcs\n  length vcs = n\n  length tsa__ = k\n  length t1s = n\n  length t2s = m\n  n_zeros tsa__ = zs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n\ngoal (20 subgoals):\n 1. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i tvs \\<C> tsa ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : tsa _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j\n                    (vcs @ zs) [$Block ([] _> t2s) es]] : tsa _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 5. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 6. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n         Some bs;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                        bs t] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 20 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cl = Func_native j (t1s _> t2s) tsa__ es\n  ves = $$* vcs\n  length vcs = n\n  length tsa__ = k\n  length t1s = n\n  length t2s = m\n  n_zeros tsa__ = zs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j (vcs @ zs)\n                                     [$Block ([] _> t2s)\n  es]] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_callcl_native"], ["proof (prove)\nusing this:\n  cl = Func_native j (t1s _> t2s) tsa__ es\n  ves = $$* vcs\n  length vcs = n\n  length tsa__ = k\n  length t1s = n\n  length t2s = m\n  n_zeros tsa__ = zs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?ves @\n      [Callcl ?cl] : ?ts _> ?ts';\n   ?cl = Func_native ?i (?t1s _> ?t2s) ?tfs ?es; ?ves = $$* ?vs;\n   length ?vs = ?n; length ?tfs = ?k; length ?t1s = ?n; length ?t2s = ?m;\n   n_zeros ?tfs = ?zs; store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Local ?m ?i\n                 (?vs @ ?zs) [$Block ([] _> ?t2s) ?es]] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j (vcs @ zs)\n                                     [$Block ([] _> t2s)\n  es]] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local m j (vcs @ zs)\n                                   [$Block ([] _> t2s)\nes]] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (19 subgoals):\n 1. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 4. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 5. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n         None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 4. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 5. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n         None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 19 subgoals...", "case (callcl_host_Some cl t1s t2s f ves vcs n m s hs s' vcs' vs i)"], ["proof (state)\nthis:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n\ngoal (19 subgoals):\n 1. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i tvs \\<C> ts ts'\n       arb_labs arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 4. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 5. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n         load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n         None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n   $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_callcl_host_some"], ["proof (prove)\nusing this:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs')\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?ves @\n      [Callcl ?cl] : ?ts _> ?ts';\n   ?cl = Func_host (?t1s _> ?t2s) ?f; ?ves = $$* ?vcs; length ?vcs = ?n;\n   length ?t1s = ?n; length ?t2s = ?m;\n   host_apply ?s (?t1s _> ?t2s) ?f ?vcs ?hs = Some (?s', ?vcs');\n   store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> $$* ?vcs' : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> $$* vcs' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (18 subgoals):\n 1. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 3. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 4. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 3. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 4. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 18 subgoals...", "case (callcl_host_None cl t1s t2s f ves vcs n m s hs vs i)"], ["proof (state)\nthis:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  store_typing s \\<S>\n  i = map typeof hs\n  vs < length (inst s)\n  \\<C> = (s_inst \\<S> ! vs)\n  \\<lparr>local := local (s_inst \\<S> ! vs) @ i, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n\ngoal (18 subgoals):\n 1. \\<And>cl t1s t2s f ves vcs n m s vs i tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> ves @\n [Callcl cl] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 3. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 4. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  store_typing s \\<S>\n  i = map typeof hs\n  vs < length (inst s)\n  \\<C> = (s_inst \\<S> ! vs)\n  \\<lparr>local := local (s_inst \\<S> ! vs) @ i, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof hs = map typeof hs", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  cl = Func_host (t1s _> t2s) f\n  ves = $$* vcs\n  length vcs = n\n  length t1s = n\n  length t2s = m\n  store_typing s \\<S>\n  i = map typeof hs\n  vs < length (inst s)\n  \\<C> = (s_inst \\<S> ! vs)\n  \\<lparr>local := local (s_inst \\<S> ! vs) @ i, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> ves @ [Callcl cl] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof hs = map typeof hs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n  map typeof hs = map typeof hs\n\ngoal (17 subgoals):\n 1. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 2. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 3. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 2. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 3. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 17 subgoals...", "case (get_local vi j s v vs i)"], ["proof (state)\nthis:\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\n\ngoal (17 subgoals):\n 1. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 2. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 3. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 17 subgoals...", "hence \"i < length (s_inst \\<S>)\""], ["proof (prove)\nusing this:\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "unfolding list_all2_conv_all_nth store_typing.simps"], ["proof (prove)\nusing this:\n  length vi = j\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     (length insts = length \\<C>s \\<and>\n      (\\<forall>i<length insts.\n          inst_typing \\<S>' (insts ! i) (\\<C>s ! i))) \\<and>\n     (length fs = length tfs \\<and>\n      (\\<forall>i<length fs. cl_typing \\<S>' (fs ! i) (tfs ! i))) \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     (length tclss = length ns \\<and>\n      (\\<forall>i<length tclss. ns ! i \\<le> length (tclss ! i))) \\<and>\n     (length bss = length ms \\<and>\n      (\\<forall>i<length bss. mem_agree (bss ! i) (ms ! i))) \\<and>\n     length gs = length tgs \\<and>\n     (\\<forall>i<length gs. glob_agree (gs ! i) (tgs ! i))\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "by fastforce"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (17 subgoals):\n 1. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 2. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 3. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  i < length (s_inst \\<S>)", "have \"local \\<C> = tvs\""], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. local \\<C> = tvs", "using store_local_label_empty assms(2) get_local"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<lbrakk>?i < length (s_inst ?\\<S>); store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> label (s_inst ?\\<S> ! ?i) = []\n  \\<lbrakk>?i < length (s_inst ?\\<S>); store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> local (s_inst ?\\<S> ! ?i) = []\n  store_typing s \\<S>\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. local \\<C> = tvs", "by fastforce"], ["proof (state)\nthis:\n  local \\<C> = tvs\n\ngoal (17 subgoals):\n 1. \\<And>vi j s v vs i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v] @ vs)\n 2. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 3. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store m (nat_of_int k) off (bits v) (t_length t) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t None a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  local \\<C> = tvs", "show ?case"], ["proof (prove)\nusing this:\n  local \\<C> = tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v] @ vs)", "using types_preserved_get_local get_local"], ["proof (prove)\nusing this:\n  local \\<C> = tvs\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Get_local ?i] : ?ts _> ?ts';\n   length ?vi = ?i; local ?\\<C> = map typeof (?vi @ [?v] @ ?vs)\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v] : ?ts _> ?ts'\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v] @ vs)", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : ts _> ts' \\<and>\n  map typeof (vi @ [v] @ vs) = map typeof (vi @ [v] @ vs)\n\ngoal (16 subgoals):\n 1. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n         Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n         Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 16 subgoals...", "case (set_local vi j s v vs v' i)"], ["proof (state)\nthis:\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts'\n\ngoal (16 subgoals):\n 1. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n         Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 16 subgoals...", "hence \"i < length (s_inst \\<S>)\""], ["proof (prove)\nusing this:\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "unfolding list_all2_conv_all_nth store_typing.simps"], ["proof (prove)\nusing this:\n  length vi = j\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     (length insts = length \\<C>s \\<and>\n      (\\<forall>i<length insts.\n          inst_typing \\<S>' (insts ! i) (\\<C>s ! i))) \\<and>\n     (length fs = length tfs \\<and>\n      (\\<forall>i<length fs. cl_typing \\<S>' (fs ! i) (tfs ! i))) \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     (length tclss = length ns \\<and>\n      (\\<forall>i<length tclss. ns ! i \\<le> length (tclss ! i))) \\<and>\n     (length bss = length ms \\<and>\n      (\\<forall>i<length bss. mem_agree (bss ! i) (ms ! i))) \\<and>\n     length gs = length tgs \\<and>\n     (\\<forall>i<length gs. glob_agree (gs ! i) (tgs ! i))\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "by fastforce"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (16 subgoals):\n 1. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n         Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 16 subgoals...", "hence \"local \\<C> = tvs\""], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. local \\<C> = tvs", "using store_local_label_empty assms(2) set_local"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<lbrakk>?i < length (s_inst ?\\<S>); store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> label (s_inst ?\\<S> ! ?i) = []\n  \\<lbrakk>?i < length (s_inst ?\\<S>); store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> local (s_inst ?\\<S> ! ?i) = []\n  store_typing s \\<S>\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. local \\<C> = tvs", "by fastforce"], ["proof (state)\nthis:\n  local \\<C> = tvs\n\ngoal (16 subgoals):\n 1. \\<And>vi j s v vs v' i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>length vi = j; store_typing s \\<S>;\n        tvs = map typeof (vi @ [v] @ vs); i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v',\n  $Set_local j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof (vi @ [v] @ vs) =\n                         map typeof (vi @ [v'] @ vs)\n 2. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n         Some mem';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  local \\<C> = tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "using set_local types_preserved_set_local"], ["proof (prove)\nusing this:\n  local \\<C> = tvs\n  length vi = j\n  store_typing s \\<S>\n  tvs = map typeof (vi @ [v] @ vs)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v', $Set_local j] : ts _> ts'\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v',\n       $Set_local ?i] : ?ts _> ?ts';\n   length ?vi = ?i; local ?\\<C> = map typeof (?vi @ [?v] @ ?vs)\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [] : ?ts _> ?ts' \\<and>\n                    map typeof (?vi @ [?v] @ ?vs) =\n                    map typeof (?vi @ [?v'] @ ?vs)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n  map typeof (vi @ [v] @ vs) = map typeof (vi @ [v'] @ vs)\n\ngoal (15 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 15 subgoals...", "case (get_global s vs j i)"], ["proof (state)\nthis:\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\n\ngoal (15 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 15 subgoals...", "have \"length (global \\<C>) > j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (global \\<C>)", "using b_e_type_get_global get_global(5) unlift_b_e[of _ _ \"[Get_global j]\" \"(ts _> ts')\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Get_global ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and> tg_t (global ?\\<C> ! ?i) = t\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts';\n   ?e = Get_global ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (global ?\\<C>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* [Get_global\n  j] : ts _> ts' \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Get_global j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. j < length (global \\<C>)", "by fastforce"], ["proof (state)\nthis:\n  j < length (global \\<C>)\n\ngoal (15 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 15 subgoals...", "hence \"glob_agree (sglob s i j) ((global \\<C>)!j)\""], ["proof (prove)\nusing this:\n  j < length (global \\<C>)\n\ngoal (1 subgoal):\n 1. glob_agree (sglob s i j) (global \\<C> ! j)", "using get_global(3,4) store_typing_imp_glob_agree[OF get_global(1)] store_typing_imp_inst_length_eq[OF get_global(1)]"], ["proof (prove)\nusing this:\n  j < length (global \\<C>)\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<lbrakk>?i < length (s_inst \\<S>);\n   ?j < length (global (s_inst \\<S> ! ?i))\\<rbrakk>\n  \\<Longrightarrow> sglob_ind s ?i ?j < length (s_globs \\<S>)\n  \\<lbrakk>?i < length (s_inst \\<S>);\n   ?j < length (global (s_inst \\<S> ! ?i))\\<rbrakk>\n  \\<Longrightarrow> glob_agree (sglob s ?i ?j)\n                     (s_globs \\<S> ! sglob_ind s ?i ?j)\n  \\<lbrakk>?i < length (s_inst \\<S>);\n   ?j < length (global (s_inst \\<S> ! ?i))\\<rbrakk>\n  \\<Longrightarrow> s_globs \\<S> ! sglob_ind s ?i ?j =\n                    global (s_inst \\<S> ! ?i) ! ?j\n  length (inst s) = length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. glob_agree (sglob s i j) (global \\<C> ! j)", "by fastforce"], ["proof (state)\nthis:\n  glob_agree (sglob s i j) (global \\<C> ! j)\n\ngoal (15 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 15 subgoals...", "hence \"typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)\""], ["proof (prove)\nusing this:\n  glob_agree (sglob s i j) (global \\<C> ! j)\n\ngoal (1 subgoal):\n 1. typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)", "unfolding glob_agree_def"], ["proof (prove)\nusing this:\n  tg_mut (global \\<C> ! j) = g_mut (sglob s i j) \\<and>\n  tg_t (global \\<C> ! j) = typeof (g_val (sglob s i j))\n\ngoal (1 subgoal):\n 1. typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)", "by simp"], ["proof (state)\nthis:\n  typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)\n\ngoal (15 subgoals):\n 1. \\<And>s vs j i tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n        i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i\n                       j] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n         store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n   $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 15 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using get_global(5) types_preserved_get_global"], ["proof (prove)\nusing this:\n  typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\n  \\<lbrakk>typeof (sglob_val ?s ?i ?j) = tg_t (global ?\\<C> ! ?j);\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Get_global ?j] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C sglob_val ?s ?i\n                    ?j] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "unfolding glob_agree_def sglob_val_def"], ["proof (prove)\nusing this:\n  typeof (g_val (sglob s i j)) = tg_t (global \\<C> ! j)\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Get_global j] : ts _> ts'\n  \\<lbrakk>typeof (g_val (sglob ?s ?i ?j)) = tg_t (global ?\\<C> ! ?j);\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Get_global ?j] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C g_val\n                    (sglob ?s ?i ?j)] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C g_val\n  (sglob s i j)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C sglob_val s i j] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (14 subgoals):\n 1. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        (int_of_nat n)] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        (int_of_nat n)] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 14 subgoals...", "case (set_global s i j v s' vs)"], ["proof (state)\nthis:\n  supdate_glob s i j v = s'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts'\n\ngoal (14 subgoals):\n 1. \\<And>s i j v s' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>supdate_glob s i j v = s'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C v,\n  $Set_global j] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        (int_of_nat n)] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  supdate_glob s i j v = s'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  supdate_glob s i j v = s'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_set_global"], ["proof (prove)\nusing this:\n  supdate_glob s i j v = s'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v, $Set_global j] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v,\n                                    $Set_global\n?j] : ?ts _> ?ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [] : ?ts _> ?ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v,\n                                    $Set_global\n?j] : ?ts _> ?ts' \\<Longrightarrow>\n  tg_t (global ?\\<C> ! ?j) = typeof ?v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (13 subgoals):\n 1. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n   $Grow_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        (int_of_nat n)] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n   $Grow_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        (int_of_nat n)] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 13 subgoals...", "case (load_Some s i j m k off t bs vs a)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = Some bs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'\n\ngoal (13 subgoals):\n 1. \\<And>s i j m k off t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n         tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n   $Grow_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        (int_of_nat n)] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = Some bs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = Some bs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise bs\n  t] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_load(1) wasm_deserialise_type"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = Some bs\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?k,\n       $Load ?t ?tp ?a ?off] : ?ts _> ?ts';\n   typeof ?v = ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v] : ?ts _> ?ts'\n  typeof (wasm_deserialise ?bs ?t) = ?t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise bs\n  t] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise bs\nt] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (12 subgoals):\n 1. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n   $Grow_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        int32_minus_one] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n   $Grow_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        int32_minus_one] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 12 subgoals...", "case (load_None s i j m k off t vs a)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'\n\ngoal (12 subgoals):\n 1. \\<And>s i j m k off t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load m (nat_of_int k) off (t_length t) = None; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n   $Grow_memory] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                        int32_minus_one] : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load m (nat_of_int k) off (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load t None a off] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (11 subgoals):\n 1. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n         \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n            \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n             i < length (inst s);\n             \\<C> = (s_inst \\<S> ! i)\n             \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n                label := arb_labs, return := arb_return\\<rparr>;\n             \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n            \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                              map typeof vs = map typeof vs';\n         Lfilled k lholed es les; Lfilled k lholed es' les';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n         \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n            \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n             i < length (inst s);\n             \\<C> = (s_inst \\<S> ! i)\n             \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n                label := arb_labs, return := arb_return\\<rparr>;\n             \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n            \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                              map typeof vs = map typeof vs';\n         Lfilled k lholed es les; Lfilled k lholed es' les';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs'\nA total of 11 subgoals...", "case (load_packed_Some s i j m sx k off tp bs vs t a)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length bs) = Some vs\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load bs (Some (tp, sx)) a\n                                    off] : ts _> ts'\n\ngoal (11 subgoals):\n 1. \\<And>s i j m sx k off tp t bs vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        Some bs;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise\n                       bs t] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 10. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n        arb_return.\n        \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n         \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n            \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n             i < length (inst s);\n             \\<C> = (s_inst \\<S> ! i)\n             \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n                label := arb_labs, return := arb_return\\<rparr>;\n             \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n            \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                              map typeof vs = map typeof vs';\n         Lfilled k lholed es les; Lfilled k lholed es' les';\n         store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n         \\<C> = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                          map typeof vs = map typeof vs'\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length bs) = Some vs\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load bs (Some (tp, sx)) a\n                                    off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length bs) = Some vs\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load bs (Some (tp, sx)) a\n                                    off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise vs\n  bs] : ts _> ts' \\<and>\n    map typeof t = map typeof t", "using types_preserved_load(1) wasm_deserialise_type"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length bs) = Some vs\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load bs (Some (tp, sx)) a\n                                    off] : ts _> ts'\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?k,\n       $Load ?t ?tp ?a ?off] : ?ts _> ?ts';\n   typeof ?v = ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v] : ?ts _> ?ts'\n  typeof (wasm_deserialise ?bs ?t) = ?t\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise vs\n  bs] : ts _> ts' \\<and>\n    map typeof t = map typeof t", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C wasm_deserialise vs\nbs] : ts _> ts' \\<and>\n  map typeof t = map typeof t\n\ngoal (10 subgoals):\n 1. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 10. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n         \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n            \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n             i < length (inst s);\n             \\<C> = (s_inst \\<S> ! i)\n             \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n                label := arb_labs, return := arb_return\\<rparr>;\n             \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n            \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                              map typeof vs = map typeof vs';\n         store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n         \\<C> = (s_inst \\<S> ! j)\n         \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n    es] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                     es'] : ts _> ts' \\<and>\n                          map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 10. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n         \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n            \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n             i < length (inst s);\n             \\<C> = (s_inst \\<S> ! i)\n             \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n                label := arb_labs, return := arb_return\\<rparr>;\n             \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n            \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                              map typeof vs = map typeof vs';\n         store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n         \\<C> = (s_inst \\<S> ! j)\n         \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n    es] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                     es'] : ts _> ts' \\<and>\n                          map typeof v0s = map typeof v0s", "case (load_packed_None s i j m sx k off tp vs t a)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length vs) = None\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load vs (Some (tp, sx)) a\n                                    off] : ts _> ts'\n\ngoal (10 subgoals):\n 1. \\<And>s i j m sx k off tp t vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m;\n        load_packed sx m (nat_of_int k) off (tp_length tp) (t_length t) =\n        None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n  $Load t (Some (tp, sx)) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 9. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 10. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n        \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n         \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n            \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n             i < length (inst s);\n             \\<C> = (s_inst \\<S> ! i)\n             \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n                label := arb_labs, return := arb_return\\<rparr>;\n             \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n            \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                              map typeof vs = map typeof vs';\n         store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n         \\<C> = (s_inst \\<S> ! j)\n         \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n            return := arb_return\\<rparr>;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n    es] : ts _> ts'\\<rbrakk>\n        \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                     es'] : ts _> ts' \\<and>\n                          map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length vs) = None\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load vs (Some (tp, sx)) a\n                                    off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length vs) = None\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load vs (Some (tp, sx)) a\n                                    off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof t = map typeof t", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  load_packed sx m (nat_of_int k) off (tp_length tp) (t_length vs) = None\n  store_typing s \\<S>\n  tvs = map typeof t\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k,\n                                  $Load vs (Some (tp, sx)) a\n                                    off] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof t = map typeof t", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n  map typeof t = map typeof t\n\ngoal (9 subgoals):\n 1. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 9. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 9. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (store_Some t v s i j m k off mem' vs a)"], ["proof (state)\nthis:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n\ngoal (9 subgoals):\n 1. \\<And>t v s i j m k off mem' vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 8. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 9. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_store"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?k, $C ?v,\n                                    $Store ?t ?tp ?a\n?off] : ?ts _> ?ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [] : ?ts _> ?ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?k, $C ?v,\n                                    $Store ?t ?tp ?a\n?off] : ?ts _> ?ts' \\<Longrightarrow>\n  types_agree ?t ?v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (8 subgoals):\n 1. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 8. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 8. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (store_None t v s i j m k off vs a)"], ["proof (state)\nthis:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n\ngoal (8 subgoals):\n 1. \\<And>t v s i j m k off vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store m (nat_of_int k) off (bits v) (t_length t) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t None a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 7. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 8. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store m (nat_of_int k) off (bits v) (t_length t) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t None a off] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (7 subgoals):\n 1. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 7. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 7. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (store_packed_Some t v s i j m k off tp mem' vs a)"], ["proof (state)\nthis:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n\ngoal (7 subgoals):\n 1. \\<And>t v s i j m k off tp mem' vs a tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) =\n        Some mem';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 6. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 7. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_store"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = Some mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?k, $C ?v,\n                                    $Store ?t ?tp ?a\n?off] : ?ts _> ?ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [] : ?ts _> ?ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?k, $C ?v,\n                                    $Store ?t ?tp ?a\n?off] : ?ts _> ?ts' \\<Longrightarrow>\n  types_agree ?t ?v\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (6 subgoals):\n 1. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 6. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 6. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (store_packed_None t v s i j m k off tp vs a)"], ["proof (state)\nthis:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n\ngoal (6 subgoals):\n 1. \\<And>t v s i j m k off tp vs a tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>types_agree t v; smem_ind s i = Some j; s.mem s ! j = m;\n        store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n  $Store t (Some tp) a off] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 5. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 6. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using e_typing_s_typing.intros(4)"], ["proof (prove)\nusing this:\n  types_agree t v\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  store_packed m (nat_of_int k) off (bits v) (tp_length tp) = None\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 k, $C v,\n                                  $Store t (Some tp) a off] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Trap] : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Trap] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (5 subgoals):\n 1. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 5. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 5. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (current_memory s i j m n vs)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\n\ngoal (5 subgoals):\n 1. \\<And>s i j m n vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 4. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 5. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n  (int_of_nat n)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_current_memory"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Current_memory] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$Current_memory] : ?ts _> ?ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n  (int_of_nat n)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n(int_of_nat n)] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (4 subgoals):\n 1. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 4. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 4. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (grow_memory s i j m n c mem' vs)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  mem_grow m (nat_of_int c) = mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n\ngoal (4 subgoals):\n 1. \\<And>s i j m n c mem' vs tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        mem_grow m (nat_of_int c) = mem'; store_typing s \\<S>;\n        tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       (int_of_nat n)] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 3. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 4. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "then"], ["proof (chain)\npicking this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  mem_grow m (nat_of_int c) = mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  mem_grow m (nat_of_int c) = mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n  (int_of_nat n)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_grow_memory"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  mem_grow m (nat_of_int c) = mem'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c,\n                                    $Grow_memory] : ?ts _> ?ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n  (int_of_nat n)] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n(int_of_nat n)] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (3 subgoals):\n 1. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 3. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 3. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (grow_memory_fail s i j m n vs c)"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n\ngoal (3 subgoals):\n 1. \\<And>s i j m n vs c tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>smem_ind s i = Some j; s.mem s ! j = m; mem_size m = n;\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c,\n  $Grow_memory] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n                       int32_minus_one] : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs\n 2. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 3. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "thus ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n  int32_minus_one] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using types_preserved_grow_memory"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  s.mem s ! j = m\n  mem_size m = n\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32 c, $Grow_memory] : ts _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c,\n                                    $Grow_memory] : ?ts _> ?ts' \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ConstInt32 ?c'] : ?ts _> ?ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\n  int32_minus_one] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C ConstInt32\nint32_minus_one] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (label s vs es i s' vs' es' k lholed les les')"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  \\<lbrakk>store_typing s \\<S>; ?tvs = map typeof vs; i < length (inst s);\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ ?tvs, label := ?arb_labs,\n      return := ?arb_return\\<rparr>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> es' : ?ts _> ?ts' \\<and>\n                    map typeof vs = map typeof vs'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "{"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  \\<lbrakk>store_typing s \\<S>; ?tvs = map typeof vs; i < length (inst s);\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ ?tvs, label := ?arb_labs,\n      return := ?arb_return\\<rparr>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> es' : ?ts _> ?ts' \\<and>\n                    map typeof vs = map typeof vs'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  i < length (inst s)\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "fix \\<C>' arb_labs' ts ts'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "assume local_assms:\"\\<C>' = \\<C>\\<lparr>label := arb_labs'@(label \\<C>), return := (return \\<C>)\\<rparr>\""], ["proof (state)\nthis:\n  \\<C>' = \\<C>\n  \\<lparr>label := arb_labs' @ label \\<C>, return := return \\<C>\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "hence \"(\\<S>\\<bullet>\\<C>' \\<turnstile> es : (ts _> ts')) \\<Longrightarrow> (\\<S>\\<bullet>\\<C>' \\<turnstile> es' : (ts _> ts')) \\<and> map typeof vs = map typeof vs'\""], ["proof (prove)\nusing this:\n  \\<C>' = \\<C>\n  \\<lparr>label := arb_labs' @ label \\<C>, return := return \\<C>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n    \\<S>\\<bullet>\\<C>' \\<turnstile> es' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "using label(4)[OF label(5,6,7)] label(8)"], ["proof (prove)\nusing this:\n  \\<C>' = \\<C>\n  \\<lparr>label := arb_labs' @ label \\<C>, return := return \\<C>\\<rparr>\n  \\<lbrakk>?\\<C> = (s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n              label := ?arb_labs, return := ?arb_return\\<rparr>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> es' : ?ts _> ?ts' \\<and>\n                    map typeof vs = map typeof vs'\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n    \\<S>\\<bullet>\\<C>' \\<turnstile> es' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "hence \"(\\<S>\\<bullet>\\<C>\\<lparr>label := arb_labs'@(label \\<C>)\\<rparr> \\<turnstile> es : (ts _> ts'))\n               \\<Longrightarrow> (\\<S>\\<bullet>\\<C>\\<lparr>label := arb_labs'@(label \\<C>)\\<rparr> \\<turnstile> es' : (ts _> ts')) \\<and>\n                     map typeof vs = map typeof vs'\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>\n    \\<lparr>label :=\n              arb_labs' @\n              label\n               \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n    \\<S>\\<bullet>\\<C>\n    \\<lparr>label :=\n              arb_labs' @\n              label \\<C>\\<rparr> \\<turnstile> es' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "using local_assms"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs'\n  \\<C>' = \\<C>\n  \\<lparr>label := arb_labs' @ label \\<C>, return := return \\<C>\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>\n    \\<lparr>label :=\n              arb_labs' @\n              label\n               \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n    \\<S>\\<bullet>\\<C>\n    \\<lparr>label :=\n              arb_labs' @\n              label \\<C>\\<rparr> \\<turnstile> es' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            arb_labs' @\n            label \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            arb_labs' @\n            label \\<C>\\<rparr> \\<turnstile> es' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<C>''2 = \\<C>\n           \\<lparr>label := ?arb_labs'2 @ label \\<C>,\n              return := return \\<C>\\<rparr>;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             ?arb_labs'2 @\n             label \\<C>\\<rparr> \\<turnstile> es : ?tsb2 _> ?ts'b2\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              ?arb_labs'2 @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> es' : ?tsb2 _> ?ts'b2 \\<and>\n                    map typeof vs = map typeof vs'\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "hence \"\\<And>arb_labs' ts ts'. \\<S>\\<bullet>\\<C>\\<lparr>label := arb_labs'@(label \\<C>)\\<rparr> \\<turnstile> es : (ts _> ts')\n                              \\<Longrightarrow> (\\<S>\\<bullet>\\<C>\\<lparr>label := arb_labs'@(label \\<C>)\\<rparr> \\<turnstile> es' : (ts _> ts'))\"\n       \"map typeof vs = map typeof vs'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<C>''2 = \\<C>\n           \\<lparr>label := ?arb_labs'2 @ label \\<C>,\n              return := return \\<C>\\<rparr>;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             ?arb_labs'2 @\n             label \\<C>\\<rparr> \\<turnstile> es : ?tsb2 _> ?ts'b2\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              ?arb_labs'2 @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> es' : ?tsb2 _> ?ts'b2 \\<and>\n                    map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. (\\<And>arb_labs' ts ts'.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  arb_labs' @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  arb_labs' @\n                  label \\<C>\\<rparr> \\<turnstile> es' : ts _> ts') &&&\n    map typeof vs = map typeof vs'", "using types_exist_lfilled[OF label(2,9)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<C>''2 = \\<C>\n           \\<lparr>label := ?arb_labs'2 @ label \\<C>,\n              return := return \\<C>\\<rparr>;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             ?arb_labs'2 @\n             label \\<C>\\<rparr> \\<turnstile> es : ?tsb2 _> ?ts'b2\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              ?arb_labs'2 @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> es' : ?tsb2 _> ?ts'b2 \\<and>\n                    map typeof vs = map typeof vs'\n  \\<exists>t1s t2s \\<C>'' arb_label. \\<S>\\<bullet>\\<C>\n     \\<lparr>label :=\n               arb_label @ label \\<C>\\<rparr> \\<turnstile> es : t1s _> t2s\n\ngoal (1 subgoal):\n 1. (\\<And>arb_labs' ts ts'.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  arb_labs' @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  arb_labs' @\n                  label \\<C>\\<rparr> \\<turnstile> es' : ts _> ts') &&&\n    map typeof vs = map typeof vs'", "by auto"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs' @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs' @ label \\<C>\\<rparr> \\<turnstile> es' : ?ts _> ?ts'\n  map typeof vs = map typeof vs'\n\ngoal (2 subgoals):\n 1. \\<And>s vs es i s' vs' es' k lholed les les' tvs \\<C> ts ts' arb_labs\n       arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        Lfilled k lholed es les; Lfilled k lholed es' les';\n        store_typing s \\<S>; tvs = map typeof vs; i < length (inst s);\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> les : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n                         map typeof vs = map typeof vs'\n 2. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs' @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs' @ label \\<C>\\<rparr> \\<turnstile> es' : ?ts _> ?ts'\n  map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "using lholed_same_type[OF label(2,3,9)]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs' @\n            label\n             \\<C>\\<rparr> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            ?arb_labs' @ label \\<C>\\<rparr> \\<turnstile> es' : ?ts _> ?ts'\n  map typeof vs = map typeof vs'\n  (\\<And>arb_labs ts ts'.\n      \\<S>\\<bullet>\\<C>\n      \\<lparr>label :=\n                arb_labs @\n                label\n                 \\<C>\\<rparr> \\<turnstile> es : ts _> ts' \\<Longrightarrow>\n      \\<S>\\<bullet>\\<C>\n      \\<lparr>label :=\n                arb_labs @\n                label\n                 \\<C>\\<rparr> \\<turnstile> es' : ts _> ts') \\<Longrightarrow>\n  \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n    map typeof vs = map typeof vs'", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> les' : ts _> ts' \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "case (local s vls es i s' vs' es' vs n j)"], ["proof (state)\nthis:\n  \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  \\<lbrakk>store_typing s \\<S>; ?tvs = map typeof vls; i < length (inst s);\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ ?tvs, label := ?arb_labs,\n      return := ?arb_return\\<rparr>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> es' : ?ts _> ?ts' \\<and>\n                    map typeof vls = map typeof vs'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  j < length (inst s)\n  \\<C> = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vls es] : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "obtain \\<C>' tls where es_def:\"i < length (s_inst \\<S>)\"\n                          \"length tls = n\"\n                          \"\\<C>' = (s_inst \\<S> ! i) \\<lparr>local := local(s_inst \\<S> ! i) @ map typeof vls, label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\"\n                          \"\\<S>\\<bullet>\\<C>' \\<turnstile> es : ([] _> tls)\"\n                          \"ts' = ts @ tls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tls \\<C>'.\n        \\<lbrakk>i < length (s_inst \\<S>); length tls = n;\n         \\<C>' = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n            label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls;\n         ts' = ts @ tls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_local[OF local(7)]"], ["proof (prove)\nusing this:\n  \\<exists>tls.\n     i < length (s_inst \\<S>) \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>(s_inst \\<S> ! i)\n     \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n        return := Some tls\\<rparr> \\<turnstile> es : [] _> tls \\<and>\n     ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. (\\<And>tls \\<C>'.\n        \\<lbrakk>i < length (s_inst \\<S>); length tls = n;\n         \\<C>' = (s_inst \\<S> ! i)\n         \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n            label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls;\n         ts' = ts @ tls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n  length tls = n\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "moreover"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n  length tls = n\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "obtain ts'' where \"ts' = ts@ts''\" \"(\\<S>\\<bullet>(Some ts'') \\<tturnstile>_i vls;es : ts'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>ts' = ts @ ts'';\n         \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_local_shallow local(7)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Local ?n ?i ?vs\n                                     ?es] : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>tls.\n     length tls = ?n \\<and>\n     ?ts' = ?ts @ tls \\<and>\n     ?\\<S>\\<bullet>Some tls \\<tturnstile>_ ?i ?vs;?es : tls\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vls es] : ts _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>ts' = ts @ ts'';\n         \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts @ ts''\n  \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "moreover"], ["proof (state)\nthis:\n  ts' = ts @ ts''\n  \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "have \"inst_typing \\<S> ((inst s)!i) ((s_inst \\<S>)!i)\" \"i < length (inst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i) &&& i < length (inst s)", "using local es_def(1)"], ["proof (prove)\nusing this:\n  \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  \\<lbrakk>store_typing s \\<S>; ?tvs = map typeof vls; i < length (inst s);\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ ?tvs, label := ?arb_labs,\n      return := ?arb_return\\<rparr>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> es' : ?ts _> ?ts' \\<and>\n                    map typeof vls = map typeof vs'\n  store_typing s \\<S>\n  tvs = map typeof vs\n  j < length (inst s)\n  \\<C> = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vls es] : ts _> ts'\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i) &&& i < length (inst s)", "unfolding store_typing.simps list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  \\<lbrakk>\\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n              s =\n              \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n                 globs = gs\\<rparr> \\<and>\n              \\<S> = \\<S>' \\<and>\n              \\<S>' =\n              \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n                 s_globs = tgs\\<rparr> \\<and>\n              (length insts = length \\<C>s \\<and>\n               (\\<forall>i<length insts.\n                   inst_typing \\<S>' (insts ! i) (\\<C>s ! i))) \\<and>\n              (length fs = length tfs \\<and>\n               (\\<forall>i<length fs.\n                   cl_typing \\<S>' (fs ! i) (tfs ! i))) \\<and>\n              list_all (tab_agree \\<S>') (concat tclss) \\<and>\n              (length tclss = length ns \\<and>\n               (\\<forall>i<length tclss.\n                   ns ! i \\<le> length (tclss ! i))) \\<and>\n              (length bss = length ms \\<and>\n               (\\<forall>i<length bss. mem_agree (bss ! i) (ms ! i))) \\<and>\n              length gs = length tgs \\<and>\n              (\\<forall>i<length gs. glob_agree (gs ! i) (tgs ! i));\n   ?tvs = map typeof vls; i < length (inst s);\n   ?\\<C> = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ ?tvs, label := ?arb_labs,\n      return := ?arb_return\\<rparr>;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>?\\<C> \\<turnstile> es' : ?ts _> ?ts' \\<and>\n                    map typeof vls = map typeof vs'\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     (length insts = length \\<C>s \\<and>\n      (\\<forall>i<length insts.\n          inst_typing \\<S>' (insts ! i) (\\<C>s ! i))) \\<and>\n     (length fs = length tfs \\<and>\n      (\\<forall>i<length fs. cl_typing \\<S>' (fs ! i) (tfs ! i))) \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     (length tclss = length ns \\<and>\n      (\\<forall>i<length tclss. ns ! i \\<le> length (tclss ! i))) \\<and>\n     (length bss = length ms \\<and>\n      (\\<forall>i<length bss. mem_agree (bss ! i) (ms ! i))) \\<and>\n     length gs = length tgs \\<and>\n     (\\<forall>i<length gs. glob_agree (gs ! i) (tgs ! i))\n  tvs = map typeof vs\n  j < length (inst s)\n  \\<C> = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n     return := arb_return\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vls es] : ts _> ts'\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i) &&& i < length (inst s)", "by fastforce+"], ["proof (state)\nthis:\n  inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)\n  i < length (inst s)\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "ultimately"], ["proof (chain)\npicking this:\n  i < length (s_inst \\<S>)\n  length tls = n\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  ts' = ts @ ts''\n  \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\n  inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)\n  i < length (inst s)", "have \"\\<S>\\<bullet>\\<C>' \\<turnstile> es' : ([] _> tls)\" \"map typeof vls = map typeof vs'\""], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  length tls = n\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  ts' = ts @ ts''\n  \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\n  inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)\n  i < length (inst s)\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> es' : [] _> tls &&&\n    map typeof vls = map typeof vs'", "using local(2)[OF local(3) _ _ _ es_def(4), of \"map typeof vls\" \"Some tls\" \"label (s_inst \\<S> ! i)\"]"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  length tls = n\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> tls\n  ts' = ts @ tls\n  ts' = ts @ ts''\n  \\<S>\\<bullet>Some ts'' \\<tturnstile>_ i vls;es : ts''\n  inst_typing \\<S> (inst s ! i) (s_inst \\<S> ! i)\n  i < length (inst s)\n  \\<lbrakk>map typeof vls = map typeof vls; i < length (inst s);\n   \\<C>' = (s_inst \\<S> ! i)\n   \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n      label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\\<rbrakk>\n  \\<Longrightarrow> \\<S>\\<bullet>\\<C>' \\<turnstile> es' : [] _> tls \\<and>\n                    map typeof vls = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> es' : [] _> tls &&&\n    map typeof vls = map typeof vs'", "by fastforce+"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es' : [] _> tls\n  map typeof vls = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "hence \"\\<S>\\<bullet>(Some tls) \\<tturnstile>_ i vs';es' : tls\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es' : [] _> tls\n  map typeof vls = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>Some tls \\<tturnstile>_ i vs';es' : tls", "using e_typing_s_typing.intros(8) es_def(1,3)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es' : [] _> tls\n  map typeof vls = map typeof vs'\n  \\<lbrakk>?i < length (s_inst ?\\<S>); ?tvs = map typeof ?vs;\n   ?\\<C> = (s_inst ?\\<S> ! ?i)\n   \\<lparr>local := local (s_inst ?\\<S> ! ?i) @ ?tvs, return := ?rs\\<rparr>;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : [] _> ?ts;\n   ?rs = Some ?ts \\<or> ?rs = None\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts\n  i < length (s_inst \\<S>)\n  \\<C>' = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vls,\n     label := label (s_inst \\<S> ! i), return := Some tls\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>Some tls \\<tturnstile>_ i vs';es' : tls", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>Some tls \\<tturnstile>_ i vs';es' : tls\n\ngoal (1 subgoal):\n 1. \\<And>s vs es i s' vs' es' v0s n j tvs \\<C> ts ts' arb_labs arb_return.\n       \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n        \\<And>tvs \\<C> ts ts' arb_labs arb_return.\n           \\<lbrakk>store_typing s \\<S>; tvs = map typeof vs;\n            i < length (inst s);\n            \\<C> = (s_inst \\<S> ! i)\n            \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n               label := arb_labs, return := arb_return\\<rparr>;\n            \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts _> ts' \\<and>\n                             map typeof vs = map typeof vs';\n        store_typing s \\<S>; tvs = map typeof v0s; j < length (inst s);\n        \\<C> = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ tvs, label := arb_labs,\n           return := arb_return\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs\n   es] : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs'\n                    es'] : ts _> ts' \\<and>\n                         map typeof v0s = map typeof v0s", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>Some tls \\<tturnstile>_ i vs';es' : tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs' es'] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "using e_typing_s_typing.intros(3,5) es_def(2,5)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>Some tls \\<tturnstile>_ i vs';es' : tls\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  \\<lbrakk>?\\<S>\\<bullet>Some ?ts \\<tturnstile>_ ?i ?vs;?es : ?ts;\n   length ?ts = ?n\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> [Local ?n ?i ?vs\n                 ?es] : [] _> ?ts\n  length tls = n\n  ts' = ts @ tls\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs' es'] : ts _> ts' \\<and>\n    map typeof vs = map typeof vs", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Local n i vs' es'] : ts _> ts' \\<and>\n  map typeof vs = map typeof vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma types_preserved_e:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\"\n          \"store_typing s \\<S>\"\n          \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"\\<S>\\<bullet>None \\<tturnstile>_i vs';es' : ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  store_typing s \\<S>\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n     store_typing s \\<S>;\n     \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "have \"i < (length (s_inst \\<S>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "using assms(3) s_typing.cases"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n  \\<lbrakk>?a1.0\\<bullet>?a2.0 \\<tturnstile>_ ?a3.0 ?a4.0;?a5.0 : ?a6.0;\n   \\<And>i \\<S> tvs vs \\<C> rs es ts.\n      \\<lbrakk>?a1.0 = \\<S>; ?a2.0 = rs; ?a3.0 = i; ?a4.0 = vs; ?a5.0 = es;\n       ?a6.0 = ts; i < length (s_inst \\<S>); tvs = map typeof vs;\n       \\<C> = (s_inst \\<S> ! i)\n       \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, return := rs\\<rparr>;\n       \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n       rs = Some ts \\<or> rs = None\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i < length (s_inst \\<S>)", "by blast"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n     store_typing s \\<S>;\n     \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "moreover"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n     store_typing s \\<S>;\n     \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "hence i_bound:\"i < length (inst s)\""], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. i < length (inst s)", "using assms(2)"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. i < length (inst s)", "unfolding list_all2_conv_all_nth store_typing.simps"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<exists>\\<S>' \\<C>s tfs ns ms tgs insts fs tclss bss gs.\n     s =\n     \\<lparr>inst = insts, funcs = fs, tab = tclss, mem = bss,\n        globs = gs\\<rparr> \\<and>\n     \\<S> = \\<S>' \\<and>\n     \\<S>' =\n     \\<lparr>s_inst = \\<C>s, s_funcs = tfs, s_tab = ns, s_mem = ms,\n        s_globs = tgs\\<rparr> \\<and>\n     (length insts = length \\<C>s \\<and>\n      (\\<forall>i<length insts.\n          inst_typing \\<S>' (insts ! i) (\\<C>s ! i))) \\<and>\n     (length fs = length tfs \\<and>\n      (\\<forall>i<length fs. cl_typing \\<S>' (fs ! i) (tfs ! i))) \\<and>\n     list_all (tab_agree \\<S>') (concat tclss) \\<and>\n     (length tclss = length ns \\<and>\n      (\\<forall>i<length tclss. ns ! i \\<le> length (tclss ! i))) \\<and>\n     (length bss = length ms \\<and>\n      (\\<forall>i<length bss. mem_agree (bss ! i) (ms ! i))) \\<and>\n     length gs = length tgs \\<and>\n     (\\<forall>i<length gs. glob_agree (gs ! i) (tgs ! i))\n\ngoal (1 subgoal):\n 1. i < length (inst s)", "by fastforce"], ["proof (state)\nthis:\n  i < length (inst s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n     store_typing s \\<S>;\n     \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "obtain tvs \\<C> where defs: \"tvs = map typeof vs\"\n                           \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i) @ tvs), label := (label ((s_inst \\<S>)!i)), return := None\\<rparr>\"\n                           \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tvs \\<C>.\n        \\<lbrakk>tvs = map typeof vs;\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n              label := label (s_inst \\<S> ! i)\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n\ngoal (1 subgoal):\n 1. (\\<And>tvs \\<C>.\n        \\<lbrakk>tvs = map typeof vs;\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n              label := label (s_inst \\<S> ! i)\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding s_typing.simps"], ["proof (prove)\nusing this:\n  \\<exists>ia \\<S>' tvs vsa \\<C> rs esa tsa.\n     \\<S> = \\<S>' \\<and>\n     None = rs \\<and>\n     i = ia \\<and>\n     vs = vsa \\<and>\n     es = esa \\<and>\n     ts = tsa \\<and>\n     ia < length (s_inst \\<S>') \\<and>\n     tvs = map typeof vsa \\<and>\n     \\<C> = (s_inst \\<S>' ! ia)\n     \\<lparr>local := local (s_inst \\<S>' ! ia) @ tvs,\n        return := rs\\<rparr> \\<and>\n     \\<S>'\\<bullet>\\<C> \\<turnstile> esa : [] _> tsa \\<and>\n     (rs = Some tsa \\<or> rs = None)\n\ngoal (1 subgoal):\n 1. (\\<And>tvs \\<C>.\n        \\<lbrakk>tvs = map typeof vs;\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n              label := label (s_inst \\<S> ! i)\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  tvs = map typeof vs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n       label := label (s_inst \\<S> ! i)\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n     store_typing s \\<S>;\n     \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "have \"(\\<S>\\<bullet>\\<C> \\<turnstile> es' : ([] _> ts)) \\<and> (map typeof vs = map typeof vs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n    map typeof vs = map typeof vs'", "using types_preserved_e1[OF assms(1,2) defs(1) i_bound defs(2,3)]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n    map typeof vs = map typeof vs'", "by simp"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>;\n     store_typing s \\<S>;\n     \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "ultimately"], ["proof (chain)\npicking this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n  map typeof vs = map typeof vs'", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n  map typeof vs = map typeof vs'\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "using defs"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n  map typeof vs = map typeof vs'\n  tvs = map typeof vs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n       label := label (s_inst \\<S> ! i)\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts", "unfolding s_typing.simps"], ["proof (prove)\nusing this:\n  i < length (s_inst \\<S>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : [] _> ts \\<and>\n  map typeof vs = map typeof vs'\n  tvs = map typeof vs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n       label := label (s_inst \\<S> ! i)\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<exists>ia \\<S>' tvs vs \\<C> rs es tsa.\n       \\<S> = \\<S>' \\<and>\n       None = rs \\<and>\n       i = ia \\<and>\n       vs' = vs \\<and>\n       es' = es \\<and>\n       ts = tsa \\<and>\n       ia < length (s_inst \\<S>') \\<and>\n       tvs = map typeof vs \\<and>\n       \\<C> = (s_inst \\<S>' ! ia)\n       \\<lparr>local := local (s_inst \\<S>' ! ia) @ tvs,\n          return := rs\\<rparr> \\<and>\n       \\<S>'\\<bullet>\\<C> \\<turnstile> es : [] _> tsa \\<and>\n       (rs = Some tsa \\<or> rs = None)", "by auto"], ["proof (state)\nthis:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs';es' : ts\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Progress\\<close>"], ["", "lemma const_list_no_progress:\n  assumes \"const_list es\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "assume \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence \"False\""], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  const_list es\n\ngoal (1 subgoal):\n 1. False", "proof (induction rule: reduce.induct)"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        const_list e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s vs j i. const_list [$Call j] \\<Longrightarrow> False\n 3. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; const_list [$Get_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; const_list [$C v', $Set_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>s vs j i. const_list [$Get_global j] \\<Longrightarrow> False\nA total of 24 subgoals...", "case (basic e e' s vs i)"], ["proof (state)\nthis:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  const_list e\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        const_list e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s vs j i. const_list [$Call j] \\<Longrightarrow> False\n 3. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; const_list [$Get_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; const_list [$C v', $Set_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>s vs j i. const_list [$Get_global j] \\<Longrightarrow> False\nA total of 24 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  const_list e\n\ngoal (1 subgoal):\n 1. False", "proof (induction rule: reduce_simple.induct)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>c iop.\n       const_list [$C ConstInt32 c, $Unop_i T_i32 iop] \\<Longrightarrow>\n       False\n 2. \\<And>c iop.\n       const_list [$C ConstInt64 c, $Unop_i T_i64 iop] \\<Longrightarrow>\n       False\n 3. \\<And>c fop.\n       const_list [$C ConstFloat32 c, $Unop_f T_f32 fop] \\<Longrightarrow>\n       False\n 4. \\<And>c fop.\n       const_list [$C ConstFloat64 c, $Unop_f T_f64 fop] \\<Longrightarrow>\n       False\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        const_list\n         [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        const_list\n         [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        const_list\n         [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        const_list\n         [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>app_binop_f fop c1 c2 = Some c;\n        const_list\n         [$C ConstFloat32 c1, $C ConstFloat32 c2,\n          $Binop_f T_f32 fop]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>app_binop_f fop c1 c2 = None;\n         const_list\n          [$C ConstFloat32 c1, $C ConstFloat32 c2,\n           $Binop_f T_f32 fop]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 42 subgoals...", "case (trap es lholed)"], ["proof (state)\nthis:\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es\n  const_list es\n\ngoal (42 subgoals):\n 1. \\<And>c iop.\n       const_list [$C ConstInt32 c, $Unop_i T_i32 iop] \\<Longrightarrow>\n       False\n 2. \\<And>c iop.\n       const_list [$C ConstInt64 c, $Unop_i T_i64 iop] \\<Longrightarrow>\n       False\n 3. \\<And>c fop.\n       const_list [$C ConstFloat32 c, $Unop_f T_f32 fop] \\<Longrightarrow>\n       False\n 4. \\<And>c fop.\n       const_list [$C ConstFloat64 c, $Unop_f T_f64 fop] \\<Longrightarrow>\n       False\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        const_list\n         [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        const_list\n         [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        const_list\n         [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        const_list\n         [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>app_binop_f fop c1 c2 = Some c;\n        const_list\n         [$C ConstFloat32 c1, $C ConstFloat32 c2,\n          $Binop_f T_f32 fop]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>app_binop_f fop c1 c2 = None;\n         const_list\n          [$C ConstFloat32 c1, $C ConstFloat32 c2,\n           $Binop_f T_f32 fop]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 42 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using trap(2)"], ["proof (prove)\nusing this:\n  Lfilled 0 lholed [Trap] es\n\ngoal (1 subgoal):\n 1. False", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>es = vs @ [Trap] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1; es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [Trap] lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "case (L0 vs es')"], ["proof (state)\nthis:\n  es = vs @ [Trap] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>es = vs @ [Trap] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1; es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [Trap] lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = vs @ [Trap] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. False", "using trap(3) list_all_append const_list_cons_last(2)[of vs Trap]"], ["proof (prove)\nusing this:\n  es = vs @ [Trap] @ es'\n  const_list vs\n  lholed = LBase vs es'\n  const_list es\n  list_all ?P (?xs @ ?ys) = (list_all ?P ?xs \\<and> list_all ?P ?ys)\n  const_list (vs @ [Trap]) \\<Longrightarrow> is_const Trap\n\ngoal (1 subgoal):\n 1. False", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  es = vs @ [Trap] @ es'\n  list_all is_const vs\n  lholed = LBase vs es'\n  list_all is_const es\n  list_all ?P (?xs @ ?ys) = (list_all ?P ?xs \\<and> list_all ?P ?ys)\n  list_all is_const (vs @ [Trap]) \\<Longrightarrow> is_const Trap\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_const_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1; es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [Trap] lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1; es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [Trap] lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "case (LN vs n es' l es'' k lfilledk)"], ["proof (state)\nthis:\n  0 = k + 1\n  es = vs @ [Label n es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l [Trap] lfilledk\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1; es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [Trap] lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 = k + 1\n  es = vs @ [Label n es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l [Trap] lfilledk\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_const_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (41 subgoals):\n 1. \\<And>c iop.\n       const_list [$C ConstInt32 c, $Unop_i T_i32 iop] \\<Longrightarrow>\n       False\n 2. \\<And>c iop.\n       const_list [$C ConstInt64 c, $Unop_i T_i64 iop] \\<Longrightarrow>\n       False\n 3. \\<And>c fop.\n       const_list [$C ConstFloat32 c, $Unop_f T_f32 fop] \\<Longrightarrow>\n       False\n 4. \\<And>c fop.\n       const_list [$C ConstFloat64 c, $Unop_f T_f64 fop] \\<Longrightarrow>\n       False\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        const_list\n         [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        const_list\n         [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        const_list\n         [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        const_list\n         [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>app_binop_f fop c1 c2 = Some c;\n        const_list\n         [$C ConstFloat32 c1, $C ConstFloat32 c2,\n          $Binop_f T_f32 fop]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>app_binop_f fop c1 c2 = None;\n         const_list\n          [$C ConstFloat32 c1, $C ConstFloat32 c2,\n           $Binop_f T_f32 fop]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 41 subgoals...", "qed (fastforce simp add: const_list_cons_last(2) is_const_def const_list_def)+"], ["proof (state)\nthis:\n  False\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i. const_list [$Call j] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; const_list [$Get_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; const_list [$C v', $Set_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. const_list [$Get_global j] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         const_list [$C v, $Set_global j]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>s vs j i. const_list [$Call j] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; const_list [$Get_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; const_list [$C v', $Set_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. const_list [$Get_global j] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         const_list [$C v, $Set_global j]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "case (label s vs es i s' vs' es' k lholed les les')"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  const_list es \\<Longrightarrow> False\n  const_list les\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i. const_list [$Call j] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; const_list [$Get_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; const_list [$C v', $Set_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. const_list [$Get_global j] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         const_list [$C v, $Set_global j]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using label(2)"], ["proof (prove)\nusing this:\n  Lfilled k lholed es les\n\ngoal (1 subgoal):\n 1. False", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; les = vs @ es @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "case (L0 vs es')"], ["proof (state)\nthis:\n  k = 0\n  les = vs @ es @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; les = vs @ es @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n  les = vs @ es @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. False", "using label(4,5) list_all_append"], ["proof (prove)\nusing this:\n  k = 0\n  les = vs @ es @ es'\n  const_list vs\n  lholed = LBase vs es'\n  const_list es \\<Longrightarrow> False\n  const_list les\n  list_all ?P (?xs @ ?ys) = (list_all ?P ?xs \\<and> list_all ?P ?ys)\n\ngoal (1 subgoal):\n 1. False", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  k = 0\n  les = vs @ es @ es'\n  list_all is_const vs\n  lholed = LBase vs es'\n  list_all is_const es \\<Longrightarrow> False\n  list_all is_const les\n  list_all ?P (?xs @ ?ys) = (list_all ?P ?xs \\<and> list_all ?P ?ys)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "case (LN vs n es' l es'' k lfilledk)"], ["proof (state)\nthis:\n  k__ = k + 1\n  les = vs @ [Label n es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k__ = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  k__ = k + 1\n  les = vs @ [Label n es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n\ngoal (1 subgoal):\n 1. False", "using label(4,5)"], ["proof (prove)\nusing this:\n  k__ = k + 1\n  les = vs @ [Label n es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  const_list es \\<Longrightarrow> False\n  const_list les\n\ngoal (1 subgoal):\n 1. False", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  k__ = k + 1\n  les = vs @ [Label n es' lfilledk] @ es''\n  list_all is_const vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  list_all is_const es \\<Longrightarrow> False\n  list_all is_const les\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_const_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (22 subgoals):\n 1. \\<And>s vs j i. const_list [$Call j] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        const_list [$C ConstInt32 c, $Call_indirect j]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        const_list (ves @ [Callcl cl])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; const_list [$Get_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; const_list [$C v', $Set_local j]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. const_list [$Get_global j] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         const_list [$C v, $Set_global j]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 22 subgoals...", "qed (fastforce simp add: const_list_cons_last(2) is_const_def const_list_def)+"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "}"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_no_progress:\n  assumes \"es = []\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "assume \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence False"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  es = []\n\ngoal (1 subgoal):\n 1. False", "proof (induction rule: reduce.induct)"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        e = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s vs j i. [$Call j] = [] \\<Longrightarrow> False\n 3. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>s vs j i. [$Get_global j] = [] \\<Longrightarrow> False\nA total of 24 subgoals...", "case (basic e e' s vs i)"], ["proof (state)\nthis:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  e = []\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        e = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s vs j i. [$Call j] = [] \\<Longrightarrow> False\n 3. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>s vs j i. [$Get_global j] = [] \\<Longrightarrow> False\nA total of 24 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  e = []\n\ngoal (1 subgoal):\n 1. False", "proof (induction rule: reduce_simple.induct)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>c iop.\n       [$C ConstInt32 c, $Unop_i T_i32 iop] = [] \\<Longrightarrow> False\n 2. \\<And>c iop.\n       [$C ConstInt64 c, $Unop_i T_i64 iop] = [] \\<Longrightarrow> False\n 3. \\<And>c fop.\n       [$C ConstFloat32 c, $Unop_f T_f32 fop] = [] \\<Longrightarrow> False\n 4. \\<And>c fop.\n       [$C ConstFloat64 c, $Unop_f T_f64 fop] = [] \\<Longrightarrow> False\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>app_binop_f fop c1 c2 = Some c;\n        [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>app_binop_f fop c1 c2 = None;\n         [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop] =\n         []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 42 subgoals...", "case (trap es lholed)"], ["proof (state)\nthis:\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es\n  es = []\n\ngoal (42 subgoals):\n 1. \\<And>c iop.\n       [$C ConstInt32 c, $Unop_i T_i32 iop] = [] \\<Longrightarrow> False\n 2. \\<And>c iop.\n       [$C ConstInt64 c, $Unop_i T_i64 iop] = [] \\<Longrightarrow> False\n 3. \\<And>c fop.\n       [$C ConstFloat32 c, $Unop_f T_f32 fop] = [] \\<Longrightarrow> False\n 4. \\<And>c fop.\n       [$C ConstFloat64 c, $Unop_f T_f64 fop] = [] \\<Longrightarrow> False\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>app_binop_f fop c1 c2 = Some c;\n        [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>app_binop_f fop c1 c2 = None;\n         [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop] =\n         []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 42 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es\n  es = []\n\ngoal (1 subgoal):\n 1. False", "using Lfilled.simps[of 0 lholed \"[Trap]\" es]"], ["proof (prove)\nusing this:\n  es \\<noteq> [Trap]\n  Lfilled 0 lholed [Trap] es\n  es = []\n  Lfilled 0 lholed [Trap] es =\n  ((\\<exists>vs lholeda es' es.\n       0 = 0 \\<and>\n       lholed = lholeda \\<and>\n       [Trap] = es \\<and>\n       es = vs @ es @ es' \\<and>\n       const_list vs \\<and> lholeda = LBase vs es') \\<or>\n   (\\<exists>vs lholeda n es' l es'' k es lfilledk.\n       0 = k + 1 \\<and>\n       lholed = lholeda \\<and>\n       [Trap] = es \\<and>\n       es = vs @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vs \\<and>\n       lholeda = LRec vs n es' l es'' \\<and> Lfilled k l es lfilledk))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (41 subgoals):\n 1. \\<And>c iop.\n       [$C ConstInt32 c, $Unop_i T_i32 iop] = [] \\<Longrightarrow> False\n 2. \\<And>c iop.\n       [$C ConstInt64 c, $Unop_i T_i64 iop] = [] \\<Longrightarrow> False\n 3. \\<And>c fop.\n       [$C ConstFloat32 c, $Unop_f T_f32 fop] = [] \\<Longrightarrow> False\n 4. \\<And>c fop.\n       [$C ConstFloat64 c, $Unop_f T_f64 fop] = [] \\<Longrightarrow> False\n 5. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        [$C ConstInt32 c1, $C ConstInt32 c2, $Binop_i T_i32 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>iop c1 c2 c.\n       \\<lbrakk>app_binop_i iop c1 c2 = Some c;\n        [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>iop c1 c2.\n       \\<lbrakk>app_binop_i iop c1 c2 = None;\n        [$C ConstInt64 c1, $C ConstInt64 c2, $Binop_i T_i64 iop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>fop c1 c2 c.\n       \\<lbrakk>app_binop_f fop c1 c2 = Some c;\n        [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop] =\n        []\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>fop c1 c2.\n        \\<lbrakk>app_binop_f fop c1 c2 = None;\n         [$C ConstFloat32 c1, $C ConstFloat32 c2, $Binop_f T_f32 fop] =\n         []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 41 subgoals...", "qed auto"], ["proof (state)\nthis:\n  False\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "case (label s vs es i s' vs' es' k lholed les les')"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  es = [] \\<Longrightarrow> False\n  les = []\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  es = [] \\<Longrightarrow> False\n  les = []\n\ngoal (1 subgoal):\n 1. False", "using Lfilled.simps[of k lholed es \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  es = [] \\<Longrightarrow> False\n  les = []\n  Lfilled k lholed es [] =\n  ((\\<exists>vs lholeda es' es.\n       k = 0 \\<and>\n       lholed = lholeda \\<and>\n       es = es \\<and>\n       [] = vs @ es @ es' \\<and>\n       const_list vs \\<and> lholeda = LBase vs es') \\<or>\n   (\\<exists>vs lholeda n es' l es'' ka es lfilledk.\n       k = ka + 1 \\<and>\n       lholed = lholeda \\<and>\n       es = es \\<and>\n       [] = vs @ [Label n es' lfilledk] @ es'' \\<and>\n       const_list vs \\<and>\n       lholeda = LRec vs n es' l es'' \\<and> Lfilled ka l es lfilledk))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (22 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf; [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = []\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = []\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 22 subgoals...", "qed auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "}"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trap_no_progress:\n  assumes \"es = [Trap]\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "assume \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence False"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  es = [Trap]\n\ngoal (1 subgoal):\n 1. False", "proof (induction rule: reduce.induct)"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        e = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s vs j i. [$Call j] = [Trap] \\<Longrightarrow> False\n 3. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>s vs j i. [$Get_global j] = [Trap] \\<Longrightarrow> False\nA total of 24 subgoals...", "case (basic e e' s vs i)"], ["proof (state)\nthis:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  e = [Trap]\n\ngoal (24 subgoals):\n 1. \\<And>e e' s vs i.\n       \\<lbrakk>\\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>;\n        e = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s vs j i. [$Call j] = [Trap] \\<Longrightarrow> False\n 3. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>s vs j i. [$Get_global j] = [Trap] \\<Longrightarrow> False\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lparr>e\\<rparr> \\<leadsto> \\<lparr>e'\\<rparr>\n  e = [Trap]\n\ngoal (1 subgoal):\n 1. False", "by (induction rule: reduce_simple.induct) auto"], ["proof (state)\nthis:\n  False\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [Trap] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [Trap] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = [Trap]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [Trap] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [Trap] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = [Trap]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "case (label s vs es i s' vs' es' k lholed les les')"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  Lfilled k lholed es les\n  Lfilled k lholed es' les'\n  es = [Trap] \\<Longrightarrow> False\n  les = [Trap]\n\ngoal (23 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [Trap] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [Trap] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = [Trap]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 23 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using label(2)"], ["proof (prove)\nusing this:\n  Lfilled k lholed es les\n\ngoal (1 subgoal):\n 1. False", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; les = vs @ es @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "case (L0 vs es')"], ["proof (state)\nthis:\n  k = 0\n  les = vs @ es @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; les = vs @ es @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using L0(2) label(1,4,5) empty_no_progress"], ["proof (prove)\nusing this:\n  les = vs @ es @ es'\n  \\<lparr>s;vsa__;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'a__\\<rparr>\n  es = [Trap] \\<Longrightarrow> False\n  les = [Trap]\n  ?es = [] \\<Longrightarrow>\n  \\<not> \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "case (LN vs n es' l es'' k' lfilledk)"], ["proof (state)\nthis:\n  k = k' + 1\n  les = vs @ [Label n es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k' l es lfilledk\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; les = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using LN(2) label(5)"], ["proof (prove)\nusing this:\n  les = vs @ [Label n es' lfilledk] @ es''\n  les = [Trap]\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Cons_eq_append_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (22 subgoals):\n 1. \\<And>s vs j i. [$Call j] = [Trap] \\<Longrightarrow> False\n 2. \\<And>s i c cl j tf vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl; stypes s i j = tf;\n        cl_type cl = tf;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>s i c cl j vs.\n       \\<lbrakk>stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j \\<noteq> cl_type cl \\<or>\n                stab s i (nat_of_int c) = None;\n        [$C ConstInt32 c, $Call_indirect j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>cl j t1s t2s ts es ves vcs n k m zs s vs i.\n       \\<lbrakk>cl = Func_native j (t1s _> t2s) ts es; ves = $$* vcs;\n        length vcs = n; length ts = k; length t1s = n; length t2s = m;\n        n_zeros ts = zs; ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>cl t1s t2s f ves vcs n m s hs s' vcs' vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        host_apply s (t1s _> t2s) f vcs hs = Some (s', vcs');\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>cl t1s t2s f ves vcs n m s vs i.\n       \\<lbrakk>cl = Func_host (t1s _> t2s) f; ves = $$* vcs;\n        length vcs = n; length t1s = n; length t2s = m;\n        ves @ [Callcl cl] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>vi j s v vs i.\n       \\<lbrakk>length vi = j; [$Get_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>vi j s v vs v' i.\n       \\<lbrakk>length vi = j; [$C v', $Set_local j] = [Trap]\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>s vs j i. [$Get_global j] = [Trap] \\<Longrightarrow> False\n 10. \\<And>s i j v s' vs.\n        \\<lbrakk>supdate_glob s i j v = s';\n         [$C v, $Set_global j] = [Trap]\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 22 subgoals...", "qed auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "}"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr> \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminal_no_progress:\n  assumes \"const_list es \\<or> es = [Trap]\"\n  shows \"\\<not>\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using const_list_no_progress trap_no_progress assms"], ["proof (prove)\nusing this:\n  const_list ?es \\<Longrightarrow>\n  \\<not> \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>\n  ?es = [Trap] \\<Longrightarrow>\n  \\<not> \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>\n  const_list es \\<or> es = [Trap]\n\ngoal (1 subgoal):\n 1. \\<not> \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["", "lemma progress_L0:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"\n          \"const_list cs\"\n  shows \"\\<lparr>s;vs;cs@es@es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs@es'@es_c\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es @\n                 es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @\n                     es' @ es_c\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es @\n                 es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @\n                     es' @ es_c\\<rparr>", "have \"\\<And>es. Lfilled 0 (LBase cs es_c) es (cs@es@es_c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>es. Lfilled 0 (LBase cs es_c) es (cs @ es @ es_c)", "using Lfilled.intros(1)[of cs \"(LBase cs es_c)\" es_c] assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list cs; LBase cs es_c = LBase cs es_c\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 (LBase cs es_c) ?es (cs @ ?es @ es_c)\n  const_list cs\n\ngoal (1 subgoal):\n 1. \\<And>es. Lfilled 0 (LBase cs es_c) es (cs @ es @ es_c)", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all is_const cs; LBase cs es_c = LBase cs es_c\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 (LBase cs es_c) ?es (cs @ ?es @ es_c)\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. \\<And>es. Lfilled 0 (LBase cs es_c) es (cs @ es @ es_c)", "by fastforce"], ["proof (state)\nthis:\n  Lfilled 0 (LBase cs es_c) ?es (cs @ ?es @ es_c)\n\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es @\n                 es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @\n                     es' @ es_c\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase cs es_c) ?es (cs @ ?es @ es_c)\n\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es @\n                 es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @\n                     es' @ es_c\\<rparr>", "using reduce.intros(23) assms(1)"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase cs es_c) ?es (cs @ ?es @ es_c)\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   Lfilled ?k ?lholed ?es ?les; Lfilled ?k ?lholed ?es' ?les'\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?les\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?les'\\<rparr>\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es @\n                 es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @\n                     es' @ es_c\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<lparr>s;vs;cs @\n               es @\n               es_c\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @\n                   es' @ es_c\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_L0_left:\n  assumes \"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\"\n          \"const_list cs\"\n  shows \"\\<lparr>s;vs;cs@es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs@es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @ es'\\<rparr>", "using assms progress_L0[where ?es_c = \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  const_list cs\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   []\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n  ?es' @ []\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>s;vs;cs @\n                 es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs @ es'\\<rparr>", "by fastforce"], ["", "lemma progress_L0_trap:\n  assumes \"const_list cs\"\n          \"cs \\<noteq> [] \\<or> es \\<noteq> []\"\n  shows \"\\<exists>a. \\<lparr>s;vs;cs@[Trap]@es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;cs @\n                    [Trap] @\n                    es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;cs @\n                    [Trap] @\n                    es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>", "have \"cs @ [Trap] @ es \\<noteq> [Trap]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs @ [Trap] @ es \\<noteq> [Trap]", "using assms(2)"], ["proof (prove)\nusing this:\n  cs \\<noteq> [] \\<or> es \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs @ [Trap] @ es \\<noteq> [Trap]", "by (cases \"cs = []\") (auto simp add: append_eq_Cons_conv)"], ["proof (state)\nthis:\n  cs @ [Trap] @ es \\<noteq> [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;cs @\n                    [Trap] @\n                    es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs @ [Trap] @ es \\<noteq> [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;cs @\n                    [Trap] @\n                    es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>", "using reduce.intros(1) assms(2) reduce_simple.trap\n          Lfilled.intros(1)[OF assms(1), of _ es \"[Trap]\"]"], ["proof (prove)\nusing this:\n  cs @ [Trap] @ es \\<noteq> [Trap]\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  cs \\<noteq> [] \\<or> es \\<noteq> []\n  \\<lbrakk>?es \\<noteq> [Trap]; Lfilled 0 ?lholed [Trap] ?es\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?es\\<rparr> \\<leadsto> \\<lparr>[Trap]\\<rparr>\n  ?lholed = LBase cs es \\<Longrightarrow>\n  Lfilled 0 ?lholed [Trap] (cs @ [Trap] @ es)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;cs @\n                    [Trap] @\n                    es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a.\n     \\<lparr>s;vs;cs @\n                  [Trap] @\n                  es\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_LN:\n  assumes \"(Lfilled j lholed [$Br (j+k)] es)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts)\"\n          \"(label \\<C>)!k = tvs\"\n  shows \"\\<exists>lholed' vs \\<C>'. (Lfilled j lholed' (vs@[$Br (j+k)]) es)\n                    \\<and> (\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tvs))\n                    \\<and> const_list vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lholed' vs \\<C>'.\n       Lfilled j lholed' (vs @ [$Br (j + k)]) es \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and> const_list vs", "using assms"], ["proof (prove)\nusing this:\n  Lfilled j lholed [$Br (j + k)] es\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n  label \\<C> ! k = tvs\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vs \\<C>'.\n       Lfilled j lholed' (vs @ [$Br (j + k)]) es \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and> const_list vs", "proof (induction \"[$Br (j+k)]\" es arbitrary: k \\<C> ts rule: Lfilled.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts;\n        label \\<C> ! k = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n                             (vs @ [$Br (0 + k)] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "case (L0 vs lholed es')"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LBase vs es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts\n  label \\<C> ! k = tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts;\n        label \\<C> ! k = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n                             (vs @ [$Br (0 + k)] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain ts' ts'' where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : ([] _> ts')\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : (ts' _> ts'')\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts'' _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts' _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF L0(3)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0 + k)] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\n\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts' _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts' _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts;\n        label \\<C> ! k = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n                             (vs @ [$Br (0 + k)] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain ts_c where \"ts' = ts_c @ tvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        ts' = ts_c @ tvs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_br[of \\<C> \"Br k\" ts' ts''] L0(3,4) ts_def(2) unlift_b_e"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<C> \\<turnstile> [Br k] : ts' _> ts''; Br k = Br ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (label \\<C>)\n  \\<lbrakk>\\<C> \\<turnstile> [Br k] : ts' _> ts''; Br k = Br ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''.\n                       ts' = ts_c @ ts'' \\<and> label \\<C> ! ?i = ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts\n  label \\<C> ! k = tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts' _> ts''\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        ts' = ts_c @ tvs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts_c @ tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts;\n        label \\<C> ! k = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n                             (vs @ [$Br (0 + k)] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "then"], ["proof (chain)\npicking this:\n  ts' = ts_c @ tvs", "obtain vs1 vs2 where vs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : ([] _> ts_c)\"\n                                   \"\\<S>\\<bullet>\\<C> \\<turnstile> vs2 : (ts_c _> (ts_c@tvs))\"\n                                   \"vs = vs1@vs2\"\n                                   \"const_list vs1\"\n                                   \"const_list vs2\""], ["proof (prove)\nusing this:\n  ts' = ts_c @ tvs\n\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c;\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs;\n         vs = vs1 @ vs2; const_list vs1; const_list vs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF L0(1)] ts_def(1)"], ["proof (prove)\nusing this:\n  ts' = ts_c @ tvs\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs : [] _> ?ts1.0 @\n        ?ts2.0 \\<Longrightarrow>\n  \\<exists>vs1 vs2.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs1 : [] _> ?ts1.0 \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs2 : ?ts1.0 _> ?ts1.0 @ ?ts2.0 \\<and>\n     vs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c;\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs;\n         vs = vs1 @ vs2; const_list vs1; const_list vs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs\n  vs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts;\n        label \\<C> ! k = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n                             (vs @ [$Br (0 + k)] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "hence \"\\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ([] _> tvs)\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs\n  vs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs", "using e_type_const_list"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs\n  vs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : [] _> ts;\n        label \\<C> ! k = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n                             (vs @ [$Br (0 + k)] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n        (vs @ [$Br (0 + k)] @ es') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "using Lfilled.intros(1)[OF vs_def(4), of _ es' \"vs2@[$Br k]\"] vs_def(3,5)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs\n  ?lholed = LBase vs1 es' \\<Longrightarrow>\n  Lfilled 0 ?lholed (vs2 @ [$Br k]) (vs1 @ (vs2 @ [$Br k]) @ es')\n  vs = vs1 @ vs2\n  const_list vs2\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n        (vs @ [$Br (0 + k)] @ es') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed' vsa \\<C>'.\n     Lfilled 0 lholed' (vsa @ [$Br (0 + k)])\n      (vs @ [$Br (0 + k)] @ es') \\<and>\n     \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "case (LN vs lholed n es' l es'' j lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled j l [$Br (j + 1 + k)] lfilledk\n  \\<lbrakk>j + 1 + k = j + ?k;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : [] _> ?ts;\n   label ?\\<C> ! ?k = tvs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                       Lfilled j lholed' (vs @ [$Br (j + ?k)])\n                        lfilledk \\<and>\n                       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                       const_list vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label n es' lfilledk] @ es'' : [] _> ts\n  label \\<C> ! k = tvs\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain t1s t2s where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : ([] _> t1s)\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : (t1s _> t2s)\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> es'' : (t2s _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF LN(5)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es'\nlfilledk] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts\n\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> t1s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain ts' ts_l where ts_l_def:\"\\<S>\\<bullet>\\<C>\\<lparr>label := [ts'] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : ([] _> ts_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' ts_l.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts'] @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[OF ts_def(2)]"], ["proof (prove)\nusing this:\n  \\<exists>tls t2sa.\n     t2s = t1s @ t2sa \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> t2sa \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label :=\n               [tls] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> t2sa\n\ngoal (1 subgoal):\n 1. (\\<And>ts' ts_l.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts'] @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            [ts'] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain lholed' vs' \\<C>' where lfilledk_def:\"Lfilled j lholed' (vs' @ [$Br (j + (1 + k))]) lfilledk\"\n                                          \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs' : ([] _> tvs)\"\n                                          \"const_list vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled j lholed' (vs' @ [$Br (j + (1 + k))]) lfilledk;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using LN(4)[OF _ ts_l_def, of \"1 + k\"] LN(5,6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>j + 1 + k = j + (1 + k);\n   label (\\<C>\\<lparr>label := [ts'] @ label \\<C>\\<rparr>) ! (1 + k) =\n   tvs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                       Lfilled j lholed' (vs @ [$Br (j + (1 + k))])\n                        lfilledk \\<and>\n                       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                       const_list vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label n es' lfilledk] @ es'' : [] _> ts\n  label \\<C> ! k = tvs\n\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled j lholed' (vs' @ [$Br (j + (1 + k))]) lfilledk;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Lfilled j lholed' (vs' @ [$Br (j + (1 + k))]) lfilledk\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs\n  const_list vs'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            label \\<C> ! kb = tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Br (k + kb)])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        label \\<C> ! ka = tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed'\n                             (vsa @ [$Br (k + 1 + ka)])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "thus ?case"], ["proof (prove)\nusing this:\n  Lfilled j lholed' (vs' @ [$Br (j + (1 + k))]) lfilledk\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs\n  const_list vs'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled (j + 1) lholed' (vsa @ [$Br (j + 1 + k)])\n        (vs @ [Label n es' lfilledk] @ es'') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "using Lfilled.intros(2)[OF LN(1) _ lfilledk_def(1)]"], ["proof (prove)\nusing this:\n  Lfilled j lholed' (vs' @ [$Br (j + (1 + k))]) lfilledk\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs\n  const_list vs'\n  ?lholed = LRec vs ?n ?es' lholed' ?es'' \\<Longrightarrow>\n  Lfilled (j + 1) ?lholed (vs' @ [$Br (j + (1 + k))])\n   (vs @ [Label ?n ?es' lfilledk] @ ?es'')\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled (j + 1) lholed' (vsa @ [$Br (j + 1 + k)])\n        (vs @ [Label n es' lfilledk] @ es'') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed' vsa \\<C>'.\n     Lfilled (j + 1) lholed' (vsa @ [$Br (j + 1 + k)])\n      (vs @ [Label n es' lfilledk] @ es'') \\<and>\n     \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_LN_return:\n  assumes \"(Lfilled j lholed [$Return] es)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts)\"\n          \"(return \\<C>) = Some tvs\"\n  shows \"\\<exists>lholed' vs \\<C>'. (Lfilled j lholed' (vs@[$Return]) es)\n                    \\<and> (\\<S>\\<bullet>\\<C>' \\<turnstile> vs : ([] _> tvs))\n                    \\<and> const_list vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lholed' vs \\<C>'.\n       Lfilled j lholed' (vs @ [$Return]) es \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and> const_list vs", "using assms"], ["proof (prove)\nusing this:\n  Lfilled j lholed [$Return] es\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n  return \\<C> = Some tvs\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vs \\<C>'.\n       Lfilled j lholed' (vs @ [$Return]) es \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and> const_list vs", "proof (induction \"[$Return]\" es arbitrary: k \\<C> ts rule: Lfilled.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Return])\n                             (vs @ [$Return] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "case (L0 vs lholed es')"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LBase vs es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts\n  return \\<C> = Some tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Return])\n                             (vs @ [$Return] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain ts' ts'' where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : ([] _> ts')\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : (ts' _> ts'')\"\n                                 \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts'' _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts' _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF L0(3)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\n\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts' _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts' _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Return])\n                             (vs @ [$Return] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain ts_c where \"ts' = ts_c @ tvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        ts' = ts_c @ tvs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using b_e_type_return[of \\<C> \"Return\" ts' ts''] L0(3,4) ts_def(2) unlift_b_e"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<C> \\<turnstile> [Return] : ts' _> ts'';\n   Return = Return\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''.\n                       ts' = ts_c @ ts'' \\<and> return \\<C> = Some ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts\n  return \\<C> = Some tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts' _> ts''\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c.\n        ts' = ts_c @ tvs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts' = ts_c @ tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Return])\n                             (vs @ [$Return] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "then"], ["proof (chain)\npicking this:\n  ts' = ts_c @ tvs", "obtain vs1 vs2 where vs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : ([] _> ts_c)\"\n                                   \"\\<S>\\<bullet>\\<C> \\<turnstile> vs2 : (ts_c _> (ts_c@tvs))\"\n                                   \"vs = vs1@vs2\"\n                                   \"const_list vs1\"\n                                   \"const_list vs2\""], ["proof (prove)\nusing this:\n  ts' = ts_c @ tvs\n\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c;\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs;\n         vs = vs1 @ vs2; const_list vs1; const_list vs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF L0(1)] ts_def(1)"], ["proof (prove)\nusing this:\n  ts' = ts_c @ tvs\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs : [] _> ?ts1.0 @\n        ?ts2.0 \\<Longrightarrow>\n  \\<exists>vs1 vs2.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs1 : [] _> ?ts1.0 \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs2 : ?ts1.0 _> ?ts1.0 @ ?ts2.0 \\<and>\n     vs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c;\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs;\n         vs = vs1 @ vs2; const_list vs1; const_list vs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs\n  vs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Return])\n                             (vs @ [$Return] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "hence \"\\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ([] _> tvs)\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs\n  vs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs", "using e_type_const_list"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ tvs\n  vs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs", "by blast"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled 0 lholed' (vsa @ [$Return])\n                             (vs @ [$Return] @ es') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled 0 lholed' (vsa @ [$Return]) (vs @ [$Return] @ es') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "using Lfilled.intros(1)[OF vs_def(4), of _ es' \"vs2@[$Return]\"] vs_def(3,5)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : [] _> tvs\n  ?lholed = LBase vs1 es' \\<Longrightarrow>\n  Lfilled 0 ?lholed (vs2 @ [$Return]) (vs1 @ (vs2 @ [$Return]) @ es')\n  vs = vs1 @ vs2\n  const_list vs2\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled 0 lholed' (vsa @ [$Return]) (vs @ [$Return] @ es') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed' vsa \\<C>'.\n     Lfilled 0 lholed' (vsa @ [$Return]) (vs @ [$Return] @ es') \\<and>\n     \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "case (LN vs lholed n es' l es'' j lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled j l [$Return] lfilledk\n  \\<lbrakk>\\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : [] _> ?ts;\n   return ?\\<C> = Some tvs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                       Lfilled j lholed' (vs @ [$Return]) lfilledk \\<and>\n                       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                       const_list vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label n es' lfilledk] @ es'' : [] _> ts\n  return \\<C> = Some tvs\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain t1s t2s where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : ([] _> t1s)\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : (t1s _> t2s)\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> es'' : (t2s _> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF LN(5)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es'\nlfilledk] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts\n\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> t1s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain ts' ts_l where ts_l_def:\"\\<S>\\<bullet>\\<C>\\<lparr>label := [ts'] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : ([] _> ts_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' ts_l.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts'] @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[OF ts_def(2)]"], ["proof (prove)\nusing this:\n  \\<exists>tls t2sa.\n     t2s = t1s @ t2sa \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> t2sa \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label :=\n               [tls] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> t2sa\n\ngoal (1 subgoal):\n 1. (\\<And>ts' ts_l.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts'] @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            [ts'] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "obtain lholed' vs' \\<C>' where lfilledk_def:\"Lfilled j lholed' (vs' @ [$Return]) lfilledk\"\n                                          \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs' : ([] _> tvs)\"\n                                          \"const_list vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled j lholed' (vs' @ [$Return]) lfilledk;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using LN(4)[OF ts_l_def] LN(6)"], ["proof (prove)\nusing this:\n  return (\\<C>\\<lparr>label := [ts'] @ label \\<C>\\<rparr>) =\n  Some tvs \\<Longrightarrow>\n  \\<exists>lholed' vs \\<C>'.\n     Lfilled j lholed' (vs @ [$Return]) lfilledk \\<and>\n     \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and> const_list vs\n  return \\<C> = Some tvs\n\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled j lholed' (vs' @ [$Return]) lfilledk;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Lfilled j lholed' (vs' @ [$Return]) lfilledk\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs\n  const_list vs'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts;\n            return \\<C> = Some tvs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                                Lfilled k lholed' (vs @ [$Return])\n                                 lfilledk \\<and>\n                                \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> tvs \\<and>\n                                const_list vs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts;\n        return \\<C> = Some tvs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed' vsa \\<C>'.\n                            Lfilled (k + 1) lholed' (vsa @ [$Return])\n                             (vs @ [Label n es' lfilledk] @ es'') \\<and>\n                            \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and>\n                            const_list vsa", "thus ?case"], ["proof (prove)\nusing this:\n  Lfilled j lholed' (vs' @ [$Return]) lfilledk\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs\n  const_list vs'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled (j + 1) lholed' (vsa @ [$Return])\n        (vs @ [Label n es' lfilledk] @ es'') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "using Lfilled.intros(2)[OF LN(1) _ lfilledk_def(1)]"], ["proof (prove)\nusing this:\n  Lfilled j lholed' (vs' @ [$Return]) lfilledk\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> tvs\n  const_list vs'\n  ?lholed = LRec vs ?n ?es' lholed' ?es'' \\<Longrightarrow>\n  Lfilled (j + 1) ?lholed (vs' @ [$Return])\n   (vs @ [Label ?n ?es' lfilledk] @ ?es'')\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' vsa \\<C>'.\n       Lfilled (j + 1) lholed' (vsa @ [$Return])\n        (vs @ [Label n es' lfilledk] @ es'') \\<and>\n       \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed' vsa \\<C>'.\n     Lfilled (j + 1) lholed' (vsa @ [$Return])\n      (vs @ [Label n es' lfilledk] @ es'') \\<and>\n     \\<S>\\<bullet>\\<C>' \\<turnstile> vsa : [] _> tvs \\<and> const_list vsa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_LN1:\n  assumes \"(Lfilled j lholed [$Br (j+k)] es)\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts _> ts')\"\n  shows \"length (label \\<C>) > k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (label \\<C>)", "using assms"], ["proof (prove)\nusing this:\n  Lfilled j lholed [$Br (j + k)] es\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : ts _> ts'\n\ngoal (1 subgoal):\n 1. k < length (label \\<C>)", "proof (induction \"[$Br (j+k)]\" es arbitrary: k \\<C> ts ts' rule: Lfilled.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [$Br (0 + k)] @ es' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> k < length (label \\<C>)\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "case (L0 vs lholed es')"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LBase vs es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Br (0 + k)] @ es' : ts _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [$Br (0 + k)] @ es' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> k < length (label \\<C>)\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "obtain ts'' ts''' where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> ts'')\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : (ts'' _> ts''')\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> es' : (ts''' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF L0(3)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Br (0 + k)] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts'''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts'' _> ts''';\n         \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' k \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [$Br (0 + k)] @ es' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> k < length (label \\<C>)\n 2. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n\ngoal (1 subgoal):\n 1. k < length (label \\<C>)", "using b_e_type_br(1)[of _ \"Br k\" ts'' ts'''] unlift_b_e"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$Br k] : ts'' _> ts'''\n  \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts''' _> ts'\n  \\<lbrakk>?\\<C> \\<turnstile> [Br k] : ts'' _> ts'''; Br k = Br ?i\\<rbrakk>\n  \\<Longrightarrow> ?i < length (label ?\\<C>)\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. k < length (label \\<C>)", "by fastforce"], ["proof (state)\nthis:\n  k < length (label \\<C>)\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "case (LN vs lholed n es' l es'' k' lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k' l [$Br (k' + 1 + k)] lfilledk\n  \\<lbrakk>k' + 1 + k = k' + ?k;\n   \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> ?k < length (label ?\\<C>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label n es' lfilledk] @ es'' : ts _> ts'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "obtain t1s t2s where ts_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs : (ts _> t1s)\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : (t1s _> t2s)\"\n                               \"\\<S>\\<bullet>\\<C> \\<turnstile> es'' : (t2s _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_comp_conc2[OF LN(5)]"], ["proof (prove)\nusing this:\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es'\nlfilledk] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts'\n\ngoal (1 subgoal):\n 1. (\\<And>t1s t2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs : ts _> t1s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label n es' lfilledk] : t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> es'' : t2s _> ts'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "obtain ts'' ts_l where ts_l_def:\"\\<S>\\<bullet>\\<C>\\<lparr>label := [ts''] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : ([] _> ts_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts_l.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts''] @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using e_type_label[OF ts_def(2)]"], ["proof (prove)\nusing this:\n  \\<exists>tls t2sa.\n     t2s = t1s @ t2sa \\<and>\n     length tls = n \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : tls _> t2sa \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label :=\n               [tls] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> t2sa\n\ngoal (1 subgoal):\n 1. (\\<And>ts'' ts_l.\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts''] @\n                  label\n                   \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            [ts''] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk ka \\<C> ts ts'.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Br (k + 1 + ka)] lfilledk;\n        \\<And>kb \\<C> ts ts'.\n           \\<lbrakk>k + 1 + ka = k + kb;\n            \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : ts _> ts'\\<rbrakk>\n           \\<Longrightarrow> kb < length (label \\<C>);\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : ts _> ts'\\<rbrakk>\n       \\<Longrightarrow> ka < length (label \\<C>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            [ts''] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l\n\ngoal (1 subgoal):\n 1. k < length (label \\<C>)", "using LN(4)[of \"1+k\"]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label :=\n            [ts''] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> ts_l\n  \\<lbrakk>k' + 1 + k = k' + (1 + k);\n   \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> 1 + k < length (label ?\\<C>)\n\ngoal (1 subgoal):\n 1. k < length (label \\<C>)", "by fastforce"], ["proof (state)\nthis:\n  k < length (label \\<C>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_LN2:\n  assumes \"(Lfilled j lholed e1s lfilled)\"\n  shows \"\\<exists>lfilled'. (Lfilled j lholed e2s lfilled')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lfilled'. Lfilled j lholed e2s lfilled'", "using assms"], ["proof (prove)\nusing this:\n  Lfilled j lholed e1s lfilled\n\ngoal (1 subgoal):\n 1. \\<exists>lfilled'. Lfilled j lholed e2s lfilled'", "proof (induction rule: Lfilled.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es.\n       \\<lbrakk>const_list vs; lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'. Lfilled 0 lholed e2s lfilled'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<exists>lfilled'. Lfilled k l e2s lfilled'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'.\n                            Lfilled (k + 1) lholed e2s lfilled'", "case (L0 vs lholed es' es)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' es.\n       \\<lbrakk>const_list vs; lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'. Lfilled 0 lholed e2s lfilled'\n 2. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<exists>lfilled'. Lfilled k l e2s lfilled'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'.\n                            Lfilled (k + 1) lholed e2s lfilled'", "thus ?case"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. \\<exists>lfilled'. Lfilled 0 lholed e2s lfilled'", "using Lfilled.intros(1)"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LBase vs es'\n  \\<lbrakk>const_list ?vs; ?lholed = LBase ?vs ?es'\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed ?es (?vs @ ?es @ ?es')\n\ngoal (1 subgoal):\n 1. \\<exists>lfilled'. Lfilled 0 lholed e2s lfilled'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lfilled'. Lfilled 0 lholed e2s lfilled'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<exists>lfilled'. Lfilled k l e2s lfilled'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'.\n                            Lfilled (k + 1) lholed e2s lfilled'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<exists>lfilled'. Lfilled k l e2s lfilled'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'.\n                            Lfilled (k + 1) lholed e2s lfilled'", "case (LN vs lholed n es' l es'' k es lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  \\<exists>lfilled'. Lfilled k l e2s lfilled'\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l es lfilledk;\n        \\<exists>lfilled'. Lfilled k l e2s lfilled'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lfilled'.\n                            Lfilled (k + 1) lholed e2s lfilled'", "thus ?case"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  \\<exists>lfilled'. Lfilled k l e2s lfilled'\n\ngoal (1 subgoal):\n 1. \\<exists>lfilled'. Lfilled (k + 1) lholed e2s lfilled'", "using Lfilled.intros(2)"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled k l es lfilledk\n  \\<exists>lfilled'. Lfilled k l e2s lfilled'\n  \\<lbrakk>const_list ?vs; ?lholed = LRec ?vs ?n ?es' ?l ?es'';\n   Lfilled ?k ?l ?es ?lfilledk\\<rbrakk>\n  \\<Longrightarrow> Lfilled (?k + 1) ?lholed ?es\n                     (?vs @ [Label ?n ?es' ?lfilledk] @ ?es'')\n\ngoal (1 subgoal):\n 1. \\<exists>lfilled'. Lfilled (k + 1) lholed e2s lfilled'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lfilled'. Lfilled (k + 1) lholed e2s lfilled'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_of_const_list:\n  assumes \"length cs = 1\"\n          \"const_list cs\"\n  shows \"\\<exists>v. cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. cs = [$C v]", "using e_type_const_unwrap assms"], ["proof (prove)\nusing this:\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n  length cs = 1\n  const_list cs\n\ngoal (1 subgoal):\n 1. \\<exists>v. cs = [$C v]", "unfolding const_list_def list_all_length"], ["proof (prove)\nusing this:\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n  length cs = 1\n  \\<forall>n<length cs. is_const (cs ! n)\n\ngoal (1 subgoal):\n 1. \\<exists>v. cs = [$C v]", "by (metis append_butlast_last_id append_self_conv2 gr_zeroI last_conv_nth length_butlast\n            length_greater_0_conv less_numeral_extra(1,4) zero_less_diff)"], ["", "lemma const_of_i32:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [(T_i32)])\"\n  shows \"\\<exists>c. cs = [$C ConstInt32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list assms(1) e_type_const_list[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  const_list cs\n  \\<exists>tvs.\n     [T_i32] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "moreover"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "hence \"\\<C> \\<turnstile> [C v] : ([] _> [(T_i32)])\""], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_i32]", "using assms(2) unlift_b_e"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32]\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : [] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "hence \"\\<exists>c. v = ConstInt32 c\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v] : [] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstInt32 c", "proof (induction \"[C v]\" \"([] _> [(T_i32)])\" rule: b_e_typing.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_i32 \\<Longrightarrow> \\<exists>c. v = ConstInt32 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_i32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_i32];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt32 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_i32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        ts @ t1s = []; ts @ t2s = [T_i32]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt32 c", "case (const \\<C>)"], ["proof (state)\nthis:\n  typeof v = T_i32\n\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_i32 \\<Longrightarrow> \\<exists>c. v = ConstInt32 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_i32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_i32];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt32 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_i32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        ts @ t1s = []; ts @ t2s = [T_i32]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt32 c", "then"], ["proof (chain)\npicking this:\n  typeof v = T_i32", "show ?case"], ["proof (prove)\nusing this:\n  typeof v = T_i32\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstInt32 c", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  (case v of ConstInt32 x \\<Rightarrow> T_i32\n   | ConstInt64 x \\<Rightarrow> T_i64 | ConstFloat32 x \\<Rightarrow> T_f32\n   | ConstFloat64 x \\<Rightarrow> T_f64) =\n  T_i32\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstInt32 c", "by (cases v, auto)"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstInt32 c\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_i32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_i32];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt32 c\n 2. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_i32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt32 c;\n        ts @ t1s = []; ts @ t2s = [T_i32]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt32 c", "qed auto"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstInt32 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "ultimately"], ["proof (chain)\npicking this:\n  cs = [$C v]\n  \\<exists>c. v = ConstInt32 c", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<exists>c. v = ConstInt32 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt32 c]", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c. cs = [$C ConstInt32 c]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_of_i64:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [(T_i64)])\"\n  shows \"\\<exists>c. cs = [$C ConstInt64 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list assms(1) e_type_const_list[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  const_list cs\n  \\<exists>tvs.\n     [T_i64] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "moreover"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "hence \"\\<C> \\<turnstile> [C v] : ([] _> [(T_i64)])\""], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_i64]", "using assms(2) unlift_b_e"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i64]\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_i64]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : [] _> [T_i64]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "hence \"\\<exists>c. v = ConstInt64 c\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v] : [] _> [T_i64]\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstInt64 c", "proof (induction \"[C v]\" \"([] _> [(T_i64)])\" rule: b_e_typing.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_i64 \\<Longrightarrow> \\<exists>c. v = ConstInt64 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_i64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_i64];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt64 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_i64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        ts @ t1s = []; ts @ t2s = [T_i64]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt64 c", "case (const \\<C>)"], ["proof (state)\nthis:\n  typeof v = T_i64\n\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_i64 \\<Longrightarrow> \\<exists>c. v = ConstInt64 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_i64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_i64];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt64 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_i64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        ts @ t1s = []; ts @ t2s = [T_i64]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt64 c", "then"], ["proof (chain)\npicking this:\n  typeof v = T_i64", "show ?case"], ["proof (prove)\nusing this:\n  typeof v = T_i64\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstInt64 c", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  (case v of ConstInt32 x \\<Rightarrow> T_i32\n   | ConstInt64 x \\<Rightarrow> T_i64 | ConstFloat32 x \\<Rightarrow> T_f32\n   | ConstFloat64 x \\<Rightarrow> T_f64) =\n  T_i64\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstInt64 c", "by (cases v, auto)"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstInt64 c\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_i64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_i64];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt64 c\n 2. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_i64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstInt64 c;\n        ts @ t1s = []; ts @ t2s = [T_i64]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstInt64 c", "qed auto"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstInt64 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "ultimately"], ["proof (chain)\npicking this:\n  cs = [$C v]\n  \\<exists>c. v = ConstInt64 c", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<exists>c. v = ConstInt64 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstInt64 c]", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c. cs = [$C ConstInt64 c]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_of_f32:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [T_f32])\"\n  shows \"\\<exists>c. cs = [$C ConstFloat32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list assms(1) e_type_const_list[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  const_list cs\n  \\<exists>tvs.\n     [T_f32] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "moreover"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "hence \"\\<C> \\<turnstile> [C v] : ([] _> [T_f32])\""], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_f32]", "using assms(2) unlift_b_e"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_f32]\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_f32]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : [] _> [T_f32]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "hence \"\\<exists>c. v = ConstFloat32 c\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v] : [] _> [T_f32]\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstFloat32 c", "proof (induction \"[C v]\" \"([] _> [T_f32])\" rule: b_e_typing.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_f32 \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_f32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_f32];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_f32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        ts @ t1s = []; ts @ t2s = [T_f32]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c", "case (const \\<C>)"], ["proof (state)\nthis:\n  typeof v = T_f32\n\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_f32 \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_f32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_f32];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_f32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        ts @ t1s = []; ts @ t2s = [T_f32]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c", "then"], ["proof (chain)\npicking this:\n  typeof v = T_f32", "show ?case"], ["proof (prove)\nusing this:\n  typeof v = T_f32\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstFloat32 c", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  (case v of ConstInt32 x \\<Rightarrow> T_i32\n   | ConstInt64 x \\<Rightarrow> T_i64 | ConstFloat32 x \\<Rightarrow> T_f32\n   | ConstFloat64 x \\<Rightarrow> T_f64) =\n  T_f32\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstFloat32 c", "by (cases v, auto)"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstFloat32 c\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_f32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_f32];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c\n 2. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_f32]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c;\n        ts @ t1s = []; ts @ t2s = [T_f32]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat32 c", "qed auto"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstFloat32 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "ultimately"], ["proof (chain)\npicking this:\n  cs = [$C v]\n  \\<exists>c. v = ConstFloat32 c", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<exists>c. v = ConstFloat32 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat32 c]", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c. cs = [$C ConstFloat32 c]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_of_f64:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [T_f64])\"\n  shows \"\\<exists>c. cs = [$C ConstFloat64 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list assms(1) e_type_const_list[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  const_list cs\n  \\<exists>tvs.\n     [T_f64] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "moreover"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "hence \"\\<C> \\<turnstile> [C v] : ([] _> [T_f64])\""], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_f64]", "using assms(2) unlift_b_e"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_f64]\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [T_f64]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : [] _> [T_f64]\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "hence \"\\<exists>c. v = ConstFloat64 c\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [C v] : [] _> [T_f64]\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstFloat64 c", "proof (induction \"[C v]\" \"([] _> [T_f64])\" rule: b_e_typing.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_f64 \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_f64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_f64];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_f64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        ts @ t1s = []; ts @ t2s = [T_f64]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c", "case (const \\<C>)"], ["proof (state)\nthis:\n  typeof v = T_f64\n\ngoal (3 subgoals):\n 1. \\<And>\\<C>.\n       typeof v = T_f64 \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c\n 2. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_f64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_f64];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c\n 3. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_f64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        ts @ t1s = []; ts @ t2s = [T_f64]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c", "then"], ["proof (chain)\npicking this:\n  typeof v = T_f64", "show ?case"], ["proof (prove)\nusing this:\n  typeof v = T_f64\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstFloat64 c", "unfolding typeof_def"], ["proof (prove)\nusing this:\n  (case v of ConstInt32 x \\<Rightarrow> T_i32\n   | ConstInt64 x \\<Rightarrow> T_i64 | ConstFloat32 x \\<Rightarrow> T_f32\n   | ConstFloat64 x \\<Rightarrow> T_f64) =\n  T_f64\n\ngoal (1 subgoal):\n 1. \\<exists>c. v = ConstFloat64 c", "by (cases v, auto)"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstFloat64 c\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t2s e.\n       \\<lbrakk>\\<C> \\<turnstile> es : [] _> t2s;\n        \\<lbrakk>es = [C v]; t2s = [T_f64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        \\<C> \\<turnstile> [e] : t2s _> [T_f64];\n        \\<lbrakk>e = C v; t2s = []\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        es @ [e] = [C v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c\n 2. \\<And>\\<C> t1s t2s ts.\n       \\<lbrakk>\\<C> \\<turnstile> [C v] : t1s _> t2s;\n        \\<lbrakk>t1s = []; t2s = [T_f64]\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c;\n        ts @ t1s = []; ts @ t2s = [T_f64]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c. v = ConstFloat64 c", "qed auto"], ["proof (state)\nthis:\n  \\<exists>c. v = ConstFloat64 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "ultimately"], ["proof (chain)\npicking this:\n  cs = [$C v]\n  \\<exists>c. v = ConstFloat64 c", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<exists>c. v = ConstFloat64 c\n\ngoal (1 subgoal):\n 1. \\<exists>c. cs = [$C ConstFloat64 c]", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c. cs = [$C ConstFloat64 c]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_unop_testop_i:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t])\"\n          \"is_int_t t\"\n          \"const_list cs\"\n          \"e = Unop_i t iop \\<or> e = Testop t testop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case T_i32"], ["proof (state)\nthis:\n  t = T_i32\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = T_i32\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using  const_of_i32[OF assms(3)] assms(1,4)\n          reduce.intros(1)[OF reduce_simple.intros(1)] reduce.intros(1)[OF reduce_simple.intros(13)]"], ["proof (prove)\nusing this:\n  t = T_i32\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> cs : [] _> [T_i32] \\<Longrightarrow>\n  \\<exists>c. cs = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  e = Unop_i t iop \\<or> e = Testop t testop\n  \\<lparr>?s;?vs;[$C ConstInt32 ?c1,\n                  $Unop_i T_i32\n                    ?iop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstInt32\n                                (app_unop_i ?iop1 ?c1)]\\<rparr>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?c1,\n                  $Testop T_i32\n                    ?testop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstInt32\n                                   (wasm_bool\n                                     (app_testop_i ?testop1 ?c1))]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case T_i64"], ["proof (state)\nthis:\n  t = T_i64\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = T_i64\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using const_of_i64[OF assms(3)] assms(1,4)\n          reduce.intros(1)[OF reduce_simple.intros(2)] reduce.intros(1)[OF reduce_simple.intros(14)]"], ["proof (prove)\nusing this:\n  t = T_i64\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> cs : [] _> [T_i64] \\<Longrightarrow>\n  \\<exists>c. cs = [$C ConstInt64 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  e = Unop_i t iop \\<or> e = Testop t testop\n  \\<lparr>?s;?vs;[$C ConstInt64 ?c1,\n                  $Unop_i T_i64\n                    ?iop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstInt64\n                                (app_unop_i ?iop1 ?c1)]\\<rparr>\n  \\<lparr>?s;?vs;[$C ConstInt64 ?c1,\n                  $Testop T_i64\n                    ?testop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstInt32\n                                   (wasm_bool\n                                     (app_testop_i ?testop1 ?c1))]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "qed (simp_all add: is_int_t_def)"], ["", "lemma progress_unop_f:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t])\"\n          \"is_float_t t\"\n          \"const_list cs\"\n          \"e = Unop_f t iop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_float_t t\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case T_f32"], ["proof (state)\nthis:\n  t = T_f32\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = T_f32\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using  const_of_f32[OF assms(3)] assms(1,4)\n          reduce.intros(1)[OF reduce_simple.intros(3)] reduce.intros(1)[OF reduce_simple.intros(13)]"], ["proof (prove)\nusing this:\n  t = T_f32\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> cs : [] _> [T_f32] \\<Longrightarrow>\n  \\<exists>c. cs = [$C ConstFloat32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  e = Unop_f t iop\n  \\<lparr>?s;?vs;[$C ConstFloat32 ?c1,\n                  $Unop_f T_f32\n                    ?fop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstFloat32\n                                (app_unop_f ?fop1 ?c1)]\\<rparr>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?c1,\n                  $Testop T_i32\n                    ?testop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstInt32\n                                   (wasm_bool\n                                     (app_testop_i ?testop1 ?c1))]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case T_f64"], ["proof (state)\nthis:\n  t = T_f64\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = T_f64\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using const_of_f64[OF assms(3)] assms(1,4)\n          reduce.intros(1)[OF reduce_simple.intros(4)] reduce.intros(1)[OF reduce_simple.intros(14)]"], ["proof (prove)\nusing this:\n  t = T_f64\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> cs : [] _> [T_f64] \\<Longrightarrow>\n  \\<exists>c. cs = [$C ConstFloat64 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  e = Unop_f t iop\n  \\<lparr>?s;?vs;[$C ConstFloat64 ?c1,\n                  $Unop_f T_f64\n                    ?fop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstFloat64\n                                (app_unop_f ?fop1 ?c1)]\\<rparr>\n  \\<lparr>?s;?vs;[$C ConstInt64 ?c1,\n                  $Testop T_i64\n                    ?testop1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ConstInt32\n                                   (wasm_bool\n                                     (app_testop_i ?testop1 ?c1))]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "qed (simp_all add: is_float_t_def)"], ["", "lemma const_list_split_2:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t1, t2])\"\n  shows \"\\<exists>c1 c2. (\\<S>\\<bullet>\\<C> \\<turnstile> [c1] : ([] _> [t1]))\n                 \\<and> (\\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ([] _> [t2]))\n                 \\<and> cs = [c1, c2]\n                 \\<and> const_list [c1]\n                 \\<and> const_list [c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "have l_cs:\"length cs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs = 2", "using assms e_type_const_list[OF assms]"], ["proof (prove)\nusing this:\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2]\n  \\<exists>tvs.\n     [t1, t2] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. length cs = 2", "by simp"], ["proof (state)\nthis:\n  length cs = 2\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "then"], ["proof (chain)\npicking this:\n  length cs = 2", "obtain c1 c2 where \"cs!0 = c1\" \"cs!1 = c2\""], ["proof (prove)\nusing this:\n  length cs = 2\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>cs ! 0 = c1; cs ! 1 = c2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs ! 0 = c1\n  cs ! 1 = c2\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "hence \"cs = [c1] @ [c2]\""], ["proof (prove)\nusing this:\n  cs ! 0 = c1\n  cs ! 1 = c2\n\ngoal (1 subgoal):\n 1. cs = [c1] @ [c2]", "using assms e_type_const_conv_vs typing_map_typeof"], ["proof (prove)\nusing this:\n  cs ! 0 = c1\n  cs ! 1 = c2\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2]\n  const_list ?ves \\<Longrightarrow> \\<exists>vs. ?ves = $$* vs\n  \\<lbrakk>?ves = $$* ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?ves : [] _> ?tvs\\<rbrakk>\n  \\<Longrightarrow> ?tvs = map typeof ?vs\n\ngoal (1 subgoal):\n 1. cs = [c1] @ [c2]", "by fastforce"], ["proof (state)\nthis:\n  cs = [c1] @ [c2]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = [c1] @ [c2]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "using assms e_type_comp[of \\<S> \\<C> \"[c1]\" c2] e_type_const[of c2 \\<S> \\<C> _ \"[t1,t2]\"]"], ["proof (prove)\nusing this:\n  cs = [c1] @ [c2]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [c1] @\n                                 [c2] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ts' _> ?t3s\n  \\<lbrakk>is_const c2;\n   \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ?ts _> [t1, t2]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       [t1, t2] = ?ts @ [t] \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> [c2] : [] _> [t]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs = [c1] @ [c2]\n  list_all is_const cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [c1] @\n                                 [c2] : ?t1s _> ?t3s \\<Longrightarrow>\n  \\<exists>ts'.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : ?t1s _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ts' _> ?t3s\n  \\<lbrakk>is_const c2;\n   \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ?ts _> [t1, t2]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       [t1, t2] = ?ts @ [t] \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> [c2] : [] _> [t]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       cs = [c1, c2] \\<and>\n       list_all is_const [c1] \\<and> list_all is_const [c2]", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n     cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_list_split_3:\n  assumes \"const_list cs\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t1, t2, t3])\"\n  shows \"\\<exists>c1 c2 c3. (\\<S>\\<bullet>\\<C> \\<turnstile> [c1] : ([] _> [t1]))\n                    \\<and> (\\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ([] _> [t2]))\n                    \\<and> (\\<S>\\<bullet>\\<C> \\<turnstile> [c3] : ([] _> [t3]))\n                    \\<and> cs = [c1, c2, c3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "have l_cs:\"length cs = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cs = 3", "using assms e_type_const_list[OF assms]"], ["proof (prove)\nusing this:\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2, t3]\n  \\<exists>tvs.\n     [t1, t2, t3] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. length cs = 3", "by simp"], ["proof (state)\nthis:\n  length cs = 3\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "then"], ["proof (chain)\npicking this:\n  length cs = 3", "obtain c1 c2 c3 where \"cs!0 = c1\" \"cs!1 = c2\" \"cs!2 = c3\""], ["proof (prove)\nusing this:\n  length cs = 3\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2 c3.\n        \\<lbrakk>cs ! 0 = c1; cs ! 1 = c2; cs ! 2 = c3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs ! 0 = c1\n  cs ! 1 = c2\n  cs ! 2 = c3\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "hence \"cs = [c1] @ [c2] @ [c3]\""], ["proof (prove)\nusing this:\n  cs ! 0 = c1\n  cs ! 1 = c2\n  cs ! 2 = c3\n\ngoal (1 subgoal):\n 1. cs = [c1] @ [c2] @ [c3]", "using assms e_type_const_conv_vs typing_map_typeof"], ["proof (prove)\nusing this:\n  cs ! 0 = c1\n  cs ! 1 = c2\n  cs ! 2 = c3\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2, t3]\n  const_list ?ves \\<Longrightarrow> \\<exists>vs. ?ves = $$* vs\n  \\<lbrakk>?ves = $$* ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?ves : [] _> ?tvs\\<rbrakk>\n  \\<Longrightarrow> ?tvs = map typeof ?vs\n\ngoal (1 subgoal):\n 1. cs = [c1] @ [c2] @ [c3]", "by fastforce"], ["proof (state)\nthis:\n  cs = [c1] @ [c2] @ [c3]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = [c1] @ [c2] @ [c3]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "using assms e_type_comp_conc2[of \\<S> \\<C> \"[c1]\" \"[c2]\" \"[c3]\" \"[]\" \"[t1,t2,t3]\"]\n          e_type_const[of c1] e_type_const[of c2] e_type_const[of c3]"], ["proof (prove)\nusing this:\n  cs = [c1] @ [c2] @ [c3]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2, t3]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [c1] @\n                                 [c2] @\n                                 [c3] : [] _> [t1, t2, t3] \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : ts'' _> [t1, t2, t3]\n  \\<lbrakk>is_const c1;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [c1] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> [c1] : [] _> [t]\n  \\<lbrakk>is_const c2;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [c2] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> [c2] : [] _> [t]\n  \\<lbrakk>is_const c3;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [c3] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> [c3] : [] _> [t]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs = [c1] @ [c2] @ [c3]\n  list_all is_const cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t1, t2, t3]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [c1] @\n                                 [c2] @\n                                 [c3] : [] _> [t1, t2, t3] \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : ts'' _> [t1, t2, t3]\n  \\<lbrakk>is_const c1;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [c1] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> [c1] : [] _> [t]\n  \\<lbrakk>is_const c2;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [c2] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> [c2] : [] _> [t]\n  \\<lbrakk>is_const c3;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> [c3] : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t.\n                       ?ts' = ?ts @ [t] \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> [c3] : [] _> [t]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2 c3.\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n       \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n       cs = [c1, c2, c3]", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c1 c2 c3.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t1] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t2] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [t3] \\<and>\n     cs = [c1, c2, c3]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_binop_relop_i:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t, t])\"\n          \"is_int_t t\"\n          \"const_list cs\"\n          \"e = Binop_i t iop \\<or> e = Relop_i t irop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (T_i32)"], ["proof (state)\nthis:\n  t = T_i32\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence cs_def:\"\\<exists>c1 c2. cs = [$C ConstInt32 c1,$C ConstInt32 c2]\""], ["proof (prove)\nusing this:\n  t = T_i32\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstInt32 c1, $C ConstInt32 c2]", "using const_list_split_2[OF assms(3,1)] assms(3) const_of_i32"], ["proof (prove)\nusing this:\n  t = T_i32\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]\n  const_list cs\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstInt32 c1, $C ConstInt32 c2]", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  t = T_i32\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and>\n     list_all is_const [c1] \\<and> list_all is_const [c2]\n  list_all is_const cs\n  \\<lbrakk>list_all is_const ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstInt32 c1, $C ConstInt32 c2]", "by blast"], ["proof (state)\nthis:\n  \\<exists>c1 c2. cs = [$C ConstInt32 c1, $C ConstInt32 c2]\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"e = Binop_i t iop\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  e = Binop_i t iop\n\ngoal (2 subgoals):\n 1. e = Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "obtain c1 c2 where \"cs = [$C ConstInt32 c1,$C ConstInt32 c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstInt32 c1, $C ConstInt32 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cs_def"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2. cs = [$C ConstInt32 c1, $C ConstInt32 c2]\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstInt32 c1, $C ConstInt32 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs = [$C ConstInt32 c1, $C ConstInt32 c2]\n\ngoal (2 subgoals):\n 1. e = Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C ConstInt32 c1, $C ConstInt32 c2]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (cases \"app_binop_i iop c1 c2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cs = [$C ConstInt32 c1, $C ConstInt32 c2];\n     app_binop_i iop c1 c2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>a.\n       \\<lbrakk>cs = [$C ConstInt32 c1, $C ConstInt32 c2];\n        app_binop_i iop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(6) reduce.intros(1) T_i32 True append_Cons append_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C ConstInt32 c1, $C ConstInt32 c2];\n        app_binop_i iop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(5) reduce.intros(1) T_i32 True append_Cons append_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  e \\<noteq> Binop_i t iop\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_i t iop\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce_simple.intros(15) assms(4) reduce.intros(1) cs_def T_i32"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_i t iop\n  \\<lparr>[$C ConstInt32 ?c1.0, $C ConstInt32 ?c2.0,\n           $Relop_i T_i32\n             ?iop]\\<rparr> \\<leadsto> \\<lparr>[$C ConstInt32\n             (wasm_bool (app_relop_i ?iop ?c1.0 ?c2.0))]\\<rparr>\n  e = Binop_i t iop \\<or> e = Relop_i t irop\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  \\<exists>c1 c2. cs = [$C ConstInt32 c1, $C ConstInt32 c2]\n  t = T_i32\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (T_i64)"], ["proof (state)\nthis:\n  t = T_i64\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence cs_def:\"\\<exists>c1 c2. cs = [$C ConstInt64 c1,$C ConstInt64 c2]\""], ["proof (prove)\nusing this:\n  t = T_i64\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstInt64 c1, $C ConstInt64 c2]", "using const_list_split_2[OF assms(3,1)] assms(3) const_of_i64"], ["proof (prove)\nusing this:\n  t = T_i64\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]\n  const_list cs\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i64]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt64 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstInt64 c1, $C ConstInt64 c2]", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  t = T_i64\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and>\n     list_all is_const [c1] \\<and> list_all is_const [c2]\n  list_all is_const cs\n  \\<lbrakk>list_all is_const ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i64]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt64 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstInt64 c1, $C ConstInt64 c2]", "by blast"], ["proof (state)\nthis:\n  \\<exists>c1 c2. cs = [$C ConstInt64 c1, $C ConstInt64 c2]\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"e = Binop_i t iop\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  e = Binop_i t iop\n\ngoal (2 subgoals):\n 1. e = Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "obtain c1 c2 where \"cs = [$C ConstInt64 c1,$C ConstInt64 c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstInt64 c1, $C ConstInt64 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cs_def"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2. cs = [$C ConstInt64 c1, $C ConstInt64 c2]\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstInt64 c1, $C ConstInt64 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs = [$C ConstInt64 c1, $C ConstInt64 c2]\n\ngoal (2 subgoals):\n 1. e = Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C ConstInt64 c1, $C ConstInt64 c2]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (cases \"app_binop_i iop c1 c2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cs = [$C ConstInt64 c1, $C ConstInt64 c2];\n     app_binop_i iop c1 c2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>a.\n       \\<lbrakk>cs = [$C ConstInt64 c1, $C ConstInt64 c2];\n        app_binop_i iop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(8) reduce.intros(1) T_i64 True append_Cons append_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C ConstInt64 c1, $C ConstInt64 c2];\n        app_binop_i iop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(7) reduce.intros(1) T_i64 True append_Cons append_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  e \\<noteq> Binop_i t iop\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_i t iop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_i t iop\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce_simple.intros(16) assms(4) reduce.intros(1) cs_def T_i64"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_i t iop\n  \\<lparr>[$C ConstInt64 ?c1.0, $C ConstInt64 ?c2.0,\n           $Relop_i T_i64\n             ?iop]\\<rparr> \\<leadsto> \\<lparr>[$C ConstInt32\n             (wasm_bool (app_relop_i ?iop ?c1.0 ?c2.0))]\\<rparr>\n  e = Binop_i t iop \\<or> e = Relop_i t irop\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  \\<exists>c1 c2. cs = [$C ConstInt64 c1, $C ConstInt64 c2]\n  t = T_i64\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_int_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_int_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "qed (simp_all add: is_int_t_def)"], ["", "lemma progress_binop_relop_f:\n  assumes \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> [t, t])\"\n          \"is_float_t t\"\n          \"const_list cs\"\n          \"e = Binop_f t fop \\<or> e = Relop_f t frop\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@([$e])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using assms(2)"], ["proof (prove)\nusing this:\n  is_float_t t\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case T_f32"], ["proof (state)\nthis:\n  t = T_f32\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence cs_def:\"\\<exists>c1 c2. cs = [$C ConstFloat32 c1,$C ConstFloat32 c2]\""], ["proof (prove)\nusing this:\n  t = T_f32\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]", "using const_list_split_2[OF assms(3,1)] assms(3) const_of_f32"], ["proof (prove)\nusing this:\n  t = T_f32\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]\n  const_list cs\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_f32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstFloat32 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  t = T_f32\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and>\n     list_all is_const [c1] \\<and> list_all is_const [c2]\n  list_all is_const cs\n  \\<lbrakk>list_all is_const ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_f32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstFloat32 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]", "by blast"], ["proof (state)\nthis:\n  \\<exists>c1 c2. cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]\n\ngoal (4 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 4. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"e = Binop_f t fop\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  e = Binop_f t fop\n\ngoal (2 subgoals):\n 1. e = Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "obtain c1 c2 where cs_def:\"cs = [$C ConstFloat32 c1,$C ConstFloat32 c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstFloat32 c1, $C ConstFloat32 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cs_def"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2. cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstFloat32 c1, $C ConstFloat32 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]\n\ngoal (2 subgoals):\n 1. e = Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (cases \"app_binop_f fop c1 c2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cs = [$C ConstFloat32 c1, $C ConstFloat32 c2];\n     app_binop_f fop c1 c2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>a.\n       \\<lbrakk>cs = [$C ConstFloat32 c1, $C ConstFloat32 c2];\n        app_binop_f fop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(10) reduce.intros(1) T_f32 True append_Cons append_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C ConstFloat32 c1, $C ConstFloat32 c2];\n        app_binop_f fop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(9) reduce.intros(1) T_f32 True append_Cons append_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  e \\<noteq> Binop_f t fop\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_f t fop\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce_simple.intros(17) assms(4) reduce.intros(1) cs_def T_f32"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_f t fop\n  \\<lparr>[$C ConstFloat32 ?c1.0, $C ConstFloat32 ?c2.0,\n           $Relop_f T_f32\n             ?fop]\\<rparr> \\<leadsto> \\<lparr>[$C ConstInt32\n             (wasm_bool (app_relop_f ?fop ?c1.0 ?c2.0))]\\<rparr>\n  e = Binop_f t fop \\<or> e = Relop_f t frop\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  \\<exists>c1 c2. cs = [$C ConstFloat32 c1, $C ConstFloat32 c2]\n  t = T_f32\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case T_f64"], ["proof (state)\nthis:\n  t = T_f64\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence cs_def:\"\\<exists>c1 c2. cs = [$C ConstFloat64 c1,$C ConstFloat64 c2]\""], ["proof (prove)\nusing this:\n  t = T_f64\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]", "using const_list_split_2[OF assms(3,1)] assms(3) const_of_f64"], ["proof (prove)\nusing this:\n  t = T_f64\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]\n  const_list cs\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_f64]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstFloat64 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  t = T_f64\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and>\n     list_all is_const [c1] \\<and> list_all is_const [c2]\n  list_all is_const cs\n  \\<lbrakk>list_all is_const ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_f64]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstFloat64 c]\n\ngoal (1 subgoal):\n 1. \\<exists>c1 c2. cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]", "by blast"], ["proof (state)\nthis:\n  \\<exists>c1 c2. cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]\n\ngoal (3 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. \\<lbrakk>is_float_t t; t = T_f64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"e = Binop_f t fop\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  e = Binop_f t fop\n\ngoal (2 subgoals):\n 1. e = Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "obtain c1 c2 where \"cs = [$C ConstFloat64 c1,$C ConstFloat64 c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstFloat64 c1, $C ConstFloat64 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cs_def"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2. cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        cs = [$C ConstFloat64 c1, $C ConstFloat64 c2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]\n\ngoal (2 subgoals):\n 1. e = Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (cases \"app_binop_f fop c1 c2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cs = [$C ConstFloat64 c1, $C ConstFloat64 c2];\n     app_binop_f fop c1 c2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>a.\n       \\<lbrakk>cs = [$C ConstFloat64 c1, $C ConstFloat64 c2];\n        app_binop_f fop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(12) reduce.intros(1) T_f64 True append_Cons append_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C ConstFloat64 c1, $C ConstFloat64 c2];\n        app_binop_f fop c1 c2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs' es'.\n                            \\<lparr>s;vs;cs @\n   [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "apply (metis reduce_simple.intros(11) reduce.intros(1) T_f64 True append_Cons append_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  e \\<noteq> Binop_f t fop\n\ngoal (1 subgoal):\n 1. e \\<noteq> Binop_f t fop \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_f t fop\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce_simple.intros(18) assms(4) reduce.intros(1) cs_def T_f64"], ["proof (prove)\nusing this:\n  e \\<noteq> Binop_f t fop\n  \\<lparr>[$C ConstFloat64 ?c1.0, $C ConstFloat64 ?c2.0,\n           $Relop_f T_f64\n             ?fop]\\<rparr> \\<leadsto> \\<lparr>[$C ConstInt32\n             (wasm_bool (app_relop_f ?fop ?c1.0 ?c2.0))]\\<rparr>\n  e = Binop_f t fop \\<or> e = Relop_f t frop\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  \\<exists>c1 c2. cs = [$C ConstFloat64 c1, $C ConstFloat64 c2]\n  t = T_f64\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs @ [$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_float_t t; t = T_i32\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<lbrakk>is_float_t t; t = T_i64\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' es'.\n                         \\<lparr>s;vs;cs @\n[$e]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "qed (simp_all add: is_float_t_def)"], ["", "lemma progress_b_e:\n  assumes \"\\<C> \\<turnstile> b_es : (ts _> ts')\"\n          \"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> ts)\"\n          \"(\\<And>lholed. \\<not>(Lfilled 0 lholed [$Return] (cs@($*b_es))))\"\n          \"\\<And> i lholed. \\<not>(Lfilled 0 lholed [$Br (i)] (cs@($*b_es)))\"\n          \"const_list cs\"\n          \"\\<not> const_list ($* b_es)\"\n          \"i < length (s_inst \\<S>)\"\n          \"length (local \\<C>) = length (vs)\"\n          \"Option.is_none (memory \\<C>) = Option.is_none (inst.mem ((inst s)!i))\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs@($*b_es)\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    ($* b_es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using assms"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> b_es : ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* b_es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* b_es))\n  const_list cs\n  \\<not> const_list ($* b_es)\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs @\n                    ($* b_es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (induction b_es \"(ts _> ts')\" arbitrary: ts ts' cs rule: b_e_typing.induct)"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>\\<C> v cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [C v]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [C v]));\n        const_list cs; \\<not> const_list ($* [C v]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [C v])) i s' vs')\n 2. \\<And>t \\<C> uu_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_i t uu_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_i t uu_]));\n        const_list cs; \\<not> const_list ($* [Unop_i t uu_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_i t uu_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 7. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 8. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 9. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 10. \\<And>t1 t2 \\<C> cs.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n         const_list cs;\n         \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                  i s' vs')\nA total of 35 subgoals...", "case (const \\<C> v)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [C v]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [C v]))\n  const_list cs\n  \\<not> const_list ($* [C v])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (35 subgoals):\n 1. \\<And>\\<C> v cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [C v]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [C v]));\n        const_list cs; \\<not> const_list ($* [C v]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [C v])) i s' vs')\n 2. \\<And>t \\<C> uu_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_i t uu_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_i t uu_]));\n        const_list cs; \\<not> const_list ($* [Unop_i t uu_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_i t uu_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 7. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 8. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 9. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 10. \\<And>t1 t2 \\<C> cs.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n         const_list cs;\n         \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                  i s' vs')\nA total of 35 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [C v]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [C v]))\n  const_list cs\n  \\<not> const_list ($* [C v])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))", "show ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [C v]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [C v]))\n  const_list cs\n  \\<not> const_list ($* [C v])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [C v])) i s' vs')", "unfolding const_list_def is_const_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [C v]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [C v]))\n  list_all\n   (\\<lambda>e.\n       case e of $C xa \\<Rightarrow> True | $_ \\<Rightarrow> False\n       | _ \\<Rightarrow> False)\n   cs\n  \\<not> list_all\n          (\\<lambda>e.\n              case e of $C xa \\<Rightarrow> True | $_ \\<Rightarrow> False\n              | _ \\<Rightarrow> False)\n          ($* [C v])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [C v])) i s' vs')", "by simp"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [C v])) i s' vs')\n\ngoal (34 subgoals):\n 1. \\<And>t \\<C> uu_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_i t uu_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_i t uu_]));\n        const_list cs; \\<not> const_list ($* [Unop_i t uu_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_i t uu_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 7. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 8. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 9. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 10. \\<And>\\<C> ts ts' cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n         const_list cs; \\<not> const_list ($* [Unreachable]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                  vs')\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>t \\<C> uu_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_i t uu_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_i t uu_]));\n        const_list cs; \\<not> const_list ($* [Unop_i t uu_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_i t uu_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 7. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 8. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 9. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 10. \\<And>\\<C> ts ts' cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n         const_list cs; \\<not> const_list ($* [Unreachable]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                  vs')\nA total of 34 subgoals...", "case (unop_i t \\<C> uu)"], ["proof (state)\nthis:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unop_i t uu]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unop_i t uu]))\n  const_list cs\n  \\<not> const_list ($* [Unop_i t uu])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (34 subgoals):\n 1. \\<And>t \\<C> uu_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_i t uu_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_i t uu_]));\n        const_list cs; \\<not> const_list ($* [Unop_i t uu_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_i t uu_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 7. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 8. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 9. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 10. \\<And>\\<C> ts ts' cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n         const_list cs; \\<not> const_list ($* [Unreachable]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                  vs')\nA total of 34 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unop_i t uu]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unop_i t uu]))\n  const_list cs\n  \\<not> const_list ($* [Unop_i t uu])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unop_i t uu])) i s' vs')", "using progress_unop_testop_i[OF unop_i(2,1)]"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unop_i t uu]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unop_i t uu]))\n  const_list cs\n  \\<not> const_list ($* [Unop_i t uu])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>const_list cs;\n   ?e = Unop_i t ?iop \\<or> ?e = Testop t ?testop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;cs @\n[$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unop_i t uu])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unop_i t uu])) i s' vs')\n\ngoal (33 subgoals):\n 1. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 7. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 8. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 9. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n         const_list cs; \\<not> const_list ($* [Nop]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 7. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 8. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 9. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n         const_list cs; \\<not> const_list ($* [Nop]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\nA total of 33 subgoals...", "case (unop_f t \\<C> uv)"], ["proof (state)\nthis:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unop_f t uv]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unop_f t uv]))\n  const_list cs\n  \\<not> const_list ($* [Unop_f t uv])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (33 subgoals):\n 1. \\<And>t \\<C> uv_ cs.\n       \\<lbrakk>is_float_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unop_f t uv_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unop_f t uv_]));\n        const_list cs; \\<not> const_list ($* [Unop_f t uv_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unop_f t uv_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 6. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 7. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 8. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 9. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n         const_list cs; \\<not> const_list ($* [Nop]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\nA total of 33 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unop_f t uv]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unop_f t uv]))\n  const_list cs\n  \\<not> const_list ($* [Unop_f t uv])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unop_f t uv])) i s' vs')", "using progress_unop_f[OF unop_f(2,1,5)]"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unop_f t uv]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unop_f t uv]))\n  const_list cs\n  \\<not> const_list ($* [Unop_f t uv])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  ?e = Unop_f t ?iop \\<Longrightarrow>\n  \\<exists>a s' vs' es'.\n     \\<lparr>?s;?vs;cs @\n                    [$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unop_f t uv])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unop_f t uv])) i s' vs')\n\ngoal (32 subgoals):\n 1. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 6. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 7. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 8. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 10. \\<And>\\<C> t cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n         const_list cs; \\<not> const_list ($* [Drop]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 6. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 7. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 8. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 10. \\<And>\\<C> t cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n         const_list cs; \\<not> const_list ($* [Drop]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\nA total of 32 subgoals...", "case (binop_i t \\<C> uw)"], ["proof (state)\nthis:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Binop_i t uw]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Binop_i t uw]))\n  const_list cs\n  \\<not> const_list ($* [Binop_i t uw])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (32 subgoals):\n 1. \\<And>t \\<C> iop cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_i t iop]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_i t iop]));\n        const_list cs; \\<not> const_list ($* [Binop_i t iop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_i t iop])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 5. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 6. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 7. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 8. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 10. \\<And>\\<C> t cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n         const_list cs; \\<not> const_list ($* [Drop]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\nA total of 32 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Binop_i t uw]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Binop_i t uw]))\n  const_list cs\n  \\<not> const_list ($* [Binop_i t uw])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Binop_i t uw])) i s' vs')", "using progress_binop_relop_i[OF binop_i(2,1)]"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Binop_i t uw]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Binop_i t uw]))\n  const_list cs\n  \\<not> const_list ($* [Binop_i t uw])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>const_list cs;\n   ?e = Binop_i t ?iop \\<or> ?e = Relop_i t ?irop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;cs @\n[$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Binop_i t uw])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Binop_i t uw])) i s' vs')\n\ngoal (31 subgoals):\n 1. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 5. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 6. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 7. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 9. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 10. \\<And>\\<C> t cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n         const_list cs; \\<not> const_list ($* [Select]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 5. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 6. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 7. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 9. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 10. \\<And>\\<C> t cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n         const_list cs; \\<not> const_list ($* [Select]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\nA total of 31 subgoals...", "case (binop_f t \\<C> ux)"], ["proof (state)\nthis:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Binop_f t ux]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Binop_f t ux]))\n  const_list cs\n  \\<not> const_list ($* [Binop_f t ux])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (31 subgoals):\n 1. \\<And>t \\<C> uw_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Binop_f t uw_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Binop_f t uw_]));\n        const_list cs; \\<not> const_list ($* [Binop_f t uw_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Binop_f t uw_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 4. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 5. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 6. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 7. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 9. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 10. \\<And>\\<C> t cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n         const_list cs; \\<not> const_list ($* [Select]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\nA total of 31 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Binop_f t ux]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Binop_f t ux]))\n  const_list cs\n  \\<not> const_list ($* [Binop_f t ux])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Binop_f t ux])) i s' vs')", "using progress_binop_relop_f[OF binop_f(2,1,5)]"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Binop_f t ux]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Binop_f t ux]))\n  const_list cs\n  \\<not> const_list ($* [Binop_f t ux])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  ?e = Binop_f t ?fop \\<or> ?e = Relop_f t ?frop \\<Longrightarrow>\n  \\<exists>a s' vs' es'.\n     \\<lparr>?s;?vs;cs @\n                    [$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Binop_f t ux])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Binop_f t ux])) i s' vs')\n\ngoal (30 subgoals):\n 1. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 4. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 5. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 6. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 7. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 8. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 9. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 10. \\<And>tf tn tm \\<C> es cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n         const_list cs; \\<not> const_list ($* [Block tf es]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                  vs')\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 4. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 5. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 6. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 7. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 8. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 9. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 10. \\<And>tf tn tm \\<C> es cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n         const_list cs; \\<not> const_list ($* [Block tf es]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                  vs')\nA total of 30 subgoals...", "case (testop t \\<C> uy)"], ["proof (state)\nthis:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Testop t uy]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Testop t uy]))\n  const_list cs\n  \\<not> const_list ($* [Testop t uy])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (30 subgoals):\n 1. \\<And>t \\<C> ux_ cs.\n       \\<lbrakk>is_int_t t; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Testop t ux_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Testop t ux_]));\n        const_list cs; \\<not> const_list ($* [Testop t ux_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Testop t ux_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 3. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 4. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 5. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 6. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 7. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 8. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 9. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 10. \\<And>tf tn tm \\<C> es cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n         const_list cs; \\<not> const_list ($* [Block tf es]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                  vs')\nA total of 30 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Testop t uy]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Testop t uy]))\n  const_list cs\n  \\<not> const_list ($* [Testop t uy])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Testop t uy])) i s' vs')", "using progress_unop_testop_i[OF testop(2,1)]"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Testop t uy]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Testop t uy]))\n  const_list cs\n  \\<not> const_list ($* [Testop t uy])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>const_list cs;\n   ?e = Unop_i t ?iop \\<or> ?e = Testop t ?testop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;cs @\n[$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Testop t uy])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Testop t uy])) i s' vs')\n\ngoal (29 subgoals):\n 1. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 3. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 4. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 5. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 7. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 8. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 9. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 10. \\<And>tf tn tm \\<C> es cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tn] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n         const_list cs; \\<not> const_list ($* [Loop tf es]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                  vs')\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 3. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 4. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 5. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 7. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 8. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 9. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 10. \\<And>tf tn tm \\<C> es cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tn] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n         const_list cs; \\<not> const_list ($* [Loop tf es]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                  vs')\nA total of 29 subgoals...", "case (relop_i t \\<C> uz)"], ["proof (state)\nthis:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Relop_i t uz]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Relop_i t uz]))\n  const_list cs\n  \\<not> const_list ($* [Relop_i t uz])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (29 subgoals):\n 1. \\<And>t \\<C> uy_ cs.\n       \\<lbrakk>is_int_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_i t uy_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_i t uy_]));\n        const_list cs; \\<not> const_list ($* [Relop_i t uy_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_i t uy_])) i s'\n                                 vs')\n 2. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 3. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 4. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 5. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 7. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 8. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 9. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 10. \\<And>tf tn tm \\<C> es cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tn] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n         const_list cs; \\<not> const_list ($* [Loop tf es]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                  vs')\nA total of 29 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Relop_i t uz]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Relop_i t uz]))\n  const_list cs\n  \\<not> const_list ($* [Relop_i t uz])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Relop_i t uz])) i s' vs')", "using progress_binop_relop_i[OF relop_i(2,1)]"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Relop_i t uz]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Relop_i t uz]))\n  const_list cs\n  \\<not> const_list ($* [Relop_i t uz])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>const_list cs;\n   ?e = Binop_i t ?iop \\<or> ?e = Relop_i t ?irop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;cs @\n[$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Relop_i t uz])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Relop_i t uz])) i s' vs')\n\ngoal (28 subgoals):\n 1. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 2. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 3. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 4. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 7. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 10. \\<And>tf tn tm \\<C> es1 es2 cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n             const_list cs; \\<not> const_list ($* es1);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n             const_list cs; \\<not> const_list ($* es2);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [b_e.If tf es1 es2]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n         const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                  i s' vs')\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 2. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 3. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 4. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 7. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 10. \\<And>tf tn tm \\<C> es1 es2 cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n             const_list cs; \\<not> const_list ($* es1);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n             const_list cs; \\<not> const_list ($* es2);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [b_e.If tf es1 es2]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n         const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                  i s' vs')\nA total of 28 subgoals...", "case (relop_f t \\<C> va)"], ["proof (state)\nthis:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Relop_f t va]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Relop_f t va]))\n  const_list cs\n  \\<not> const_list ($* [Relop_f t va])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (28 subgoals):\n 1. \\<And>t \\<C> uz_ cs.\n       \\<lbrakk>is_float_t t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Relop_f t uz_]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Relop_f t uz_]));\n        const_list cs; \\<not> const_list ($* [Relop_f t uz_]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Relop_f t uz_])) i s'\n                                 vs')\n 2. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 3. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 4. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 7. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 10. \\<And>tf tn tm \\<C> es1 es2 cs.\n        \\<lbrakk>tf = tn _> tm;\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n             const_list cs; \\<not> const_list ($* es1);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C>\n                     \\<lparr>label :=\n                               [tm] @\n                               label\n                                \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n             const_list cs; \\<not> const_list ($* es2);\n             i < length (s_inst \\<S>);\n             length\n              (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             length vs;\n             Option.is_none\n              (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [b_e.If tf es1 es2]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n         const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                  i s' vs')\nA total of 28 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Relop_f t va]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Relop_f t va]))\n  const_list cs\n  \\<not> const_list ($* [Relop_f t va])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Relop_f t va])) i s' vs')", "using progress_binop_relop_f[OF relop_f(2,1,5)]"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Relop_f t va]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Relop_f t va]))\n  const_list cs\n  \\<not> const_list ($* [Relop_f t va])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  ?e = Binop_f t ?fop \\<or> ?e = Relop_f t ?frop \\<Longrightarrow>\n  \\<exists>a s' vs' es'.\n     \\<lparr>?s;?vs;cs @\n                    [$?e]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Relop_f t va])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Relop_f t va])) i s' vs')\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 2. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 3. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 10. \\<And>ia \\<C> ts t1s t2s cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n         const_list cs; \\<not> const_list ($* [Br ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 2. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 3. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 10. \\<And>ia \\<C> ts t1s t2s cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n         const_list cs; \\<not> const_list ($* [Br ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\nA total of 27 subgoals...", "case (convert t1 t2 sx \\<C>)"], ["proof (state)\nthis:\n  t1 \\<noteq> t2\n  (sx = None) =\n  (is_float_t t1 \\<and> is_float_t t2 \\<or>\n   is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2)\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Cvtop t1 Convert t2 sx]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Cvtop t1 Convert t2 sx]))\n  const_list cs\n  \\<not> const_list ($* [Cvtop t1 Convert t2 sx])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 2. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 3. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 10. \\<And>ia \\<C> ts t1s t2s cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n         const_list cs; \\<not> const_list ($* [Br ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\nA total of 27 subgoals...", "obtain v where cs_def:\"cs = [$ C v]\" \"typeof v = t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>cs = [$C v]; typeof v = t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_typeof const_of_const_list[OF _ convert(6)] e_type_const_list[OF convert(6,3)]"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v] : [] _> [?t] \\<Longrightarrow>\n  typeof ?v = ?t\n  length cs = 1 \\<Longrightarrow> \\<exists>v. cs = [$C v]\n  \\<exists>tvs.\n     [t2] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>cs = [$C v]; typeof v = t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n  typeof v = t2\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2 sx \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and> is_int_t t2 \\<and> t_length t1 < t_length t2);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Convert t2 sx]));\n        const_list cs; \\<not> const_list ($* [Cvtop t1 Convert t2 sx]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')\n 2. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 3. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 6. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 9. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 10. \\<And>ia \\<C> ts t1s t2s cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n         const_list cs; \\<not> const_list ($* [Br ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\nA total of 27 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  typeof v = t2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "proof (cases \"cvt t1 sx v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs\n                              (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')\n 2. \\<And>a.\n       \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')", "case None"], ["proof (state)\nthis:\n  cvt t1 sx v = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs\n                              (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')\n 2. \\<And>a.\n       \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')", "thus ?thesis"], ["proof (prove)\nusing this:\n  cvt t1 sx v = None\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.convert_None[OF _ None]] cs_def"], ["proof (prove)\nusing this:\n  cvt t1 sx v = None\n  types_agree ?t1.1 v \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C v,\n                  $Cvtop t1 Convert ?t1.1\n                    sx]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Trap]\\<rparr>\n  cs = [$C v]\n  typeof v = t2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  cvt t1 sx v = None\n  typeof v = ?t1.1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C v,\n                  $Cvtop t1 Convert ?t1.1\n                    sx]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Trap]\\<rparr>\n  cs = [$C v]\n  typeof v = t2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'.\n     Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')", "case (Some a)"], ["proof (state)\nthis:\n  cvt t1 sx v = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>cs = [$C v]; typeof v = t2; cvt t1 sx v = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Convert t2 sx])) i s'\n                                 vs')", "thus ?thesis"], ["proof (prove)\nusing this:\n  cvt t1 sx v = Some a\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.convert_Some[OF _ Some]] cs_def"], ["proof (prove)\nusing this:\n  cvt t1 sx v = Some a\n  types_agree ?t1.1 v \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C v,\n                  $Cvtop t1 Convert ?t1.1\n                    sx]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C a]\\<rparr>\n  cs = [$C v]\n  typeof v = t2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  cvt t1 sx v = Some a\n  typeof v = ?t1.1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C v,\n                  $Cvtop t1 Convert ?t1.1\n                    sx]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C a]\\<rparr>\n  cs = [$C v]\n  typeof v = t2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'.\n     Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs'.\n     Ex (reduce s vs (cs @ ($* [Cvtop t1 Convert t2 sx])) i s' vs')\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 2. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 9. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 10. \\<And>ia \\<C> ts cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n         const_list cs; \\<not> const_list ($* [Br_if ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_if ia])) i s'\n                                  vs')\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 2. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 9. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 10. \\<And>ia \\<C> ts cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n         const_list cs; \\<not> const_list ($* [Br_if ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_if ia])) i s'\n                                  vs')\nA total of 26 subgoals...", "case (reinterpret t1 t2 \\<C>)"], ["proof (state)\nthis:\n  t1 \\<noteq> t2\n  t_length t1 = t_length t2\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2]\n  \\<not> Lfilled 0 ?lholed [$Return]\n          (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i]\n          (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n  const_list cs\n  \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 2. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 9. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 10. \\<And>ia \\<C> ts cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n         const_list cs; \\<not> const_list ($* [Br_if ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_if ia])) i s'\n                                  vs')\nA total of 26 subgoals...", "obtain v where cs_def:\"cs = [$ C v]\" \"typeof v = t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>cs = [$C v]; typeof v = t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_typeof const_of_const_list[OF _ reinterpret(6)] e_type_const_list[OF reinterpret(6,3)]"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> [$C ?v] : [] _> [?t] \\<Longrightarrow>\n  typeof ?v = ?t\n  length cs = 1 \\<Longrightarrow> \\<exists>v. cs = [$C v]\n  \\<exists>tvs.\n     [t2] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>cs = [$C v]; typeof v = t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n  typeof v = t2\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2 \\<C> cs.\n       \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t2];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i]\n                   (cs @ ($* [Cvtop t1 Reinterpret t2 None]));\n        const_list cs;\n        \\<not> const_list ($* [Cvtop t1 Reinterpret t2 None]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs\n                                 (cs @ ($* [Cvtop t1 Reinterpret t2 None]))\n                                 i s' vs')\n 2. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 5. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 8. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 9. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 10. \\<And>ia \\<C> ts cs.\n        \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n         const_list cs; \\<not> const_list ($* [Br_if ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_if ia])) i s'\n                                  vs')\nA total of 26 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  typeof v = t2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Reinterpret t2 None])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.reinterpret]"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  typeof v = t2\n  types_agree ?t1.1 ?v1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ?v1,\n                  $Cvtop ?t2.1 Reinterpret ?t1.1\n                    None]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C wasm_deserialise\n                               (bits ?v1) ?t2.1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Reinterpret t2 None])) i s' vs')", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  typeof v = t2\n  typeof ?v1 = ?t1.1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ?v1,\n                  $Cvtop ?t2.1 Reinterpret ?t1.1\n                    None]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C wasm_deserialise\n                               (bits ?v1) ?t2.1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Cvtop t1 Reinterpret t2 None])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'.\n     Ex (reduce s vs (cs @ ($* [Cvtop t1 Reinterpret t2 None])) i s' vs')\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 3. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 5. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 8. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 9. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 10. \\<And>\\<C> ts is ia t1s t2s cs.\n        \\<lbrakk>list_all\n                  (\\<lambda>i.\n                      i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                  (is @ [ia]);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n         const_list cs; \\<not> const_list ($* [Br_table is ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                  s' vs')\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 3. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 5. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 8. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 9. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 10. \\<And>\\<C> ts is ia t1s t2s cs.\n        \\<lbrakk>list_all\n                  (\\<lambda>i.\n                      i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                  (is @ [ia]);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n         const_list cs; \\<not> const_list ($* [Br_table is ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                  s' vs')\nA total of 25 subgoals...", "case (unreachable \\<C> ts ts')"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unreachable]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unreachable]))\n  const_list cs\n  \\<not> const_list ($* [Unreachable])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> ts ts' cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Unreachable]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Unreachable]));\n        const_list cs; \\<not> const_list ($* [Unreachable]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Unreachable])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 3. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 4. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 5. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 6. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 7. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 8. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 9. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 10. \\<And>\\<C> ts is ia t1s t2s cs.\n        \\<lbrakk>list_all\n                  (\\<lambda>i.\n                      i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                  (is @ [ia]);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n         const_list cs; \\<not> const_list ($* [Br_table is ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                  s' vs')\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unreachable]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unreachable]))\n  const_list cs\n  \\<not> const_list ($* [Unreachable])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unreachable])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.unreachable] progress_L0[OF _ unreachable(4)]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Unreachable]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Unreachable]))\n  const_list cs\n  \\<not> const_list ($* [Unreachable])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lparr>?s;?vs;[$Unreachable]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Trap]\\<rparr>\n  \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unreachable])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Unreachable])) i s' vs')\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 3. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 6. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 7. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 8. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 9. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 10. \\<And>\\<C> ts t1s t2s cs.\n        \\<lbrakk>return \\<C> = Some ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n         const_list cs; \\<not> const_list ($* [Return]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 3. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 6. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 7. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 8. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 9. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 10. \\<And>\\<C> ts t1s t2s cs.\n        \\<lbrakk>return \\<C> = Some ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n         const_list cs; \\<not> const_list ($* [Return]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\nA total of 24 subgoals...", "case (nop \\<C>)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Nop]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Nop]))\n  const_list cs\n  \\<not> const_list ($* [Nop])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Nop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Nop]));\n        const_list cs; \\<not> const_list ($* [Nop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 3. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 6. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 7. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 8. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 9. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 10. \\<And>\\<C> ts t1s t2s cs.\n        \\<lbrakk>return \\<C> = Some ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n         const_list cs; \\<not> const_list ($* [Return]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Nop]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Nop]))\n  const_list cs\n  \\<not> const_list ($* [Nop])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.nop] progress_L0[OF _ nop(4)]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Nop]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Nop]))\n  const_list cs\n  \\<not> const_list ($* [Nop])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lparr>?s;?vs;[$Nop]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[]\\<rparr>\n  \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Nop])) i s' vs')\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 6. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 7. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 8. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 9. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 10. \\<And>ia \\<C> ts ts' cs.\n        \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n         const_list cs; \\<not> const_list ($* [Call ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 6. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 7. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 8. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 9. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 10. \\<And>ia \\<C> ts ts' cs.\n        \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n         const_list cs; \\<not> const_list ($* [Call ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\nA total of 23 subgoals...", "case (drop \\<C> t)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Drop]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Drop]))\n  const_list cs\n  \\<not> const_list ($* [Drop])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 6. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 7. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 8. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 9. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 10. \\<And>ia \\<C> ts ts' cs.\n        \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n         const_list cs; \\<not> const_list ($* [Call ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\nA total of 23 subgoals...", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list drop(4) e_type_const_list[OF drop(4,1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  const_list cs\n  \\<exists>tvs.\n     [t] = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Drop]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Drop]));\n        const_list cs; \\<not> const_list ($* [Drop]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n 2. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 5. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 6. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 7. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 8. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 9. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 10. \\<And>ia \\<C> ts ts' cs.\n        \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n         const_list cs; \\<not> const_list ($* [Call ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.drop] progress_L0[OF _ drop(4)]"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  \\<lparr>?s;?vs;[$C ?v1,\n                  $Drop]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[]\\<rparr>\n  \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Drop])) i s' vs')\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 5. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 6. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 7. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 8. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 9. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 10. \\<And>ia \\<C> t1s t2s cs.\n        \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n         table \\<C> \\<noteq> None;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Call_indirect ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n         const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call_indirect ia]))\n                                  i s' vs')\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 5. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 6. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 7. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 8. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 9. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 10. \\<And>ia \\<C> t1s t2s cs.\n        \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n         table \\<C> \\<noteq> None;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Call_indirect ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n         const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call_indirect ia]))\n                                  i s' vs')\nA total of 22 subgoals...", "case (select \\<C> t)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Select]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Select]))\n  const_list cs\n  \\<not> const_list ($* [Select])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 5. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 6. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 7. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 8. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 9. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 10. \\<And>ia \\<C> t1s t2s cs.\n        \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n         table \\<C> \\<noteq> None;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Call_indirect ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n         const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call_indirect ia]))\n                                  i s' vs')\nA total of 22 subgoals...", "obtain v1 v2 v3 where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [$ C v3] : ([] _> [T_i32])\"\n                               \"cs = [$C v1, $C v2, $ C v3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v3 v1 v2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32];\n         cs = [$C v1, $C v2, $C v3]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_list_split_3[OF select(4,1)] select(4)"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2 c3.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [T_i32] \\<and>\n     cs = [c1, c2, c3]\n  const_list cs\n\ngoal (1 subgoal):\n 1. (\\<And>v3 v1 v2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32];\n         cs = [$C v1, $C v2, $C v3]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2 c3.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c3] : [] _> [T_i32] \\<and>\n     cs = [c1, c2, c3]\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. (\\<And>v3 v1 v2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32];\n         cs = [$C v1, $C v2, $C v3]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list_all_simps(1) e_type_const_unwrap)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32]\n  cs = [$C v1, $C v2, $C v3]\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 5. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 6. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 7. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 8. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 9. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 10. \\<And>ia \\<C> t1s t2s cs.\n        \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n         table \\<C> \\<noteq> None;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Call_indirect ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n         const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call_indirect ia]))\n                                  i s' vs')\nA total of 22 subgoals...", "obtain c3 where c_def:\"v3 = ConstInt32 c3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c3.\n        v3 = ConstInt32 c3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cs_def select(4) const_of_i32[OF _ cs_def(1)]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32]\n  cs = [$C v1, $C v2, $C v3]\n  const_list cs\n  const_list [$C v3] \\<Longrightarrow>\n  \\<exists>c. [$C v3] = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. (\\<And>c3.\n        v3 = ConstInt32 c3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32]\n  cs = [$C v1, $C v2, $C v3]\n  list_all is_const cs\n  list_all is_const [$C v3] \\<Longrightarrow>\n  \\<exists>c. [$C v3] = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. (\\<And>c3.\n        v3 = ConstInt32 c3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v3 = ConstInt32 c3\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 5. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 6. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 7. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 8. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 9. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 10. \\<And>ia \\<C> t1s t2s cs.\n        \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n         table \\<C> \\<noteq> None;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Call_indirect ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n         const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call_indirect ia]))\n                                  i s' vs')\nA total of 22 subgoals...", "have \"\\<exists>a s' vs' es'. \\<lparr>s;vs;[$C v1, $C v2, $ C ConstInt32 c3, $Select]\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"int_eq c3 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  int_eq c3 0\n\ngoal (2 subgoals):\n 1. int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  int_eq c3 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(1)[OF reduce_simple.select_false]"], ["proof (prove)\nusing this:\n  int_eq c3 0\n  int_eq ?n1 0 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ?v1.1, $C ?v2.1, $C ConstInt32 ?n1,\n                  $Select]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ?v2.1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                   $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  \\<not> int_eq c3 0\n\ngoal (1 subgoal):\n 1. \\<not> int_eq c3 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> int_eq c3 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(1)[OF reduce_simple.select_true]"], ["proof (prove)\nusing this:\n  \\<not> int_eq c3 0\n  \\<not> int_eq ?n1 0 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ?v1.1, $C ?v2.1, $C ConstInt32 ?n1,\n                  $Select]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$C ?v1.1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                     $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                   $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                   $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> t cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t, t, T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Select]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Select]));\n        const_list cs; \\<not> const_list ($* [Select]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 4. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 5. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 6. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 7. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 8. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 9. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 10. \\<And>ia \\<C> t1s t2s cs.\n        \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n         table \\<C> \\<noteq> None;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Call_indirect ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n         const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Call_indirect ia]))\n                                  i s' vs')\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                   $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Select])) i s' vs')", "using c_def cs_def"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C v1, $C v2, $C ConstInt32 c3,\n                   $Select]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  v3 = ConstInt32 c3\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v3] : [] _> [T_i32]\n  cs = [$C v1, $C v2, $C v3]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Select])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Select])) i s' vs')\n\ngoal (21 subgoals):\n 1. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 4. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 5. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 6. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 7. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 8. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 9. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n         const_list cs; \\<not> const_list ($* [Get_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                  vs')\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 4. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 5. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 6. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 7. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 8. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 9. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n         const_list cs; \\<not> const_list ($* [Get_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                  vs')\nA total of 21 subgoals...", "case (block tf tn tm \\<C> es)"], ["proof (state)\nthis:\n  tf = tn _> tm\n  \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n  \\<lbrakk>\\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     [tm] @ label \\<C>\\<rparr> \\<turnstile> ?cs : [] _> tn;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* es));\n   const_list ?cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n   length (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n   length vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* es)) i s' vs')\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Block tf es]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Block tf es]))\n  const_list cs\n  \\<not> const_list ($* [Block tf es])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (21 subgoals):\n 1. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Block tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Block tf es]));\n        const_list cs; \\<not> const_list ($* [Block tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Block tf es])) i s'\n                                 vs')\n 2. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 3. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 4. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 5. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 6. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 7. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 8. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 9. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n         const_list cs; \\<not> const_list ($* [Get_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                  vs')\nA total of 21 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Block tf es])) i s' vs')", "using reduce_simple.block[OF block(7), of _ tn tm _ es]\n          e_type_const_list[OF block(7,4)] reduce.intros(1) block(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>length cs = ?n; length tn = ?n; length tm = ?m\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>cs @\n                            [$Block (tn _> tm)\n                               es]\\<rparr> \\<leadsto> \\<lparr>[Label ?m []\n                          (cs @ ($* es))]\\<rparr>\n  \\<exists>tvs.\n     tn = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  tf = tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Block tf es])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Block tf es])) i s' vs')\n\ngoal (20 subgoals):\n 1. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 2. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 3. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 4. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 5. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 6. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 7. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 8. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n         const_list cs; \\<not> const_list ($* [Set_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                  vs')\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 2. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 3. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 4. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 5. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 6. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 7. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 8. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n         const_list cs; \\<not> const_list ($* [Set_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                  vs')\nA total of 20 subgoals...", "case (loop tf tn tm \\<C> es)"], ["proof (state)\nthis:\n  tf = tn _> tm\n  \\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm\n  \\<lbrakk>\\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     [tn] @ label \\<C>\\<rparr> \\<turnstile> ?cs : [] _> tn;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* es));\n   const_list ?cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n   length (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n   length vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* es)) i s' vs')\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Loop tf es]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Loop tf es]))\n  const_list cs\n  \\<not> const_list ($* [Loop tf es])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (20 subgoals):\n 1. \\<And>tf tn tm \\<C> es cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tn] @ label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tn] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Loop tf es]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Loop tf es]));\n        const_list cs; \\<not> const_list ($* [Loop tf es]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Loop tf es])) i s'\n                                 vs')\n 2. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 3. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 4. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 5. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 6. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 7. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 8. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n         const_list cs; \\<not> const_list ($* [Set_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                  vs')\nA total of 20 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Loop tf es])) i s' vs')", "using reduce_simple.loop[OF loop(7), of _ tn tm _ es]\n          e_type_const_list[OF loop(7,4)] reduce.intros(1) loop(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>length cs = ?n; length tn = ?n; length tm = ?m\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>cs @\n                            [$Loop (tn _> tm)\n                               es]\\<rparr> \\<leadsto> \\<lparr>[Label ?n\n                          [$Loop (tn _> tm) es] (cs @ ($* es))]\\<rparr>\n  \\<exists>tvs.\n     tn = [] @ tvs \\<and>\n     length cs = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> cs : [] _> tvs\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  tf = tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Loop tf es])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Loop tf es])) i s' vs')\n\ngoal (19 subgoals):\n 1. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 2. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 3. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 4. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 5. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 6. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 7. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n         const_list cs; \\<not> const_list ($* [Tee_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                  vs')\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 2. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 3. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 4. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 5. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 6. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 7. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n         const_list cs; \\<not> const_list ($* [Tee_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                  vs')\nA total of 19 subgoals...", "case (if_wasm tf tn tm \\<C> es1 es2)"], ["proof (state)\nthis:\n  tf = tn _> tm\n  \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm\n  \\<lbrakk>\\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     [tm] @ label \\<C>\\<rparr> \\<turnstile> ?cs : [] _> tn;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* es1));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* es1));\n   const_list ?cs; \\<not> const_list ($* es1); i < length (s_inst \\<S>);\n   length (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n   length vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* es1)) i s' vs')\n  \\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm\n  \\<lbrakk>\\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     [tm] @ label \\<C>\\<rparr> \\<turnstile> ?cs : [] _> tn;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* es2));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* es2));\n   const_list ?cs; \\<not> const_list ($* es2); i < length (s_inst \\<S>);\n   length (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n   length vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* es2)) i s' vs')\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [b_e.If tf es1 es2]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [b_e.If tf es1 es2]))\n  const_list cs\n  \\<not> const_list ($* [b_e.If tf es1 es2])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (19 subgoals):\n 1. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 2. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 3. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 4. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 5. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 6. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 7. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n         const_list cs; \\<not> const_list ($* [Tee_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                  vs')\nA total of 19 subgoals...", "obtain c1s c2s where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> c1s : ([] _> tn)\"\n                              \"\\<S>\\<bullet>\\<C> \\<turnstile> c2s : ([] _> [T_i32])\"\n                              \"const_list c1s\"\n                              \"const_list c2s\"\n                              \"cs = c1s @ c2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1s c2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> c1s : [] _> tn;\n         \\<S>\\<bullet>\\<C> \\<turnstile> c2s : [] _> [T_i32]; const_list c1s;\n         const_list c2s; cs = c1s @ c2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF if_wasm(9,6)] e_type_const_list"], ["proof (prove)\nusing this:\n  \\<exists>vs1 vs2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> tn \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : tn _> tn @ [T_i32] \\<and>\n     cs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>c1s c2s.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> c1s : [] _> tn;\n         \\<S>\\<bullet>\\<C> \\<turnstile> c2s : [] _> [T_i32]; const_list c1s;\n         const_list c2s; cs = c1s @ c2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> c1s : [] _> tn\n  \\<S>\\<bullet>\\<C> \\<turnstile> c2s : [] _> [T_i32]\n  const_list c1s\n  const_list c2s\n  cs = c1s @ c2s\n\ngoal (19 subgoals):\n 1. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 2. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 3. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 4. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 5. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 6. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 7. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n         const_list cs; \\<not> const_list ($* [Tee_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                  vs')\nA total of 19 subgoals...", "obtain c where c_def: \"c2s = [$ C (ConstInt32 c)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c2s = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_i32 cs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> c1s : [] _> tn\n  \\<S>\\<bullet>\\<C> \\<turnstile> c2s : [] _> [T_i32]\n  const_list c1s\n  const_list c2s\n  cs = c1s @ c2s\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c2s = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c2s = [$C ConstInt32 c]\n\ngoal (19 subgoals):\n 1. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 2. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 3. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 4. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 5. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 6. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 7. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n         const_list cs; \\<not> const_list ($* [Tee_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                  vs')\nA total of 19 subgoals...", "have \"\\<exists>a s' vs' es'. \\<lparr>s;vs;[$ C (ConstInt32 c), $ If tf es1 es2]\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"int_eq c 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  int_eq c 0\n\ngoal (2 subgoals):\n 1. int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  int_eq c 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(1)[OF reduce_simple.if_false]"], ["proof (prove)\nusing this:\n  int_eq c 0\n  int_eq ?n1 0 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?n1,\n                  $b_e.If ?tf1 ?e1s1\n                    ?e2s1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$Block\n                              ?tf1 ?e2s1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $b_e.If tf es1\n                     es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  \\<not> int_eq c 0\n\ngoal (1 subgoal):\n 1. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> int_eq c 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(1)[OF reduce_simple.if_true]"], ["proof (prove)\nusing this:\n  \\<not> int_eq c 0\n  \\<not> int_eq ?n1 0 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?n1,\n                  $b_e.If ?tf1 ?e1s1\n                    ?e2s1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$Block\n                              ?tf1 ?e1s1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $b_e.If tf es1\n                       es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $b_e.If tf es1\n                     es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $b_e.If tf es1\n                     es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (19 subgoals):\n 1. \\<And>tf tn tm \\<C> es1 es2 cs.\n       \\<lbrakk>tf = tn _> tm;\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es1));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es1));\n            const_list cs; \\<not> const_list ($* es1);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es1)) i s' vs');\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [tm] @\n                              label \\<C>\\<rparr> \\<turnstile> cs : [] _> tn;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es2));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es2));\n            const_list cs; \\<not> const_list ($* es2);\n            i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es2)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> tn @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [b_e.If tf es1 es2]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [b_e.If tf es1 es2]));\n        const_list cs; \\<not> const_list ($* [b_e.If tf es1 es2]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2]))\n                                 i s' vs')\n 2. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 3. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 4. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 5. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 6. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 7. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n         const_list cs; \\<not> const_list ($* [Tee_local ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                  vs')\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $b_e.If tf es1\n                     es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2])) i s' vs')", "using c_def cs_def progress_L0"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $b_e.If tf es1\n                     es2]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  c2s = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> c1s : [] _> tn\n  \\<S>\\<bullet>\\<C> \\<turnstile> c2s : [] _> [T_i32]\n  const_list c1s\n  const_list c2s\n  cs = c1s @ c2s\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'.\n     Ex (reduce s vs (cs @ ($* [b_e.If tf es1 es2])) i s' vs')\n\ngoal (18 subgoals):\n 1. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 2. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 3. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 4. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 5. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 6. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n         const_list cs; \\<not> const_list ($* [Get_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Get_global ia])) i\n                                  s' vs')\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 2. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 3. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 4. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 5. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 6. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n         const_list cs; \\<not> const_list ($* [Get_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Get_global ia])) i\n                                  s' vs')\nA total of 18 subgoals...", "case (br i \\<C> ts t1s t2s)"], ["proof (state)\nthis:\n  i < length (label \\<C>)\n  label \\<C> ! i = ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Br i]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Br i]))\n  const_list cs\n  \\<not> const_list ($* [Br i])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (18 subgoals):\n 1. \\<And>ia \\<C> ts t1s t2s cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br ia]));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br ia]));\n        const_list cs; \\<not> const_list ($* [Br ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br ia])) i s' vs')\n 2. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 3. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 4. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 5. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 6. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n         const_list cs; \\<not> const_list ($* [Get_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Get_global ia])) i\n                                  s' vs')\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  i < length (label \\<C>)\n  label \\<C> ! i = ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Br i]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Br i]))\n  const_list cs\n  \\<not> const_list ($* [Br i])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br i])) i s' vs')", "using Lfilled.intros(1)[OF br(6), of _ \"[]\" \"[$Br i]\"]"], ["proof (prove)\nusing this:\n  i < length (label \\<C>)\n  label \\<C> ! i = ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Br i]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Br i]))\n  const_list cs\n  \\<not> const_list ($* [Br i])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  ?lholed = LBase cs [] \\<Longrightarrow>\n  Lfilled 0 ?lholed [$Br i] (cs @ [$Br i] @ [])\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br i])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br i])) i s' vs')\n\ngoal (17 subgoals):\n 1. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 2. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 3. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 4. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 5. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         is_mut (global \\<C> ! ia);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n         const_list cs; \\<not> const_list ($* [Set_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_global ia])) i\n                                  s' vs')\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 2. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 3. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 4. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 5. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         is_mut (global \\<C> ! ia);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n         const_list cs; \\<not> const_list ($* [Set_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_global ia])) i\n                                  s' vs')\nA total of 17 subgoals...", "case (br_if j \\<C> ts)"], ["proof (state)\nthis:\n  j < length (label \\<C>)\n  label \\<C> ! j = ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Br_if j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Br_if j]))\n  const_list cs\n  \\<not> const_list ($* [Br_if j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (17 subgoals):\n 1. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 2. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 3. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 4. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 5. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         is_mut (global \\<C> ! ia);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n         const_list cs; \\<not> const_list ($* [Set_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_global ia])) i\n                                  s' vs')\nA total of 17 subgoals...", "obtain cs1 cs2 where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : ([] _> ts)\"\n                              \"\\<S>\\<bullet>\\<C> \\<turnstile> cs2 : ([] _> [T_i32])\"\n                              \"const_list cs1\"\n                              \"const_list cs2\"\n                              \"cs = cs1 @ cs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]; const_list cs1;\n         const_list cs2; cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF br_if(6,3)] e_type_const_list"], ["proof (prove)\nusing this:\n  \\<exists>vs1 vs2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts _> ts @ [T_i32] \\<and>\n     cs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]; const_list cs1;\n         const_list cs2; cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]\n  const_list cs1\n  const_list cs2\n  cs = cs1 @ cs2\n\ngoal (17 subgoals):\n 1. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 2. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 3. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 4. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 5. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         is_mut (global \\<C> ! ia);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n         const_list cs; \\<not> const_list ($* [Set_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_global ia])) i\n                                  s' vs')\nA total of 17 subgoals...", "obtain c where c_def:\"cs2 = [$C ConstInt32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs2 = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_i32[OF cs_def(4,2)]"], ["proof (prove)\nusing this:\n  \\<exists>c. cs2 = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs2 = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs2 = [$C ConstInt32 c]\n\ngoal (17 subgoals):\n 1. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 2. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 3. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 4. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 5. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         is_mut (global \\<C> ! ia);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n         const_list cs; \\<not> const_list ($* [Set_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_global ia])) i\n                                  s' vs')\nA total of 17 subgoals...", "have \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs2@($* [Br_if j])\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"int_eq c 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  int_eq c 0\n\ngoal (2 subgoals):\n 1. int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  int_eq c 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using c_def reduce.intros(1)[OF reduce_simple.br_if_false]"], ["proof (prove)\nusing this:\n  int_eq c 0\n  cs2 = [$C ConstInt32 c]\n  int_eq ?n1 0 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?n1,\n                  $Br_if\n                    ?i1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* [Br_if\n                        j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  \\<not> int_eq c 0\n\ngoal (1 subgoal):\n 1. \\<not> int_eq c 0 \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> int_eq c 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using c_def reduce.intros(1)[OF reduce_simple.br_if_true]"], ["proof (prove)\nusing this:\n  \\<not> int_eq c 0\n  cs2 = [$C ConstInt32 c]\n  \\<not> int_eq ?n1 0 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?n1,\n                  $Br_if\n                    ?i1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$Br\n                            ?i1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* [Br_if\n                          j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* [Br_if\n                        j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* [Br_if\n                        j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (17 subgoals):\n 1. \\<And>ia \\<C> ts cs.\n       \\<lbrakk>ia < length (label \\<C>); label \\<C> ! ia = ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_if ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_if ia]));\n        const_list cs; \\<not> const_list ($* [Br_if ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_if ia])) i s' vs')\n 2. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 3. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 4. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 5. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 10. \\<And>ia \\<C> t cs.\n        \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n         is_mut (global \\<C> ! ia);\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n         const_list cs; \\<not> const_list ($* [Set_global ia]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Set_global ia])) i\n                                  s' vs')\nA total of 17 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* [Br_if\n                        j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br_if j])) i s' vs')", "using cs_def(5) progress_L0[OF _ cs_def(3), of s vs \"cs2 @ ($* [Br_if j])\" _ _ _ _ \"[]\"]"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* [Br_if\n                        j])\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  cs = cs1 @ cs2\n  \\<lparr>s;vs;cs2 @\n               ($* [Br_if\n                     j])\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>s;vs;cs1 @\n               (cs2 @ ($* [Br_if j])) @\n               []\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs1 @\n                    ?es' @ []\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br_if j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br_if j])) i s' vs')\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 2. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 3. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 4. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 10. \\<And>\\<C> n a tp_sx t off cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         load_store_t_bounds a (option_projl tp_sx) t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Load t tp_sx a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Load t tp_sx a off]));\n         const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Load t tp_sx a off])) i s' vs')\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 2. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 3. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 4. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 10. \\<And>\\<C> n a tp_sx t off cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         load_store_t_bounds a (option_projl tp_sx) t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Load t tp_sx a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Load t tp_sx a off]));\n         const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Load t tp_sx a off])) i s' vs')\nA total of 16 subgoals...", "case (br_table \\<C> ts \"is\" i' t1s t2s)"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n   (is @ [i'])\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Br_table is i']))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Br_table is i']))\n  const_list cs\n  \\<not> const_list ($* [Br_table is i'])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 2. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 3. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 4. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 10. \\<And>\\<C> n a tp_sx t off cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         load_store_t_bounds a (option_projl tp_sx) t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Load t tp_sx a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Load t tp_sx a off]));\n         const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Load t tp_sx a off])) i s' vs')\nA total of 16 subgoals...", "obtain cs1 cs2 where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : ([]_> (t1s @ ts))\"\n                              \"\\<S>\\<bullet>\\<C> \\<turnstile> cs2 : ([] _> [T_i32])\"\n                              \"const_list cs1\"\n                              \"const_list cs2\"\n                              \"cs = cs1 @ cs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s @ ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]; const_list cs1;\n         const_list cs2; cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF br_table(5), of \\<S> \\<C> \"(t1s @ ts)\" \"[T_i32]\"]\n          e_type_const_list[of _ \\<S> \\<C> \"t1s @ ts\" \"(t1s @ ts) @ [T_i32]\"]\n          br_table(2,5)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> (t1s @ ts) @\n      [T_i32] \\<Longrightarrow>\n  \\<exists>vs1 vs2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> t1s @ ts \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : t1s @\n    ts _> (t1s @ ts) @ [T_i32] \\<and>\n     cs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<lbrakk>const_list ?vs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?vs : t1s @\n  ts _> (t1s @ ts) @ [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       (t1s @ ts) @ [T_i32] = (t1s @ ts) @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32]\n  const_list cs\n\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s @ ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]; const_list cs1;\n         const_list cs2; cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> (t1s @ ts) @\n      [T_i32] \\<Longrightarrow>\n  \\<exists>vs1 vs2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> t1s @ ts \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : t1s @\n    ts _> (t1s @ ts) @ [T_i32] \\<and>\n     cs = vs1 @ vs2 \\<and>\n     list_all is_const vs1 \\<and> list_all is_const vs2\n  \\<lbrakk>list_all is_const ?vs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?vs : t1s @\n  ts _> (t1s @ ts) @ [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       (t1s @ ts) @ [T_i32] = (t1s @ ts) @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32]\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s @ ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32];\n         list_all is_const cs1; list_all is_const cs2;\n         cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s @ ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]\n  const_list cs1\n  const_list cs2\n  cs = cs1 @ cs2\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 2. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 3. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 4. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 10. \\<And>\\<C> n a tp_sx t off cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         load_store_t_bounds a (option_projl tp_sx) t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Load t tp_sx a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Load t tp_sx a off]));\n         const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Load t tp_sx a off])) i s' vs')\nA total of 16 subgoals...", "obtain c where c_def:\"cs2 = [$C ConstInt32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs2 = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_i32[OF cs_def(4,2)]"], ["proof (prove)\nusing this:\n  \\<exists>c. cs2 = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs2 = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs2 = [$C ConstInt32 c]\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 2. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 3. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 4. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 10. \\<And>\\<C> n a tp_sx t off cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         load_store_t_bounds a (option_projl tp_sx) t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Load t tp_sx a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Load t tp_sx a off]));\n         const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Load t tp_sx a off])) i s' vs')\nA total of 16 subgoals...", "have \"\\<exists>a s' vs' es'. \\<lparr>s;vs;[$C ConstInt32 c, $Br_table is i']\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"(nat_of_int c) < length is\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case True"], ["proof (state)\nthis:\n  nat_of_int c < length is\n\ngoal (2 subgoals):\n 1. nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<not> nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(1)[OF reduce_simple.br_table[OF True]]"], ["proof (prove)\nusing this:\n  \\<lparr>?s;?vs;[$C ConstInt32 c,\n                  $Br_table is\n                    ?i1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$Br\n                            (is ! nat_of_int c)]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Br_table is\n                     i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case False"], ["proof (state)\nthis:\n  \\<not> nat_of_int c < length is\n\ngoal (1 subgoal):\n 1. \\<not> nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "hence \"length is \\<le> nat_of_int c\""], ["proof (prove)\nusing this:\n  \\<not> nat_of_int c < length is\n\ngoal (1 subgoal):\n 1. length is \\<le> nat_of_int c", "by fastforce"], ["proof (state)\nthis:\n  length is \\<le> nat_of_int c\n\ngoal (1 subgoal):\n 1. \\<not> nat_of_int c < length is \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  length is \\<le> nat_of_int c\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(1)[OF reduce_simple.br_table_length]"], ["proof (prove)\nusing this:\n  length is \\<le> nat_of_int c\n  length ?is1 \\<le> nat_of_int ?c1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?c1,\n                  $Br_table ?is1\n                    ?i1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[$Br\n                            ?i1]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Br_table is\n                       i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Br_table is\n                     i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Br_table is\n                     i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> ts is ia t1s t2s cs.\n       \\<lbrakk>list_all\n                 (\\<lambda>i.\n                     i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n                 (is @ [ia]);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Br_table is ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Br_table is ia]));\n        const_list cs; \\<not> const_list ($* [Br_table is ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Br_table is ia])) i\n                                 s' vs')\n 2. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 3. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 4. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 9. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 10. \\<And>\\<C> n a tp_sx t off cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         load_store_t_bounds a (option_projl tp_sx) t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Load t tp_sx a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i]\n                    (cs @ ($* [Load t tp_sx a off]));\n         const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs\n                                  (cs @ ($* [Load t tp_sx a off])) i s' vs')\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Br_table is\n                     i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Br_table is i'])) i s' vs')", "using c_def cs_def progress_L0"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Br_table is\n                     i']\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  cs2 = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s @ ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]\n  const_list cs1\n  const_list cs2\n  cs = cs1 @ cs2\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Br_table is i'])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Br_table is i'])) i s' vs')\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 2. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 3. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 9. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 10. \\<And>\\<C> n a tp t off cs.\n        \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Store t tp a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n         const_list cs; \\<not> const_list ($* [Store t tp a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Store t tp a off]))\n                                  i s' vs')\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 2. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 3. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 9. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 10. \\<And>\\<C> n a tp t off cs.\n        \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Store t tp a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n         const_list cs; \\<not> const_list ($* [Store t tp a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Store t tp a off]))\n                                  i s' vs')\nA total of 15 subgoals...", "case (return \\<C> ts t1s t2s)"], ["proof (state)\nthis:\n  return \\<C> = Some ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Return]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Return]))\n  const_list cs\n  \\<not> const_list ($* [Return])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> ts t1s t2s cs.\n       \\<lbrakk>return \\<C> = Some ts;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Return]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Return]));\n        const_list cs; \\<not> const_list ($* [Return]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n 2. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 3. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 8. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 9. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 10. \\<And>\\<C> n a tp t off cs.\n        \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return]\n                    (cs @ ($* [Store t tp a off]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n         const_list cs; \\<not> const_list ($* [Store t tp a off]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>aa s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Store t tp a off]))\n                                  i s' vs')\nA total of 15 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  return \\<C> = Some ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Return]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Return]))\n  const_list cs\n  \\<not> const_list ($* [Return])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Return])) i s' vs')", "using Lfilled.intros(1)[OF return(5), of _ \"[]\" \"[$Return]\"]"], ["proof (prove)\nusing this:\n  return \\<C> = Some ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Return]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Return]))\n  const_list cs\n  \\<not> const_list ($* [Return])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  ?lholed = LBase cs [] \\<Longrightarrow>\n  Lfilled 0 ?lholed [$Return] (cs @ [$Return] @ [])\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Return])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Return])) i s' vs')\n\ngoal (14 subgoals):\n 1. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 2. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 8. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 9. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n         const_list cs; \\<not> const_list ($* [Current_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                  s' vs')\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 2. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 8. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 9. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n         const_list cs; \\<not> const_list ($* [Current_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                  s' vs')\nA total of 14 subgoals...", "case (call j \\<C>)"], ["proof (state)\nthis:\n  j < length (func_t \\<C>)\n  func_t \\<C> ! j = ts _> ts'\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Call j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Call j]))\n  const_list cs\n  \\<not> const_list ($* [Call j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (14 subgoals):\n 1. \\<And>ia \\<C> ts ts' cs.\n       \\<lbrakk>ia < length (func_t \\<C>); func_t \\<C> ! ia = ts _> ts';\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call ia]));\n        const_list cs; \\<not> const_list ($* [Call ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call ia])) i s' vs')\n 2. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 7. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 8. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 9. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n         const_list cs; \\<not> const_list ($* [Current_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                  s' vs')\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Call j])) i s' vs')", "using progress_L0[OF reduce.intros(2) call(6)]"], ["proof (prove)\nusing this:\n  \\<lparr>?s;?vs;cs @\n                 [$Call ?j1] @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;cs @\n                       [Callcl (sfunc ?s ?i ?j1)] @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Call j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Call j])) i s' vs')\n\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "case (call_indirect j \\<C> t1s t2s)"], ["proof (state)\nthis:\n  j < length (types_t \\<C>)\n  types_t \\<C> ! j = t1s _> t2s\n  table \\<C> \\<noteq> None\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Call_indirect j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Call_indirect j]))\n  const_list cs\n  \\<not> const_list ($* [Call_indirect j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "obtain cs1 cs2 where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : ([]_> t1s)\"\n                              \"\\<S>\\<bullet>\\<C> \\<turnstile> cs2 : ([] _> [T_i32])\"\n                              \"const_list cs1\"\n                              \"const_list cs2\"\n                              \"cs = cs1 @ cs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]; const_list cs1;\n         const_list cs2; cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF call_indirect(7), of \\<S> \\<C> t1s \"[T_i32]\"]\n          e_type_const_list[of _ \\<S> \\<C> t1s \"t1s @ [T_i32]\"]\n          call_indirect(4)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32] \\<Longrightarrow>\n  \\<exists>vs1 vs2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> t1s \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : t1s _> t1s @ [T_i32] \\<and>\n     cs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<lbrakk>const_list ?vs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?vs : t1s _> t1s @ [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       t1s @ [T_i32] = t1s @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32]\n\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]; const_list cs1;\n         const_list cs2; cs = cs1 @ cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]\n  const_list cs1\n  const_list cs2\n  cs = cs1 @ cs2\n\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "obtain c where c_def:\"cs2 = [$C ConstInt32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs2 = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cs_def(2,4) const_of_i32"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]\n  const_list cs2\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs2 = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs2 = [$C ConstInt32 c]\n\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "consider \n    (1) \"\\<exists>cl tf. stab s i (nat_of_int c) = Some cl \\<and> stypes s i j = tf \\<and> cl_type cl = tf\"\n  | (2) \"\\<exists>cl. stab s i (nat_of_int c) = Some cl \\<and> stypes s i j \\<noteq> cl_type cl\"\n  | (3) \"stab s i (nat_of_int c) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>cl tf.\n                stab s i (nat_of_int c) = Some cl \\<and>\n                stypes s i j = tf \\<and> cl_type cl = tf \\<Longrightarrow>\n             thesis;\n     \\<exists>cl.\n        stab s i (nat_of_int c) = Some cl \\<and>\n        stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n     thesis;\n     stab s i (nat_of_int c) = None \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis option.collapse)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>cl tf.\n              stab s i (nat_of_int c) = Some cl \\<and>\n              stypes s i j = tf \\<and> cl_type cl = tf \\<Longrightarrow>\n           ?thesis;\n   \\<exists>cl.\n      stab s i (nat_of_int c) = Some cl \\<and>\n      stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n   ?thesis;\n   stab s i (nat_of_int c) = None \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "hence \"\\<exists>a s' vs' es'. \\<lparr>s;vs;[$C ConstInt32 c, $Call_indirect j]\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>cl tf.\n              stab s i (nat_of_int c) = Some cl \\<and>\n              stypes s i j = tf \\<and> cl_type cl = tf \\<Longrightarrow>\n           ?thesis;\n   \\<exists>cl.\n      stab s i (nat_of_int c) = Some cl \\<and>\n      stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n   ?thesis;\n   stab s i (nat_of_int c) = None \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>cl tf.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j = tf \\<and> cl_type cl = tf \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<exists>cl.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case 1"], ["proof (state)\nthis:\n  \\<exists>cl tf.\n     stab s i (nat_of_int c) = Some cl \\<and>\n     stypes s i j = tf \\<and> cl_type cl = tf\n\ngoal (3 subgoals):\n 1. \\<exists>cl tf.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j = tf \\<and> cl_type cl = tf \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<exists>cl.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 3. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>cl tf.\n     stab s i (nat_of_int c) = Some cl \\<and>\n     stypes s i j = tf \\<and> cl_type cl = tf\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(3)"], ["proof (prove)\nusing this:\n  \\<exists>cl tf.\n     stab s i (nat_of_int c) = Some cl \\<and>\n     stypes s i j = tf \\<and> cl_type cl = tf\n  \\<lbrakk>stab ?s ?i (nat_of_int ?c) = Some ?cl; stypes ?s ?i ?j = ?tf;\n   cl_type ?cl = ?tf\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;[$C ConstInt32 ?c,\n                                    $Call_indirect\n?j]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Callcl ?cl]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>cl.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>cl.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case 2"], ["proof (state)\nthis:\n  \\<exists>cl.\n     stab s i (nat_of_int c) = Some cl \\<and>\n     stypes s i j \\<noteq> cl_type cl\n\ngoal (2 subgoals):\n 1. \\<exists>cl.\n       stab s i (nat_of_int c) = Some cl \\<and>\n       stypes s i j \\<noteq> cl_type cl \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>cl.\n     stab s i (nat_of_int c) = Some cl \\<and>\n     stypes s i j \\<noteq> cl_type cl\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(4)"], ["proof (prove)\nusing this:\n  \\<exists>cl.\n     stab s i (nat_of_int c) = Some cl \\<and>\n     stypes s i j \\<noteq> cl_type cl\n  stab ?s ?i (nat_of_int ?c) = Some ?cl \\<and>\n  stypes ?s ?i ?j \\<noteq> cl_type ?cl \\<or>\n  stab ?s ?i (nat_of_int ?c) = None \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?c,\n                  $Call_indirect\n                    ?j]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Trap]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case 3"], ["proof (state)\nthis:\n  stab s i (nat_of_int c) = None\n\ngoal (1 subgoal):\n 1. stab s i (nat_of_int c) = None \\<Longrightarrow>\n    \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  stab s i (nat_of_int c) = None\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(4)"], ["proof (prove)\nusing this:\n  stab s i (nat_of_int c) = None\n  stab ?s ?i (nat_of_int ?c) = Some ?cl \\<and>\n  stypes ?s ?i ?j \\<noteq> cl_type ?cl \\<or>\n  stab ?s ?i (nat_of_int ?c) = None \\<Longrightarrow>\n  \\<lparr>?s;?vs;[$C ConstInt32 ?c,\n                  $Call_indirect\n                    ?j]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Trap]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Call_indirect\n                       j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (13 subgoals):\n 1. \\<And>ia \\<C> t1s t2s cs.\n       \\<lbrakk>ia < length (types_t \\<C>); types_t \\<C> ! ia = t1s _> t2s;\n        table \\<C> \\<noteq> None;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s @ [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Call_indirect ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Call_indirect ia]));\n        const_list cs; \\<not> const_list ($* [Call_indirect ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Call_indirect ia])) i\n                                 s' vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 6. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 7. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 8. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 10. \\<And>\\<C> n cs.\n        \\<lbrakk>memory \\<C> = Some n;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n         const_list cs; \\<not> const_list ($* [Grow_memory]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                  vs')\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Call_indirect j])) i s' vs')", "using c_def cs_def progress_L0"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Call_indirect\n                     j]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  cs2 = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> t1s\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> [T_i32]\n  const_list cs1\n  const_list cs2\n  cs = cs1 @ cs2\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Call_indirect j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Call_indirect j])) i s' vs')\n\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "case (get_local j \\<C> t)"], ["proof (state)\nthis:\n  j < length (local \\<C>)\n  local \\<C> ! j = t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Get_local j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Get_local j]))\n  const_list cs\n  \\<not> const_list ($* [Get_local j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "obtain v vj vj' where v_def:\"v = vs ! j\" \"vj = (take j vs)\" \"vj' = (drop (j+1) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v vj vj'.\n        \\<lbrakk>v = vs ! j; vj = take j vs; vj' = drop (j + 1) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = vs ! j\n  vj = take j vs\n  vj' = drop (j + 1) vs\n\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "have j_def:\"j < length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length vs", "using get_local(1,9)"], ["proof (prove)\nusing this:\n  j < length (local \\<C>)\n  length (local \\<C>) = length vs\n\ngoal (1 subgoal):\n 1. j < length vs", "by simp"], ["proof (state)\nthis:\n  j < length vs\n\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "hence vj_len:\"length vj = j\""], ["proof (prove)\nusing this:\n  j < length vs\n\ngoal (1 subgoal):\n 1. length vj = j", "using v_def(2)"], ["proof (prove)\nusing this:\n  j < length vs\n  vj = take j vs\n\ngoal (1 subgoal):\n 1. length vj = j", "by fastforce"], ["proof (state)\nthis:\n  length vj = j\n\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "hence \"vs = vj @ [v] @ vj'\""], ["proof (prove)\nusing this:\n  length vj = j\n\ngoal (1 subgoal):\n 1. vs = vj @ [v] @ vj'", "using v_def id_take_nth_drop j_def"], ["proof (prove)\nusing this:\n  length vj = j\n  v = vs ! j\n  vj = take j vs\n  vj' = drop (j + 1) vs\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n  j < length vs\n\ngoal (1 subgoal):\n 1. vs = vj @ [v] @ vj'", "by fastforce"], ["proof (state)\nthis:\n  vs = vj @ [v] @ vj'\n\ngoal (12 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_local ia]));\n        const_list cs; \\<not> const_list ($* [Get_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 5. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 6. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 7. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 9. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 10. \\<And>\\<C> cs.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n         const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* [])) i s' vs')\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  vs = vj @ [v] @ vj'\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Get_local j])) i s' vs')", "using progress_L0[OF reduce.intros(8)[OF vj_len, of s v vj'] get_local(6)]"], ["proof (prove)\nusing this:\n  vs = vj @ [v] @ vj'\n  \\<lparr>s;vj @\n            [v] @\n            vj';cs @\n                [$Get_local j] @\n                ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>s;vj @\n                 [v] @ vj';cs @ [$C v] @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Get_local j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Get_local j])) i s' vs')\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "case (set_local j \\<C> t)"], ["proof (state)\nthis:\n  j < length (local \\<C>)\n  local \\<C> ! j = t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Set_local j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Set_local j]))\n  const_list cs\n  \\<not> const_list ($* [Set_local j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "obtain v vj vj' where v_def:\"v = vs ! j\" \"vj = (take j vs)\" \"vj' = (drop (j+1) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v vj vj'.\n        \\<lbrakk>v = vs ! j; vj = take j vs; vj' = drop (j + 1) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = vs ! j\n  vj = take j vs\n  vj' = drop (j + 1) vs\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "obtain v' where cs_def: \"cs = [$C v']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'. cs = [$C v'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_const_list set_local(3,6) e_type_const_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  const_list cs\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v'. cs = [$C v'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v']\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "have j_def:\"j < length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length vs", "using set_local(1,9)"], ["proof (prove)\nusing this:\n  j < length (local \\<C>)\n  length (local \\<C>) = length vs\n\ngoal (1 subgoal):\n 1. j < length vs", "by simp"], ["proof (state)\nthis:\n  j < length vs\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "hence vj_len:\"length vj = j\""], ["proof (prove)\nusing this:\n  j < length vs\n\ngoal (1 subgoal):\n 1. length vj = j", "using v_def(2)"], ["proof (prove)\nusing this:\n  j < length vs\n  vj = take j vs\n\ngoal (1 subgoal):\n 1. length vj = j", "by fastforce"], ["proof (state)\nthis:\n  length vj = j\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "hence \"vs = vj @ [v] @ vj'\""], ["proof (prove)\nusing this:\n  length vj = j\n\ngoal (1 subgoal):\n 1. vs = vj @ [v] @ vj'", "using v_def id_take_nth_drop j_def"], ["proof (prove)\nusing this:\n  length vj = j\n  v = vs ! j\n  vj = take j vs\n  vj' = drop (j + 1) vs\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n  j < length vs\n\ngoal (1 subgoal):\n 1. vs = vj @ [v] @ vj'", "by fastforce"], ["proof (state)\nthis:\n  vs = vj @ [v] @ vj'\n\ngoal (11 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_local ia]));\n        const_list cs; \\<not> const_list ($* [Set_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 4. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 5. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 6. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 8. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 9. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s e t3s cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<C> \\<turnstile> [e] : t2s _> t3s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n             \\<And>lholed.\n                \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n             \\<And>lholed i.\n                \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n             const_list cs; \\<not> const_list ($* [e]);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n         \\<And>lholed.\n            \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n         \\<And>lholed i.\n            \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n         const_list cs; \\<not> const_list ($* es @ [e]);\n         i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  vs = vj @ [v] @ vj'\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Set_local j])) i s' vs')", "using reduce.intros(9)[OF vj_len, of s v vj' v' i] cs_def"], ["proof (prove)\nusing this:\n  vs = vj @ [v] @ vj'\n  \\<lparr>s;vj @\n            [v] @\n            vj';[$C v',\n                 $Set_local\n                   j]\\<rparr> \\<leadsto>_ i \\<lparr>s;vj @\n                [v'] @ vj';[]\\<rparr>\n  cs = [$C v']\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Set_local j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Set_local j])) i s' vs')\n\ngoal (10 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 4. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 5. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s ts cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n         const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 4. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 5. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s ts cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n         const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (tee_local i \\<C> t)"], ["proof (state)\nthis:\n  i < length (local \\<C>)\n  local \\<C> ! i = t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Tee_local i]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Tee_local i]))\n  const_list cs\n  \\<not> const_list ($* [Tee_local i])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (10 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 4. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 5. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s ts cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n         const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list tee_local(3,6) e_type_const_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  const_list cs\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (10 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (local \\<C>); local \\<C> ! ia = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Tee_local ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Tee_local ia]));\n        const_list cs; \\<not> const_list ($* [Tee_local ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Tee_local ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 3. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 4. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 5. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 7. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 8. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 10. \\<And>\\<C> es t1s t2s ts cs.\n        \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n         \\<And>cs.\n            \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n             \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n             \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n             const_list cs; \\<not> const_list ($* es);\n             i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n             Option.is_none (memory \\<C>) =\n             Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n            \\<Longrightarrow> \\<exists>a s' vs'.\n                                 Ex (reduce s vs (cs @ ($* es)) i s' vs');\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n         \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n         \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n         const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n         length (local \\<C>) = length vs;\n         Option.is_none (memory \\<C>) =\n         Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'.\n                             Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Tee_local i])) i s' vs')", "using reduce.intros(1)[OF reduce_simple.tee_local] tee_local(6)"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  is_const ?v1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[?v1,\n                  $Tee_local\n                    ?i1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[?v1, ?v1,\n                          $Set_local ?i1]\\<rparr>\n  const_list cs\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Tee_local i])) i s' vs')", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  is_const ?v1 \\<Longrightarrow>\n  \\<lparr>?s;?vs;[?v1,\n                  $Tee_local\n                    ?i1]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[?v1, ?v1,\n                          $Set_local ?i1]\\<rparr>\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Tee_local i])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Tee_local i])) i s' vs')\n\ngoal (9 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 3. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 4. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 7. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 3. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 4. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 7. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (get_global j \\<C> t)"], ["proof (state)\nthis:\n  j < length (global \\<C>)\n  tg_t (global \\<C> ! j) = t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Get_global j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Get_global j]))\n  const_list cs\n  \\<not> const_list ($* [Get_global j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (9 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Get_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Get_global ia]));\n        const_list cs; \\<not> const_list ($* [Get_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Get_global ia])) i s'\n                                 vs')\n 2. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 3. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 4. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 6. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 7. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 9. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  j < length (global \\<C>)\n  tg_t (global \\<C> ! j) = t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Get_global j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Get_global j]))\n  const_list cs\n  \\<not> const_list ($* [Get_global j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Get_global j])) i s' vs')", "using reduce.intros(10)[of s vs j i] progress_L0"], ["proof (prove)\nusing this:\n  j < length (global \\<C>)\n  tg_t (global \\<C> ! j) = t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Get_global j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Get_global j]))\n  const_list cs\n  \\<not> const_list ($* [Get_global j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lparr>s;vs;[$Get_global\n                  j]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[$C sglob_val s i\n                       j]\\<rparr>\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Get_global j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Get_global j])) i s' vs')\n\ngoal (8 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 2. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 3. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 2. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 3. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (set_global j \\<C> t)"], ["proof (state)\nthis:\n  j < length (global \\<C>)\n  tg_t (global \\<C> ! j) = t\n  is_mut (global \\<C> ! j)\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Set_global j]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Set_global j]))\n  const_list cs\n  \\<not> const_list ($* [Set_global j])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (8 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 2. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 3. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain v where \"cs = [$C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using const_of_const_list set_global(4,7) e_type_const_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?cs = 1; const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v. ?cs = [$C v]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t]\n  const_list cs\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>v. cs = [$C v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C v]\n\ngoal (8 subgoals):\n 1. \\<And>ia \\<C> t cs.\n       \\<lbrakk>ia < length (global \\<C>); tg_t (global \\<C> ! ia) = t;\n        is_mut (global \\<C> ! ia);\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Set_global ia]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Set_global ia]));\n        const_list cs; \\<not> const_list ($* [Set_global ia]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Set_global ia])) i s'\n                                 vs')\n 2. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 3. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 5. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 6. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 8. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  cs = [$C v]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Set_global j])) i s' vs')", "using reduce.intros(11)[of s i j v _ vs]"], ["proof (prove)\nusing this:\n  cs = [$C v]\n  supdate_glob s i j v = ?s' \\<Longrightarrow>\n  \\<lparr>s;vs;[$C v,\n                $Set_global\n                  j]\\<rparr> \\<leadsto>_ i \\<lparr>?s';vs;[]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Set_global j])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Set_global j])) i s' vs')\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 2. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 2. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (load \\<C> n a tp_sx t off)"], ["proof (state)\nthis:\n  memory \\<C> = Some n\n  load_store_t_bounds a (option_projl tp_sx) t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Load t tp_sx a off]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Load t tp_sx a off]))\n  const_list cs\n  \\<not> const_list ($* [Load t tp_sx a off])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 2. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain c where c_def: \"cs = [$C ConstInt32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_i32 load(3,6) e_type_const_unwrap"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32]\n  const_list cs\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all is_const ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32]\n  list_all is_const cs\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C ConstInt32 c]\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 2. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain j where mem_some:\"smem_ind s i = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using load(1,10)"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding smem_ind_def"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        inst.mem (inst s ! i) = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 2. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "have \"\\<exists>a' s' vs' es'. \\<lparr>s;vs;[$C ConstInt32 c, $Load t tp_sx a off]\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases tp_sx)"], ["proof (state)\ngoal (2 subgoals):\n 1. tp_sx = None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case None"], ["proof (state)\nthis:\n  tp_sx = None\n\ngoal (2 subgoals):\n 1. tp_sx = None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "note tp_none = None"], ["proof (state)\nthis:\n  tp_sx = None\n\ngoal (2 subgoals):\n 1. tp_sx = None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"load ((mem s)!j) (nat_of_int c) off (t_length t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case None"], ["proof (state)\nthis:\n  load (s.mem s ! j) (nat_of_int c) off (t_length t) = None\n\ngoal (2 subgoals):\n 1. load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(13)[OF mem_some _ None, of vs] tp_none load(2)"], ["proof (prove)\nusing this:\n  s.mem s ! j = s.mem s ! j \\<Longrightarrow>\n  \\<lparr>s;vs;[$C ConstInt32 c,\n                $Load t None ?a\n                  off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n  tp_sx = None\n  load_store_t_bounds a (option_projl tp_sx) t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  load (s.mem s ! j) (nat_of_int c) off (t_length t) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       load (s.mem s ! j) (nat_of_int c) off (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(12)[OF mem_some _ Some, of vs] tp_none load(2)"], ["proof (prove)\nusing this:\n  s.mem s ! j = s.mem s ! j \\<Longrightarrow>\n  \\<lparr>s;vs;[$C ConstInt32 c,\n                $Load t None ?a\n                  off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[$C wasm_deserialise\n                         a t]\\<rparr>\n  tp_sx = None\n  load_store_t_bounds a__ (option_projl tp_sx) t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  tp_sx = Some a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "obtain tp sx where tp_some:\"tp_sx = Some (tp, sx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tp sx.\n        tp_sx = Some (tp, sx) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Some"], ["proof (prove)\nusing this:\n  tp_sx = Some a\n\ngoal (1 subgoal):\n 1. (\\<And>tp sx.\n        tp_sx = Some (tp, sx) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  tp_sx = Some (tp, sx)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp_sx = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"load_packed sx ((mem s)!j) (nat_of_int c) off (tp_length tp) (t_length t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n     (t_length t) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n        (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case None"], ["proof (state)\nthis:\n  load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n   (t_length t) =\n  None\n\ngoal (2 subgoals):\n 1. load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n     (t_length t) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n        (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(15)[OF mem_some _ None, of vs] tp_some load(2)"], ["proof (prove)\nusing this:\n  s.mem s ! j = s.mem s ! j \\<Longrightarrow>\n  \\<lparr>s;vs;[$C ConstInt32 c,\n                $Load t (Some (tp, sx)) ?a\n                  off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n  tp_sx = Some (tp, sx)\n  load_store_t_bounds a__ (option_projl tp_sx) t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n        (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n        (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n   (t_length t) =\n  Some a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       load_packed sx (s.mem s ! j) (nat_of_int c) off (tp_length tp)\n        (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c,\n                        $Load t tp_sx a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(14)[OF mem_some _ Some, of vs] tp_some load(2)"], ["proof (prove)\nusing this:\n  s.mem s ! j = s.mem s ! j \\<Longrightarrow>\n  \\<lparr>s;vs;[$C ConstInt32 c,\n                $Load t (Some (tp, sx)) ?a\n                  off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[$C wasm_deserialise\n                         a t]\\<rparr>\n  tp_sx = Some (tp, sx)\n  load_store_t_bounds a__ (option_projl tp_sx) t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c,\n                     $Load t tp_sx a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> n a tp_sx t off cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        load_store_t_bounds a (option_projl tp_sx) t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return]\n                   (cs @ ($* [Load t tp_sx a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Load t tp_sx a off]));\n        const_list cs; \\<not> const_list ($* [Load t tp_sx a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Load t tp_sx a off]))\n                                 i s' vs')\n 2. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 4. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 5. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 7. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "then"], ["proof (chain)\npicking this:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>aa s' vs'.\n       Ex (reduce s vs (cs @ ($* [Load t tp_sx a off])) i s' vs')", "using c_def progress_L0"], ["proof (prove)\nusing this:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c,\n                   $Load t tp_sx a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  cs = [$C ConstInt32 c]\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>aa s' vs'.\n       Ex (reduce s vs (cs @ ($* [Load t tp_sx a off])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>aa s' vs'.\n     Ex (reduce s vs (cs @ ($* [Load t tp_sx a off])) i s' vs')\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (store \\<C> n a tp t off)"], ["proof (state)\nthis:\n  memory \\<C> = Some n\n  load_store_t_bounds a tp t\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Store t tp a off]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Store t tp a off]))\n  const_list cs\n  \\<not> const_list ($* [Store t tp a off])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain cs' v where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> [cs'] : ([] _> [T_i32])\"\n                            \"\\<S>\\<bullet>\\<C> \\<turnstile> [$ C v] : ([] _> [t])\"\n                            \"cs = [cs',$ C v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs' v.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [cs'] : [] _> [T_i32];\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : [] _> [t];\n         cs = [cs', $C v]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_list_split_2[OF store(6,3)] e_type_const_unwrap"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [T_i32] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and> const_list [c1] \\<and> const_list [c2]\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n\ngoal (1 subgoal):\n 1. (\\<And>cs' v.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [cs'] : [] _> [T_i32];\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : [] _> [t];\n         cs = [cs', $C v]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<exists>c1 c2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c1] : [] _> [T_i32] \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [c2] : [] _> [t] \\<and>\n     cs = [c1, c2] \\<and>\n     list_all is_const [c1] \\<and> list_all is_const [c2]\n  is_const ?e \\<Longrightarrow> \\<exists>v. ?e = $C v\n\ngoal (1 subgoal):\n 1. (\\<And>cs' v.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> [cs'] : [] _> [T_i32];\n         \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : [] _> [t];\n         cs = [cs', $C v]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [cs'] : [] _> [T_i32]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : [] _> [t]\n  cs = [cs', $C v]\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "have t_def:\"typeof v = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = t", "using cs_def(2) b_e_type_value[OF unlift_b_e[of \\<S> \\<C> \"[C v]\" \"([] _> [t])\"]]"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : [] _> [t]\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> $* [C v] : [] _> [t];\n   C v = C ?v\\<rbrakk>\n  \\<Longrightarrow> [t] = [] @ [typeof ?v]\n\ngoal (1 subgoal):\n 1. typeof v = t", "by fastforce"], ["proof (state)\nthis:\n  typeof v = t\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain j where mem_some:\"smem_ind s i = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using store(1,10)"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding smem_ind_def"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        inst.mem (inst s ! i) = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain c where c_def:\"cs' = $C ConstInt32 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs' = $C ConstInt32 c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_i32[OF _ cs_def(1)] cs_def(3) store(6)"], ["proof (prove)\nusing this:\n  const_list [cs'] \\<Longrightarrow> \\<exists>c. [cs'] = [$C ConstInt32 c]\n  cs = [cs', $C v]\n  const_list cs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs' = $C ConstInt32 c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  list_all is_const [cs'] \\<Longrightarrow>\n  \\<exists>c. [cs'] = [$C ConstInt32 c]\n  cs = [cs', $C v]\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs' = $C ConstInt32 c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs' = $C ConstInt32 c\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "have \"\\<exists>a' s' vs' es'. \\<lparr>s;vs;[$C ConstInt32 c, $C v, $Store t tp a off]\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases tp)"], ["proof (state)\ngoal (2 subgoals):\n 1. tp = None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case None"], ["proof (state)\nthis:\n  tp = None\n\ngoal (2 subgoals):\n 1. tp = None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "note tp_none = None"], ["proof (state)\nthis:\n  tp = None\n\ngoal (2 subgoals):\n 1. tp = None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case None"], ["proof (state)\nthis:\n  store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) = None\n\ngoal (2 subgoals):\n 1. store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>aa.\n       store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(17)[OF _ mem_some _ None, of vs] t_def tp_none store(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>types_agree t v; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t None ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n  typeof v = t\n  tp = None\n  load_store_t_bounds a tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>typeof v = t; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t None ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n  typeof v = t\n  tp = None\n  load_store_t_bounds a tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       store (s.mem s ! j) (nat_of_int c) off (bits v) (t_length t) =\n       Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(16)[OF _ mem_some _ Some, of vs] t_def tp_none store(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>types_agree t v; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t None ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s\n                    \\<lparr>s.mem := (s.mem s)[j := a]\\<rparr>;vs;[]\\<rparr>\n  typeof v = t\n  tp = None\n  load_store_t_bounds a__ tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>typeof v = t; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t None ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s\n                    \\<lparr>s.mem := (s.mem s)[j := a]\\<rparr>;vs;[]\\<rparr>\n  typeof v = t\n  tp = None\n  load_store_t_bounds a__ tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  tp = Some a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "note tp_some = Some"], ["proof (state)\nthis:\n  tp = Some a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       tp = Some aa \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof (cases \"store_packed (s.mem s ! j) (nat_of_int c) off (bits v) (tp_length a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. store_packed (s.mem s ! j) (nat_of_int c) off (bits v) (tp_length a) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>ab.\n       store_packed (s.mem s ! j) (nat_of_int c) off (bits v)\n        (tp_length a) =\n       Some ab \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case None"], ["proof (state)\nthis:\n  store_packed (s.mem s ! j) (nat_of_int c) off (bits v) (tp_length a) =\n  None\n\ngoal (2 subgoals):\n 1. store_packed (s.mem s ! j) (nat_of_int c) off (bits v) (tp_length a) =\n    None \\<Longrightarrow>\n    \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n 2. \\<And>ab.\n       store_packed (s.mem s ! j) (nat_of_int c) off (bits v)\n        (tp_length a) =\n       Some ab \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(19)[OF _ mem_some _ None, of t vs] t_def tp_some store(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>types_agree t v; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t (Some a) ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n  typeof v = t\n  tp = Some a\n  load_store_t_bounds a__ tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>typeof v = t; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t (Some a) ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;[Trap]\\<rparr>\n  typeof v = t\n  tp = Some a\n  load_store_t_bounds a__ tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>ab.\n       store_packed (s.mem s ! j) (nat_of_int c) off (bits v)\n        (tp_length a) =\n       Some ab \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab.\n       store_packed (s.mem s ! j) (nat_of_int c) off (bits v)\n        (tp_length a) =\n       Some ab \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  store_packed (s.mem s ! j) (nat_of_int c) off (bits v) (tp_length aa__) =\n  Some a\n\ngoal (1 subgoal):\n 1. \\<And>ab.\n       store_packed (s.mem s ! j) (nat_of_int c) off (bits v)\n        (tp_length aa__) =\n       Some ab \\<Longrightarrow>\n       \\<exists>a' s' vs' es'.\n          \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                        $Store t tp a__\n                          off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using reduce.intros(18)[OF _ mem_some _ Some, of t vs] t_def tp_some store(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>types_agree t v; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t (Some aa__) ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s\n                    \\<lparr>s.mem := (s.mem s)[j := a]\\<rparr>;vs;[]\\<rparr>\n  typeof v = t\n  tp = Some aa__\n  load_store_t_bounds a__ tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "unfolding types_agree_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>typeof v = t; s.mem s ! j = s.mem s ! j\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                                  $Store t (Some aa__) ?a\n                                    off]\\<rparr> \\<leadsto>_ i \\<lparr>s\n                    \\<lparr>s.mem := (s.mem s)[j := a]\\<rparr>;vs;[]\\<rparr>\n  typeof v = t\n  tp = Some aa__\n  load_store_t_bounds a__ tp t\n\ngoal (1 subgoal):\n 1. \\<exists>a' s' vs' es'.\n       \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                     $Store t tp a__\n                       off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a__\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> n a tp t off cs.\n       \\<lbrakk>memory \\<C> = Some n; load_store_t_bounds a tp t;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32, t];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Store t tp a off]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Store t tp a off]));\n        const_list cs; \\<not> const_list ($* [Store t tp a off]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Store t tp a off])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 3. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 4. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 6. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "then"], ["proof (chain)\npicking this:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>aa s' vs'.\n       Ex (reduce s vs (cs @ ($* [Store t tp a off])) i s' vs')", "using c_def cs_def progress_L0"], ["proof (prove)\nusing this:\n  \\<exists>a' s' vs' es'.\n     \\<lparr>s;vs;[$C ConstInt32 c, $C v,\n                   $Store t tp a\n                     off]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  cs' = $C ConstInt32 c\n  \\<S>\\<bullet>\\<C> \\<turnstile> [cs'] : [] _> [T_i32]\n  \\<S>\\<bullet>\\<C> \\<turnstile> [$C v] : [] _> [t]\n  cs = [cs', $C v]\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>aa s' vs'.\n       Ex (reduce s vs (cs @ ($* [Store t tp a off])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>aa s' vs'.\n     Ex (reduce s vs (cs @ ($* [Store t tp a off])) i s' vs')\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (current_memory \\<C> n)"], ["proof (state)\nthis:\n  memory \\<C> = Some n\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Current_memory]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Current_memory]))\n  const_list cs\n  \\<not> const_list ($* [Current_memory])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain j where mem_some:\"smem_ind s i = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using current_memory(1,9)"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding smem_ind_def"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        inst.mem (inst s ! i) = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Current_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Current_memory]));\n        const_list cs; \\<not> const_list ($* [Current_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Current_memory])) i\n                                 s' vs')\n 2. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 3. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 5. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Current_memory])) i s' vs')", "using progress_L0[OF reduce.intros(20)[OF mem_some] current_memory(5), of _ _ vs \"[]\"]"], ["proof (prove)\nusing this:\n  smem_ind s i = Some j\n  \\<lbrakk>s.mem s ! j = ?m1; mem_size ?m1 = ?n1\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;cs @\n                                 [$Current_memory] @\n                                 []\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;cs @\n                                 [$C ConstInt32 (int_of_nat ?n1)] @\n                                 []\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'.\n       Ex (reduce s vs (cs @ ($* [Current_memory])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Current_memory])) i s' vs')\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (grow_memory \\<C> n)"], ["proof (state)\nthis:\n  memory \\<C> = Some n\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32]\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* [Grow_memory]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* [Grow_memory]))\n  const_list cs\n  \\<not> const_list ($* [Grow_memory])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain c where c_def:\"cs = [$C ConstInt32 c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const_of_i32 grow_memory(2,5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list ?cs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?cs : [] _> [T_i32]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c. ?cs = [$C ConstInt32 c]\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32]\n  const_list cs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        cs = [$C ConstInt32 c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  cs = [$C ConstInt32 c]\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain j where mem_some:\"smem_ind s i = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using grow_memory(1,9)"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        smem_ind s i = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding smem_ind_def"], ["proof (prove)\nusing this:\n  memory \\<C> = Some n\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        inst.mem (inst s ! i) = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  smem_ind s i = Some j\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> n cs.\n       \\<lbrakk>memory \\<C> = Some n;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [T_i32];\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [Grow_memory]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [Grow_memory]));\n        const_list cs; \\<not> const_list ($* [Grow_memory]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [Grow_memory])) i s'\n                                 vs')\n 2. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 4. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Grow_memory])) i s' vs')", "using reduce.intros(22)[OF mem_some, of _] c_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>s.mem s ! j = ?m; mem_size ?m = ?n\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;?vs;[$C ConstInt32 ?c,\n                                   $Grow_memory]\\<rparr> \\<leadsto>_ i \\<lparr>s;?vs;[$C ConstInt32\n              int32_minus_one]\\<rparr>\n  cs = [$C ConstInt32 c]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Grow_memory])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [Grow_memory])) i s' vs')\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (empty \\<C>)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* []))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* []))\n  const_list cs\n  \\<not> const_list ($* [])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> [];\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* []));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* []));\n        const_list cs; \\<not> const_list ($* []); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* [])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 3. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* []))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* []))\n  const_list cs\n  \\<not> const_list ($* [])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [])) i s' vs')", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> []\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* []))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* []))\n  list_all is_const cs\n  \\<not> list_all is_const ($* [])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [])) i s' vs')", "by simp"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* [])) i s' vs')\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (composition \\<C> es t1s t2s e t3s)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> t1s;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* es));\n   const_list ?cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n   length (local \\<C>) = length vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* es)) i s' vs')\n  \\<C> \\<turnstile> [e] : t2s _> t3s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> t2s;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* [e]));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* [e]));\n   const_list ?cs; \\<not> const_list ($* [e]); i < length (s_inst \\<S>);\n   length (local \\<C>) = length vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* [e])) i s' vs')\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es @ [e]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es @ [e]))\n  const_list cs\n  \\<not> const_list ($* es @ [e])\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "consider (1) \"\\<not> const_list ($* es)\" | (2) \"const_list ($* es)\" \"\\<not> const_list ($*[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> const_list ($* es) \\<Longrightarrow> thesis;\n     \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using composition(9)"], ["proof (prove)\nusing this:\n  \\<not> const_list ($* es @ [e])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> const_list ($* es) \\<Longrightarrow> thesis;\n     \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<not> list_all is_const ($* es @ [e])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> list_all is_const ($* es) \\<Longrightarrow> thesis;\n     \\<lbrakk>list_all is_const ($* es);\n      \\<not> list_all is_const ($* [e])\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> const_list ($* es) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> es t1s t2s e t3s cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t2s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* [e]));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* [e]));\n            const_list cs; \\<not> const_list ($* [e]);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* [e])) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n        \\<And>lholed.\n           \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es @ [e]));\n        \\<And>lholed i.\n           \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es @ [e]));\n        const_list cs; \\<not> const_list ($* es @ [e]);\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> const_list ($* es) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> const_list ($* es) \\<Longrightarrow>\n    \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "case 1"], ["proof (state)\nthis:\n  \\<not> const_list ($* es)\n\ngoal (2 subgoals):\n 1. \\<not> const_list ($* es) \\<Longrightarrow>\n    \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "have \"(\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es)))\"\n         \"(\\<And>i lholed. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es))) &&&\n    (\\<And>i lholed. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "fix lholed"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "assume \"Lfilled 0 lholed [$Return] (cs @ ($* es))\""], ["proof (state)\nthis:\n  Lfilled 0 lholed [$Return] (cs @ ($* es))\n\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "hence \"\\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\""], ["proof (prove)\nusing this:\n  Lfilled 0 lholed [$Return] (cs @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs @ ($* es) = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))", "case (L0 vs es')"], ["proof (state)\nthis:\n  cs @ ($* es) = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs @ ($* es) = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs @ ($* es) = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))", "using Lfilled.intros(1)[of \"vs\" _ \"es'@ ($*[e])\" \"[$Return]\"]"], ["proof (prove)\nusing this:\n  cs @ ($* es) = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n  \\<lbrakk>const_list vs; ?lholed = LBase vs (es' @ ($* [e]))\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed [$Return]\n                     (vs @ [$Return] @ es' @ ($* [e]))\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))", "by (metis append.assoc map_append)"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))", "qed simp"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\n\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. False", "using composition(6)"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs @ ($* es @ [e]))\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "fix i lholed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "assume \"Lfilled 0 lholed [$Br i] (cs @ ($* es))\""], ["proof (state)\nthis:\n  Lfilled 0 lholed [$Br i] (cs @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "hence \"\\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\""], ["proof (prove)\nusing this:\n  Lfilled 0 lholed [$Br i] (cs @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs @ ($* es) = vs @ [$Br i] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es''; Lfilled k l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))", "case (L0 vs es')"], ["proof (state)\nthis:\n  cs @ ($* es) = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs @ ($* es) = vs @ [$Br i] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es''; Lfilled k l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs @ ($* es) = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))", "using Lfilled.intros(1)[of \"vs\" _ \"es'@ ($*[e])\" \"[$Br i]\"]"], ["proof (prove)\nusing this:\n  cs @ ($* es) = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n  \\<lbrakk>const_list vs; ?lholed = LBase vs (es' @ ($* [e]))\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed [$Br i]\n                     (vs @ [$Br i] @ es' @ ($* [e]))\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))", "by (metis append.assoc map_append)"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es''; Lfilled k l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))", "qed simp"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs @ ($* es)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. False", "using composition(7)"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs @ ($* es @ [e]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es @ [e]))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es))\n\ngoal (2 subgoals):\n 1. \\<not> const_list ($* es) \\<Longrightarrow>\n    \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n 2. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "using composition(2)[OF composition(5) _ _ composition(8) 1 composition(10,11,12)] progress_L0[of s vs \"(cs @ ($* es))\" i _ _ _ \"[]\" \"$*[e]\"]"], ["proof (prove)\nusing this:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es))\n  \\<lbrakk>\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (cs @ ($* es)) i s' vs')\n  \\<lbrakk>\\<lparr>s;vs;cs @\n                        ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list []\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[] @\n                                 (cs @ ($* es)) @\n                                 ($* [e])\\<rparr> \\<leadsto>_ i \\<lparr>?s';?vs';[] @\n     ?es' @ ($* [e])\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es))\n  \\<lbrakk>\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (cs @ ($* es)) i s' vs')\n  \\<lbrakk>\\<lparr>s;vs;cs @\n                        ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>?s';?vs';?es'\\<rparr>;\n   list_all is_const []\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[] @\n                                 (cs @ ($* es)) @\n                                 ($* [e])\\<rparr> \\<leadsto>_ i \\<lparr>?s';?vs';[] @\n     ?es' @ ($* [e])\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "case 2"], ["proof (state)\nthis:\n  const_list ($* es)\n  \\<not> const_list ($* [e])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "hence \"const_list (cs@($* es))\""], ["proof (prove)\nusing this:\n  const_list ($* es)\n  \\<not> const_list ($* [e])\n\ngoal (1 subgoal):\n 1. const_list (cs @ ($* es))", "using composition(8)"], ["proof (prove)\nusing this:\n  const_list ($* es)\n  \\<not> const_list ($* [e])\n  const_list cs\n\ngoal (1 subgoal):\n 1. const_list (cs @ ($* es))", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  list_all is_const ($* es)\n  \\<not> list_all is_const ($* [e])\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. list_all is_const (cs @ ($* es))", "by simp"], ["proof (state)\nthis:\n  const_list (cs @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "moreover"], ["proof (state)\nthis:\n  const_list (cs @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "have \"\\<S>\\<bullet>\\<C> \\<turnstile> (cs@($* es)) : ([] _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s", "using composition(5) e_typing_s_typing.intros(1)[OF composition(1)] e_type_comp_conc"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s\n  ?\\<S>\\<bullet>\\<C> \\<turnstile> $* es : t1s _> t2s\n  \\<lbrakk>?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n               ?es' : ?t1s _> ?t3s\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list ($* es); \\<not> const_list ($* [e])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs'.\n                         Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "ultimately"], ["proof (chain)\npicking this:\n  const_list (cs @ ($* es))\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s", "show ?thesis"], ["proof (prove)\nusing this:\n  const_list (cs @ ($* es))\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "using composition(4)[of \"(cs@($* es))\"] 2(2) composition(6,7) composition(10-)"], ["proof (prove)\nusing this:\n  const_list (cs @ ($* es))\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs @ ($* es) : [] _> t2s;\n   \\<And>lholed.\n      \\<not> Lfilled 0 lholed [$Return] ((cs @ ($* es)) @ ($* [e]));\n   \\<And>lholed i.\n      \\<not> Lfilled 0 lholed [$Br i] ((cs @ ($* es)) @ ($* [e]));\n   const_list (cs @ ($* es)); \\<not> const_list ($* [e]);\n   i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs ((cs @ ($* es)) @ ($* [e])) i s' vs')\n  \\<not> const_list ($* [e])\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es @ [e]))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es @ [e]))\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es @ [e])) i s' vs')\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "case (weakening \\<C> es t1s t2s ts)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> t1s;\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (?cs @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (?cs @ ($* es));\n   const_list ?cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n   length (local \\<C>) = length vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (?cs @ ($* es)) i s' vs')\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es))\n  const_list cs\n  \\<not> const_list ($* es)\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "obtain cs1 cs2 where cs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : ([] _> ts)\"\n                              \"\\<S>\\<bullet>\\<C> \\<turnstile> cs2 : ([] _> t1s)\"\n                              \"cs = cs1 @ cs2\"\n                              \"const_list cs1\"\n                              \"const_list cs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> t1s; cs = cs1 @ cs2;\n         const_list cs1; const_list cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF weakening(6,3)] e_type_const_list[of _ \\<S> \\<C> \"ts\" \"ts @ t1s\"]"], ["proof (prove)\nusing this:\n  \\<exists>vs1 vs2.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts _> ts @ t1s \\<and>\n     cs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<lbrakk>const_list ?vs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?vs : ts _> ts @ t1s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ts @ t1s = ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       \\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n\ngoal (1 subgoal):\n 1. (\\<And>cs1 cs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> ts;\n         \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> t1s; cs = cs1 @ cs2;\n         const_list cs1; const_list cs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs1 : [] _> ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs2 : [] _> t1s\n  cs = cs1 @ cs2\n  const_list cs1\n  const_list cs2\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "have \"(\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs2 @ ($* es)))\"\n       \"(\\<And>i lholed. \\<not> Lfilled 0 lholed [$Br i] (cs2 @ ($* es)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs2 @ ($* es))) &&&\n    (\\<And>i lholed. \\<not> Lfilled 0 lholed [$Br i] (cs2 @ ($* es)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs2 @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "fix lholed"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs2 @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "assume \"Lfilled 0 lholed [$Return] (cs2 @ ($* es))\""], ["proof (state)\nthis:\n  Lfilled 0 lholed [$Return] (cs2 @ ($* es))\n\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs2 @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "hence \"\\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))\""], ["proof (prove)\nusing this:\n  Lfilled 0 lholed [$Return] (cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs2 @ ($* es) = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return]\n                             (cs1 @ cs2 @ ($* es))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs2 @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return]\n                             (cs1 @ cs2 @ ($* es))", "case (L0 vs es')"], ["proof (state)\nthis:\n  cs2 @ ($* es) = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs2 @ ($* es) = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return]\n                             (cs1 @ cs2 @ ($* es))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs2 @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return]\n                             (cs1 @ cs2 @ ($* es))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs2 @ ($* es) = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))", "using Lfilled.intros(1)[of \"cs1 @ vs\" _ \"es'\" \"[$Return]\"] cs_def(4)"], ["proof (prove)\nusing this:\n  cs2 @ ($* es) = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n  \\<lbrakk>const_list (cs1 @ vs); ?lholed = LBase (cs1 @ vs) es'\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed [$Return]\n                     ((cs1 @ vs) @ [$Return] @ es')\n  const_list cs1\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs2 @ ($* es) = vs @ [$Return] @ es'\n  list_all is_const vs\n  lholed = LBase vs es'\n  \\<lbrakk>list_all is_const (cs1 @ vs);\n   ?lholed = LBase (cs1 @ vs) es'\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed [$Return]\n                     ((cs1 @ vs) @ [$Return] @ es')\n  list_all is_const cs1\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs2 @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Return]\n                             (cs1 @ cs2 @ ($* es))", "qed simp"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))\n\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       Lfilled 0 lholed [$Return] (cs2 @ ($* es)) \\<Longrightarrow> False\n 2. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. False", "using weakening(4) cs_def(3)"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Return] (cs1 @ cs2 @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Return] (cs @ ($* es))\n  cs = cs1 @ cs2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "fix i lholed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "assume \"Lfilled 0 lholed [$Br i] (cs2 @ ($* es))\""], ["proof (state)\nthis:\n  Lfilled 0 lholed [$Br i] (cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "hence \"\\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\""], ["proof (prove)\nusing this:\n  Lfilled 0 lholed [$Br i] (cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs2 @ ($* es) = vs @ [$Br i] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs2 @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es''; Lfilled k l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "case (L0 vs es')"], ["proof (state)\nthis:\n  cs2 @ ($* es) = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>cs2 @ ($* es) = vs @ [$Br i] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\n 2. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs2 @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es''; Lfilled k l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs2 @ ($* es) = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "using Lfilled.intros(1)[of \"cs1 @ vs\" _ \"es'\" \"[$Br i]\"] cs_def(4)"], ["proof (prove)\nusing this:\n  cs2 @ ($* es) = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n  \\<lbrakk>const_list (cs1 @ vs); ?lholed = LBase (cs1 @ vs) es'\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed [$Br i] ((cs1 @ vs) @ [$Br i] @ es')\n  const_list cs1\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs2 @ ($* es) = vs @ [$Br i] @ es'\n  list_all is_const vs\n  lholed = LBase vs es'\n  \\<lbrakk>list_all is_const (cs1 @ vs);\n   ?lholed = LBase (cs1 @ vs) es'\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed [$Br i] ((cs1 @ vs) @ [$Br i] @ es')\n  list_all is_const cs1\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' k lfilledk.\n       \\<lbrakk>0 = k + 1;\n        cs2 @ ($* es) = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es''; Lfilled k l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))", "qed simp"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<And>i lholed.\n       Lfilled 0 lholed [$Br i] (cs2 @ ($* es)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. False", "using weakening(5) cs_def(3)"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled 0 lholed' [$Br i] (cs1 @ cs2 @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs @ ($* es))\n  cs = cs1 @ cs2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs2 @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "hence \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs2@($*es)\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs2 @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs2 @ ($* es))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using weakening(2)[OF cs_def(2) _ _ cs_def(5) weakening(7)] weakening(8-)"], ["proof (prove)\nusing this:\n  \\<not> Lfilled 0 ?lholed [$Return] (cs2 @ ($* es))\n  \\<not> Lfilled 0 ?lholed [$Br ?i] (cs2 @ ($* es))\n  \\<lbrakk>\\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs2 @ ($* es));\n   \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs2 @ ($* es));\n   i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs'.\n                       Ex (reduce s vs (cs2 @ ($* es)) i s' vs')\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs2 @\n                    ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> es t1s t2s ts cs.\n       \\<lbrakk>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> t1s;\n            \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n            \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n            const_list cs; \\<not> const_list ($* es);\n            i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs (cs @ ($* es)) i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts @ t1s;\n        \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* es));\n        \\<And>lholed i. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* es));\n        const_list cs; \\<not> const_list ($* es); i < length (s_inst \\<S>);\n        length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vs (cs @ ($* es)) i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es)) i s' vs')", "using progress_L0[OF _ cs_def(4), of s vs \"cs2 @ ($* es)\" i _ _ _ \"[]\"] cs_def(3)"], ["proof (prove)\nusing this:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs2 @\n                  ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n  \\<lparr>s;vs;cs2 @\n               ($* es)\\<rparr> \\<leadsto>_ i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>s;vs;cs1 @\n               (cs2 @ ($* es)) @\n               []\\<rparr> \\<leadsto>_ i \\<lparr>?s';?vs';cs1 @\n                   ?es' @ []\\<rparr>\n  cs = cs1 @ cs2\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es)) i s' vs')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs'. Ex (reduce s vs (cs @ ($* es)) i s' vs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_e:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;cs_es : ts'\"\n          \"\\<And> k lholed. \\<not>(Lfilled k lholed [$Return] cs_es)\"\n          \"\\<And> i k lholed. (Lfilled k lholed [$Br (i)] cs_es) \\<Longrightarrow> i < k\"\n          \"cs_es \\<noteq> [Trap]\"\n          \"\\<not> const_list (cs_es)\"\n          \"store_typing s \\<S>\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "fix \\<C> cs es ts_c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "have prems1:\n      \"\\<S>\\<bullet>\\<C> \\<turnstile> es : (ts_c _> ts') \\<Longrightarrow>\n       \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : ([] _> ts') \\<Longrightarrow>\n       cs_es = cs@es \\<Longrightarrow>\n       const_list cs \\<Longrightarrow>\n       \\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> ts_c) \\<Longrightarrow>\n       (\\<And> k lholed. \\<not>(Lfilled k lholed [$Return] cs_es)) \\<Longrightarrow>\n       (\\<And> i k lholed. (Lfilled k lholed [$Br (i)] cs_es) \\<Longrightarrow> i < k) \\<Longrightarrow>\n       cs_es \\<noteq> [Trap] \\<Longrightarrow>\n       \\<not> const_list (cs_es) \\<Longrightarrow>\n       store_typing s \\<S> \\<Longrightarrow>\n       i < length (s_inst \\<S>) \\<Longrightarrow>\n       length (local \\<C>) = length (vs) \\<Longrightarrow>\n       Option.is_none (memory \\<C>) = Option.is_none (inst.mem ((inst s)!i))  \\<Longrightarrow>\n         \\<exists>a s' vs' cs_es'. \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';cs_es'\\<rparr>\"\n   and prems2:\n      \"\\<S>\\<bullet>None \\<tturnstile>_i vs;cs_es : ts' \\<Longrightarrow>\n       (\\<And> k lholed. \\<not>(Lfilled k lholed [$Return] cs_es)) \\<Longrightarrow>\n       (\\<And> i k lholed. (Lfilled k lholed [$Br (i)] cs_es) \\<Longrightarrow> i < k) \\<Longrightarrow>\n       cs_es \\<noteq> [Trap] \\<Longrightarrow>\n       \\<not> const_list (cs_es) \\<Longrightarrow>\n       store_typing s \\<S> \\<Longrightarrow>\n         \\<exists>a s' vs' cs_es'. \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';cs_es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : ts_c _> ts';\n      \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n      const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n      \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n      \\<And>i k lholed.\n         Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n      cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n      i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n      Option.is_none (memory \\<C>) =\n      Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n     \\<Longrightarrow> \\<exists>a s' vs' cs_es'.\n                          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs_es'\\<rparr>) &&&\n    (\\<lbrakk>\\<S>\\<bullet>None \\<tturnstile>_ i vs;cs_es : ts';\n      \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n      \\<And>i k lholed.\n         Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n      cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n      store_typing s \\<S>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>a s' vs' cs_es'.\n                          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs_es'\\<rparr>)", "proof (induction arbitrary: vs ts_c ts' i cs_es cs rule: e_typing_s_typing.inducts)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<C> b_es tf \\<S> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<C> \\<turnstile> b_es : tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ ($* b_es); const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> es t1s t2s e t3s vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ [e]; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ es @ [e]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 6. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 7. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 8. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (1 \\<C> b_es tf \\<S>)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> b_es : tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ ($* b_es)\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> b_es tf \\<S> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<C> \\<turnstile> b_es : tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ ($* b_es); const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> es t1s t2s e t3s vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ [e]; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ es @ [e]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 6. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 7. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 8. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "hence \"\\<C> \\<turnstile> b_es : (ts_c _> ts')\""], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> b_es : tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ ($* b_es)\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> b_es : ts_c _> ts'", "using e_type_comp_conc1[of \\<S> \\<C> cs \"($* b_es)\" \"[]\" \"ts'\"] unlift_b_e"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> b_es : tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ ($* b_es)\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs @\n                                 ($* b_es) : [] _> ts' \\<Longrightarrow>\n  \\<exists>ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> $* b_es : ts'' _> ts'\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> b_es : ts_c _> ts'", "by (metis e_type_const_conv_vs typing_map_typeof)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> b_es : ts_c _> ts'\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> b_es tf \\<S> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<C> \\<turnstile> b_es : tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ ($* b_es); const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> es t1s t2s e t3s vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ [e]; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ es @ [e]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 6. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 7. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 8. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "then"], ["proof (chain)\npicking this:\n  \\<C> \\<turnstile> b_es : ts_c _> ts'", "show ?case"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> b_es : ts_c _> ts'\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using progress_b_e[OF _ 1(5) _ _ 1(4)] 1(3,4,9) list_all_append 1"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> b_es : ts_c _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> ?b_es : ts_c _> ?ts';\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* ?b_es));\n   \\<And>i lholed. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* ?b_es));\n   \\<not> const_list ($* ?b_es); ?i < length (s_inst \\<S>);\n   length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst ?s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;cs @\n($* ?b_es)\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n  cs_es = cs @ ($* b_es)\n  const_list cs\n  \\<not> const_list cs_es\n  list_all ?P (?xs @ ?ys) = (list_all ?P ?xs \\<and> list_all ?P ?ys)\n  \\<C> \\<turnstile> b_es : tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ ($* b_es)\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> b_es : ts_c _> ts'\n  \\<lbrakk>\\<C> \\<turnstile> ?b_es : ts_c _> ?ts';\n   \\<And>lholed. \\<not> Lfilled 0 lholed [$Return] (cs @ ($* ?b_es));\n   \\<And>i lholed. \\<not> Lfilled 0 lholed [$Br i] (cs @ ($* ?b_es));\n   \\<not> list_all is_const ($* ?b_es); ?i < length (s_inst \\<S>);\n   length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst ?s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;cs @\n($* ?b_es)\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n  cs_es = cs @ ($* b_es)\n  list_all is_const cs\n  \\<not> list_all is_const cs_es\n  list_all ?P (?xs @ ?ys) = (list_all ?P ?xs \\<and> list_all ?P ?ys)\n  \\<C> \\<turnstile> b_es : tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ ($* b_es)\n  list_all is_const cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> list_all is_const cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (7 subgoals):\n 1. \\<And>\\<S> \\<C> es t1s t2s e t3s vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ [e]; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ es @ [e]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 5. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 6. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 7. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<S> \\<C> es t1s t2s e t3s vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ [e]; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ es @ [e]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 5. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 6. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 7. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (2 \\<S> \\<C> es t1s t2s e t3s)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s\n  \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ es; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>); length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ [e]; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>); length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ es @ [e]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (7 subgoals):\n 1. \\<And>\\<S> \\<C> es t1s t2s e t3s vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> [e] : t2s _> t3s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ [e]; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ es @ [e]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 5. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 6. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 7. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "proof (cases \"const_list es\")"], ["proof (state)\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case True"], ["proof (state)\nthis:\n  const_list es\n\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence \"const_list (cs@es)\""], ["proof (prove)\nusing this:\n  const_list es\n\ngoal (1 subgoal):\n 1. const_list (cs @ es)", "using 2(7)"], ["proof (prove)\nusing this:\n  const_list es\n  const_list cs\n\ngoal (1 subgoal):\n 1. const_list (cs @ es)", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  list_all is_const es\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. list_all is_const (cs @ es)", "by simp"], ["proof (state)\nthis:\n  const_list (cs @ es)\n\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "moreover"], ["proof (state)\nthis:\n  const_list (cs @ es)\n\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<exists>ts''. (\\<S>\\<bullet>\\<C> \\<turnstile> (cs @ es) : ([] _> ts''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''", "using 2(5,6)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ es @ [e]\n\ngoal (1 subgoal):\n 1. \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''", "by (metis append.assoc e_type_comp_conc1)"], ["proof (state)\nthis:\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  const_list (cs @ es)\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''", "show ?thesis"], ["proof (prove)\nusing this:\n  const_list (cs @ es)\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using 2(4)[OF 2(5) _ _ _ 2(9,10,11,12,13,14,15), of \"(cs@es)\"] 2(6,16)"], ["proof (prove)\nusing this:\n  const_list (cs @ es)\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n  \\<lbrakk>cs_es = (cs @ es) @ [e]; const_list (cs @ es);\n   \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ?ts_c;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] cs_es \\<Longrightarrow>\n      Lfilled k (?lholed1 i k lholed) [$Br i] cs_es;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  cs_es = cs @ es @ [e]\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case False"], ["proof (state)\nthis:\n  \\<not> const_list es\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence \"\\<not>const_list (cs@es)\""], ["proof (prove)\nusing this:\n  \\<not> const_list es\n\ngoal (1 subgoal):\n 1. \\<not> const_list (cs @ es)", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<not> list_all is_const es\n\ngoal (1 subgoal):\n 1. \\<not> list_all is_const (cs @ es)", "by simp"], ["proof (state)\nthis:\n  \\<not> const_list (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<not> const_list (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<exists>ts''. (\\<S>\\<bullet>\\<C> \\<turnstile> (cs @ es) : ([] _> ts''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''", "using 2(5,6)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ es @ [e]\n\ngoal (1 subgoal):\n 1. \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''", "by (metis append.assoc e_type_comp_conc1)"], ["proof (state)\nthis:\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "assume \"\\<exists>k lholed. Lfilled k lholed [$Return] (cs @ es)\""], ["proof (state)\nthis:\n  \\<exists>k lholed. Lfilled k lholed [$Return] (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] (cs @ es)", "obtain k lholed where local_assms:\"Lfilled k lholed [$Return] (cs @ es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] (cs @ es)\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed.\n        Lfilled k lholed [$Return] (cs @ es) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k lholed [$Return] (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "hence \"\\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])\""], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Return] (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; cs @ es = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])", "case (L0 vs es')"], ["proof (state)\nthis:\n  k = 0\n  cs @ es = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; cs @ es = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])", "obtain lholed' where \"lholed' = LBase vs (es'@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed'.\n        lholed' = LBase vs (es' @ [e]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lholed' = LBase vs (es' @ [e])\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>k = 0; cs @ es = vs @ [$Return] @ es'; const_list vs;\n        lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])", "thus ?thesis"], ["proof (prove)\nusing this:\n  lholed' = LBase vs (es' @ [e])\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])", "using L0"], ["proof (prove)\nusing this:\n  lholed' = LBase vs (es' @ [e])\n  k = 0\n  cs @ es = vs @ [$Return] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])", "by (metis Lfilled.intros(1) append.assoc)"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Return] (cs @ es @ [e])", "case (LN vs ts es' l es'' k lfilledk)"], ["proof (state)\nthis:\n  k__ = k + 1\n  cs @ es = vs @ [Label ts es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs ts es' l es''\n  Lfilled k l [$Return] lfilledk\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k__ = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k__ lholed' [$Return] (cs @ es @ [e])", "obtain lholed' where \"lholed' = LRec vs ts es' l (es''@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed'.\n        lholed' = LRec vs ts es' l (es'' @ [e]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lholed' = LRec vs ts es' l (es'' @ [e])\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>k__ = ka + 1; cs @ es = vs @ [Label n es' lfilledk] @ es'';\n        const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Return] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k__ lholed' [$Return] (cs @ es @ [e])", "thus ?thesis"], ["proof (prove)\nusing this:\n  lholed' = LRec vs ts es' l (es'' @ [e])\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled k__ lholed' [$Return] (cs @ es @ [e])", "using LN"], ["proof (prove)\nusing this:\n  lholed' = LRec vs ts es' l (es'' @ [e])\n  k__ = k + 1\n  cs @ es = vs @ [Label ts es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs ts es' l es''\n  Lfilled k l [$Return] lfilledk\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled k__ lholed' [$Return] (cs @ es @ [e])", "by (metis Lfilled.intros(2) append.assoc)"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled k__ lholed' [$Return] (cs @ es @ [e])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "hence False"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])\n\ngoal (1 subgoal):\n 1. False", "using 2(6,9)"], ["proof (prove)\nusing this:\n  \\<exists>lholed'. Lfilled k lholed' [$Return] (cs @ es @ [e])\n  cs_es = cs @ es @ [e]\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "}"], ["proof (state)\nthis:\n  \\<exists>k lholed. Lfilled k lholed [$Return] (cs @ es) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "thus \"\\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] (cs @ es) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] (cs @ es)", "by blast"], ["proof (state)\nthis:\n  \\<not> Lfilled ?k ?lholed [$Return] (cs @ es)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> Lfilled ?k ?lholed [$Return] (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<not> Lfilled ?k ?lholed [$Return] (cs @ es)\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<And>i k lholed.  Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "assume \"\\<exists>i k lholed.  Lfilled k lholed [$Br i] (cs @ es) \\<and> \\<not>(i < k)\""], ["proof (state)\nthis:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] (cs @ es) \\<and> \\<not> i < k\n\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "then"], ["proof (chain)\npicking this:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] (cs @ es) \\<and> \\<not> i < k", "obtain i k lholed where local_assms:\"Lfilled k lholed [$Br i] (cs @ es)\" \"\\<not>(i < k)\""], ["proof (prove)\nusing this:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] (cs @ es) \\<and> \\<not> i < k\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed i.\n        \\<lbrakk>Lfilled k lholed [$Br i] (cs @ es); \\<not> i < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k lholed [$Br i] (cs @ es)\n  \\<not> i < k\n\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "hence \"\\<exists>lholed'.  Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not>(i < k)\""], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Br i] (cs @ es)\n  \\<not> i < k\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k", "proof (cases rule: Lfilled.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>\\<not> i < k; k = 0; cs @ es = vs @ [$Br i] @ es';\n        const_list vs; lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k; k = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k", "case (L0 vs es')"], ["proof (state)\nthis:\n  k = 0\n  cs @ es = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>\\<not> i < k; k = 0; cs @ es = vs @ [$Br i] @ es';\n        const_list vs; lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k; k = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k", "obtain lholed' where \"lholed' = LBase vs (es'@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed'.\n        lholed' = LBase vs (es' @ [e]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lholed' = LBase vs (es' @ [e])\n\ngoal (2 subgoals):\n 1. \\<And>vs es'.\n       \\<lbrakk>\\<not> i < k; k = 0; cs @ es = vs @ [$Br i] @ es';\n        const_list vs; lholed = LBase vs es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k\n 2. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k; k = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lholed' = LBase vs (es' @ [e])\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k", "using L0 local_assms(2)"], ["proof (prove)\nusing this:\n  lholed' = LBase vs (es' @ [e])\n  k = 0\n  cs @ es = vs @ [$Br i] @ es'\n  const_list vs\n  lholed = LBase vs es'\n  \\<not> i < k\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k", "by (metis Lfilled.intros(1) append.assoc)"], ["proof (state)\nthis:\n  \\<exists>lholed'.\n     Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k; k = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k; k = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and>\n                            \\<not> i < k", "case (LN vs ts es' l es'' k lfilledk)"], ["proof (state)\nthis:\n  k__ = k + 1\n  cs @ es = vs @ [Label ts es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs ts es' l es''\n  Lfilled k l [$Br i] lfilledk\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k__; k__ = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k__ lholed' [$Br i]\n                             (cs @ es @ [e]) \\<and>\n                            \\<not> i < k__", "obtain lholed' where \"lholed' = LRec vs ts es' l (es''@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lholed'.\n        lholed' = LRec vs ts es' l (es'' @ [e]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lholed' = LRec vs ts es' l (es'' @ [e])\n\ngoal (1 subgoal):\n 1. \\<And>vs n es' l es'' ka lfilledk.\n       \\<lbrakk>\\<not> i < k__; k__ = ka + 1;\n        cs @ es = vs @ [Label n es' lfilledk] @ es''; const_list vs;\n        lholed = LRec vs n es' l es'';\n        Lfilled ka l [$Br i] lfilledk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled k__ lholed' [$Br i]\n                             (cs @ es @ [e]) \\<and>\n                            \\<not> i < k__", "thus ?thesis"], ["proof (prove)\nusing this:\n  lholed' = LRec vs ts es' l (es'' @ [e])\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled k__ lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k__", "using LN local_assms(2)"], ["proof (prove)\nusing this:\n  lholed' = LRec vs ts es' l (es'' @ [e])\n  k__ = k + 1\n  cs @ es = vs @ [Label ts es' lfilledk] @ es''\n  const_list vs\n  lholed = LRec vs ts es' l es''\n  Lfilled k l [$Br i] lfilledk\n  \\<not> i < k__\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled k__ lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k__", "by (metis Lfilled.intros(2) append.assoc)"], ["proof (state)\nthis:\n  \\<exists>lholed'.\n     Lfilled k__ lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k__\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>lholed'.\n     Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k\n\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "hence False"], ["proof (prove)\nusing this:\n  \\<exists>lholed'.\n     Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k\n\ngoal (1 subgoal):\n 1. False", "using 2(6,10)"], ["proof (prove)\nusing this:\n  \\<exists>lholed'.\n     Lfilled k lholed' [$Br i] (cs @ es @ [e]) \\<and> \\<not> i < k\n  cs_es = cs @ es @ [e]\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "}"], ["proof (state)\nthis:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] (cs @ es) \\<and>\n     \\<not> i < k \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "thus \"\\<And>i k lholed.  Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k\""], ["proof (prove)\nusing this:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] (cs @ es) \\<and>\n     \\<not> i < k \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i k lholed.\n       Lfilled k lholed [$Br i] (cs @ es) \\<Longrightarrow> i < k", "by blast"], ["proof (state)\nthis:\n  Lfilled ?k ?lholed [$Br ?i] (cs @ es) \\<Longrightarrow> ?i < ?k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lfilled ?k ?lholed [$Br ?i] (cs @ es) \\<Longrightarrow> ?i < ?k\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "moreover"], ["proof (state)\nthis:\n  Lfilled ?k ?lholed [$Br ?i] (cs @ es) \\<Longrightarrow> ?i < ?k\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "note preds = calculation"], ["proof (state)\nthis:\n  \\<not> const_list (cs @ es)\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n  \\<not> Lfilled ?k ?lholed [$Return] (cs @ es)\n  Lfilled ?k ?lholed [$Br ?i] (cs @ es) \\<Longrightarrow> ?i < ?k\n\ngoal (1 subgoal):\n 1. \\<not> const_list es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "proof (cases \"cs @ es = [Trap]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs @ es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. cs @ es \\<noteq> [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case True"], ["proof (state)\nthis:\n  cs @ es = [Trap]\n\ngoal (2 subgoals):\n 1. cs @ es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. cs @ es \\<noteq> [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs @ es = [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using reduce_simple.trap[of _ \"(LBase [] [e])\"]\n                Lfilled.intros(1)[of \"[]\" \"LBase [] [e]\" \"[e]\" \"cs @ es\"]\n                reduce.intros(1) 2(6,11)"], ["proof (prove)\nusing this:\n  cs @ es = [Trap]\n  \\<lbrakk>?es \\<noteq> [Trap]; Lfilled 0 (LBase [] [e]) [Trap] ?es\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?es\\<rparr> \\<leadsto> \\<lparr>[Trap]\\<rparr>\n  \\<lbrakk>const_list []; LBase [] [e] = LBase [] [e]\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 (LBase [] [e]) (cs @ es)\n                     ([] @ (cs @ es) @ [e])\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  cs_es = cs @ es @ [e]\n  cs_es \\<noteq> [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs @ es = [Trap]\n  \\<lbrakk>?es \\<noteq> [Trap]; Lfilled 0 (LBase [] [e]) [Trap] ?es\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?es\\<rparr> \\<leadsto> \\<lparr>[Trap]\\<rparr>\n  \\<lbrakk>list_all is_const []; LBase [] [e] = LBase [] [e]\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 (LBase [] [e]) (cs @ es)\n                     ([] @ (cs @ es) @ [e])\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  cs_es = cs @ es @ [e]\n  cs_es \\<noteq> [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by (metis append.assoc append_Nil list.pred_inject(1))"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (1 subgoal):\n 1. cs @ es \\<noteq> [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs @ es \\<noteq> [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case False"], ["proof (state)\nthis:\n  cs @ es \\<noteq> [Trap]\n\ngoal (1 subgoal):\n 1. cs @ es \\<noteq> [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs @ es \\<noteq> [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using 2(3)[OF _ _ 2(7,8) _ _ _ _  2(13,14,15)] preds 2(6,16)\n                progress_L0[of s vs \"(cs @ es)\" _ _ _ _ \"[]\" \"[e]\"]"], ["proof (prove)\nusing this:\n  cs @ es \\<noteq> [Trap]\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = cs @ es;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;vs;?cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  \\<not> const_list (cs @ es)\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n  \\<not> Lfilled ?k ?lholed [$Return] (cs @ es)\n  Lfilled ?k ?lholed [$Br ?i] (cs @ es) \\<Longrightarrow> ?i < ?k\n  cs_es = cs @ es @ [e]\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>\\<lparr>s;vs;cs @\n                        es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list []\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[] @\n                                 (cs @ es) @\n                                 [e]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';[] @\n ?es' @ [e]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  cs @ es \\<noteq> [Trap]\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = cs @ es;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> list_all is_const ?cs_es;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;vs;?cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  \\<not> list_all is_const (cs @ es)\n  \\<exists>ts''. \\<S>\\<bullet>\\<C> \\<turnstile> cs @ es : [] _> ts''\n  \\<not> Lfilled ?k ?lholed [$Return] (cs @ es)\n  Lfilled ?k ?lholed [$Br ?i] (cs @ es) \\<Longrightarrow> ?i < ?k\n  cs_es = cs @ es @ [e]\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>\\<lparr>s;vs;cs @\n                        es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   list_all is_const []\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;vs;[] @\n                                 (cs @ es) @\n                                 [e]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';[] @\n ?es' @ [e]\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by (metis append.assoc append_Nil list.pred_inject(1))"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (6 subgoals):\n 1. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 4. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 6. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 4. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 6. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (3 \\<S> \\<C> es t1s t2s ts)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ es; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>); length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ es\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (6 subgoals):\n 1. \\<And>\\<S> \\<C> es t1s t2s ts vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n        const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 4. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 6. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : t1s _> t2s\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ es; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>); length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ es\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 3. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 3. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (4 \\<S> \\<C>)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ [Trap]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (5 subgoals):\n 1. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 3. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "have cs_es_def:\"Lfilled 0 (LBase cs []) [Trap] cs_es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lfilled 0 (LBase cs []) [Trap] cs_es", "using Lfilled.intros(1)[OF 4(3), of _ \"[]\" \"[Trap]\"] 4(2)"], ["proof (prove)\nusing this:\n  ?lholed = LBase cs [] \\<Longrightarrow>\n  Lfilled 0 ?lholed [Trap] (cs @ [Trap] @ [])\n  cs_es = cs @ [Trap]\n\ngoal (1 subgoal):\n 1. Lfilled 0 (LBase cs []) [Trap] cs_es", "by fastforce"], ["proof (state)\nthis:\n  Lfilled 0 (LBase cs []) [Trap] cs_es\n\ngoal (5 subgoals):\n 1. \\<And>\\<S> \\<C> tf vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Trap]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 3. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 5. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase cs []) [Trap] cs_es\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using reduce_simple.trap[OF 4(7) cs_es_def] reduce.intros(1)"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase cs []) [Trap] cs_es\n  \\<lparr>cs_es\\<rparr> \\<leadsto> \\<lparr>[Trap]\\<rparr>\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 2. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 2. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (5 \\<S> ts j vls es n \\<C>)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>Some ts \\<tturnstile>_ j vls;es : ts\n  length ts = n\n  \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n   \\<And>i k lholed. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n   es \\<noteq> [Trap]; \\<not> const_list es; store_typing s \\<S>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ j \\<lparr>s';vs';b\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ [Local n j vls es]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (4 subgoals):\n 1. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 2. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "consider (1) \"(\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es)\"\n                 \"(\\<And>k lholed i. (Lfilled k lholed [$Br i] es) \\<Longrightarrow> i < k)\"\n                 \"es \\<noteq> [Trap]\"\n                 \"\\<not> const_list es\"\n           | (2) \"\\<exists>k lholed. Lfilled k lholed [$Return] es\"\n           | (3) \"const_list es \\<or> (es = [Trap])\"\n           | (4) \"\\<exists>k lholed i. (Lfilled k lholed [$Br i] es) \\<and> i \\<ge> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n              \\<And>k lholed i.\n                 Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n              es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n     thesis;\n     const_list es \\<or> es = [Trap] \\<Longrightarrow> thesis;\n     \\<exists>k lholed i.\n        Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using not_le_imp_less"], ["proof (prove)\nusing this:\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n              \\<And>k lholed i.\n                 Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n              es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n     thesis;\n     const_list es \\<or> es = [Trap] \\<Longrightarrow> thesis;\n     \\<exists>k lholed i.\n        Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n            \\<And>k lholed i.\n               Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n            es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n   ?thesis;\n   const_list es \\<or> es = [Trap] \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed i.\n      Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (4 subgoals):\n 1. \\<And>\\<S> ts i vs es n \\<C> vsa ts_c ts' ia cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>Some ts \\<tturnstile>_ i vs;es : ts;\n        \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n         \\<And>i k lholed.\n            Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n         es \\<noteq> [Trap]; \\<not> const_list es;\n         store_typing s \\<S>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Local n i vs es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        ia < length (s_inst \\<S>); length (local \\<C>) = length vsa;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'.\n                            Ex (reduce s vsa cs_es ia s' vs')\n 2. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 4. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n            \\<And>k lholed i.\n               Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n            es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n   ?thesis;\n   const_list es \\<or> es = [Trap] \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed i.\n      Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 1"], ["proof (state)\nthis:\n  \\<not> Lfilled ?k ?lholed [$Return] es\n  Lfilled ?k ?lholed [$Br ?i] es \\<Longrightarrow> ?i < ?k\n  es \\<noteq> [Trap]\n  \\<not> const_list es\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "obtain s' vs'' a where temp1:\"\\<lparr>s;vls;es\\<rparr> \\<leadsto>_ j \\<lparr>s';vs'';a\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' vs'' a.\n        \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ j \\<lparr>s';vs'';a\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 5(3)[OF 1(1) _ 1(3,4) 5(12)] 1(2)"], ["proof (prove)\nusing this:\n  (\\<And>i k lholed.\n      Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k) \\<Longrightarrow>\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ j \\<lparr>s';vs';b\\<rparr>\n  Lfilled ?k ?lholed [$Br ?i] es \\<Longrightarrow> ?i < ?k\n\ngoal (1 subgoal):\n 1. (\\<And>s' vs'' a.\n        \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ j \\<lparr>s';vs'';a\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lparr>s;vls;es\\<rparr> \\<leadsto>_ j \\<lparr>s';vs'';a\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using reduce.intros(24)[OF temp1, of vs] progress_L0[where ?cs = cs, OF _ 5(6)] 5(5)"], ["proof (prove)\nusing this:\n  \\<lparr>s;vs;[Local ?n j vls\n                 es]\\<rparr> \\<leadsto>_ ?j \\<lparr>s';vs;[Local ?n j vs''\n                      a]\\<rparr>\n  \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         ?es' @ ?es_c\\<rparr>\n  cs_es = cs @ [Local n j vls es]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 2"], ["proof (state)\nthis:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es\n\ngoal (3 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es", "obtain k lholed where local_assms:\"(Lfilled k lholed [$Return] es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed.\n        Lfilled k lholed [$Return] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k lholed [$Return] es\n\ngoal (3 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  Lfilled k lholed [$Return] es", "obtain lholed' vs' \\<C>' where lholed'_def:\"(Lfilled k lholed' (vs'@[$Return]) es)\"\n                                                   \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs' : ([] _> ts)\"\n                                                   \"const_list vs'\""], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled k lholed' (vs' @ [$Return]) es;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using progress_LN_return[OF local_assms, of \\<S> _ ts ts] s_type_unfold[OF 5(1)]"], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Return] es\n  \\<lbrakk>\\<S>\\<bullet>?\\<C> \\<turnstile> es : [] _> ts;\n   return ?\\<C> = Some ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>lholed' vs \\<C>'.\n                       Lfilled k lholed' (vs @ [$Return]) es \\<and>\n                       \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> ts \\<and>\n                       const_list vs\n  j < length (s_inst \\<S>)\n  Some ts = Some ts \\<or> Some ts = None\n  \\<S>\\<bullet>(s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n     return := Some ts\\<rparr> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled k lholed' (vs' @ [$Return]) es;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Lfilled k lholed' (vs' @ [$Return]) es\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts\n  const_list vs'\n\ngoal (3 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence temp1:\"\\<exists>a. \\<lparr>[Local n j vls es]\\<rparr> \\<leadsto> \\<lparr>vs'\\<rparr>\""], ["proof (prove)\nusing this:\n  Lfilled k lholed' (vs' @ [$Return]) es\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts\n  const_list vs'\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>[Local n j vls es]\\<rparr> \\<leadsto> \\<lparr>vs'\\<rparr>", "using reduce_simple.return[OF lholed'_def(3)]\n              e_type_const_list[OF lholed'_def(3,2)] 5(2)"], ["proof (prove)\nusing this:\n  Lfilled k lholed' (vs' @ [$Return]) es\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts\n  const_list vs'\n  \\<lbrakk>length vs' = ?n;\n   Lfilled ?j ?lholed (vs' @ [$Return]) ?es\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>[Local ?n ?i ?vls\n                              ?es]\\<rparr> \\<leadsto> \\<lparr>vs'\\<rparr>\n  \\<exists>tvs.\n     ts = [] @ tvs \\<and>\n     length vs' = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> vs' : [] _> tvs\n  length ts = n\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>[Local n j vls es]\\<rparr> \\<leadsto> \\<lparr>vs'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a.\n     \\<lparr>[Local n j vls es]\\<rparr> \\<leadsto> \\<lparr>vs'\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using temp1 progress_L0[OF reduce.intros(1) 5(6)] 5(5)"], ["proof (prove)\nusing this:\n  \\<exists>a.\n     \\<lparr>[Local n j vls es]\\<rparr> \\<leadsto> \\<lparr>vs'\\<rparr>\n  \\<lparr>?es\\<rparr> \\<leadsto> \\<lparr>?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;cs @\n                       ?es' @ ?es_c\\<rparr>\n  cs_es = cs @ [Local n j vls es]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (2 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 3"], ["proof (state)\nthis:\n  const_list es \\<or> es = [Trap]\n\ngoal (2 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  const_list es \\<or> es = [Trap]", "consider (1) \"const_list es\" | (2) \"es = [Trap]\""], ["proof (prove)\nusing this:\n  const_list es \\<or> es = [Trap]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>const_list es \\<Longrightarrow> thesis;\n     es = [Trap] \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>const_list es \\<Longrightarrow> ?thesis;\n   es = [Trap] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence temp1:\"\\<exists>a. \\<lparr>s;vs;[Local n j vls es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list es \\<Longrightarrow> ?thesis;\n   es = [Trap] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n 2. es = [Trap] \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "case 1"], ["proof (state)\nthis:\n  const_list es\n\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n 2. es = [Trap] \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "have \"length es = length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length es = length ts", "using s_type_unfold[OF 5(1)] e_type_const_list[OF 1]"], ["proof (prove)\nusing this:\n  j < length (s_inst \\<S>)\n  Some ts = Some ts \\<or> Some ts = None\n  \\<S>\\<bullet>(s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n     return := Some ts\\<rparr> \\<turnstile> es : [] _> ts\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> es : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>tvs.\n     ?ts' = ?ts @ tvs \\<and>\n     length es = length tvs \\<and>\n     ?\\<S>\\<bullet>?\\<C>' \\<turnstile> es : [] _> tvs\n\ngoal (1 subgoal):\n 1. length es = length ts", "by fastforce"], ["proof (state)\nthis:\n  length es = length ts\n\ngoal (2 subgoals):\n 1. const_list es \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n 2. es = [Trap] \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  length es = length ts\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "using reduce_simple.local_const[OF 1] reduce.intros(1) 5(2)"], ["proof (prove)\nusing this:\n  length es = length ts\n  length es = ?n \\<Longrightarrow>\n  \\<lparr>[Local ?n ?i ?vs es]\\<rparr> \\<leadsto> \\<lparr>es\\<rparr>\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n  length ts = n\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a.\n     \\<lparr>s;vs;[Local n j vls\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n\ngoal (1 subgoal):\n 1. es = [Trap] \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. es = [Trap] \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "case 2"], ["proof (state)\nthis:\n  es = [Trap]\n\ngoal (1 subgoal):\n 1. es = [Trap] \\<Longrightarrow>\n    \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "using reduce_simple.local_trap reduce.intros(1)"], ["proof (prove)\nusing this:\n  es = [Trap]\n  \\<lparr>[Local ?n ?i ?vs [Trap]]\\<rparr> \\<leadsto> \\<lparr>[Trap]\\<rparr>\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Local n j vls\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a.\n     \\<lparr>s;vs;[Local n j vls\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     \\<lparr>s;vs;[Local n j vls\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n\ngoal (2 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a.\n     \\<lparr>s;vs;[Local n j vls\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using progress_L0[where ?cs = cs, OF _ 5(6)] 5(5)"], ["proof (prove)\nusing this:\n  \\<exists>a.\n     \\<lparr>s;vs;[Local n j vls\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n  \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         ?es' @ ?es_c\\<rparr>\n  cs_es = cs @ [Local n j vls es]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 4"], ["proof (state)\nthis:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k \\<le> i", "obtain k' lholed' i' where temp1:\"Lfilled k' lholed' [$Br (k'+i')] es\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<And>k' lholed' i'.\n        Lfilled k' lholed' [$Br (k' + i')] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k \\<le> i\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>k' lholed' i'.\n        Lfilled k' lholed' [$Br (k' + i')] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k' lholed' [$Br (k' + i')] es\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "obtain \\<C>' where c_def:\"\\<C>' = ((s_inst \\<S>)!j)\\<lparr>local := (local ((s_inst \\<S>)!j)) @ (map typeof vls), return := Some ts\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>'.\n        \\<C>' = (s_inst \\<S> ! j)\n        \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n           return := Some ts\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<C>' = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n     return := Some ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence  es_def:\"\\<S>\\<bullet>\\<C>' \\<turnstile> es : ([] _> ts)\" \"j < length (s_inst \\<S>)\""], ["proof (prove)\nusing this:\n  \\<C>' = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n     return := Some ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> ts &&&\n    j < length (s_inst \\<S>)", "using 5(1) s_type_unfold"], ["proof (prove)\nusing this:\n  \\<C>' = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n     return := Some ts\\<rparr>\n  \\<S>\\<bullet>Some ts \\<tturnstile>_ j vls;es : ts\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?i < length (s_inst ?\\<S>)\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?rs = Some ?ts \\<or> ?rs = None\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?\\<S>\\<bullet>(s_inst ?\\<S> ! ?i)\n  \\<lparr>local := local (s_inst ?\\<S> ! ?i) @ map typeof ?vs,\n     return := ?rs\\<rparr> \\<turnstile> ?es : [] _> ?ts\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> ts &&&\n    j < length (s_inst \\<S>)", "by fastforce+"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> ts\n  j < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence \"length (label \\<C>') = 0\""], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> ts\n  j < length (s_inst \\<S>)\n\ngoal (1 subgoal):\n 1. length (label \\<C>') = 0", "using c_def store_local_label_empty 5(12)"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C>' \\<turnstile> es : [] _> ts\n  j < length (s_inst \\<S>)\n  \\<C>' = (s_inst \\<S> ! j)\n  \\<lparr>local := local (s_inst \\<S> ! j) @ map typeof vls,\n     return := Some ts\\<rparr>\n  \\<lbrakk>?i < length (s_inst ?\\<S>); store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> label (s_inst ?\\<S> ! ?i) = []\n  \\<lbrakk>?i < length (s_inst ?\\<S>); store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> local (s_inst ?\\<S> ! ?i) = []\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. length (label \\<C>') = 0", "by fastforce"], ["proof (state)\nthis:\n  length (label \\<C>') = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (label \\<C>') = 0\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using progress_LN1[OF temp1 es_def(1)]"], ["proof (prove)\nusing this:\n  length (label \\<C>') = 0\n  i' < length (label \\<C>')\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by linarith"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (6 \\<S> cl tf \\<C>)"], ["proof (state)\nthis:\n  cl_typing \\<S> cl tf\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ [Callcl cl]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "obtain ts'' where ts''_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> cs : ([] _> ts'')\" \"\\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : (ts'' _> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 6(2,3) e_type_comp_conc1"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ [Callcl cl]\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es @\n                                   ?es' : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>ts''.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es : ?ts _> ts'' \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?es' : ts'' _> ?ts'\n\ngoal (1 subgoal):\n 1. (\\<And>ts''.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts'';\n         \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts''\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Callcl cl] : ts'' _> ts'\n\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "obtain ts_c t1s t2s where cl_def:\"(ts'' = ts_c @ t1s)\"\n                                     \"(ts' = ts_c @ t2s)\"\n                                     \"cl_type cl = (t1s _> t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts_c t1s t2s.\n        \\<lbrakk>ts'' = ts_c @ t1s; ts' = ts_c @ t2s;\n         cl_type cl = t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_callcl[OF ts''_def(2)]"], ["proof (prove)\nusing this:\n  \\<exists>t1s t2s ts_c.\n     ts'' = ts_c @ t1s \\<and>\n     ts' = ts_c @ t2s \\<and> cl_type cl = t1s _> t2s\n\ngoal (1 subgoal):\n 1. (\\<And>ts_c t1s t2s.\n        \\<lbrakk>ts'' = ts_c @ t1s; ts' = ts_c @ t2s;\n         cl_type cl = t1s _> t2s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ts'' = ts_c @ t1s\n  ts' = ts_c @ t2s\n  cl_type cl = t1s _> t2s\n\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "obtain vs1 vs2 where vs_def:\"\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : ([] _> ts_c)\"\n                                \"\\<S>\\<bullet>\\<C> \\<turnstile> vs2 : (ts_c _> ts_c @ t1s)\"\n                                \"cs = vs1 @ vs2\"\n                                \"const_list vs1\"\n                                \"const_list vs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c;\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ t1s;\n         cs = vs1 @ vs2; const_list vs1; const_list vs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_list_cons[OF 6(4)] ts''_def(1) cl_def(1)"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> cs : [] _> ?ts1.0 @\n        ?ts2.0 \\<Longrightarrow>\n  \\<exists>vs1 vs2.\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs1 : [] _> ?ts1.0 \\<and>\n     ?\\<S>\\<bullet>?\\<C> \\<turnstile> vs2 : ?ts1.0 _> ?ts1.0 @ ?ts2.0 \\<and>\n     cs = vs1 @ vs2 \\<and> const_list vs1 \\<and> const_list vs2\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts''\n  ts'' = ts_c @ t1s\n\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c;\n         \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ t1s;\n         cs = vs1 @ vs2; const_list vs1; const_list vs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs1 : [] _> ts_c\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ t1s\n  cs = vs1 @ vs2\n  const_list vs1\n  const_list vs2\n\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "have l:\"(length vs2) = (length t1s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs2 = length t1s", "using e_type_const_list vs_def(2,5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list ?vs;\n   ?\\<S>\\<bullet>?\\<C> \\<turnstile> ?vs : ?ts _> ?ts'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tvs.\n                       ?ts' = ?ts @ tvs \\<and>\n                       length ?vs = length tvs \\<and>\n                       ?\\<S>\\<bullet>?\\<C>' \\<turnstile> ?vs : [] _> tvs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ t1s\n  const_list vs2\n\ngoal (1 subgoal):\n 1. length vs2 = length t1s", "by fastforce"], ["proof (state)\nthis:\n  length vs2 = length t1s\n\ngoal (3 subgoals):\n 1. \\<And>\\<S> cl tf \\<C> vs ts_c ts' i cs_es cs.\n       \\<lbrakk>cl_typing \\<S> cl tf;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Callcl cl]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 3. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "proof (cases cl)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       cl = Func_native x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case (Func_native x11 x12 x13 x14)"], ["proof (state)\nthis:\n  cl = Func_native x11 x12 x13 x14\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       cl = Func_native x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence func_native_def:\"cl = Func_native x11 (t1s _> t2s) x13 x14\""], ["proof (prove)\nusing this:\n  cl = Func_native x11 x12 x13 x14\n\ngoal (1 subgoal):\n 1. cl = Func_native x11 (t1s _> t2s) x13 x14", "using cl_def(3)"], ["proof (prove)\nusing this:\n  cl = Func_native x11 x12 x13 x14\n  cl_type cl = t1s _> t2s\n\ngoal (1 subgoal):\n 1. cl = Func_native x11 (t1s _> t2s) x13 x14", "unfolding cl_type_def"], ["proof (prove)\nusing this:\n  cl = Func_native x11 x12 x13 x14\n  (case cl of Func_native x tf xa xb \\<Rightarrow> tf\n   | Func_host tf x \\<Rightarrow> tf) =\n  t1s _> t2s\n\ngoal (1 subgoal):\n 1. cl = Func_native x11 (t1s _> t2s) x13 x14", "by simp"], ["proof (state)\nthis:\n  cl = Func_native x11 (t1s _> t2s) x13 x14\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       cl = Func_native x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<exists>a a'. \\<lparr>s;vs;vs2 @ [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>", "using reduce.intros(5)[OF func_native_def] e_type_const_conv_vs[OF vs_def(5)] l"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ves = $$* ?vcs; length ?vcs = ?n; length x13 = ?k;\n   length t1s = ?n; length t2s = ?m; n_zeros x13 = ?zs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?ves @\n                                   [Callcl\n                                     cl]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Local\n     ?m x11 (?vcs @ ?zs) [$Block ([] _> t2s) x14]]\\<rparr>\n  \\<exists>vs. vs2 = $$* vs\n  length vs2 = length t1s\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>", "unfolding n_zeros_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ves = $$* ?vcs; length ?vcs = ?n; length x13 = ?k;\n   length t1s = ?n; length t2s = ?m; map bitzero x13 = ?zs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?ves @\n                                   [Callcl\n                                     cl]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Local\n     ?m x11 (?vcs @ ?zs) [$Block ([] _> t2s) x14]]\\<rparr>\n  \\<exists>vs. vs2 = $$* vs\n  length vs2 = length t1s\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       cl = Func_native x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using progress_L0 vs_def(3,4) 6(3)"], ["proof (prove)\nusing this:\n  \\<exists>a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;a\\<rparr>\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n  cs = vs1 @ vs2\n  const_list vs1\n  cs_es = cs @ [Callcl cl]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case (Func_host x21 x22)"], ["proof (state)\nthis:\n  cl = Func_host x21 x22\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence func_host_def:\"cl = Func_host (t1s _> t2s) x22\""], ["proof (prove)\nusing this:\n  cl = Func_host x21 x22\n\ngoal (1 subgoal):\n 1. cl = Func_host (t1s _> t2s) x22", "using cl_def(3)"], ["proof (prove)\nusing this:\n  cl = Func_host x21 x22\n  cl_type cl = t1s _> t2s\n\ngoal (1 subgoal):\n 1. cl = Func_host (t1s _> t2s) x22", "unfolding cl_type_def"], ["proof (prove)\nusing this:\n  cl = Func_host x21 x22\n  (case cl of Func_native x tf xa xb \\<Rightarrow> tf\n   | Func_host tf x \\<Rightarrow> tf) =\n  t1s _> t2s\n\ngoal (1 subgoal):\n 1. cl = Func_host (t1s _> t2s) x22", "by simp"], ["proof (state)\nthis:\n  cl = Func_host (t1s _> t2s) x22\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "obtain vcs where vcs_def:\"vs2 = $$* vcs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vcs. vs2 = $$* vcs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_type_const_conv_vs[OF vs_def(5)]"], ["proof (prove)\nusing this:\n  \\<exists>vs. vs2 = $$* vs\n\ngoal (1 subgoal):\n 1. (\\<And>vcs. vs2 = $$* vcs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vs2 = $$* vcs\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "fix hs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<exists>s' a a'. \\<lparr>s;vs;vs2 @ [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "proof (cases \"host_apply s (t1s _> t2s) x22 vcs hs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. host_apply s (t1s _> t2s) x22 vcs hs = None \\<Longrightarrow>\n    \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n 2. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "case None"], ["proof (state)\nthis:\n  host_apply s (t1s _> t2s) x22 vcs hs = None\n\ngoal (2 subgoals):\n 1. host_apply s (t1s _> t2s) x22 vcs hs = None \\<Longrightarrow>\n    \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n 2. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  host_apply s (t1s _> t2s) x22 vcs hs = None\n\ngoal (1 subgoal):\n 1. \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "using reduce.intros(7)[OF func_host_def] l vcs_def"], ["proof (prove)\nusing this:\n  host_apply s (t1s _> t2s) x22 vcs hs = None\n  \\<lbrakk>?ves = $$* ?vcs; length ?vcs = ?n; length t1s = ?n;\n   length t2s = ?m\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?ves @\n                                   [Callcl\n                                     cl]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;[Trap]\\<rparr>\n  length vs2 = length t1s\n  vs2 = $$* vcs\n\ngoal (1 subgoal):\n 1. \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>s' a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "case (Some a)"], ["proof (state)\nthis:\n  host_apply s (t1s _> t2s) x22 vcs hs = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "then"], ["proof (chain)\npicking this:\n  host_apply s (t1s _> t2s) x22 vcs hs = Some a", "obtain s' vcs' where ha_def:\"host_apply s (t1s _> t2s) x22 vcs hs = Some (s', vcs')\""], ["proof (prove)\nusing this:\n  host_apply s (t1s _> t2s) x22 vcs hs = Some a\n\ngoal (1 subgoal):\n 1. (\\<And>s' vcs'.\n        host_apply s (t1s _> t2s) x22 vcs hs =\n        Some (s', vcs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  host_apply s (t1s _> t2s) x22 vcs hs = Some (s', vcs')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "have \"list_all2 types_agree t1s vcs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 types_agree t1s vcs", "using e_typing_imp_list_types_agree vs_def(2,4) vcs_def"], ["proof (prove)\nusing this:\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $$* ?vs : ?ts' _> ?ts' @\n               ?ts \\<Longrightarrow>\n  list_all2 types_agree ?ts ?vs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs2 : ts_c _> ts_c @ t1s\n  const_list vs1\n  vs2 = $$* vcs\n\ngoal (1 subgoal):\n 1. list_all2 types_agree t1s vcs", "by simp"], ["proof (state)\nthis:\n  list_all2 types_agree t1s vcs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       host_apply s (t1s _> t2s) x22 vcs hs = Some a \\<Longrightarrow>\n       \\<exists>s' a a'.\n          \\<lparr>s;vs;vs2 @\n                       [Callcl\n                         cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all2 types_agree t1s vcs\n\ngoal (1 subgoal):\n 1. \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "using reduce.intros(6)[OF func_host_def _ _ _ _ ha_def] l vcs_def\n                host_apply_respect_type[OF _ ha_def]"], ["proof (prove)\nusing this:\n  list_all2 types_agree t1s vcs\n  \\<lbrakk>?ves = $$* vcs; length vcs = ?n; length t1s = ?n;\n   length t2s = ?m\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>s;?vs;?ves @\n                                  [Callcl\n                                    cl]\\<rparr> \\<leadsto>_ ?i \\<lparr>s';?vs;$$* vcs'\\<rparr>\n  length vs2 = length t1s\n  vs2 = $$* vcs\n  list_all2 types_agree t1s vcs \\<Longrightarrow>\n  list_all2 types_agree t2s vcs'\n\ngoal (1 subgoal):\n 1. \\<exists>s' a a'.\n       \\<lparr>s;vs;vs2 @\n                    [Callcl\n                      cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>s' a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s' a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       cl = Func_host x21 x22 \\<Longrightarrow>\n       \\<exists>a s' vs' b.\n          \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s' a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using vs_def(3,4) 6(3) progress_L0"], ["proof (prove)\nusing this:\n  \\<exists>s' a a'.\n     \\<lparr>s;vs;vs2 @\n                  [Callcl cl]\\<rparr> \\<leadsto>_ i \\<lparr>s';vs;a\\<rparr>\n  cs = vs1 @ vs2\n  const_list vs1\n  cs_es = cs @ [Callcl cl]\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (7 \\<S> \\<C> e0s ts t2s es n)"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s\n  length ts = n\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ e0s; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>); length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<lbrakk>\\<S>\\<bullet>\\<C>\n           \\<lparr>label :=\n                     [ts] @\n                     label \\<C>\\<rparr> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ es; const_list ?cs;\n   \\<S>\\<bullet>\\<C>\n   \\<lparr>label :=\n             [ts] @ label \\<C>\\<rparr> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>);\n   length (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n   length ?vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'\n  cs_es = cs @ [Label n e0s es]\n  const_list cs\n  \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c\n  \\<not> Lfilled ?k ?lholed [$Return] cs_es\n  Lfilled ?k ?lholed [$Br ?i] cs_es \\<Longrightarrow> ?i < ?k\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  i < length (s_inst \\<S>)\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (2 subgoals):\n 1. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "consider (1) \"(\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es)\"\n                 \"(\\<And>k lholed i. (Lfilled k lholed [$Br i] es) \\<Longrightarrow> i < k)\"\n                 \"es \\<noteq> [Trap]\"\n                 \"\\<not> const_list es\"\n           | (2) \"\\<exists>k lholed. Lfilled k lholed [$Return] es\"\n           | (3) \"const_list es \\<or> (es = [Trap])\"\n           | (4) \"\\<exists>k lholed i. (Lfilled k lholed [$Br i] es) \\<and> i = k\"\n           | (5) \"\\<exists>k lholed i. (Lfilled k lholed [$Br i] es) \\<and> i > k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n              \\<And>k lholed i.\n                 Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n              es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n     thesis;\n     const_list es \\<or> es = [Trap] \\<Longrightarrow> thesis;\n     \\<exists>k lholed i.\n        Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n     thesis;\n     \\<exists>k lholed i.\n        Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using linorder_neqE_nat"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?R;\n   ?y < ?x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n              \\<And>k lholed i.\n                 Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n              es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n     thesis;\n     const_list es \\<or> es = [Trap] \\<Longrightarrow> thesis;\n     \\<exists>k lholed i.\n        Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n     thesis;\n     \\<exists>k lholed i.\n        Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n            \\<And>k lholed i.\n               Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n            es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n   ?thesis;\n   const_list es \\<or> es = [Trap] \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed i.\n      Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n   ?thesis;\n   \\<exists>k lholed i.\n      Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>\\<S> \\<C> e0s ts t2s es n vs ts_c ts' i cs_es cs.\n       \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> e0s : ts _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ e0s; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        \\<S>\\<bullet>\\<C>\n        \\<lparr>label :=\n                  [ts] @ label \\<C>\\<rparr> \\<turnstile> es : [] _> t2s;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C>\n                    \\<lparr>label :=\n                              [ts] @\n                              label\n                               \\<C>\\<rparr> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C>\n            \\<lparr>label :=\n                      [ts] @\n                      label \\<C>\\<rparr> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length\n             (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            length vs;\n            Option.is_none\n             (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        length ts = n; \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n        cs_es = cs @ [Label n e0s es]; const_list cs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n        cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n        i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n        Option.is_none (memory \\<C>) =\n        Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs cs_es i s' vs')\n 2. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n            \\<And>k lholed i.\n               Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n            es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n   ?thesis;\n   const_list es \\<or> es = [Trap] \\<Longrightarrow> ?thesis;\n   \\<exists>k lholed i.\n      Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n   ?thesis;\n   \\<exists>k lholed i.\n      Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "proof (cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 1"], ["proof (state)\nthis:\n  \\<not> Lfilled ?k ?lholed [$Return] es\n  Lfilled ?k ?lholed [$Br ?i] es \\<Longrightarrow> ?i < ?k\n  es \\<noteq> [Trap]\n  \\<not> const_list es\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have temp1:\"es = [] @ es\" \"const_list []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = [] @ es &&& const_list []", "unfolding const_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. es = [] @ es &&& list_all is_const []", "by auto"], ["proof (state)\nthis:\n  es = [] @ es\n  const_list []\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have temp2:\"\\<S>\\<bullet>\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr> \\<turnstile> [] : ([] _> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>\n    \\<lparr>label := [ts] @ label \\<C>\\<rparr> \\<turnstile> [] : [] _> []", "using b_e_typing.empty e_typing_s_typing.intros(1)"], ["proof (prove)\nusing this:\n  ?\\<C> \\<turnstile> [] : [] _> []\n  ?\\<C> \\<turnstile> ?b_es : ?tf \\<Longrightarrow>\n  ?\\<S>\\<bullet>?\\<C> \\<turnstile> $* ?b_es : ?tf\n\ngoal (1 subgoal):\n 1. \\<S>\\<bullet>\\<C>\n    \\<lparr>label := [ts] @ label \\<C>\\<rparr> \\<turnstile> [] : [] _> []", "by fastforce"], ["proof (state)\nthis:\n  \\<S>\\<bullet>\\<C>\n  \\<lparr>label := [ts] @ label \\<C>\\<rparr> \\<turnstile> [] : [] _> []\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<exists>s' vs' a. \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s' vs' a.\n       \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>", "using 7(5)[OF 7(2), of \"[]\" \"[]\", OF temp1 temp2 1(1) _ 1(3,4) 7(14,15)]\n              1(2) 7(16,17)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i k lholed.\n              Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n   length (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n   length ?vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  Lfilled ?k ?lholed [$Br ?i] es \\<Longrightarrow> ?i < ?k\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>s' vs' a.\n       \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i k lholed.\n              Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n   length (local (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n   length ?vs;\n   Option.is_none\n    (memory (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>)) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  Lfilled ?k ?lholed [$Br ?i] es \\<Longrightarrow> ?i < ?k\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>s' vs' a.\n       \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>s' vs' a.\n     \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  \\<exists>s' vs' a.\n     \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>", "obtain s' vs' a where red_def:\"\\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<exists>s' vs' a.\n     \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>s' vs' a.\n        \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have temp4:\"\\<And>es. Lfilled 0 (LBase [] []) es es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>es. Lfilled 0 (LBase [] []) es es", "using Lfilled.intros(1)[of \"[]\" \"(LBase [] [])\" \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>const_list []; LBase [] [] = LBase [] []\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 (LBase [] []) ?es ([] @ ?es @ [])\n\ngoal (1 subgoal):\n 1. \\<And>es. Lfilled 0 (LBase [] []) es es", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all is_const []; LBase [] [] = LBase [] []\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 (LBase [] []) ?es ([] @ ?es @ [])\n\ngoal (1 subgoal):\n 1. \\<And>es. Lfilled 0 (LBase [] []) es es", "by fastforce"], ["proof (state)\nthis:\n  Lfilled 0 (LBase [] []) ?es ?es\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence temp5:\"Lfilled 1 (LRec cs n e0s (LBase [] []) []) es (cs@[Label n e0s es])\""], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase [] []) ?es ?es\n\ngoal (1 subgoal):\n 1. Lfilled 1 (LRec cs n e0s (LBase [] []) []) es (cs @ [Label n e0s es])", "using Lfilled.intros(2)[of cs \"(LRec cs n e0s (LBase [] []) [])\" n e0s \"(LBase [] [])\" \"[]\" 0 es es] 7(8)"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase [] []) ?es ?es\n  \\<lbrakk>const_list cs;\n   LRec cs n e0s (LBase [] []) [] = LRec cs n e0s (LBase [] []) [];\n   Lfilled 0 (LBase [] []) es es\\<rbrakk>\n  \\<Longrightarrow> Lfilled (0 + 1) (LRec cs n e0s (LBase [] []) []) es\n                     (cs @ [Label n e0s es] @ [])\n  const_list cs\n\ngoal (1 subgoal):\n 1. Lfilled 1 (LRec cs n e0s (LBase [] []) []) es (cs @ [Label n e0s es])", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase [] []) ?es ?es\n  \\<lbrakk>list_all is_const cs;\n   LRec cs n e0s (LBase [] []) [] = LRec cs n e0s (LBase [] []) [];\n   Lfilled 0 (LBase [] []) es es\\<rbrakk>\n  \\<Longrightarrow> Lfilled (0 + 1) (LRec cs n e0s (LBase [] []) []) es\n                     (cs @ [Label n e0s es] @ [])\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. Lfilled 1 (LRec cs n e0s (LBase [] []) []) es (cs @ [Label n e0s es])", "by fastforce"], ["proof (state)\nthis:\n  Lfilled 1 (LRec cs n e0s (LBase [] []) []) es (cs @ [Label n e0s es])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have temp6:\"Lfilled 1 (LRec cs n e0s (LBase [] []) []) a (cs@[Label n e0s a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lfilled 1 (LRec cs n e0s (LBase [] []) []) a (cs @ [Label n e0s a])", "using temp4 Lfilled.intros(2)[of cs \"(LRec cs n e0s (LBase [] []) [])\" n e0s \"(LBase [] [])\" \"[]\" 0 a a] 7(8)"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase [] []) ?es ?es\n  \\<lbrakk>const_list cs;\n   LRec cs n e0s (LBase [] []) [] = LRec cs n e0s (LBase [] []) [];\n   Lfilled 0 (LBase [] []) a a\\<rbrakk>\n  \\<Longrightarrow> Lfilled (0 + 1) (LRec cs n e0s (LBase [] []) []) a\n                     (cs @ [Label n e0s a] @ [])\n  const_list cs\n\ngoal (1 subgoal):\n 1. Lfilled 1 (LRec cs n e0s (LBase [] []) []) a (cs @ [Label n e0s a])", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  Lfilled 0 (LBase [] []) ?es ?es\n  \\<lbrakk>list_all is_const cs;\n   LRec cs n e0s (LBase [] []) [] = LRec cs n e0s (LBase [] []) [];\n   Lfilled 0 (LBase [] []) a a\\<rbrakk>\n  \\<Longrightarrow> Lfilled (0 + 1) (LRec cs n e0s (LBase [] []) []) a\n                     (cs @ [Label n e0s a] @ [])\n  list_all is_const cs\n\ngoal (1 subgoal):\n 1. Lfilled 1 (LRec cs n e0s (LBase [] []) []) a (cs @ [Label n e0s a])", "by fastforce"], ["proof (state)\nthis:\n  Lfilled 1 (LRec cs n e0s (LBase [] []) []) a (cs @ [Label n e0s a])\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n     \\<And>k lholed i. Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n     es \\<noteq> [Trap]; \\<not> const_list es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a s' vs' b.\n                         \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 5. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using reduce.intros(23)[OF _ temp5 temp6] 7(7) red_def"], ["proof (prove)\nusing this:\n  \\<lparr>?s;?vs;es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';a\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 [Label n e0s\n                   es]\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         [Label n e0s a]\\<rparr>\n  cs_es = cs @ [Label n e0s es]\n  \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';a\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (4 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 2"], ["proof (state)\nthis:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es\n\ngoal (4 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es", "obtain k lholed where \"(Lfilled k lholed [$Return] es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed.\n        Lfilled k lholed [$Return] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k lholed [$Return] es\n\ngoal (4 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence \"(Lfilled (k+1) (LRec cs n e0s lholed []) [$Return] (cs@[Label n e0s es]))\""], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. Lfilled (k + 1) (LRec cs n e0s lholed []) [$Return]\n     (cs @ [Label n e0s es])", "using Lfilled.intros(2) 7(8)"], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Return] es\n  \\<lbrakk>const_list ?vs; ?lholed = LRec ?vs ?n ?es' ?l ?es'';\n   Lfilled ?k ?l ?es ?lfilledk\\<rbrakk>\n  \\<Longrightarrow> Lfilled (?k + 1) ?lholed ?es\n                     (?vs @ [Label ?n ?es' ?lfilledk] @ ?es'')\n  const_list cs\n\ngoal (1 subgoal):\n 1. Lfilled (k + 1) (LRec cs n e0s lholed []) [$Return]\n     (cs @ [Label n e0s es])", "by fastforce"], ["proof (state)\nthis:\n  Lfilled (k + 1) (LRec cs n e0s lholed []) [$Return]\n   (cs @ [Label n e0s es])\n\ngoal (4 subgoals):\n 1. \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 4. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Lfilled (k + 1) (LRec cs n e0s lholed []) [$Return]\n   (cs @ [Label n e0s es])\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using 7(10)[of \"k+1\"] 7(7)"], ["proof (prove)\nusing this:\n  Lfilled (k + 1) (LRec cs n e0s lholed []) [$Return]\n   (cs @ [Label n e0s es])\n  \\<not> Lfilled (k + 1) ?lholed [$Return] cs_es\n  cs_es = cs @ [Label n e0s es]\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (3 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 3"], ["proof (state)\nthis:\n  const_list es \\<or> es = [Trap]\n\ngoal (3 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence temp1:\"\\<exists>a. \\<lparr>s;vs;[Label n e0s es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\""], ["proof (prove)\nusing this:\n  const_list es \\<or> es = [Trap]\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Label n e0s\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "using reduce_simple.label_const reduce_simple.label_trap reduce.intros(1)"], ["proof (prove)\nusing this:\n  const_list es \\<or> es = [Trap]\n  const_list ?vs \\<Longrightarrow>\n  \\<lparr>[Label ?n ?es ?vs]\\<rparr> \\<leadsto> \\<lparr>?vs\\<rparr>\n  \\<lparr>[Label ?n ?es [Trap]]\\<rparr> \\<leadsto> \\<lparr>[Trap]\\<rparr>\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       \\<lparr>s;vs;[Label n e0s\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a.\n     \\<lparr>s;vs;[Label n e0s\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n\ngoal (3 subgoals):\n 1. const_list es \\<or> es = [Trap] \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 3. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using progress_L0[OF _ 7(8)] 7(7) temp1"], ["proof (prove)\nusing this:\n  \\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;cs @\n                 ?es @\n                 ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';cs @\n                         ?es' @ ?es_c\\<rparr>\n  cs_es = cs @ [Label n e0s es]\n  \\<exists>a.\n     \\<lparr>s;vs;[Label n e0s\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 4"], ["proof (state)\nthis:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> i = k\n\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> i = k", "obtain k lholed where lholed_def:\"(Lfilled k lholed [$Br (k+0)] es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> i = k\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed.\n        Lfilled k lholed [$Br (k + 0)] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Lfilled k lholed [$Br (k + 0)] es\n\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  Lfilled k lholed [$Br (k + 0)] es", "obtain lholed' vs' \\<C>' where lholed'_def:\"(Lfilled k lholed' (vs'@[$Br (k)]) es)\"\n                                                   \"\\<S>\\<bullet>\\<C>' \\<turnstile> vs' : ([] _> ts)\"\n                                                   \"const_list vs'\""], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Br (k + 0)] es\n\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled k lholed' (vs' @ [$Br k]) es;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using progress_LN[OF lholed_def 7(2), of ts]"], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Br (k + 0)] es\n  label (\\<C>\\<lparr>label := [ts] @ label \\<C>\\<rparr>) ! 0 =\n  ts \\<Longrightarrow>\n  \\<exists>lholed' vs \\<C>'.\n     Lfilled k lholed' (vs @ [$Br (k + 0)]) es \\<and>\n     \\<S>\\<bullet>\\<C>' \\<turnstile> vs : [] _> ts \\<and> const_list vs\n\ngoal (1 subgoal):\n 1. (\\<And>lholed' vs' \\<C>'.\n        \\<lbrakk>Lfilled k lholed' (vs' @ [$Br k]) es;\n         \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts;\n         const_list vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Lfilled k lholed' (vs' @ [$Br k]) es\n  \\<S>\\<bullet>\\<C>' \\<turnstile> vs' : [] _> ts\n  const_list vs'\n\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "have \"\\<exists>es' a. \\<lparr>[Label n e0s es]\\<rparr> \\<leadsto> \\<lparr>vs'@e0s\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>es' a.\n       \\<lparr>[Label n e0s es]\\<rparr> \\<leadsto> \\<lparr>vs' @ e0s\\<rparr>", "using reduce_simple.br[OF lholed'_def(3) _ lholed'_def(1)] 7(3)\n              e_type_const_list[OF lholed'_def(3,2)]"], ["proof (prove)\nusing this:\n  length vs' = ?n \\<Longrightarrow>\n  \\<lparr>[Label ?n ?es es]\\<rparr> \\<leadsto> \\<lparr>vs' @ ?es\\<rparr>\n  length ts = n\n  \\<exists>tvs.\n     ts = [] @ tvs \\<and>\n     length vs' = length tvs \\<and>\n     \\<S>\\<bullet>?\\<C>' \\<turnstile> vs' : [] _> tvs\n\ngoal (1 subgoal):\n 1. \\<exists>es' a.\n       \\<lparr>[Label n e0s es]\\<rparr> \\<leadsto> \\<lparr>vs' @ e0s\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>es' a.\n     \\<lparr>[Label n e0s es]\\<rparr> \\<leadsto> \\<lparr>vs' @ e0s\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "hence \"\\<exists>es' a. \\<lparr>s;vs;[Label n e0s es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es'\\<rparr>\""], ["proof (prove)\nusing this:\n  \\<exists>es' a.\n     \\<lparr>[Label n e0s es]\\<rparr> \\<leadsto> \\<lparr>vs' @ e0s\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>es' a.\n       \\<lparr>s;vs;[Label n e0s\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es'\\<rparr>", "using reduce.intros(1)"], ["proof (prove)\nusing this:\n  \\<exists>es' a.\n     \\<lparr>[Label n e0s es]\\<rparr> \\<leadsto> \\<lparr>vs' @ e0s\\<rparr>\n  \\<lparr>?e\\<rparr> \\<leadsto> \\<lparr>?e'\\<rparr> \\<Longrightarrow>\n  \\<lparr>?s;?vs;?e\\<rparr> \\<leadsto>_ ?i \\<lparr>?s;?vs;?e'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>es' a.\n       \\<lparr>s;vs;[Label n e0s\n                      es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>es' a.\n     \\<lparr>s;vs;[Label n e0s\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> i = k \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n 2. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>es' a.\n     \\<lparr>s;vs;[Label n e0s\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using progress_L0 7(7,8)"], ["proof (prove)\nusing this:\n  \\<exists>es' a.\n     \\<lparr>s;vs;[Label n e0s\n                    es]\\<rparr> \\<leadsto>_ i \\<lparr>s;vs;es'\\<rparr>\n  \\<lbrakk>\\<lparr>?s;?vs;?es\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?es'\\<rparr>;\n   const_list ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<lparr>?s;?vs;?cs @\n                                   ?es @\n                                   ?es_c\\<rparr> \\<leadsto>_ ?i \\<lparr>?s';?vs';?cs @\n     ?es' @ ?es_c\\<rparr>\n  cs_es = cs @ [Label n e0s es]\n  const_list cs\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "case 5"], ["proof (state)\nthis:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k < i\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k < i", "obtain i k lholed where lholed_def:\"(Lfilled k lholed [$Br i] es)\" \"i > k\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k < i\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed i.\n        \\<lbrakk>Lfilled k lholed [$Br i] es; k < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_imp_add_positive"], ["proof (prove)\nusing this:\n  \\<exists>k lholed i. Lfilled k lholed [$Br i] es \\<and> k < i\n  ?i < ?j \\<Longrightarrow> \\<exists>k>0. ?i + k = ?j\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed i.\n        \\<lbrakk>Lfilled k lholed [$Br i] es; k < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k lholed [$Br i] es\n  k < i\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ ia__ \\<lparr>s';vs';b\\<rparr>", "have k1_def:\"Lfilled (k+1) (LRec cs n e0s lholed []) [$Br i] cs_es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lfilled (k + 1) (LRec cs n e0s lholed []) [$Br i] cs_es", "using 7(7) Lfilled.intros(2)[OF 7(8) _ lholed_def(1), of _ n e0s \"[]\"]"], ["proof (prove)\nusing this:\n  cs_es = cs @ [Label n e0s es]\n  ?lholed = LRec cs n e0s lholed [] \\<Longrightarrow>\n  Lfilled (k + 1) ?lholed [$Br i] (cs @ [Label n e0s es] @ [])\n\ngoal (1 subgoal):\n 1. Lfilled (k + 1) (LRec cs n e0s lholed []) [$Br i] cs_es", "by fastforce"], ["proof (state)\nthis:\n  Lfilled (k + 1) (LRec cs n e0s lholed []) [$Br i] cs_es\n\ngoal (1 subgoal):\n 1. \\<exists>k lholed i.\n       Lfilled k lholed [$Br i] es \\<and> k < i \\<Longrightarrow>\n    \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ ia__ \\<lparr>s';vs';b\\<rparr>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Lfilled (k + 1) (LRec cs n e0s lholed []) [$Br i] cs_es\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ ia__ \\<lparr>s';vs';b\\<rparr>", "using 7(11)[OF k1_def] lholed_def(2)"], ["proof (prove)\nusing this:\n  Lfilled (k + 1) (LRec cs n e0s lholed []) [$Br i] cs_es\n  i < k + 1\n  k < i\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ ia__ \\<lparr>s';vs';b\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ ia__ \\<lparr>s';vs';b\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "case (8 i \\<S> tvs vs \\<C> rs es ts)"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n  tvs = map typeof vs\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, return := rs\\<rparr>\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n  rs = Some ts \\<or> rs = None\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> ?cs_es : [] _> ?ts';\n   ?cs_es = ?cs @ es; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es; store_typing s \\<S>;\n   ?i < length (s_inst \\<S>); length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! ?i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';b\\<rparr>\n  \\<not> Lfilled ?k ?lholed [$Return] es\n  Lfilled ?k ?lholed [$Br ?i] es \\<Longrightarrow> ?i < ?k\n  es \\<noteq> [Trap]\n  \\<not> const_list es\n  store_typing s \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "have \"length (local \\<C>) = length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local \\<C>) = length vs", "using 8(2,3) store_local_label_empty[OF 8(1,11)]"], ["proof (prove)\nusing this:\n  tvs = map typeof vs\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, return := rs\\<rparr>\n  label (s_inst \\<S> ! i) = []\n  local (s_inst \\<S> ! i) = []\n\ngoal (1 subgoal):\n 1. length (local \\<C>) = length vs", "by fastforce"], ["proof (state)\nthis:\n  length (local \\<C>) = length vs\n\ngoal (1 subgoal):\n 1. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "moreover"], ["proof (state)\nthis:\n  length (local \\<C>) = length vs\n\ngoal (1 subgoal):\n 1. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "have \"Option.is_none (memory \\<C>) = Option.is_none (inst.mem ((inst s)!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))", "using store_mem_exists[OF 8(1,11)] 8(3)"], ["proof (prove)\nusing this:\n  Option.is_none (memory (s_inst \\<S> ! i)) =\n  Option.is_none (inst.mem (inst s ! i))\n  \\<C> = (s_inst \\<S> ! i)\n  \\<lparr>local := local (s_inst \\<S> ! i) @ tvs, return := rs\\<rparr>\n\ngoal (1 subgoal):\n 1. Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))", "by simp"], ["proof (state)\nthis:\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i \\<S> tvs vs \\<C> rs es ts.\n       \\<lbrakk>i < length (s_inst \\<S>); tvs = map typeof vs;\n        \\<C> = (s_inst \\<S> ! i)\n        \\<lparr>local := local (s_inst \\<S> ! i) @ tvs,\n           return := rs\\<rparr>;\n        \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts;\n        \\<And>vs ts_c ts' i cs_es cs.\n           \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts';\n            cs_es = cs @ es; const_list cs;\n            \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n            \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n            \\<And>i k lholed.\n               Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n            cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n            store_typing s \\<S>; i < length (s_inst \\<S>);\n            length (local \\<C>) = length vs;\n            Option.is_none (memory \\<C>) =\n            Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a s' vs'.\n                                Ex (reduce s vs cs_es i s' vs');\n        rs = Some ts \\<or> rs = None;\n        \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es;\n        \\<And>i k lholed.\n           Lfilled k lholed [$Br i] es \\<Longrightarrow> i < k;\n        es \\<noteq> [Trap]; \\<not> const_list es;\n        store_typing s \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s' vs'. Ex (reduce s vs es i s' vs')", "ultimately"], ["proof (chain)\npicking this:\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))", "show ?case"], ["proof (prove)\nusing this:\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "using 8(6)[OF 8(4) _ _ _ 8(7,8,9,10,11,1)]\n            e_typing_s_typing.intros(1)[OF b_e_typing.empty[of \\<C>]]"], ["proof (prove)\nusing this:\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>es = ?cs @ es; const_list ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] es \\<Longrightarrow>\n      Lfilled k (?lholed1 i k lholed) [$Br i] es;\n   length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  ?\\<S>\\<bullet>\\<C> \\<turnstile> $* [] : [] _> []\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "unfolding const_list_def"], ["proof (prove)\nusing this:\n  length (local \\<C>) = length vs\n  Option.is_none (memory \\<C>) = Option.is_none (inst.mem (inst s ! i))\n  \\<lbrakk>es = ?cs @ es; list_all is_const ?cs;\n   \\<S>\\<bullet>\\<C> \\<turnstile> ?cs : [] _> ?ts_c;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] es \\<Longrightarrow>\n      Lfilled k (?lholed1 i k lholed) [$Br i] es;\n   length (local \\<C>) = length ?vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' b.\n                       \\<lparr>s;?vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n  ?\\<S>\\<bullet>\\<C> \\<turnstile> $* [] : [] _> []\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' b.\n       \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' b.\n     \\<lparr>s;vs;es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';b\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<S>\\<bullet>\\<C> \\<turnstile> es : ts_c _> ts';\n   \\<S>\\<bullet>\\<C> \\<turnstile> cs_es : [] _> ts'; cs_es = cs @ es;\n   const_list cs; \\<S>\\<bullet>\\<C> \\<turnstile> cs : [] _> ts_c;\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n   \\<And>i k lholed. Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n   cs_es \\<noteq> [Trap]; \\<not> const_list cs_es; store_typing s \\<S>;\n   i < length (s_inst \\<S>); length (local \\<C>) = length vs;\n   Option.is_none (memory \\<C>) =\n   Option.is_none (inst.mem (inst s ! i))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' cs_es'.\n                       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs_es'\\<rparr>\n  \\<lbrakk>\\<S>\\<bullet>None \\<tturnstile>_ i vs;cs_es : ts';\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] cs_es;\n   \\<And>i k lholed. Lfilled k lholed [$Br i] cs_es \\<Longrightarrow> i < k;\n   cs_es \\<noteq> [Trap]; \\<not> const_list cs_es;\n   store_typing s \\<S>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' cs_es'.\n                       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs_es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using prems2[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>i k lholed.\n      Lfilled k lholed [$Br i] cs_es \\<Longrightarrow>\n      Lfilled k (?lholed2 i k lholed) [$Br i] cs_es) \\<Longrightarrow>\n  \\<exists>a s' vs' cs_es'.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';cs_es'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a s' vs' es'.\n     \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_e1:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n  shows \"\\<not>(Lfilled k lholed [$Return] es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "assume \"\\<exists>k lholed. (Lfilled k lholed [$Return] es)\""], ["proof (state)\nthis:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "then"], ["proof (chain)\npicking this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es", "obtain k lholed where local_assms:\"(Lfilled k lholed [$Return] es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed.\n        Lfilled k lholed [$Return] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Lfilled k lholed [$Return] es\n\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "obtain \\<C> where c_def:\"i < length (s_inst \\<S>)\"\n                   \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i)) @ (map typeof vs), return := None\\<rparr>\"\n                   \"(\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>.\n        \\<lbrakk>i < length (s_inst \\<S>);\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local :=\n                     local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms s_type_unfold"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?i < length (s_inst ?\\<S>)\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?rs = Some ?ts \\<or> ?rs = None\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?\\<S>\\<bullet>(s_inst ?\\<S> ! ?i)\n  \\<lparr>local := local (s_inst ?\\<S> ! ?i) @ map typeof ?vs,\n     return := ?rs\\<rparr> \\<turnstile> ?es : [] _> ?ts\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>.\n        \\<lbrakk>i < length (s_inst \\<S>);\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local :=\n                     local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "have \"\\<exists>rs. return \\<C> = Some rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs. return \\<C> = Some rs", "using local_assms c_def(3)"], ["proof (prove)\nusing this:\n  Lfilled k lholed [$Return] es\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<exists>rs. return \\<C> = Some rs", "proof (induction \"[$Return]\" es arbitrary: \\<C> ts rule: Lfilled.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [$Return] @ es' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts \\<Longrightarrow>\n           \\<exists>rs. return \\<C> = Some rs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs", "case (L0 vs lholed es')"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LBase vs es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts\n\ngoal (2 subgoals):\n 1. \\<And>vs lholed es' \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LBase vs es';\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [$Return] @ es' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs\n 2. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts \\<Longrightarrow>\n           \\<exists>rs. return \\<C> = Some rs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs", "thus ?case"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LBase vs es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<exists>rs. return \\<C> = Some rs", "using e_type_comp_conc2[OF L0(3)] unlift_b_e[of \\<S> \\<C> \"[Return]\"] b_e_type_return"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LBase vs es'\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @ [$Return] @ es' : [] _> ts\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [$Return] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : ts'' _> ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> $* [Return] : ?tf \\<Longrightarrow>\n  \\<C> \\<turnstile> [Return] : ?tf\n  \\<lbrakk>?\\<C> \\<turnstile> [?e] : ?ts _> ?ts'; ?e = Return\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts_c ts''.\n                       ?ts = ts_c @ ts'' \\<and> return ?\\<C> = Some ts''\n\ngoal (1 subgoal):\n 1. \\<exists>rs. return \\<C> = Some rs", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rs. return \\<C> = Some rs\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts \\<Longrightarrow>\n           \\<exists>rs. return \\<C> = Some rs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts \\<Longrightarrow>\n           \\<exists>rs. return \\<C> = Some rs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs", "case (LN vs lholed tls es' l es'' k lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs tls es' l es''\n  Lfilled k l [$Return] lfilledk\n  \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : [] _> ?ts \\<Longrightarrow>\n  \\<exists>rs. return ?\\<C> = Some rs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label tls es' lfilledk] @ es'' : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk \\<C> ts.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled k l [$Return] lfilledk;\n        \\<And>\\<C> ts.\n           \\<S>\\<bullet>\\<C> \\<turnstile> lfilledk : [] _> ts \\<Longrightarrow>\n           \\<exists>rs. return \\<C> = Some rs;\n        \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n [Label n es' lfilledk] @ es'' : [] _> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs. return \\<C> = Some rs", "thus ?case"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs tls es' l es''\n  Lfilled k l [$Return] lfilledk\n  \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : [] _> ?ts \\<Longrightarrow>\n  \\<exists>rs. return ?\\<C> = Some rs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label tls es' lfilledk] @ es'' : [] _> ts\n\ngoal (1 subgoal):\n 1. \\<exists>rs. return \\<C> = Some rs", "using e_type_comp_conc2[OF LN(5)] e_type_label[of \\<S> \\<C> tls es' lfilledk]"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs tls es' l es''\n  Lfilled k l [$Return] lfilledk\n  \\<S>\\<bullet>?\\<C> \\<turnstile> lfilledk : [] _> ?ts \\<Longrightarrow>\n  \\<exists>rs. return ?\\<C> = Some rs\n  \\<S>\\<bullet>\\<C> \\<turnstile> vs @\n                                 [Label tls es' lfilledk] @ es'' : [] _> ts\n  \\<exists>ts' ts''.\n     \\<S>\\<bullet>\\<C> \\<turnstile> vs : [] _> ts' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> [Label tls es'\nlfilledk] : ts' _> ts'' \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es'' : ts'' _> ts\n  \\<S>\\<bullet>\\<C> \\<turnstile> [Label tls es'\n                                   lfilledk] : ?ts _> ?ts' \\<Longrightarrow>\n  \\<exists>tlsa t2s.\n     ?ts' = ?ts @ t2s \\<and>\n     length tlsa = tls \\<and>\n     \\<S>\\<bullet>\\<C> \\<turnstile> es' : tlsa _> t2s \\<and>\n     \\<S>\\<bullet>\\<C>\n     \\<lparr>label :=\n               [tlsa] @ label \\<C>\\<rparr> \\<turnstile> lfilledk : [] _> t2s\n\ngoal (1 subgoal):\n 1. \\<exists>rs. return \\<C> = Some rs", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rs. return \\<C> = Some rs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>rs. return \\<C> = Some rs\n\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "hence False"], ["proof (prove)\nusing this:\n  \\<exists>rs. return \\<C> = Some rs\n\ngoal (1 subgoal):\n 1. False", "using c_def(2)"], ["proof (prove)\nusing this:\n  \\<exists>rs. return \\<C> = Some rs\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "}"], ["proof (state)\nthis:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> Lfilled k lholed [$Return] es", "thus \"\\<And> k lholed. \\<not>(Lfilled k lholed [$Return] es)\""], ["proof (prove)\nusing this:\n  \\<exists>k lholed. Lfilled k lholed [$Return] es \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>k lholed. \\<not> Lfilled k lholed [$Return] es", "by blast"], ["proof (state)\nthis:\n  \\<not> Lfilled ?k ?lholed [$Return] es\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_e2:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;es : ts\"\n          \"store_typing s \\<S>\"\n  shows \"(Lfilled k lholed [$Br (j)] es) \\<Longrightarrow> j < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "assume \"(\\<exists>i k lholed. (Lfilled k lholed [$Br (i)] es) \\<and> i \\<ge> k)\""], ["proof (state)\nthis:\n  \\<exists>i k lholed. Lfilled k lholed [$Br i] es \\<and> k \\<le> i\n\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "then"], ["proof (chain)\npicking this:\n  \\<exists>i k lholed. Lfilled k lholed [$Br i] es \\<and> k \\<le> i", "obtain j k lholed where local_assms:\"(Lfilled k lholed [$Br (k+j)] es)\""], ["proof (prove)\nusing this:\n  \\<exists>i k lholed. Lfilled k lholed [$Br i] es \\<and> k \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<And>k lholed j.\n        Lfilled k lholed [$Br (k + j)] es \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis le_iff_add)"], ["proof (state)\nthis:\n  Lfilled k lholed [$Br (k + j)] es\n\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "obtain \\<C> where c_def:\"i < length (s_inst \\<S>)\"\n                   \"\\<C> = ((s_inst \\<S>)!i)\\<lparr>local := (local ((s_inst \\<S>)!i)) @ (map typeof vs), return := None\\<rparr>\"\n                   \"(\\<S>\\<bullet>\\<C> \\<turnstile> es : ([] _> ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<C>.\n        \\<lbrakk>i < length (s_inst \\<S>);\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local :=\n                     local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms s_type_unfold"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;es : ts\n  store_typing s \\<S>\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?i < length (s_inst ?\\<S>)\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?rs = Some ?ts \\<or> ?rs = None\n  ?\\<S>\\<bullet>?rs \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  ?\\<S>\\<bullet>(s_inst ?\\<S> ! ?i)\n  \\<lparr>local := local (s_inst ?\\<S> ! ?i) @ map typeof ?vs,\n     return := ?rs\\<rparr> \\<turnstile> ?es : [] _> ?ts\n\ngoal (1 subgoal):\n 1. (\\<And>\\<C>.\n        \\<lbrakk>i < length (s_inst \\<S>);\n         \\<C> =\n         return_update Map.empty\n          ((s_inst \\<S> ! i)\n           \\<lparr>local :=\n                     local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>);\n         \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  i < length (s_inst \\<S>)\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>)\n  \\<S>\\<bullet>\\<C> \\<turnstile> es : [] _> ts\n\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "have \"j < length (label \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (label \\<C>)", "using progress_LN1[OF local_assms c_def(3)]"], ["proof (prove)\nusing this:\n  j < length (label \\<C>)\n\ngoal (1 subgoal):\n 1. j < length (label \\<C>)", "by -"], ["proof (state)\nthis:\n  j < length (label \\<C>)\n\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "hence False"], ["proof (prove)\nusing this:\n  j < length (label \\<C>)\n\ngoal (1 subgoal):\n 1. False", "using store_local_label_empty(1)[OF c_def(1) assms(2)] c_def(2)"], ["proof (prove)\nusing this:\n  j < length (label \\<C>)\n  label (s_inst \\<S> ! i) = []\n  \\<C> =\n  return_update Map.empty\n   ((s_inst \\<S> ! i)\n    \\<lparr>local := local (s_inst \\<S> ! i) @ map typeof vs\\<rparr>)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "}"], ["proof (state)\nthis:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "thus \"(\\<And> j k lholed. (Lfilled k lholed [$Br (j)] es) \\<Longrightarrow> j < k)\""], ["proof (prove)\nusing this:\n  \\<exists>i k lholed.\n     Lfilled k lholed [$Br i] es \\<and> k \\<le> i \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>j k lholed. Lfilled k lholed [$Br j] es \\<Longrightarrow> j < k", "by fastforce"], ["proof (state)\nthis:\n  Lfilled ?k ?lholed [$Br ?j] es \\<Longrightarrow> ?j < ?k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma progress_e3:\n  assumes \"\\<S>\\<bullet>None \\<tturnstile>_i vs;cs_es : ts'\"\n          \"cs_es \\<noteq> [Trap]\"\n          \"\\<not> const_list (cs_es)\"\n          \"store_typing s \\<S>\"\n  shows \"\\<exists>a s' vs' es'. \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_i \\<lparr>s';vs';es'\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "using assms progress_e progress_e1 progress_e2"], ["proof (prove)\nusing this:\n  \\<S>\\<bullet>None \\<tturnstile>_ i vs;cs_es : ts'\n  cs_es \\<noteq> [Trap]\n  \\<not> const_list cs_es\n  store_typing s \\<S>\n  \\<lbrakk>?\\<S>\\<bullet>None \\<tturnstile>_ ?i ?vs;?cs_es : ?ts';\n   \\<And>k lholed. \\<not> Lfilled k lholed [$Return] ?cs_es;\n   \\<And>i k lholed.\n      Lfilled k lholed [$Br i] ?cs_es \\<Longrightarrow> i < k;\n   ?cs_es \\<noteq> [Trap]; \\<not> const_list ?cs_es;\n   store_typing ?s ?\\<S>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a s' vs' es'.\n                       \\<lparr>?s;?vs;?cs_es\\<rparr> \\<leadsto>_ ?i \\<lparr>s';vs';es'\\<rparr>\n  ?\\<S>\\<bullet>None \\<tturnstile>_ ?i ?vs;?es : ?ts \\<Longrightarrow>\n  \\<not> Lfilled ?k ?lholed [$Return] ?es\n  \\<lbrakk>?\\<S>\\<bullet>None \\<tturnstile>_ ?i ?vs;?es : ?ts;\n   store_typing ?s ?\\<S>; Lfilled ?k ?lholed [$Br ?j] ?es\\<rbrakk>\n  \\<Longrightarrow> ?j < ?k\n\ngoal (1 subgoal):\n 1. \\<exists>a s' vs' es'.\n       \\<lparr>s;vs;cs_es\\<rparr> \\<leadsto>_ i \\<lparr>s';vs';es'\\<rparr>", "by fastforce"], ["", "end"]]}