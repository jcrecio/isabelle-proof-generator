{"file_name": "/home/qj213/afp-2021-10-22/thys/WebAssembly/Wasm_Interpreter.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WebAssembly", "problem_names": ["lemma split_n_conv_take_drop: \"split_n es n = (take n es, drop n es)\"", "lemma split_n_length:\n  assumes \"split_n es n = (es1, es2)\" \"length es \\<ge> n\"\n  shows \"length es1 = n\"", "lemma split_n_conv_app:\n  assumes \"split_n es n = (es1, es2)\"\n  shows \"es = es1@es2\"", "lemma app_conv_split_n:\n  assumes \"es = es1@es2\"\n  shows \"split_n es (length es1) = (es1, es2)\"", "lemma split_vals_const_list: \"split_vals (map EConst vs) = (vs, [])\"", "lemma split_vals_e_const_list: \"split_vals_e ($$* vs) = (vs, [])\"", "lemma split_vals_e_conv_app:\n  assumes \"split_vals_e xs = (as, bs)\"\n  shows \"xs = ($$* as)@bs\"", "lemma[simp]: \"e_is_trap e = (e = Trap)\"", "lemma[simp]: \"es_is_trap es = (es = [Trap])\""], "translations": [["", "lemma split_n_conv_take_drop: \"split_n es n = (take n es, drop n es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_n es n = (take n es, drop n es)", "by (induction es n rule: split_n.induct, simp_all)"], ["", "lemma split_n_length:\n  assumes \"split_n es n = (es1, es2)\" \"length es \\<ge> n\"\n  shows \"length es1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length es1 = n", "using assms"], ["proof (prove)\nusing this:\n  split_n es n = (es1, es2)\n  n \\<le> length es\n\ngoal (1 subgoal):\n 1. length es1 = n", "unfolding split_n_conv_take_drop"], ["proof (prove)\nusing this:\n  (take n es, drop n es) = (es1, es2)\n  n \\<le> length es\n\ngoal (1 subgoal):\n 1. length es1 = n", "by fastforce"], ["", "lemma split_n_conv_app:\n  assumes \"split_n es n = (es1, es2)\"\n  shows \"es = es1@es2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = es1 @ es2", "using assms"], ["proof (prove)\nusing this:\n  split_n es n = (es1, es2)\n\ngoal (1 subgoal):\n 1. es = es1 @ es2", "unfolding split_n_conv_take_drop"], ["proof (prove)\nusing this:\n  (take n es, drop n es) = (es1, es2)\n\ngoal (1 subgoal):\n 1. es = es1 @ es2", "by auto"], ["", "lemma app_conv_split_n:\n  assumes \"es = es1@es2\"\n  shows \"split_n es (length es1) = (es1, es2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_n es (length es1) = (es1, es2)", "using assms"], ["proof (prove)\nusing this:\n  es = es1 @ es2\n\ngoal (1 subgoal):\n 1. split_n es (length es1) = (es1, es2)", "unfolding split_n_conv_take_drop"], ["proof (prove)\nusing this:\n  es = es1 @ es2\n\ngoal (1 subgoal):\n 1. (take (length es1) es, drop (length es1) es) = (es1, es2)", "by auto"], ["", "lemma split_vals_const_list: \"split_vals (map EConst vs) = (vs, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_vals (map EConst vs) = (vs, [])", "by (induction vs, simp_all)"], ["", "lemma split_vals_e_const_list: \"split_vals_e ($$* vs) = (vs, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_vals_e ($$* vs) = (vs, [])", "by (induction vs, simp_all)"], ["", "lemma split_vals_e_conv_app:\n  assumes \"split_vals_e xs = (as, bs)\"\n  shows \"xs = ($$* as)@bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ($$* as) @ bs", "using assms"], ["proof (prove)\nusing this:\n  split_vals_e xs = (as, bs)\n\ngoal (1 subgoal):\n 1. xs = ($$* as) @ bs", "proof (induction xs arbitrary: as rule: split_vals_e.induct)"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>v es as.\n       \\<lbrakk>\\<And>as.\n                   split_vals_e es = (as, bs) \\<Longrightarrow>\n                   es = ($$* as) @ bs;\n        split_vals_e (($C v) # es) = (as, bs)\\<rbrakk>\n       \\<Longrightarrow> ($C v) # es = ($$* as) @ bs\n 2. \\<And>as.\n       split_vals_e [] = (as, bs) \\<Longrightarrow> [] = ($$* as) @ bs\n 3. \\<And>va as.\n       split_vals_e (($Unreachable) # va) = (as, bs) \\<Longrightarrow>\n       ($Unreachable) # va = ($$* as) @ bs\n 4. \\<And>va as.\n       split_vals_e (($Nop) # va) = (as, bs) \\<Longrightarrow>\n       ($Nop) # va = ($$* as) @ bs\n 5. \\<And>va as.\n       split_vals_e (($Drop) # va) = (as, bs) \\<Longrightarrow>\n       ($Drop) # va = ($$* as) @ bs\n 6. \\<And>va as.\n       split_vals_e (($Select) # va) = (as, bs) \\<Longrightarrow>\n       ($Select) # va = ($$* as) @ bs\n 7. \\<And>vc vd va as.\n       split_vals_e (($Block vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Block vc vd) # va = ($$* as) @ bs\n 8. \\<And>vc vd va as.\n       split_vals_e (($Loop vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Loop vc vd) # va = ($$* as) @ bs\n 9. \\<And>vc vd ve va as.\n       split_vals_e (($b_e.If vc vd ve) # va) = (as, bs) \\<Longrightarrow>\n       ($b_e.If vc vd ve) # va = ($$* as) @ bs\n 10. \\<And>vc va as.\n        split_vals_e (($Br vc) # va) = (as, bs) \\<Longrightarrow>\n        ($Br vc) # va = ($$* as) @ bs\nA total of 36 subgoals...", "case (1 v es)"], ["proof (state)\nthis:\n  split_vals_e es = (?as, bs) \\<Longrightarrow> es = ($$* ?as) @ bs\n  split_vals_e (($C v) # es) = (as, bs)\n\ngoal (36 subgoals):\n 1. \\<And>v es as.\n       \\<lbrakk>\\<And>as.\n                   split_vals_e es = (as, bs) \\<Longrightarrow>\n                   es = ($$* as) @ bs;\n        split_vals_e (($C v) # es) = (as, bs)\\<rbrakk>\n       \\<Longrightarrow> ($C v) # es = ($$* as) @ bs\n 2. \\<And>as.\n       split_vals_e [] = (as, bs) \\<Longrightarrow> [] = ($$* as) @ bs\n 3. \\<And>va as.\n       split_vals_e (($Unreachable) # va) = (as, bs) \\<Longrightarrow>\n       ($Unreachable) # va = ($$* as) @ bs\n 4. \\<And>va as.\n       split_vals_e (($Nop) # va) = (as, bs) \\<Longrightarrow>\n       ($Nop) # va = ($$* as) @ bs\n 5. \\<And>va as.\n       split_vals_e (($Drop) # va) = (as, bs) \\<Longrightarrow>\n       ($Drop) # va = ($$* as) @ bs\n 6. \\<And>va as.\n       split_vals_e (($Select) # va) = (as, bs) \\<Longrightarrow>\n       ($Select) # va = ($$* as) @ bs\n 7. \\<And>vc vd va as.\n       split_vals_e (($Block vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Block vc vd) # va = ($$* as) @ bs\n 8. \\<And>vc vd va as.\n       split_vals_e (($Loop vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Loop vc vd) # va = ($$* as) @ bs\n 9. \\<And>vc vd ve va as.\n       split_vals_e (($b_e.If vc vd ve) # va) = (as, bs) \\<Longrightarrow>\n       ($b_e.If vc vd ve) # va = ($$* as) @ bs\n 10. \\<And>vc va as.\n        split_vals_e (($Br vc) # va) = (as, bs) \\<Longrightarrow>\n        ($Br vc) # va = ($$* as) @ bs\nA total of 36 subgoals...", "obtain as' bs' where \"split_vals_e es = (as', bs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' bs'.\n        split_vals_e es = (as', bs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split_vals_e es = (as', bs')\n\ngoal (36 subgoals):\n 1. \\<And>v es as.\n       \\<lbrakk>\\<And>as.\n                   split_vals_e es = (as, bs) \\<Longrightarrow>\n                   es = ($$* as) @ bs;\n        split_vals_e (($C v) # es) = (as, bs)\\<rbrakk>\n       \\<Longrightarrow> ($C v) # es = ($$* as) @ bs\n 2. \\<And>as.\n       split_vals_e [] = (as, bs) \\<Longrightarrow> [] = ($$* as) @ bs\n 3. \\<And>va as.\n       split_vals_e (($Unreachable) # va) = (as, bs) \\<Longrightarrow>\n       ($Unreachable) # va = ($$* as) @ bs\n 4. \\<And>va as.\n       split_vals_e (($Nop) # va) = (as, bs) \\<Longrightarrow>\n       ($Nop) # va = ($$* as) @ bs\n 5. \\<And>va as.\n       split_vals_e (($Drop) # va) = (as, bs) \\<Longrightarrow>\n       ($Drop) # va = ($$* as) @ bs\n 6. \\<And>va as.\n       split_vals_e (($Select) # va) = (as, bs) \\<Longrightarrow>\n       ($Select) # va = ($$* as) @ bs\n 7. \\<And>vc vd va as.\n       split_vals_e (($Block vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Block vc vd) # va = ($$* as) @ bs\n 8. \\<And>vc vd va as.\n       split_vals_e (($Loop vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Loop vc vd) # va = ($$* as) @ bs\n 9. \\<And>vc vd ve va as.\n       split_vals_e (($b_e.If vc vd ve) # va) = (as, bs) \\<Longrightarrow>\n       ($b_e.If vc vd ve) # va = ($$* as) @ bs\n 10. \\<And>vc va as.\n        split_vals_e (($Br vc) # va) = (as, bs) \\<Longrightarrow>\n        ($Br vc) # va = ($$* as) @ bs\nA total of 36 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  split_vals_e es = (as', bs')\n\ngoal (1 subgoal):\n 1. ($C v) # es = ($$* as) @ bs", "using 1"], ["proof (prove)\nusing this:\n  split_vals_e es = (as', bs')\n  split_vals_e es = (?as, bs) \\<Longrightarrow> es = ($$* ?as) @ bs\n  split_vals_e (($C v) # es) = (as, bs)\n\ngoal (1 subgoal):\n 1. ($C v) # es = ($$* as) @ bs", "by fastforce"], ["proof (state)\nthis:\n  ($C v) # es = ($$* as) @ bs\n\ngoal (35 subgoals):\n 1. \\<And>as.\n       split_vals_e [] = (as, bs) \\<Longrightarrow> [] = ($$* as) @ bs\n 2. \\<And>va as.\n       split_vals_e (($Unreachable) # va) = (as, bs) \\<Longrightarrow>\n       ($Unreachable) # va = ($$* as) @ bs\n 3. \\<And>va as.\n       split_vals_e (($Nop) # va) = (as, bs) \\<Longrightarrow>\n       ($Nop) # va = ($$* as) @ bs\n 4. \\<And>va as.\n       split_vals_e (($Drop) # va) = (as, bs) \\<Longrightarrow>\n       ($Drop) # va = ($$* as) @ bs\n 5. \\<And>va as.\n       split_vals_e (($Select) # va) = (as, bs) \\<Longrightarrow>\n       ($Select) # va = ($$* as) @ bs\n 6. \\<And>vc vd va as.\n       split_vals_e (($Block vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Block vc vd) # va = ($$* as) @ bs\n 7. \\<And>vc vd va as.\n       split_vals_e (($Loop vc vd) # va) = (as, bs) \\<Longrightarrow>\n       ($Loop vc vd) # va = ($$* as) @ bs\n 8. \\<And>vc vd ve va as.\n       split_vals_e (($b_e.If vc vd ve) # va) = (as, bs) \\<Longrightarrow>\n       ($b_e.If vc vd ve) # va = ($$* as) @ bs\n 9. \\<And>vc va as.\n       split_vals_e (($Br vc) # va) = (as, bs) \\<Longrightarrow>\n       ($Br vc) # va = ($$* as) @ bs\n 10. \\<And>vc va as.\n        split_vals_e (($Br_if vc) # va) = (as, bs) \\<Longrightarrow>\n        ($Br_if vc) # va = ($$* as) @ bs\nA total of 35 subgoals...", "qed simp_all"], ["", "abbreviation expect :: \"'a option \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b\" where\n  \"expect a f b \\<equiv> (case a of\n                     Some a' \\<Rightarrow> f a'\n                   | None \\<Rightarrow> b)\""], ["", "abbreviation vs_to_es :: \" v list \\<Rightarrow> e list\"\n  where \"vs_to_es v \\<equiv> $$* (rev v)\""], ["", "definition e_is_trap :: \"e \\<Rightarrow> bool\" where\n  \"e_is_trap e = (case e of Trap \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "definition es_is_trap :: \"e list \\<Rightarrow> bool\" where\n  \"es_is_trap es = (case es of [e] \\<Rightarrow> e_is_trap e | _ \\<Rightarrow> False)\""], ["", "lemma[simp]: \"e_is_trap e = (e = Trap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_is_trap e = (e = Trap)", "using e_is_trap_def"], ["proof (prove)\nusing this:\n  e_is_trap ?e =\n  (case ?e of Trap \\<Rightarrow> True | _ \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. e_is_trap e = (e = Trap)", "by (cases \"e\") auto"], ["", "lemma[simp]: \"es_is_trap es = (es = [Trap])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "proof (cases es)"], ["proof (state)\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow> es_is_trap es = (es = [Trap])\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow> es_is_trap es = (es = [Trap])", "case Nil"], ["proof (state)\nthis:\n  es = []\n\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow> es_is_trap es = (es = [Trap])\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow> es_is_trap es = (es = [Trap])", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = []\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "using es_is_trap_def"], ["proof (prove)\nusing this:\n  es = []\n  es_is_trap ?es =\n  (case ?es of [] \\<Rightarrow> False | [e] \\<Rightarrow> e_is_trap e\n   | e # aa # lista \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "by auto"], ["proof (state)\nthis:\n  es_is_trap es = (es = [Trap])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> es_is_trap es = (es = [Trap])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> es_is_trap es = (es = [Trap])", "case outer_Cons:(Cons a list)"], ["proof (state)\nthis:\n  es = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> es_is_trap es = (es = [Trap])", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = a # list\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "proof (cases list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>es = a # list; list = []\\<rbrakk>\n    \\<Longrightarrow> es_is_trap es = (es = [Trap])\n 2. \\<And>aa lista.\n       \\<lbrakk>es = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> es_is_trap es = (es = [Trap])", "case Nil"], ["proof (state)\nthis:\n  list = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>es = a # list; list = []\\<rbrakk>\n    \\<Longrightarrow> es_is_trap es = (es = [Trap])\n 2. \\<And>aa lista.\n       \\<lbrakk>es = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> es_is_trap es = (es = [Trap])", "thus ?thesis"], ["proof (prove)\nusing this:\n  list = []\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "using outer_Cons es_is_trap_def"], ["proof (prove)\nusing this:\n  list = []\n  es = a # list\n  es_is_trap ?es =\n  (case ?es of [] \\<Rightarrow> False | [e] \\<Rightarrow> e_is_trap e\n   | e # aa # lista \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "by auto"], ["proof (state)\nthis:\n  es_is_trap es = (es = [Trap])\n\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>es = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> es_is_trap es = (es = [Trap])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>es = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> es_is_trap es = (es = [Trap])", "case (Cons a' list')"], ["proof (state)\nthis:\n  list = a' # list'\n\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>es = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> es_is_trap es = (es = [Trap])", "thus ?thesis"], ["proof (prove)\nusing this:\n  list = a' # list'\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "using es_is_trap_def outer_Cons"], ["proof (prove)\nusing this:\n  list = a' # list'\n  es_is_trap ?es =\n  (case ?es of [] \\<Rightarrow> False | [e] \\<Rightarrow> e_is_trap e\n   | e # aa # lista \\<Rightarrow> False)\n  es = a # list\n\ngoal (1 subgoal):\n 1. es_is_trap es = (es = [Trap])", "by auto"], ["proof (state)\nthis:\n  es_is_trap es = (es = [Trap])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  es_is_trap es = (es = [Trap])\n\ngoal:\nNo subgoals!", "qed"], ["", "axiomatization \n  mem_grow_impl:: \"mem \\<Rightarrow> nat \\<Rightarrow> mem option\" where\n  mem_grow_impl_correct:\"(mem_grow_impl m n = Some m') \\<Longrightarrow> (mem_grow m n = m')\""], ["", "(*\ndefinition mem_grow_impl:: \"mem \\<Rightarrow> nat \\<Rightarrow> mem option\" where\n  \"mem_grow_impl m n = Some (mem_grow m n)\"\n\nlemma mem_grow_impl_correct:\n  \"(mem_grow_impl m n = Some m') \\<Longrightarrow> (mem_grow m n = m')\"\n  unfolding mem_grow_impl_def\n*)"], ["", "axiomatization \n  host_apply_impl:: \"s \\<Rightarrow> tf \\<Rightarrow> host \\<Rightarrow> v list \\<Rightarrow> (s \\<times> v list) option\" where\n  host_apply_impl_correct:\"(host_apply_impl s tf h vs = Some m') \\<Longrightarrow> (\\<exists>hs. host_apply s tf h vs hs = Some m')\""], ["", "function (sequential)                                                                               \n    run_step :: \"depth \\<Rightarrow> nat \\<Rightarrow> config_tuple \\<Rightarrow> res_tuple\"\nand run_one_step :: \"depth \\<Rightarrow> nat \\<Rightarrow> config_one_tuple \\<Rightarrow> res_tuple\" where\n  \"run_step d i (s,vs,es) = (let (ves, es') = split_vals_e es in\n                             case es' of\n                               [] \\<Rightarrow> (s,vs, crash_error)\n                             | e#es'' \\<Rightarrow>\n                               if e_is_trap e\n                                 then\n                                   if (es'' \\<noteq> [] \\<or> ves \\<noteq> [])\n                                     then\n                                       (s, vs, RSNormal [Trap])\n                                     else\n                                       (s, vs, crash_error)\n                                 else\n                                   (let (s',vs',r) = run_one_step d i (s,vs,(rev ves),e) in\n                                    case r of\n                                      RSNormal res \\<Rightarrow> (s', vs', RSNormal (res@es''))\n                                  | _ \\<Rightarrow> (s', vs', r)))\"\n| \"run_one_step d i (s, vs, ves, e) =\n     (case e of\n    \\<comment> \\<open>\\<open>B_E\\<close>\\<close>\n      \\<comment> \\<open>\\<open>UNOPS\\<close>\\<close>\n        $(Unop_i T_i32 iop) \\<Rightarrow>\n         (case ves of\n            (ConstInt32 c)#ves' \\<Rightarrow>\n              (s, vs, RSNormal (vs_to_es ((ConstInt32 (app_unop_i iop c))#ves')))\n          | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Unop_i T_i64 iop) \\<Rightarrow>\n          (case ves of\n             (ConstInt64 c)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt64 (app_unop_i iop c))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Unop_i _ iop) \\<Rightarrow> (s, vs, crash_error)\n      | $(Unop_f T_f32 fop) \\<Rightarrow>\n          (case ves of\n             (ConstFloat32 c)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstFloat32 (app_unop_f fop c))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Unop_f T_f64 fop) \\<Rightarrow>\n          (case ves of\n             (ConstFloat64 c)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstFloat64 (app_unop_f fop c))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Unop_f _ fop) \\<Rightarrow> (s, vs, crash_error)\n      \\<comment> \\<open>\\<open>BINOPS\\<close>\\<close>\n      | $(Binop_i T_i32 iop) \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c2)#(ConstInt32 c1)#ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2) (\\<lambda>c. (s, vs, RSNormal (vs_to_es ((ConstInt32 c)#ves')))) (s, vs, RSNormal ((vs_to_es ves')@[Trap]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Binop_i T_i64 iop) \\<Rightarrow>\n          (case ves of\n             (ConstInt64 c2)#(ConstInt64 c1)#ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2) (\\<lambda>c. (s, vs, RSNormal (vs_to_es ((ConstInt64 c)#ves')))) (s, vs, RSNormal ((vs_to_es ves')@[Trap]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Binop_i _ iop) \\<Rightarrow> (s, vs, crash_error)\n      | $(Binop_f T_f32 fop) \\<Rightarrow>\n          (case ves of\n             (ConstFloat32 c2)#(ConstFloat32 c1)#ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2) (\\<lambda>c. (s, vs, RSNormal (vs_to_es ((ConstFloat32 c)#ves')))) (s, vs, RSNormal ((vs_to_es ves')@[Trap]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Binop_f T_f64 fop) \\<Rightarrow>\n        (case ves of\n           (ConstFloat64 c2)#(ConstFloat64 c1)#ves' \\<Rightarrow>\n              expect (app_binop_f fop c1 c2) (\\<lambda>c. (s, vs, RSNormal (vs_to_es ((ConstFloat64 c)#ves')))) (s, vs, RSNormal ((vs_to_es ves')@[Trap]))\n         | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Binop_f _ fop) \\<Rightarrow> (s, vs, crash_error)\n      \\<comment> \\<open>\\<open>TESTOPS\\<close>\\<close>\n      | $(Testop T_i32 testop) \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt32 (wasm_bool (app_testop_i testop c)))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Testop T_i64 testop) \\<Rightarrow>\n          (case ves of\n             (ConstInt64 c)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt32 (wasm_bool (app_testop_i testop c)))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Testop _ testop) \\<Rightarrow> (s, vs, crash_error)\n      \\<comment> \\<open>\\<open>RELOPS\\<close>\\<close>\n      | $(Relop_i T_i32 iop) \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c2)#(ConstInt32 c1)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt32 (wasm_bool (app_relop_i iop c1 c2)))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Relop_i T_i64 iop) \\<Rightarrow>\n          (case ves of\n             (ConstInt64 c2)#(ConstInt64 c1)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt32 (wasm_bool (app_relop_i iop c1 c2)))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Relop_i _ iop) \\<Rightarrow> (s, vs, crash_error)\n      | $(Relop_f T_f32 fop) \\<Rightarrow>\n          (case ves of\n             (ConstFloat32 c2)#(ConstFloat32 c1)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt32 (wasm_bool (app_relop_f fop c1 c2)))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Relop_f T_f64 fop) \\<Rightarrow>\n          (case ves of\n             (ConstFloat64 c2)#(ConstFloat64 c1)#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ((ConstInt32 (wasm_bool (app_relop_f fop c1 c2)))#ves')))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Relop_f _ fop) \\<Rightarrow> (s, vs, crash_error)\n      \\<comment> \\<open>\\<open>CONVERT\\<close>\\<close>\n      | $(Cvtop t2 Convert t1 sx) \\<Rightarrow>\n          (case ves of\n             v#ves' \\<Rightarrow>\n               (if (types_agree t1 v)\n                  then\n                    expect (cvt t2 sx v) (\\<lambda>v'. (s, vs, RSNormal (vs_to_es (v'#ves')))) (s, vs, RSNormal ((vs_to_es ves')@[Trap]))\n                  else\n                    (s, vs, crash_error))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      | $(Cvtop t2 Reinterpret t1 sx) \\<Rightarrow>\n          (case ves of\n             v#ves' \\<Rightarrow>\n               (if (types_agree t1 v \\<and> sx = None)\n                  then\n                    (s, vs, RSNormal (vs_to_es ((wasm_deserialise (bits v) t2)#ves')))\n                  else\n                    (s, vs, crash_error))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>UNREACHABLE\\<close>\\<close>\n      | $Unreachable \\<Rightarrow>\n          (s, vs, RSNormal ((vs_to_es ves)@[Trap]))\n      \\<comment> \\<open>\\<open>NOP\\<close>\\<close>\n      | $Nop \\<Rightarrow>\n          (s, vs, RSNormal (vs_to_es ves))\n      \\<comment> \\<open>\\<open>DROP\\<close>\\<close>\n      | $Drop \\<Rightarrow>\n          (case ves of\n             v#ves' \\<Rightarrow>\n               (s, vs, RSNormal (vs_to_es ves'))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>SELECT\\<close>\\<close>\n      | $Select \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#v2#v1#ves' \\<Rightarrow>\n               (if int_eq c 0 then (s, vs, RSNormal (vs_to_es (v2#ves'))) else (s, vs, RSNormal (vs_to_es (v1#ves'))))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>BLOCK\\<close>\\<close>\n      | $(Block (t1s _> t2s) es) \\<Rightarrow>\n          (if length ves \\<ge> length t1s\n             then\n               let (ves', ves'') = split_n ves (length t1s) in\n               (s, vs, RSNormal ((vs_to_es ves'') @ [Label (length t2s) [] ((vs_to_es ves')@($* es))]))\n             else\n               (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>LOOP\\<close>\\<close>\n      | $(Loop (t1s _> t2s) es) \\<Rightarrow>\n          (if length ves \\<ge> length t1s\n             then\n               let (ves', ves'') = split_n ves (length t1s) in\n               (s, vs, RSNormal ((vs_to_es ves'') @ [Label (length t1s) [$(Loop (t1s _> t2s) es)] ((vs_to_es ves')@($* es))]))\n             else\n               (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>IF\\<close>\\<close>\n      | $(If tf es1 es2) \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#ves' \\<Rightarrow>\n                if int_eq c 0\n                  then\n                    (s, vs, RSNormal ((vs_to_es ves')@[$(Block tf es2)]))\n                  else\n                    (s, vs, RSNormal ((vs_to_es ves')@[$(Block tf es1)]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>BR\\<close>\\<close>\n      | $Br j \\<Rightarrow>\n          (s, vs, RSBreak j ves)\n      \\<comment> \\<open>\\<open>BR_IF\\<close>\\<close>\n      | $Br_if j \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#ves' \\<Rightarrow>\n                if int_eq c 0\n                  then\n                    (s, vs, RSNormal (vs_to_es ves'))\n                  else\n                    (s, vs, RSNormal ((vs_to_es ves') @ [$Br j]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>BR_TABLE\\<close>\\<close>\n      | $Br_table js j \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#ves' \\<Rightarrow>\n             let k = nat_of_int c in\n                if k < length js\n                  then\n                    (s, vs, RSNormal ((vs_to_es ves') @ [$Br (js!k)]))\n                  else\n                    (s, vs, RSNormal ((vs_to_es ves') @ [$Br j]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>CALL\\<close>\\<close>\n      | $Call j \\<Rightarrow>\n          (s, vs, RSNormal ((vs_to_es ves) @ [Callcl (sfunc s i j)]))\n      \\<comment> \\<open>\\<open>CALL_INDIRECT\\<close>\\<close>\n      | $Call_indirect j \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#ves' \\<Rightarrow>\n               (case (stab s i (nat_of_int c)) of\n                  Some cl \\<Rightarrow>\n                    if (stypes s i j = cl_type cl)\n                      then\n                        (s, vs, RSNormal ((vs_to_es ves') @ [Callcl cl]))\n                      else\n                        (s, vs, RSNormal ((vs_to_es ves')@[Trap]))\n                | _ \\<Rightarrow> (s, vs, RSNormal ((vs_to_es ves')@[Trap])))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>RETURN\\<close>\\<close>\n      | $Return \\<Rightarrow>\n          (s, vs, RSReturn ves)\n      \\<comment> \\<open>\\<open>GET_LOCAL\\<close>\\<close>\n      | $Get_local j \\<Rightarrow>\n          (if j < length vs\n             then (s, vs, RSNormal (vs_to_es ((vs!j)#ves)))\n             else (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>SET_LOCAL\\<close>\\<close>\n      | $Set_local j \\<Rightarrow>\n          (case ves of\n             v#ves' \\<Rightarrow>\n               if j < length vs\n                 then (s, vs[j := v], RSNormal (vs_to_es ves'))\n                 else (s, vs, crash_error)\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>TEE_LOCAL\\<close>\\<close>\n      | $Tee_local j \\<Rightarrow>\n          (case ves of\n             v#ves' \\<Rightarrow>\n               (s, vs, RSNormal ((vs_to_es (v#ves)) @ [$(Set_local j)]))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>GET_GLOBAL\\<close>\\<close>\n      | $Get_global j \\<Rightarrow>\n          (s, vs, RSNormal (vs_to_es ((sglob_val s i j)#ves)))\n      \\<comment> \\<open>\\<open>SET_GLOBAL\\<close>\\<close>\n      | $Set_global j \\<Rightarrow>\n          (case ves of\n             v#ves' \\<Rightarrow> ((supdate_glob s i j v), vs, RSNormal (vs_to_es ves'))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>LOAD\\<close>\\<close>\n      | $(Load t None a off) \\<Rightarrow>\n          (case ves of\n             (ConstInt32 k)#ves' \\<Rightarrow>\n               expect (smem_ind s i)\n                  (\\<lambda>j.\n                    expect (load ((mem s)!j) (nat_of_int k) off (t_length t))\n                      (\\<lambda>bs. (s, vs, RSNormal (vs_to_es ((wasm_deserialise bs t)#ves'))))\n                      (s, vs, RSNormal ((vs_to_es ves')@[Trap])))\n                  (s, vs, crash_error)\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>LOAD PACKED\\<close>\\<close>\n      | $(Load t (Some (tp, sx)) a off) \\<Rightarrow>\n          (case ves of\n             (ConstInt32 k)#ves' \\<Rightarrow>\n               expect (smem_ind s i)\n                  (\\<lambda>j.\n                    expect (load_packed sx ((mem s)!j) (nat_of_int k) off (tp_length tp) (t_length t))\n                      (\\<lambda>bs. (s, vs, RSNormal (vs_to_es ((wasm_deserialise bs t)#ves'))))\n                      (s, vs, RSNormal ((vs_to_es ves')@[Trap])))\n                  (s, vs, crash_error)\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>STORE\\<close>\\<close>\n      | $(Store t None a off) \\<Rightarrow>\n          (case ves of\n             v#(ConstInt32 k)#ves' \\<Rightarrow>\n               (if (types_agree t v)\n                 then\n                   expect (smem_ind s i)\n                      (\\<lambda>j.\n                         expect (store ((mem s)!j) (nat_of_int k) off (bits v) (t_length t))\n                           (\\<lambda>mem'. (s\\<lparr>mem:= ((mem s)[j := mem'])\\<rparr>, vs, RSNormal (vs_to_es ves')))\n                           (s, vs, RSNormal ((vs_to_es ves')@[Trap])))\n                      (s, vs, crash_error)\n                 else\n                   (s, vs, crash_error))\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>STORE_PACKED\\<close>\\<close>\n      | $(Store t (Some tp) a off) \\<Rightarrow>\n          (case ves of\n                  v#(ConstInt32 k)#ves' \\<Rightarrow>\n                    (if (types_agree t v)\n                      then\n                        expect (smem_ind s i)\n                           (\\<lambda>j.\n                              expect (store_packed ((mem s)!j) (nat_of_int k) off (bits v) (tp_length tp))\n                                (\\<lambda>mem'. (s\\<lparr>mem:= ((mem s)[j := mem'])\\<rparr>, vs, RSNormal (vs_to_es ves')))\n                                (s, vs, RSNormal ((vs_to_es ves')@[Trap])))\n                           (s, vs, crash_error)\n                      else\n                        (s, vs, crash_error))\n                | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>CURRENT_MEMORY\\<close>\\<close>\n      | $Current_memory \\<Rightarrow>\n          expect (smem_ind s i)\n            (\\<lambda>j. (s, vs, RSNormal (vs_to_es ((ConstInt32 (int_of_nat (mem_size ((s.mem s)!j))))#ves))))\n            (s, vs, crash_error)\n      \\<comment> \\<open>\\<open>GROW_MEMORY\\<close>\\<close>\n      | $Grow_memory \\<Rightarrow>\n          (case ves of\n             (ConstInt32 c)#ves' \\<Rightarrow>\n                expect (smem_ind s i)\n                  (\\<lambda>j.\n                     let l = (mem_size ((s.mem s)!j)) in\n                     (expect (mem_grow_impl ((mem s)!j) (nat_of_int c))\n                        (\\<lambda>mem'. (s\\<lparr>mem:= ((mem s)[j := mem'])\\<rparr>, vs, RSNormal (vs_to_es ((ConstInt32 (int_of_nat l))#ves'))))\n                        (s, vs, RSNormal (vs_to_es ((ConstInt32 int32_minus_one)#ves')))))\n                  (s, vs, crash_error)\n           | _ \\<Rightarrow> (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>VAL\\<close> - should not be executed\\<close>\n      | $C v \\<Rightarrow> (s, vs, crash_error)\n    \\<comment> \\<open>\\<open>E\\<close>\\<close>\n      \\<comment> \\<open>\\<open>CALLCL\\<close>\\<close>\n      | Callcl cl \\<Rightarrow>\n          (case cl of\n             Func_native i' (t1s _> t2s) ts es \\<Rightarrow>\n               let n = length t1s in\n               let m = length t2s in\n               if length ves \\<ge> n\n                 then\n                   let (ves', ves'') = split_n ves n in\n                   let zs = n_zeros ts in\n                     (s, vs, RSNormal ((vs_to_es ves'') @ ([Local m i' ((rev ves')@zs) [$(Block ([] _> t2s) es)]])))\n                 else\n                   (s, vs, crash_error)\n           | Func_host (t1s _> t2s) f \\<Rightarrow>\n               let n = length t1s in\n               let m = length t2s in\n               if length ves \\<ge> n\n                 then\n                   let (ves', ves'') = split_n ves n in\n                   case host_apply_impl s (t1s _> t2s) f (rev ves') of\n                     Some (s',rves) \\<Rightarrow> \n                       if list_all2 types_agree t2s rves\n                         then\n                           (s', vs, RSNormal ((vs_to_es ves'') @ ($$* rves)))\n                         else\n                           (s', vs, crash_error)\n                   | None \\<Rightarrow> (s, vs, RSNormal ((vs_to_es ves'')@[Trap]))\n                 else\n                   (s, vs, crash_error))\n      \\<comment> \\<open>\\<open>LABEL\\<close>\\<close>\n      | Label ln les es \\<Rightarrow>\n          if es_is_trap es\n            then\n              (s, vs, RSNormal ((vs_to_es ves)@[Trap]))\n             else\n               (if (const_list es)\n                  then\n                    (s, vs, RSNormal ((vs_to_es ves)@es))\n                  else\n                    let (s', vs', res) = run_step d i (s, vs, es) in\n                    (case res of\n                       RSBreak 0 bvs \\<Rightarrow>\n                         if (length bvs \\<ge> ln)\n                           then (s', vs', RSNormal ((vs_to_es ((take ln bvs)@ves))@les))\n                           else (s', vs', crash_error)\n                     | RSBreak (Suc n) bvs \\<Rightarrow>\n                         (s', vs', RSBreak n bvs)\n                     | RSReturn rvs \\<Rightarrow>\n                         (s', vs', RSReturn rvs)\n                     | RSNormal es' \\<Rightarrow>\n                         (s', vs', RSNormal ((vs_to_es ves)@[Label ln les es']))\n                     | _ \\<Rightarrow> (s', vs', crash_error)))\n     \\<comment> \\<open>\\<open>LOCAL\\<close>\\<close>\n     | Local ln j vls es \\<Rightarrow>\n          if es_is_trap es\n            then\n              (s, vs, RSNormal ((vs_to_es ves)@[Trap]))\n             else\n               (if (const_list es)\n                  then\n                    if (length es = ln)\n                      then (s, vs, RSNormal ((vs_to_es ves)@es))\n                      else (s, vs, crash_error)\n                  else\n                    case d of\n                      0 \\<Rightarrow> (s, vs, crash_error)\n                    | Suc d' \\<Rightarrow>\n                        let (s', vls', res) = run_step d' j (s, vls, es) in\n                        (case res of\n                           RSReturn rvs \\<Rightarrow>\n                             if (length rvs \\<ge> ln)\n                               then (s', vs, RSNormal (vs_to_es ((take ln rvs)@ves)))\n                               else (s', vs, crash_error)\n                         | RSNormal es' \\<Rightarrow>\n                             (s', vs, RSNormal ((vs_to_es ves)@[Local ln j vls' es']))\n                         | _ \\<Rightarrow> (s', vs, RSCrash CExhaustion)))\n     \\<comment> \\<open>\\<open>TRAP\\<close> - should not be executed\\<close>\n     | Trap \\<Rightarrow> (s, vs, crash_error))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>d i s vs es.\n                   x = Inl (d, i, s, vs, es) \\<Longrightarrow> P;\n        \\<And>d i s vs ves e.\n           x = Inr (d, i, s, vs, ves, e) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>d i s vs es da ia sa vsa esa.\n       Inl (d, i, s, vs, es) = Inl (da, ia, sa, vsa, esa) \\<Longrightarrow>\n       (let (ves, y) = split_vals_e es\n        in case_list (s, vs, crash_error)\n            (\\<lambda>e es''.\n                if e_is_trap e\n                then if es'' \\<noteq> [] \\<or> ves \\<noteq> []\n                     then (s, vs, RSNormal [Trap]) else (s, vs, crash_error)\n                else let (s', vs', r) =\n                           run_step_run_one_step_sumC\n                            (Inr (d, i, s, vs, rev ves, e))\n                     in case r of\n                        RSNormal res \\<Rightarrow>\n                          (s', vs', RSNormal (res @ es''))\n                        | _ \\<Rightarrow> (s', vs', r))\n            y) =\n       (let (ves, y) = split_vals_e esa\n        in case_list (sa, vsa, crash_error)\n            (\\<lambda>e es''.\n                if e_is_trap e\n                then if es'' \\<noteq> [] \\<or> ves \\<noteq> []\n                     then (sa, vsa, RSNormal [Trap])\n                     else (sa, vsa, crash_error)\n                else let (s', vs', r) =\n                           run_step_run_one_step_sumC\n                            (Inr (da, ia, sa, vsa, rev ves, e))\n                     in case r of\n                        RSNormal res \\<Rightarrow>\n                          (s', vs', RSNormal (res @ es''))\n                        | _ \\<Rightarrow> (s', vs', r))\n            y)\n 3. \\<And>d i s vs es da ia sa vsa ves e.\n       Inl (d, i, s, vs, es) =\n       Inr (da, ia, sa, vsa, ves, e) \\<Longrightarrow>\n       (let (ves, y) = split_vals_e es\n        in case_list (s, vs, crash_error)\n            (\\<lambda>e es''.\n                if e_is_trap e\n                then if es'' \\<noteq> [] \\<or> ves \\<noteq> []\n                     then (s, vs, RSNormal [Trap]) else (s, vs, crash_error)\n                else let (s', vs', r) =\n                           run_step_run_one_step_sumC\n                            (Inr (d, i, s, vs, rev ves, e))\n                     in case r of\n                        RSNormal res \\<Rightarrow>\n                          (s', vs', RSNormal (res @ es''))\n                        | _ \\<Rightarrow> (s', vs', r))\n            y) =\n       (case e of\n        $Unreachable \\<Rightarrow>\n          (sa, vsa, RSNormal (vs_to_es ves @ [Trap]))\n        | $Nop \\<Rightarrow> (sa, vsa, RSNormal (vs_to_es ves))\n        | $Drop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow> (sa, vsa, RSNormal (vs_to_es ves'))\n        | $Select \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c, v2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # v2 # v1 # ves' \\<Rightarrow>\n                if int_eq c 0\n                then (sa, vsa, RSNormal (vs_to_es (v2 # ves')))\n                else (sa, vsa, RSNormal (vs_to_es (v1 # ves')))\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Block (t1s _> t2s) es \\<Rightarrow>\n            if length t1s \\<le> length ves\n            then let (ves', ves'') = split_n ves (length t1s)\n                 in (sa, vsa,\n                     RSNormal\n                      (vs_to_es ves'' @\n                       [Label (length t2s) [] (vs_to_es ves' @ ($* es))]))\n            else (sa, vsa, crash_error)\n        | $Loop (t1s _> t2s) es \\<Rightarrow>\n            if length t1s \\<le> length ves\n            then let (ves', ves'') = split_n ves (length t1s)\n                 in (sa, vsa,\n                     RSNormal\n                      (vs_to_es ves'' @\n                       [Label (length t1s) [$Loop (t1s _> t2s) es]\n                         (vs_to_es ves' @ ($* es))]))\n            else (sa, vsa, crash_error)\n        | $b_e.If tf es1 es2 \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                if int_eq c 0\n                then (sa, vsa, RSNormal (vs_to_es ves' @ [$Block tf es2]))\n                else (sa, vsa, RSNormal (vs_to_es ves' @ [$Block tf es1]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Br j \\<Rightarrow> (sa, vsa, RSBreak j ves)\n        | $Br_if j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                if int_eq c 0 then (sa, vsa, RSNormal (vs_to_es ves'))\n                else (sa, vsa, RSNormal (vs_to_es ves' @ [$Br j]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Br_table js j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                let k = nat_of_int c\n                in if k < length js\n                   then (sa, vsa, RSNormal (vs_to_es ves' @ [$Br (js ! k)]))\n                   else (sa, vsa, RSNormal (vs_to_es ves' @ [$Br j]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Return \\<Rightarrow> (sa, vsa, RSReturn ves)\n        | $Call j \\<Rightarrow>\n            (sa, vsa, RSNormal (vs_to_es ves @ [Callcl (sfunc sa ia j)]))\n        | $Call_indirect j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                expect (stab sa ia (nat_of_int c))\n                 (\\<lambda>cl.\n                     if stypes sa ia j = cl_type cl\n                     then (sa, vsa, RSNormal (vs_to_es ves' @ [Callcl cl]))\n                     else (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Get_local j \\<Rightarrow>\n            if j < length vsa\n            then (sa, vsa, RSNormal (vs_to_es (vsa ! j # ves)))\n            else (sa, vsa, crash_error)\n        | $Set_local j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                if j < length vsa\n                then (sa, vsa[j := v], RSNormal (vs_to_es ves'))\n                else (sa, vsa, crash_error)\n        | $Tee_local j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                (sa, vsa, RSNormal (vs_to_es (v # ves) @ [$Set_local j]))\n        | $Get_global j \\<Rightarrow>\n            (sa, vsa, RSNormal (vs_to_es (sglob_val sa ia j # ves)))\n        | $Set_global j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                (supdate_glob sa ia j v, vsa, RSNormal (vs_to_es ves'))\n        | $Load t aa a off \\<Rightarrow>\n            expect aa\n             (\\<lambda>(tp, sx).\n                 case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n                 | ConstInt32 k # ves' \\<Rightarrow>\n                     expect (smem_ind sa ia)\n                      (\\<lambda>a'.\n                          expect\n                           (load_packed sx (s.mem sa ! a') (nat_of_int k)\n                             off (tp_length tp) (t_length t))\n                           (\\<lambda>a'.\n                               (sa, vsa,\n                                RSNormal\n                                 (vs_to_es (wasm_deserialise a' t # ves'))))\n                           (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                      (sa, vsa, crash_error)\n                 | _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n             (case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n              | ConstInt32 k # ves' \\<Rightarrow>\n                  expect (smem_ind sa ia)\n                   (\\<lambda>a'.\n                       expect\n                        (load (s.mem sa ! a') (nat_of_int k) off\n                          (t_length t))\n                        (\\<lambda>a'.\n                            (sa, vsa,\n                             RSNormal\n                              (vs_to_es (wasm_deserialise a' t # ves'))))\n                        (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                   (sa, vsa, crash_error)\n              | _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n        | $Store t aa a off \\<Rightarrow>\n            expect aa\n             (\\<lambda>tp.\n                 case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n                 | [v] \\<Rightarrow> (sa, vsa, crash_error)\n                 | v # ConstInt32 k # ves' \\<Rightarrow>\n                     if types_agree t v\n                     then expect (smem_ind sa ia)\n                           (\\<lambda>a'.\n                               expect\n                                (store_packed (s.mem sa ! a') (nat_of_int k)\n                                  off (bits v) (tp_length tp))\n                                (\\<lambda>a'a.\n                                    (sa\\<lparr>s.mem := (s.mem sa)\n           [a' := a'a]\\<rparr>,\n                                     vsa, RSNormal (vs_to_es ves')))\n                                (sa, vsa,\n                                 RSNormal (vs_to_es ves' @ [Trap])))\n                           (sa, vsa, crash_error)\n                     else (sa, vsa, crash_error)\n                 | v # _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n             (case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n              | [v] \\<Rightarrow> (sa, vsa, crash_error)\n              | v # ConstInt32 k # ves' \\<Rightarrow>\n                  if types_agree t v\n                  then expect (smem_ind sa ia)\n                        (\\<lambda>a'.\n                            expect\n                             (store (s.mem sa ! a') (nat_of_int k) off\n                               (bits v) (t_length t))\n                             (\\<lambda>a'a.\n                                 (sa\\<lparr>s.mem := (s.mem sa)\n        [a' := a'a]\\<rparr>,\n                                  vsa, RSNormal (vs_to_es ves')))\n                             (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                        (sa, vsa, crash_error)\n                  else (sa, vsa, crash_error)\n              | v # _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n        | $Current_memory \\<Rightarrow>\n            expect (smem_ind sa ia)\n             (\\<lambda>a'.\n                 (sa, vsa,\n                  RSNormal\n                   (vs_to_es\n                     (ConstInt32 (int_of_nat (mem_size (s.mem sa ! a'))) #\n                      ves))))\n             (sa, vsa, crash_error)\n        | $Grow_memory \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                expect (smem_ind sa ia)\n                 (\\<lambda>a'.\n                     let l = mem_size (s.mem sa ! a')\n                     in expect\n                         (mem_grow_impl (s.mem sa ! a') (nat_of_int c))\n                         (\\<lambda>a'a.\n                             (sa\\<lparr>s.mem := (s.mem sa)\n    [a' := a'a]\\<rparr>,\n                              vsa,\n                              RSNormal\n                               (vs_to_es\n                                 (ConstInt32 (int_of_nat l) # ves'))))\n                         (sa, vsa,\n                          RSNormal\n                           (vs_to_es (ConstInt32 int32_minus_one # ves'))))\n                 (sa, vsa, crash_error)\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $C v \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_i T_i32 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal (vs_to_es (ConstInt32 (app_unop_i iop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_i T_i64 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal (vs_to_es (ConstInt64 (app_unop_i iop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_i _ iop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_f T_f32 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat32 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es (ConstFloat32 (app_unop_f fop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_f T_f64 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat64 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es (ConstFloat64 (app_unop_f fop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_f _ fop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_i T_i32 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c2 # ConstInt32 c1 # ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa, RSNormal (vs_to_es (ConstInt32 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstInt32 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_i T_i64 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c2 # ConstInt64 c1 # ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa, RSNormal (vs_to_es (ConstInt64 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstInt64 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_i _ iop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_f T_f32 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat32 c2 # ConstFloat32 c1 # ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa,\n                      RSNormal (vs_to_es (ConstFloat32 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstFloat32 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_f T_f64 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat64 c2 # ConstFloat64 c1 # ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa,\n                      RSNormal (vs_to_es (ConstFloat64 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstFloat64 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_f _ fop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Testop T_i32 testop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_testop_i testop c)) #\n                     ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Testop T_i64 testop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_testop_i testop c)) #\n                     ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Testop _ testop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_i T_i32 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c2 # ConstInt32 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_i iop c1 c2)) #\n                     ves')))\n            | ConstInt32 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_i T_i64 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c2 # ConstInt64 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_i iop c1 c2)) #\n                     ves')))\n            | ConstInt64 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_i _ iop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_f T_f32 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat32 c2 # ConstFloat32 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_f fop c1 c2)) #\n                     ves')))\n            | ConstFloat32 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_f T_f64 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat64 c2 # ConstFloat64 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_f fop c1 c2)) #\n                     ves')))\n            | ConstFloat64 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_f _ fop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Cvtop t2 Convert t1 sx \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                if types_agree t1 v\n                then expect (cvt t2 sx v)\n                      (\\<lambda>a'.\n                          (sa, vsa, RSNormal (vs_to_es (a' # ves'))))\n                      (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n                else (sa, vsa, crash_error)\n        | $Cvtop t2 Reinterpret t1 sx \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                if types_agree t1 v \\<and> sx = None\n                then (sa, vsa,\n                      RSNormal\n                       (vs_to_es (wasm_deserialise (bits v) t2 # ves')))\n                else (sa, vsa, crash_error)\n        | Trap \\<Rightarrow> (sa, vsa, crash_error)\n        | Callcl (Func_native i' (t1s _> t2s) ts es) \\<Rightarrow>\n            let n = length t1s; m = length t2s\n            in if n \\<le> length ves\n               then let (ves', ves'') = split_n ves n; zs = n_zeros ts\n                    in (sa, vsa,\n                        RSNormal\n                         (vs_to_es ves'' @\n                          [Local m i' (rev ves' @ zs)\n                            [$Block ([] _> t2s) es]]))\n               else (sa, vsa, crash_error)\n        | Callcl (Func_host (t1s _> t2s) f) \\<Rightarrow>\n            let n = length t1s; m = length t2s\n            in if n \\<le> length ves\n               then let (ves', ves'') = split_n ves n\n                    in expect (host_apply_impl sa (t1s _> t2s) f (rev ves'))\n                        (\\<lambda>(s', rves).\n                            if list_all2 types_agree t2s rves\n                            then (s', vsa,\n                                  RSNormal (vs_to_es ves'' @ ($$* rves)))\n                            else (s', vsa, crash_error))\n                        (sa, vsa, RSNormal (vs_to_es ves'' @ [Trap]))\n               else (sa, vsa, crash_error)\n        | Label ln les es \\<Rightarrow>\n            if es_is_trap es\n            then (sa, vsa, RSNormal (vs_to_es ves @ [Trap]))\n            else if const_list es\n                 then (sa, vsa, RSNormal (vs_to_es ves @ es))\n                 else let (s', vs', y) =\n                            run_step_run_one_step_sumC\n                             (Inl (da, ia, sa, vsa, es))\n                      in case_res_step\n                          (\\<lambda>res_crash. (s', vs', crash_error))\n                          (\\<lambda>nat bvs.\n                              case nat of\n                              0 \\<Rightarrow>\n                                if ln \\<le> length bvs\n                                then (s', vs',\nRSNormal (vs_to_es (take ln bvs @ ves) @ les))\n                                else (s', vs', crash_error)\n                              | Suc n \\<Rightarrow>\n                                  (s', vs', RSBreak n bvs))\n                          (\\<lambda>rvs. (s', vs', RSReturn rvs))\n                          (\\<lambda>es'.\n                              (s', vs',\n                               RSNormal\n                                (vs_to_es ves @ [Label ln les es'])))\n                          y\n        | Local ln j vls es \\<Rightarrow>\n            if es_is_trap es\n            then (sa, vsa, RSNormal (vs_to_es ves @ [Trap]))\n            else if const_list es\n                 then if length es = ln\n                      then (sa, vsa, RSNormal (vs_to_es ves @ es))\n                      else (sa, vsa, crash_error)\n                 else case da of 0 \\<Rightarrow> (sa, vsa, crash_error)\n                      | Suc d' \\<Rightarrow>\n                          let (s', vls', y) =\n                                run_step_run_one_step_sumC\n                                 (Inl (d', j, sa, vls, es))\n                          in case_res_step\n                              (\\<lambda>res_crash.\n                                  (s', vsa, RSCrash CExhaustion))\n                              (\\<lambda>nat list.\n                                  (s', vsa, RSCrash CExhaustion))\n                              (\\<lambda>rvs.\n                                  if ln \\<le> length rvs\n                                  then (s', vsa,\n  RSNormal (vs_to_es (take ln rvs @ ves)))\n                                  else (s', vsa, crash_error))\n                              (\\<lambda>es'.\n                                  (s', vsa,\n                                   RSNormal\n                                    (vs_to_es ves @ [Local ln j vls' es'])))\n                              y)\n 4. \\<And>d i s vs ves e da ia sa vsa vesa ea.\n       Inr (d, i, s, vs, ves, e) =\n       Inr (da, ia, sa, vsa, vesa, ea) \\<Longrightarrow>\n       (case e of\n        $Unreachable \\<Rightarrow> (s, vs, RSNormal (vs_to_es ves @ [Trap]))\n        | $Nop \\<Rightarrow> (s, vs, RSNormal (vs_to_es ves))\n        | $Drop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | v # ves' \\<Rightarrow> (s, vs, RSNormal (vs_to_es ves'))\n        | $Select \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstInt32 c] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstInt32 c, v2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # v2 # v1 # ves' \\<Rightarrow>\n                if int_eq c 0 then (s, vs, RSNormal (vs_to_es (v2 # ves')))\n                else (s, vs, RSNormal (vs_to_es (v1 # ves')))\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Block (t1s _> t2s) es \\<Rightarrow>\n            if length t1s \\<le> length ves\n            then let (ves', ves'') = split_n ves (length t1s)\n                 in (s, vs,\n                     RSNormal\n                      (vs_to_es ves'' @\n                       [Label (length t2s) [] (vs_to_es ves' @ ($* es))]))\n            else (s, vs, crash_error)\n        | $Loop (t1s _> t2s) es \\<Rightarrow>\n            if length t1s \\<le> length ves\n            then let (ves', ves'') = split_n ves (length t1s)\n                 in (s, vs,\n                     RSNormal\n                      (vs_to_es ves'' @\n                       [Label (length t1s) [$Loop (t1s _> t2s) es]\n                         (vs_to_es ves' @ ($* es))]))\n            else (s, vs, crash_error)\n        | $b_e.If tf es1 es2 \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                if int_eq c 0\n                then (s, vs, RSNormal (vs_to_es ves' @ [$Block tf es2]))\n                else (s, vs, RSNormal (vs_to_es ves' @ [$Block tf es1]))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Br j \\<Rightarrow> (s, vs, RSBreak j ves)\n        | $Br_if j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                if int_eq c 0 then (s, vs, RSNormal (vs_to_es ves'))\n                else (s, vs, RSNormal (vs_to_es ves' @ [$Br j]))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Br_table js j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                let k = nat_of_int c\n                in if k < length js\n                   then (s, vs, RSNormal (vs_to_es ves' @ [$Br (js ! k)]))\n                   else (s, vs, RSNormal (vs_to_es ves' @ [$Br j]))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Return \\<Rightarrow> (s, vs, RSReturn ves)\n        | $Call j \\<Rightarrow>\n            (s, vs, RSNormal (vs_to_es ves @ [Callcl (sfunc s i j)]))\n        | $Call_indirect j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                expect (stab s i (nat_of_int c))\n                 (\\<lambda>cl.\n                     if stypes s i j = cl_type cl\n                     then (s, vs, RSNormal (vs_to_es ves' @ [Callcl cl]))\n                     else (s, vs, RSNormal (vs_to_es ves' @ [Trap])))\n                 (s, vs, RSNormal (vs_to_es ves' @ [Trap]))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Get_local j \\<Rightarrow>\n            if j < length vs\n            then (s, vs, RSNormal (vs_to_es (vs ! j # ves)))\n            else (s, vs, crash_error)\n        | $Set_local j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | v # ves' \\<Rightarrow>\n                if j < length vs\n                then (s, vs[j := v], RSNormal (vs_to_es ves'))\n                else (s, vs, crash_error)\n        | $Tee_local j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | v # ves' \\<Rightarrow>\n                (s, vs, RSNormal (vs_to_es (v # ves) @ [$Set_local j]))\n        | $Get_global j \\<Rightarrow>\n            (s, vs, RSNormal (vs_to_es (sglob_val s i j # ves)))\n        | $Set_global j \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | v # ves' \\<Rightarrow>\n                (supdate_glob s i j v, vs, RSNormal (vs_to_es ves'))\n        | $Load t aa a off \\<Rightarrow>\n            expect aa\n             (\\<lambda>(tp, sx).\n                 case ves of [] \\<Rightarrow> (s, vs, crash_error)\n                 | ConstInt32 k # ves' \\<Rightarrow>\n                     expect (smem_ind s i)\n                      (\\<lambda>a'.\n                          expect\n                           (load_packed sx (s.mem s ! a') (nat_of_int k) off\n                             (tp_length tp) (t_length t))\n                           (\\<lambda>a'.\n                               (s, vs,\n                                RSNormal\n                                 (vs_to_es (wasm_deserialise a' t # ves'))))\n                           (s, vs, RSNormal (vs_to_es ves' @ [Trap])))\n                      (s, vs, crash_error)\n                 | _ # ves' \\<Rightarrow> (s, vs, crash_error))\n             (case ves of [] \\<Rightarrow> (s, vs, crash_error)\n              | ConstInt32 k # ves' \\<Rightarrow>\n                  expect (smem_ind s i)\n                   (\\<lambda>a'.\n                       expect\n                        (load (s.mem s ! a') (nat_of_int k) off\n                          (t_length t))\n                        (\\<lambda>a'.\n                            (s, vs,\n                             RSNormal\n                              (vs_to_es (wasm_deserialise a' t # ves'))))\n                        (s, vs, RSNormal (vs_to_es ves' @ [Trap])))\n                   (s, vs, crash_error)\n              | _ # ves' \\<Rightarrow> (s, vs, crash_error))\n        | $Store t aa a off \\<Rightarrow>\n            expect aa\n             (\\<lambda>tp.\n                 case ves of [] \\<Rightarrow> (s, vs, crash_error)\n                 | [v] \\<Rightarrow> (s, vs, crash_error)\n                 | v # ConstInt32 k # ves' \\<Rightarrow>\n                     if types_agree t v\n                     then expect (smem_ind s i)\n                           (\\<lambda>a'.\n                               expect\n                                (store_packed (s.mem s ! a') (nat_of_int k)\n                                  off (bits v) (tp_length tp))\n                                (\\<lambda>a'a.\n                                    (s\\<lparr>s.mem := (s.mem s)\n          [a' := a'a]\\<rparr>,\n                                     vs, RSNormal (vs_to_es ves')))\n                                (s, vs, RSNormal (vs_to_es ves' @ [Trap])))\n                           (s, vs, crash_error)\n                     else (s, vs, crash_error)\n                 | v # _ # ves' \\<Rightarrow> (s, vs, crash_error))\n             (case ves of [] \\<Rightarrow> (s, vs, crash_error)\n              | [v] \\<Rightarrow> (s, vs, crash_error)\n              | v # ConstInt32 k # ves' \\<Rightarrow>\n                  if types_agree t v\n                  then expect (smem_ind s i)\n                        (\\<lambda>a'.\n                            expect\n                             (store (s.mem s ! a') (nat_of_int k) off\n                               (bits v) (t_length t))\n                             (\\<lambda>a'a.\n                                 (s\\<lparr>s.mem := (s.mem s)\n       [a' := a'a]\\<rparr>,\n                                  vs, RSNormal (vs_to_es ves')))\n                             (s, vs, RSNormal (vs_to_es ves' @ [Trap])))\n                        (s, vs, crash_error)\n                  else (s, vs, crash_error)\n              | v # _ # ves' \\<Rightarrow> (s, vs, crash_error))\n        | $Current_memory \\<Rightarrow>\n            expect (smem_ind s i)\n             (\\<lambda>a'.\n                 (s, vs,\n                  RSNormal\n                   (vs_to_es\n                     (ConstInt32 (int_of_nat (mem_size (s.mem s ! a'))) #\n                      ves))))\n             (s, vs, crash_error)\n        | $Grow_memory \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                expect (smem_ind s i)\n                 (\\<lambda>a'.\n                     let l = mem_size (s.mem s ! a')\n                     in expect (mem_grow_impl (s.mem s ! a') (nat_of_int c))\n                         (\\<lambda>a'a.\n                             (s\\<lparr>s.mem := (s.mem s)\n   [a' := a'a]\\<rparr>,\n                              vs,\n                              RSNormal\n                               (vs_to_es\n                                 (ConstInt32 (int_of_nat l) # ves'))))\n                         (s, vs,\n                          RSNormal\n                           (vs_to_es (ConstInt32 int32_minus_one # ves'))))\n                 (s, vs, crash_error)\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $C v \\<Rightarrow> (s, vs, crash_error)\n        | $Unop_i T_i32 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal (vs_to_es (ConstInt32 (app_unop_i iop c) # ves')))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Unop_i T_i64 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt64 c # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal (vs_to_es (ConstInt64 (app_unop_i iop c) # ves')))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Unop_i _ iop \\<Rightarrow> (s, vs, crash_error)\n        | $Unop_f T_f32 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstFloat32 c # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es (ConstFloat32 (app_unop_f fop c) # ves')))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Unop_f T_f64 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstFloat64 c # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es (ConstFloat64 (app_unop_f fop c) # ves')))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Unop_f _ fop \\<Rightarrow> (s, vs, crash_error)\n        | $Binop_i T_i32 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstInt32 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c2 # ConstInt32 c1 # ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2)\n                 (\\<lambda>a'.\n                     (s, vs, RSNormal (vs_to_es (ConstInt32 a' # ves'))))\n                 (s, vs, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstInt32 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Binop_i T_i64 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstInt64 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt64 c2 # ConstInt64 c1 # ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2)\n                 (\\<lambda>a'.\n                     (s, vs, RSNormal (vs_to_es (ConstInt64 a' # ves'))))\n                 (s, vs, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstInt64 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Binop_i _ iop \\<Rightarrow> (s, vs, crash_error)\n        | $Binop_f T_f32 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstFloat32 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstFloat32 c2 # ConstFloat32 c1 # ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2)\n                 (\\<lambda>a'.\n                     (s, vs, RSNormal (vs_to_es (ConstFloat32 a' # ves'))))\n                 (s, vs, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstFloat32 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Binop_f T_f64 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstFloat64 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstFloat64 c2 # ConstFloat64 c1 # ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2)\n                 (\\<lambda>a'.\n                     (s, vs, RSNormal (vs_to_es (ConstFloat64 a' # ves'))))\n                 (s, vs, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstFloat64 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Binop_f _ fop \\<Rightarrow> (s, vs, crash_error)\n        | $Testop T_i32 testop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_testop_i testop c)) #\n                     ves')))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Testop T_i64 testop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt64 c # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_testop_i testop c)) #\n                     ves')))\n            | _ # ves' \\<Rightarrow> (s, vs, crash_error)\n        | $Testop _ testop \\<Rightarrow> (s, vs, crash_error)\n        | $Relop_i T_i32 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstInt32 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt32 c2 # ConstInt32 c1 # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_i iop c1 c2)) #\n                     ves')))\n            | ConstInt32 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Relop_i T_i64 iop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstInt64 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstInt64 c2 # ConstInt64 c1 # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_i iop c1 c2)) #\n                     ves')))\n            | ConstInt64 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Relop_i _ iop \\<Rightarrow> (s, vs, crash_error)\n        | $Relop_f T_f32 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstFloat32 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstFloat32 c2 # ConstFloat32 c1 # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_f fop c1 c2)) #\n                     ves')))\n            | ConstFloat32 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Relop_f T_f64 fop \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | [ConstFloat64 c2] \\<Rightarrow> (s, vs, crash_error)\n            | ConstFloat64 c2 # ConstFloat64 c1 # ves' \\<Rightarrow>\n                (s, vs,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_f fop c1 c2)) #\n                     ves')))\n            | ConstFloat64 c2 # _ # ves' \\<Rightarrow> (s, vs, crash_error)\n            | _ # list \\<Rightarrow> (s, vs, crash_error)\n        | $Relop_f _ fop \\<Rightarrow> (s, vs, crash_error)\n        | $Cvtop t2 Convert t1 sx \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | v # ves' \\<Rightarrow>\n                if types_agree t1 v\n                then expect (cvt t2 sx v)\n                      (\\<lambda>a'.\n                          (s, vs, RSNormal (vs_to_es (a' # ves'))))\n                      (s, vs, RSNormal (vs_to_es ves' @ [Trap]))\n                else (s, vs, crash_error)\n        | $Cvtop t2 Reinterpret t1 sx \\<Rightarrow>\n            case ves of [] \\<Rightarrow> (s, vs, crash_error)\n            | v # ves' \\<Rightarrow>\n                if types_agree t1 v \\<and> sx = None\n                then (s, vs,\n                      RSNormal\n                       (vs_to_es (wasm_deserialise (bits v) t2 # ves')))\n                else (s, vs, crash_error)\n        | Trap \\<Rightarrow> (s, vs, crash_error)\n        | Callcl (Func_native i' (t1s _> t2s) ts es) \\<Rightarrow>\n            let n = length t1s; m = length t2s\n            in if n \\<le> length ves\n               then let (ves', ves'') = split_n ves n; zs = n_zeros ts\n                    in (s, vs,\n                        RSNormal\n                         (vs_to_es ves'' @\n                          [Local m i' (rev ves' @ zs)\n                            [$Block ([] _> t2s) es]]))\n               else (s, vs, crash_error)\n        | Callcl (Func_host (t1s _> t2s) f) \\<Rightarrow>\n            let n = length t1s; m = length t2s\n            in if n \\<le> length ves\n               then let (ves', ves'') = split_n ves n\n                    in expect (host_apply_impl s (t1s _> t2s) f (rev ves'))\n                        (\\<lambda>(s', rves).\n                            if list_all2 types_agree t2s rves\n                            then (s', vs,\n                                  RSNormal (vs_to_es ves'' @ ($$* rves)))\n                            else (s', vs, crash_error))\n                        (s, vs, RSNormal (vs_to_es ves'' @ [Trap]))\n               else (s, vs, crash_error)\n        | Label ln les es \\<Rightarrow>\n            if es_is_trap es then (s, vs, RSNormal (vs_to_es ves @ [Trap]))\n            else if const_list es then (s, vs, RSNormal (vs_to_es ves @ es))\n                 else let (s', vs', y) =\n                            run_step_run_one_step_sumC\n                             (Inl (d, i, s, vs, es))\n                      in case_res_step\n                          (\\<lambda>res_crash. (s', vs', crash_error))\n                          (\\<lambda>nat bvs.\n                              case nat of\n                              0 \\<Rightarrow>\n                                if ln \\<le> length bvs\n                                then (s', vs',\nRSNormal (vs_to_es (take ln bvs @ ves) @ les))\n                                else (s', vs', crash_error)\n                              | Suc n \\<Rightarrow>\n                                  (s', vs', RSBreak n bvs))\n                          (\\<lambda>rvs. (s', vs', RSReturn rvs))\n                          (\\<lambda>es'.\n                              (s', vs',\n                               RSNormal\n                                (vs_to_es ves @ [Label ln les es'])))\n                          y\n        | Local ln j vls es \\<Rightarrow>\n            if es_is_trap es then (s, vs, RSNormal (vs_to_es ves @ [Trap]))\n            else if const_list es\n                 then if length es = ln\n                      then (s, vs, RSNormal (vs_to_es ves @ es))\n                      else (s, vs, crash_error)\n                 else case d of 0 \\<Rightarrow> (s, vs, crash_error)\n                      | Suc d' \\<Rightarrow>\n                          let (s', vls', y) =\n                                run_step_run_one_step_sumC\n                                 (Inl (d', j, s, vls, es))\n                          in case_res_step\n                              (\\<lambda>res_crash.\n                                  (s', vs, RSCrash CExhaustion))\n                              (\\<lambda>nat list.\n                                  (s', vs, RSCrash CExhaustion))\n                              (\\<lambda>rvs.\n                                  if ln \\<le> length rvs\n                                  then (s', vs,\n  RSNormal (vs_to_es (take ln rvs @ ves)))\n                                  else (s', vs, crash_error))\n                              (\\<lambda>es'.\n                                  (s', vs,\n                                   RSNormal\n                                    (vs_to_es ves @ [Local ln j vls' es'])))\n                              y) =\n       (case ea of\n        $Unreachable \\<Rightarrow>\n          (sa, vsa, RSNormal (vs_to_es vesa @ [Trap]))\n        | $Nop \\<Rightarrow> (sa, vsa, RSNormal (vs_to_es vesa))\n        | $Drop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow> (sa, vsa, RSNormal (vs_to_es ves'))\n        | $Select \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c, v2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # v2 # v1 # ves' \\<Rightarrow>\n                if int_eq c 0\n                then (sa, vsa, RSNormal (vs_to_es (v2 # ves')))\n                else (sa, vsa, RSNormal (vs_to_es (v1 # ves')))\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Block (t1s _> t2s) es \\<Rightarrow>\n            if length t1s \\<le> length vesa\n            then let (ves', ves'') = split_n vesa (length t1s)\n                 in (sa, vsa,\n                     RSNormal\n                      (vs_to_es ves'' @\n                       [Label (length t2s) [] (vs_to_es ves' @ ($* es))]))\n            else (sa, vsa, crash_error)\n        | $Loop (t1s _> t2s) es \\<Rightarrow>\n            if length t1s \\<le> length vesa\n            then let (ves', ves'') = split_n vesa (length t1s)\n                 in (sa, vsa,\n                     RSNormal\n                      (vs_to_es ves'' @\n                       [Label (length t1s) [$Loop (t1s _> t2s) es]\n                         (vs_to_es ves' @ ($* es))]))\n            else (sa, vsa, crash_error)\n        | $b_e.If tf es1 es2 \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                if int_eq c 0\n                then (sa, vsa, RSNormal (vs_to_es ves' @ [$Block tf es2]))\n                else (sa, vsa, RSNormal (vs_to_es ves' @ [$Block tf es1]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Br j \\<Rightarrow> (sa, vsa, RSBreak j vesa)\n        | $Br_if j \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                if int_eq c 0 then (sa, vsa, RSNormal (vs_to_es ves'))\n                else (sa, vsa, RSNormal (vs_to_es ves' @ [$Br j]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Br_table js j \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                let k = nat_of_int c\n                in if k < length js\n                   then (sa, vsa, RSNormal (vs_to_es ves' @ [$Br (js ! k)]))\n                   else (sa, vsa, RSNormal (vs_to_es ves' @ [$Br j]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Return \\<Rightarrow> (sa, vsa, RSReturn vesa)\n        | $Call j \\<Rightarrow>\n            (sa, vsa, RSNormal (vs_to_es vesa @ [Callcl (sfunc sa ia j)]))\n        | $Call_indirect j \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                expect (stab sa ia (nat_of_int c))\n                 (\\<lambda>cl.\n                     if stypes sa ia j = cl_type cl\n                     then (sa, vsa, RSNormal (vs_to_es ves' @ [Callcl cl]))\n                     else (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Get_local j \\<Rightarrow>\n            if j < length vsa\n            then (sa, vsa, RSNormal (vs_to_es (vsa ! j # vesa)))\n            else (sa, vsa, crash_error)\n        | $Set_local j \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                if j < length vsa\n                then (sa, vsa[j := v], RSNormal (vs_to_es ves'))\n                else (sa, vsa, crash_error)\n        | $Tee_local j \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                (sa, vsa, RSNormal (vs_to_es (v # vesa) @ [$Set_local j]))\n        | $Get_global j \\<Rightarrow>\n            (sa, vsa, RSNormal (vs_to_es (sglob_val sa ia j # vesa)))\n        | $Set_global j \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                (supdate_glob sa ia j v, vsa, RSNormal (vs_to_es ves'))\n        | $Load t aa a off \\<Rightarrow>\n            expect aa\n             (\\<lambda>(tp, sx).\n                 case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n                 | ConstInt32 k # ves' \\<Rightarrow>\n                     expect (smem_ind sa ia)\n                      (\\<lambda>a'.\n                          expect\n                           (load_packed sx (s.mem sa ! a') (nat_of_int k)\n                             off (tp_length tp) (t_length t))\n                           (\\<lambda>a'.\n                               (sa, vsa,\n                                RSNormal\n                                 (vs_to_es (wasm_deserialise a' t # ves'))))\n                           (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                      (sa, vsa, crash_error)\n                 | _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n             (case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n              | ConstInt32 k # ves' \\<Rightarrow>\n                  expect (smem_ind sa ia)\n                   (\\<lambda>a'.\n                       expect\n                        (load (s.mem sa ! a') (nat_of_int k) off\n                          (t_length t))\n                        (\\<lambda>a'.\n                            (sa, vsa,\n                             RSNormal\n                              (vs_to_es (wasm_deserialise a' t # ves'))))\n                        (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                   (sa, vsa, crash_error)\n              | _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n        | $Store t aa a off \\<Rightarrow>\n            expect aa\n             (\\<lambda>tp.\n                 case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n                 | [v] \\<Rightarrow> (sa, vsa, crash_error)\n                 | v # ConstInt32 k # ves' \\<Rightarrow>\n                     if types_agree t v\n                     then expect (smem_ind sa ia)\n                           (\\<lambda>a'.\n                               expect\n                                (store_packed (s.mem sa ! a') (nat_of_int k)\n                                  off (bits v) (tp_length tp))\n                                (\\<lambda>a'a.\n                                    (sa\\<lparr>s.mem := (s.mem sa)\n           [a' := a'a]\\<rparr>,\n                                     vsa, RSNormal (vs_to_es ves')))\n                                (sa, vsa,\n                                 RSNormal (vs_to_es ves' @ [Trap])))\n                           (sa, vsa, crash_error)\n                     else (sa, vsa, crash_error)\n                 | v # _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n             (case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n              | [v] \\<Rightarrow> (sa, vsa, crash_error)\n              | v # ConstInt32 k # ves' \\<Rightarrow>\n                  if types_agree t v\n                  then expect (smem_ind sa ia)\n                        (\\<lambda>a'.\n                            expect\n                             (store (s.mem sa ! a') (nat_of_int k) off\n                               (bits v) (t_length t))\n                             (\\<lambda>a'a.\n                                 (sa\\<lparr>s.mem := (s.mem sa)\n        [a' := a'a]\\<rparr>,\n                                  vsa, RSNormal (vs_to_es ves')))\n                             (sa, vsa, RSNormal (vs_to_es ves' @ [Trap])))\n                        (sa, vsa, crash_error)\n                  else (sa, vsa, crash_error)\n              | v # _ # ves' \\<Rightarrow> (sa, vsa, crash_error))\n        | $Current_memory \\<Rightarrow>\n            expect (smem_ind sa ia)\n             (\\<lambda>a'.\n                 (sa, vsa,\n                  RSNormal\n                   (vs_to_es\n                     (ConstInt32 (int_of_nat (mem_size (s.mem sa ! a'))) #\n                      vesa))))\n             (sa, vsa, crash_error)\n        | $Grow_memory \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                expect (smem_ind sa ia)\n                 (\\<lambda>a'.\n                     let l = mem_size (s.mem sa ! a')\n                     in expect\n                         (mem_grow_impl (s.mem sa ! a') (nat_of_int c))\n                         (\\<lambda>a'a.\n                             (sa\\<lparr>s.mem := (s.mem sa)\n    [a' := a'a]\\<rparr>,\n                              vsa,\n                              RSNormal\n                               (vs_to_es\n                                 (ConstInt32 (int_of_nat l) # ves'))))\n                         (sa, vsa,\n                          RSNormal\n                           (vs_to_es (ConstInt32 int32_minus_one # ves'))))\n                 (sa, vsa, crash_error)\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $C v \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_i T_i32 iop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal (vs_to_es (ConstInt32 (app_unop_i iop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_i T_i64 iop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal (vs_to_es (ConstInt64 (app_unop_i iop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_i _ iop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_f T_f32 fop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat32 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es (ConstFloat32 (app_unop_f fop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_f T_f64 fop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat64 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es (ConstFloat64 (app_unop_f fop c) # ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Unop_f _ fop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_i T_i32 iop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c2 # ConstInt32 c1 # ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa, RSNormal (vs_to_es (ConstInt32 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstInt32 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_i T_i64 iop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c2 # ConstInt64 c1 # ves' \\<Rightarrow>\n                expect (app_binop_i iop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa, RSNormal (vs_to_es (ConstInt64 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstInt64 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_i _ iop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_f T_f32 fop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat32 c2 # ConstFloat32 c1 # ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa,\n                      RSNormal (vs_to_es (ConstFloat32 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstFloat32 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_f T_f64 fop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat64 c2 # ConstFloat64 c1 # ves' \\<Rightarrow>\n                expect (app_binop_f fop c1 c2)\n                 (\\<lambda>a'.\n                     (sa, vsa,\n                      RSNormal (vs_to_es (ConstFloat64 a' # ves'))))\n                 (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n            | ConstFloat64 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Binop_f _ fop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Testop T_i32 testop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_testop_i testop c)) #\n                     ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Testop T_i64 testop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_testop_i testop c)) #\n                     ves')))\n            | _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n        | $Testop _ testop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_i T_i32 iop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt32 c2 # ConstInt32 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_i iop c1 c2)) #\n                     ves')))\n            | ConstInt32 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_i T_i64 iop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstInt64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstInt64 c2 # ConstInt64 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_i iop c1 c2)) #\n                     ves')))\n            | ConstInt64 c2 # _ # ves' \\<Rightarrow> (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_i _ iop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_f T_f32 fop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat32 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat32 c2 # ConstFloat32 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_f fop c1 c2)) #\n                     ves')))\n            | ConstFloat32 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_f T_f64 fop \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | [ConstFloat64 c2] \\<Rightarrow> (sa, vsa, crash_error)\n            | ConstFloat64 c2 # ConstFloat64 c1 # ves' \\<Rightarrow>\n                (sa, vsa,\n                 RSNormal\n                  (vs_to_es\n                    (ConstInt32 (wasm_bool (app_relop_f fop c1 c2)) #\n                     ves')))\n            | ConstFloat64 c2 # _ # ves' \\<Rightarrow>\n                (sa, vsa, crash_error)\n            | _ # list \\<Rightarrow> (sa, vsa, crash_error)\n        | $Relop_f _ fop \\<Rightarrow> (sa, vsa, crash_error)\n        | $Cvtop t2 Convert t1 sx \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                if types_agree t1 v\n                then expect (cvt t2 sx v)\n                      (\\<lambda>a'.\n                          (sa, vsa, RSNormal (vs_to_es (a' # ves'))))\n                      (sa, vsa, RSNormal (vs_to_es ves' @ [Trap]))\n                else (sa, vsa, crash_error)\n        | $Cvtop t2 Reinterpret t1 sx \\<Rightarrow>\n            case vesa of [] \\<Rightarrow> (sa, vsa, crash_error)\n            | v # ves' \\<Rightarrow>\n                if types_agree t1 v \\<and> sx = None\n                then (sa, vsa,\n                      RSNormal\n                       (vs_to_es (wasm_deserialise (bits v) t2 # ves')))\n                else (sa, vsa, crash_error)\n        | Trap \\<Rightarrow> (sa, vsa, crash_error)\n        | Callcl (Func_native i' (t1s _> t2s) ts es) \\<Rightarrow>\n            let n = length t1s; m = length t2s\n            in if n \\<le> length vesa\n               then let (ves', ves'') = split_n vesa n; zs = n_zeros ts\n                    in (sa, vsa,\n                        RSNormal\n                         (vs_to_es ves'' @\n                          [Local m i' (rev ves' @ zs)\n                            [$Block ([] _> t2s) es]]))\n               else (sa, vsa, crash_error)\n        | Callcl (Func_host (t1s _> t2s) f) \\<Rightarrow>\n            let n = length t1s; m = length t2s\n            in if n \\<le> length vesa\n               then let (ves', ves'') = split_n vesa n\n                    in expect (host_apply_impl sa (t1s _> t2s) f (rev ves'))\n                        (\\<lambda>(s', rves).\n                            if list_all2 types_agree t2s rves\n                            then (s', vsa,\n                                  RSNormal (vs_to_es ves'' @ ($$* rves)))\n                            else (s', vsa, crash_error))\n                        (sa, vsa, RSNormal (vs_to_es ves'' @ [Trap]))\n               else (sa, vsa, crash_error)\n        | Label ln les es \\<Rightarrow>\n            if es_is_trap es\n            then (sa, vsa, RSNormal (vs_to_es vesa @ [Trap]))\n            else if const_list es\n                 then (sa, vsa, RSNormal (vs_to_es vesa @ es))\n                 else let (s', vs', y) =\n                            run_step_run_one_step_sumC\n                             (Inl (da, ia, sa, vsa, es))\n                      in case_res_step\n                          (\\<lambda>res_crash. (s', vs', crash_error))\n                          (\\<lambda>nat bvs.\n                              case nat of\n                              0 \\<Rightarrow>\n                                if ln \\<le> length bvs\n                                then (s', vs',\nRSNormal (vs_to_es (take ln bvs @ vesa) @ les))\n                                else (s', vs', crash_error)\n                              | Suc n \\<Rightarrow>\n                                  (s', vs', RSBreak n bvs))\n                          (\\<lambda>rvs. (s', vs', RSReturn rvs))\n                          (\\<lambda>es'.\n                              (s', vs',\n                               RSNormal\n                                (vs_to_es vesa @ [Label ln les es'])))\n                          y\n        | Local ln j vls es \\<Rightarrow>\n            if es_is_trap es\n            then (sa, vsa, RSNormal (vs_to_es vesa @ [Trap]))\n            else if const_list es\n                 then if length es = ln\n                      then (sa, vsa, RSNormal (vs_to_es vesa @ es))\n                      else (sa, vsa, crash_error)\n                 else case da of 0 \\<Rightarrow> (sa, vsa, crash_error)\n                      | Suc d' \\<Rightarrow>\n                          let (s', vls', y) =\n                                run_step_run_one_step_sumC\n                                 (Inl (d', j, sa, vls, es))\n                          in case_res_step\n                              (\\<lambda>res_crash.\n                                  (s', vsa, RSCrash CExhaustion))\n                              (\\<lambda>nat list.\n                                  (s', vsa, RSCrash CExhaustion))\n                              (\\<lambda>rvs.\n                                  if ln \\<le> length rvs\n                                  then (s', vsa,\n  RSNormal (vs_to_es (take ln rvs @ vesa)))\n                                  else (s', vsa, crash_error))\n                              (\\<lambda>es'.\n                                  (s', vsa,\n                                   RSNormal\n                                    (vs_to_es vesa @\n                                     [Local ln j vls' es'])))\n                              y)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "fix xs::\"e list\" and as b bs"], ["proof (state)\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "assume local_assms:\"(as, b#bs) = split_vals_e xs\""], ["proof (state)\nthis:\n  (as, b # bs) = split_vals_e xs\n\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "have \"2*(size b) < 2*(size_list size xs) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * size b < 2 * size_list size xs + 1", "using local_assms[symmetric] split_vals_e_conv_app\n            size_list_estimation'[of b xs \"size b\" size]"], ["proof (prove)\nusing this:\n  split_vals_e xs = (as, b # bs)\n  split_vals_e ?xs = (?as, ?bs) \\<Longrightarrow> ?xs = ($$* ?as) @ ?bs\n  \\<lbrakk>b \\<in> set xs; size b \\<le> size b\\<rbrakk>\n  \\<Longrightarrow> size b \\<le> size_list size xs\n\ngoal (1 subgoal):\n 1. 2 * size b < 2 * size_list size xs + 1", "unfolding size_list_def"], ["proof (prove)\nusing this:\n  split_vals_e xs = (as, b # bs)\n  split_vals_e ?xs = (?as, ?bs) \\<Longrightarrow> ?xs = ($$* ?as) @ ?bs\n  \\<lbrakk>b \\<in> set xs; size b \\<le> size b\\<rbrakk>\n  \\<Longrightarrow> size b\n                    \\<le> rec_list 0 (\\<lambda>x xa xb. size x + xb + Suc 0)\n                           xs\n\ngoal (1 subgoal):\n 1. 2 * size b\n    < 2 * rec_list 0 (\\<lambda>x xa xb. size x + xb + Suc 0) xs + 1", "by fastforce"], ["proof (state)\nthis:\n  2 * size b < 2 * size_list size xs + 1\n\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "}"], ["proof (state)\nthis:\n  (?as2, ?b2 # ?bs2) = split_vals_e ?xs2 \\<Longrightarrow>\n  2 * size ?b2 < 2 * size_list size ?xs2 + 1\n\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?as2, ?b2 # ?bs2) = split_vals_e ?xs2 \\<Longrightarrow>\n  2 * size ?b2 < 2 * size_list size ?xs2 + 1\n\ngoal (1 subgoal):\n 1. All run_step_run_one_step_dom", "by (relation \"measure (case_sum\n                               (\\<lambda>p. 2 * (size_list size (snd (snd (snd (snd p))))) + 1)\n                               (\\<lambda>p. 2 * size (snd (snd (snd (snd (snd p)))))))\") auto"], ["proof (state)\nthis:\n  All run_step_run_one_step_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "fun run_v :: \"fuel \\<Rightarrow> depth \\<Rightarrow> nat \\<Rightarrow> config_tuple \\<Rightarrow> (s \\<times> res)\" where\n  \"run_v (Suc n) d i (s,vs,es) = (if (es_is_trap es)\n                                    then (s, RTrap)\n                                    else if (const_list es)\n                                           then (s, RValue (fst (split_vals_e es)))\n                                           else (let (s',vs',res) = (run_step d i (s,vs,es)) in\n                                                 case res of\n                                                   RSNormal es' \\<Rightarrow> run_v n d i (s',vs',es')\n                                                 | RSCrash error \\<Rightarrow> (s, RCrash error)\n                                                 | _ \\<Rightarrow> (s, RCrash CError)))\"\n| \"run_v 0 d i (s,vs,es) = (s, RCrash CExhaustion)\""], ["", "end"]]}