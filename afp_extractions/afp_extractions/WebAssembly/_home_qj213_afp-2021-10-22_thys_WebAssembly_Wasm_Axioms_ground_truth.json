{"file_name": "/home/qj213/afp-2021-10-22/thys/WebAssembly/Wasm_Axioms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WebAssembly", "problem_names": ["lemma mem_grow_size:\n  assumes \"mem_grow m n = m'\"\n  shows \"(mem_size m + (64000 * n)) = mem_size m'\"", "lemma load_size:\n  \"(load m n off l = None) = (mem_size m < (off + n + l))\"", "lemma load_packed_size:\n  \"(load_packed sx m n off lp l = None) = (mem_size m < (off + n + lp))\"", "lemma store_size1:\n  \"(store m n off v l = None) = (mem_size m < (off + n + l))\"", "lemma store_size:\n  assumes \"(store m n off v l = Some m')\"\n  shows \"mem_size m = mem_size m'\"", "lemma store_packed_size1:\n  \"(store_packed m n off v l = None) = (mem_size m < (off + n + l))\"", "lemma store_packed_size:\n  assumes \"(store_packed m n off v l = Some m')\"\n  shows \"mem_size m = mem_size m'\""], "translations": [["", "lemma mem_grow_size:\n  assumes \"mem_grow m n = m'\"\n  shows \"(mem_size m + (64000 * n)) = mem_size m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_size m + 64000 * n = mem_size m'", "using assms Abs_mem_inverse Abs_bytes_inverse"], ["proof (prove)\nusing this:\n  mem_grow m n = m'\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_mem (Abs_mem ?y) = ?y\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_bytes (Abs_bytes ?y) = ?y\n\ngoal (1 subgoal):\n 1. mem_size m + 64000 * n = mem_size m'", "unfolding mem_grow_def mem_size_def mem_append_def bytes_replicate_def"], ["proof (prove)\nusing this:\n  map_fun Rep_mem (map_fun Rep_bytes Abs_mem) (@) m\n   (map_fun id (map_fun Rep_uint8 Abs_bytes)\n     (\\<lambda>n b. replicate n (Abs_uint8 b)) (n * 64000) 0) =\n  m'\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_mem (Abs_mem ?y) = ?y\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_bytes (Abs_bytes ?y) = ?y\n\ngoal (1 subgoal):\n 1. length (Rep_mem m) + 64000 * n = length (Rep_mem m')", "by auto"], ["", "lemma load_size:\n  \"(load m n off l = None) = (mem_size m < (off + n + l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (load m n off l = None) = (mem_size m < off + n + l)", "unfolding load_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if n + off + l \\<le> mem_size m then Some (read_bytes m (n + off) l)\n      else None) =\n     None) =\n    (mem_size m < off + n + l)", "by (cases \"n + off + l \\<le> mem_size m\") auto"], ["", "lemma load_packed_size:\n  \"(load_packed sx m n off lp l = None) = (mem_size m < (off + n + lp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (load_packed sx m n off lp l = None) = (mem_size m < off + n + lp)", "using load_size"], ["proof (prove)\nusing this:\n  (load ?m ?n ?off ?l = None) = (mem_size ?m < ?off + ?n + ?l)\n\ngoal (1 subgoal):\n 1. (load_packed sx m n off lp l = None) = (mem_size m < off + n + lp)", "unfolding load_packed_def"], ["proof (prove)\nusing this:\n  (load ?m ?n ?off ?l = None) = (mem_size ?m < ?off + ?n + ?l)\n\ngoal (1 subgoal):\n 1. (map_option (sign_extend sx l) (load m n off lp) = None) =\n    (mem_size m < off + n + lp)", "by (cases \"n + off + l \\<le> mem_size m\") auto"], ["", "lemma store_size1:\n  \"(store m n off v l = None) = (mem_size m < (off + n + l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (store m n off v l = None) = (mem_size m < off + n + l)", "unfolding store_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if n + off + l \\<le> mem_size m\n      then Some (write_bytes m (n + off) (bytes_takefill 0 l v))\n      else None) =\n     None) =\n    (mem_size m < off + n + l)", "by (cases \"n + off + l \\<le> mem_size m\") auto"], ["", "lemma store_size:\n  assumes \"(store m n off v l = Some m')\"\n  shows \"mem_size m = mem_size m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_size m = mem_size m'", "using assms Abs_mem_inverse Abs_bytes_inverse"], ["proof (prove)\nusing this:\n  store m n off v l = Some m'\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_mem (Abs_mem ?y) = ?y\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_bytes (Abs_bytes ?y) = ?y\n\ngoal (1 subgoal):\n 1. mem_size m = mem_size m'", "unfolding store_def write_bytes_def bytes_takefill_def"], ["proof (prove)\nusing this:\n  (if n + off + l \\<le> mem_size m\n   then Some\n         (map_fun Rep_mem (map_fun id (map_fun Rep_bytes Abs_mem))\n           (\\<lambda>m n bs. take n m @ bs @ drop (n + length bs) m) m\n           (n + off)\n           (map_fun Rep_uint8 (map_fun id (map_fun Rep_bytes Abs_bytes))\n             (\\<lambda>a. takefill (Abs_uint8 a)) 0 l v))\n   else None) =\n  Some m'\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_mem (Abs_mem ?y) = ?y\n  ?y \\<in> UNIV \\<Longrightarrow> Rep_bytes (Abs_bytes ?y) = ?y\n\ngoal (1 subgoal):\n 1. mem_size m = mem_size m'", "by (cases \"n + off + l \\<le> mem_size m\") (auto simp add: mem_size_def)"], ["", "lemma store_packed_size1:\n  \"(store_packed m n off v l = None) = (mem_size m < (off + n + l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (store_packed m n off v l = None) = (mem_size m < off + n + l)", "using store_size1"], ["proof (prove)\nusing this:\n  (store ?m ?n ?off ?v ?l = None) = (mem_size ?m < ?off + ?n + ?l)\n\ngoal (1 subgoal):\n 1. (store_packed m n off v l = None) = (mem_size m < off + n + l)", "unfolding store_packed_def"], ["proof (prove)\nusing this:\n  (store ?m ?n ?off ?v ?l = None) = (mem_size ?m < ?off + ?n + ?l)\n\ngoal (1 subgoal):\n 1. (store m n off v l = None) = (mem_size m < off + n + l)", "by simp"], ["", "lemma store_packed_size:\n  assumes \"(store_packed m n off v l = Some m')\"\n  shows \"mem_size m = mem_size m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_size m = mem_size m'", "using assms store_size"], ["proof (prove)\nusing this:\n  store_packed m n off v l = Some m'\n  store ?m ?n ?off ?v ?l = Some ?m' \\<Longrightarrow>\n  mem_size ?m = mem_size ?m'\n\ngoal (1 subgoal):\n 1. mem_size m = mem_size m'", "unfolding store_packed_def"], ["proof (prove)\nusing this:\n  store m n off v l = Some m'\n  store ?m ?n ?off ?v ?l = Some ?m' \\<Longrightarrow>\n  mem_size ?m = mem_size ?m'\n\ngoal (1 subgoal):\n 1. mem_size m = mem_size m'", "by simp"], ["", "axiomatization where\n  wasm_deserialise_type:\"typeof (wasm_deserialise bs t) = t\""], ["", "axiomatization where\n    host_apply_preserve_store:\" list_all2 types_agree t1s vs \\<Longrightarrow> host_apply s (t1s _> t2s) f vs hs = Some (s', vs') \\<Longrightarrow> store_extension s s'\"\nand host_apply_respect_type:\"list_all2 types_agree t1s vs \\<Longrightarrow> host_apply s (t1s _> t2s) f vs hs = Some (s', vs') \\<Longrightarrow> list_all2 types_agree t2s vs'\""], ["", "end"]]}