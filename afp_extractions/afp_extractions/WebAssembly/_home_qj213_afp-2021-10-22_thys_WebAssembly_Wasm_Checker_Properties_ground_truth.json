{"file_name": "/home/qj213/afp-2021-10-22/thys/WebAssembly/Wasm_Checker_Properties.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WebAssembly", "problem_names": ["lemma b_e_check_single_type_sound:\n  assumes \"type_update (Type x1) (to_ct_list t_in) (Type t_out) = Type x2\"\n          \"c_types_agree (Type x2) tm\"\n          \"\\<C> \\<turnstile> [e] : (t_in _> t_out)\"\n  shows \"\\<exists>tn. c_types_agree (Type x1) tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\"", "lemma b_e_check_single_top_sound:\n  assumes \"type_update (TopType x1) (to_ct_list t_in) (Type t_out) = TopType x2\"\n          \"c_types_agree (TopType x2) tm\"\n          \"\\<C> \\<turnstile> [e] : (t_in _> t_out)\"\n  shows \"\\<exists>tn. c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\"", "lemma b_e_check_single_top_not_bot_sound:\n  assumes \"type_update ts (to_ct_list t_in) (TopType []) = ts'\"\n          \"ts \\<noteq> Bot\"\n          \"ts' \\<noteq> Bot\"\n  shows \"\\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\"", "lemma b_e_check_single_type_not_bot_sound:\n  assumes \"type_update ts (to_ct_list t_in) (Type t_out) = ts'\"\n          \"ts \\<noteq> Bot\"\n          \"ts' \\<noteq> Bot\"\n          \"c_types_agree ts' tm\"\n          \"\\<C> \\<turnstile> [e] : (t_in _> t_out)\"\n  shows \"\\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\"", "lemma b_e_check_single_sound_unop_testop_cvtop:\n  assumes \"check_single \\<C> e tn' = tm'\"\n          \"((e = (Unop_i t uu) \\<or> e = (Testop t uv)) \\<and> is_int_t t)\n           \\<or> (e = (Unop_f t uw) \\<and> is_float_t t)\n           \\<or> (e = (Cvtop t1 Convert t sx) \\<and> convert_cond t1 t sx)\n           \\<or> (e = (Cvtop t1 Reinterpret t sx) \\<and> ((t1 \\<noteq> t) \\<and> t_length t1 = t_length t \\<and> sx = None))\"\n          \"c_types_agree tm' tm\"\n          \"tn' \\<noteq> Bot\"\n          \"tm' \\<noteq> Bot\"\n shows \"\\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\"", "lemma b_e_check_single_sound_binop_relop:\n  assumes \"check_single \\<C> e tn' = tm'\"\n          \"((e = Binop_i t iop \\<and> is_int_t t)\n            \\<or> (e = Binop_f t fop \\<and> is_float_t t)\n            \\<or> (e = Relop_i t irop \\<and> is_int_t t)\n            \\<or> (e = Relop_f t frop \\<and> is_float_t t))\"\n          \"c_types_agree tm' tm\"\n          \"tn' \\<noteq> Bot\"\n          \"tm' \\<noteq> Bot\"\n shows \"\\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\"", "lemma b_e_type_checker_sound:\n  assumes \"b_e_type_checker \\<C> es (tn _> tm)\"\n  shows \"\\<C> \\<turnstile> es : (tn _> tm)\"", "lemma check_single_imp:\n  assumes \"check_single \\<C> e ctn = ctm\"\n          \"ctm \\<noteq> Bot\"\n  shows \"check_single \\<C> e = id\n         \\<or> check_single \\<C> e = (\\<lambda>ctn. type_update_select ctn)\n         \\<or> (\\<exists>cons prods. (check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)))\"", "lemma check_equiv_fold:\n  \"check \\<C> es ts = foldl (\\<lambda> ts e. (case ts of Bot \\<Rightarrow> Bot | _ \\<Rightarrow> check_single \\<C> e ts)) ts es\"", "lemma check_neq_bot_snoc:\n  assumes \"check \\<C> (es@[e]) ts \\<noteq> Bot\"\n  shows \"check \\<C> es ts \\<noteq> Bot\"", "lemma check_unfold_snoc:\n  assumes \"check \\<C> es ts \\<noteq> Bot\"\n  shows \"check \\<C> (es@[e]) ts = check_single \\<C> e (check \\<C> es ts)\"", "lemma check_single_imp_weakening:\n  assumes \"check_single \\<C> e (Type t1s) = ctm\"\n          \"ctm \\<noteq> Bot\"\n          \"c_types_agree ctn t1s\"\n          \"c_types_agree ctm t2s\"\n  shows \"\\<exists>ctm'. check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\"", "lemma b_e_type_checker_compose:\n  assumes \"b_e_type_checker \\<C> es (t1s _> t2s)\"\n          \"b_e_type_checker \\<C> [e] (t2s _> t3s)\"\n  shows \"b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)\"", "lemma b_e_check_single_type_type:\n  assumes \"check_single \\<C> e xs = (Type tm)\"\n  shows \"\\<exists>tn. xs = (Type tn)\"", "lemma b_e_check_single_weaken_type:\n  assumes \"check_single \\<C> e (Type tn) = (Type tm)\"\n  shows \"check_single \\<C> e (Type (ts@tn)) = Type (ts@tm)\"", "lemma b_e_check_single_weaken_top:\n  assumes \"check_single \\<C> e (Type tn) = TopType tm\"\n  shows \"check_single \\<C> e (Type (ts@tn)) = TopType tm\"", "lemma b_e_check_weaken_type:\n  assumes \"check \\<C> es (Type tn) = (Type tm)\"\n  shows \"check \\<C> es (Type (ts@tn)) = (Type (ts@tm))\"", "lemma check_bot: \"check \\<C> es Bot = Bot\"", "lemma b_e_check_weaken_top:\n  assumes \"check \\<C> es (Type tn) = (TopType tm)\"\n  shows \"check \\<C> es (Type (ts@tn)) = (TopType tm)\"", "lemma b_e_type_checker_weaken:\n  assumes \"b_e_type_checker \\<C> es (t1s _> t2s)\"\n  shows \"b_e_type_checker \\<C> es (ts@t1s _> ts@t2s)\"", "lemma b_e_type_checker_complete:\n  assumes \"\\<C> \\<turnstile> es : (tn _> tm)\"\n  shows \"b_e_type_checker \\<C> es (tn _> tm)\"", "theorem b_e_typing_equiv_b_e_type_checker:\n  shows \"(\\<C> \\<turnstile> es : (tn _> tm)) = (b_e_type_checker \\<C> es (tn _> tm))\""], "translations": [["", "lemma b_e_check_single_type_sound:\n  assumes \"type_update (Type x1) (to_ct_list t_in) (Type t_out) = Type x2\"\n          \"c_types_agree (Type x2) tm\"\n          \"\\<C> \\<turnstile> [e] : (t_in _> t_out)\"\n  shows \"\\<exists>tn. c_types_agree (Type x1) tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (Type x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using assms(2) b_e_typing.intros(35)[OF assms(3)] type_update_type[OF assms(1)]"], ["proof (prove)\nusing this:\n  c_types_agree (Type x2) tm\n  \\<C> \\<turnstile> [e] : ?ts @ t_in _> ?ts @ t_out\n  Type x2 \\<noteq> Bot \\<Longrightarrow>\n  Type x2 = Type t_out \\<and>\n  (\\<exists>ts_c. Type t_out = TopType ts_c) \\<or>\n  (\\<exists>ts_a ts_b.\n      Type t_out = Type ts_a \\<and>\n      x1 = ts_b @ t_in \\<and> Type x2 = Type (ts_b @ ts_a))\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (Type x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by auto"], ["", "lemma b_e_check_single_top_sound:\n  assumes \"type_update (TopType x1) (to_ct_list t_in) (Type t_out) = TopType x2\"\n          \"c_types_agree (TopType x2) tm\"\n          \"\\<C> \\<turnstile> [e] : (t_in _> t_out)\"\n  shows \"\\<exists>tn. c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "obtain t_ag where t_ag_def:\"ct_suffix (to_ct_list t_out) x2\"\n                             \"tm = t_ag @ t_out\"\n                             \"c_types_agree (TopType x1) (t_ag @ t_in)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t_ag.\n        \\<lbrakk>ct_suffix (to_ct_list t_out) x2; tm = t_ag @ t_out;\n         c_types_agree (TopType x1) (t_ag @ t_in)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using type_update_top_top[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list t_out) x2\n  \\<exists>t_ag'.\n     tm = t_ag' @ t_out \\<and> c_types_agree (TopType x1) (t_ag' @ t_in)\n\ngoal (1 subgoal):\n 1. (\\<And>t_ag.\n        \\<lbrakk>ct_suffix (to_ct_list t_out) x2; tm = t_ag @ t_out;\n         c_types_agree (TopType x1) (t_ag @ t_in)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ct_suffix (to_ct_list t_out) x2\n  tm = t_ag @ t_out\n  c_types_agree (TopType x1) (t_ag @ t_in)\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "hence \"\\<C> \\<turnstile> [e] : (t_ag@t_in _> t_ag@t_out)\""], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list t_out) x2\n  tm = t_ag @ t_out\n  c_types_agree (TopType x1) (t_ag @ t_in)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : t_ag @ t_in _> t_ag @ t_out", "using b_e_typing.intros(35)[OF assms(3)]"], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list t_out) x2\n  tm = t_ag @ t_out\n  c_types_agree (TopType x1) (t_ag @ t_in)\n  \\<C> \\<turnstile> [e] : ?ts @ t_in _> ?ts @ t_out\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : t_ag @ t_in _> t_ag @ t_out", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [e] : t_ag @ t_in _> t_ag @ t_out\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [e] : t_ag @ t_in _> t_ag @ t_out\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using t_ag_def"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [e] : t_ag @ t_in _> t_ag @ t_out\n  ct_suffix (to_ct_list t_out) x2\n  tm = t_ag @ t_out\n  c_types_agree (TopType x1) (t_ag @ t_in)\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree (TopType x1) tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_top_not_bot_sound:\n  assumes \"type_update ts (to_ct_list t_in) (TopType []) = ts'\"\n          \"ts \\<noteq> Bot\"\n          \"ts' \\<noteq> Bot\"\n  shows \"\\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "proof (cases ts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ts = TopType x1 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 3. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "case (TopType x1)"], ["proof (state)\nthis:\n  ts = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ts = TopType x1 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 3. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "then"], ["proof (chain)\npicking this:\n  ts = TopType x1", "obtain t_int where \"consume (TopType x1) (to_ct_list t_in) = t_int\" \"t_int \\<noteq> Bot\""], ["proof (prove)\nusing this:\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>consume (TopType x1) (to_ct_list t_in) = t_int;\n         t_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  ts = TopType x1\n  type_update ts (to_ct_list t_in) (TopType []) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>consume (TopType x1) (to_ct_list t_in) = t_int;\n         t_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  consume (TopType x1) (to_ct_list t_in) = t_int\n  t_int \\<noteq> Bot\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ts = TopType x1 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 3. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  consume (TopType x1) (to_ct_list t_in) = t_int\n  t_int \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "using TopType ct_suffix_ct_list_eq_exists ct_suffix_ts_conv_suffix"], ["proof (prove)\nusing this:\n  consume (TopType x1) (to_ct_list t_in) = t_int\n  t_int \\<noteq> Bot\n  ts = TopType x1\n  ct_suffix ?x1.0 ?x2.0 \\<Longrightarrow>\n  \\<exists>ts_c.\n     ct_suffix ?x1.0 (to_ct_list ts_c) \\<and>\n     ct_list_eq (to_ct_list ts_c) ?x2.0\n  ct_suffix (to_ct_list ?ts) (to_ct_list ?ts') = suffix ?ts ?ts'\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "unfolding consume.simps"], ["proof (prove)\nusing this:\n  (if ct_suffix (to_ct_list t_in) x1\n   then TopType (take (length x1 - length (to_ct_list t_in)) x1)\n   else if ct_suffix x1 (to_ct_list t_in) then TopType [] else Bot) =\n  t_int\n  t_int \\<noteq> Bot\n  ts = TopType x1\n  ct_suffix ?x1.0 ?x2.0 \\<Longrightarrow>\n  \\<exists>ts_c.\n     ct_suffix ?x1.0 (to_ct_list ts_c) \\<and>\n     ct_list_eq (to_ct_list ts_c) ?x2.0\n  ct_suffix (to_ct_list ?ts) (to_ct_list ?ts') = suffix ?ts ?ts'\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "by (metis append_Nil c_types_agree.simps(2) ct_suffix_def)"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "case (Type x2)"], ["proof (state)\nthis:\n  ts = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "then"], ["proof (chain)\npicking this:\n  ts = Type x2", "obtain t_int where \"consume (Type x2) (to_ct_list t_in) = t_int\" \"t_int \\<noteq> Bot\""], ["proof (prove)\nusing this:\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>consume (Type x2) (to_ct_list t_in) = t_int;\n         t_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  ts = Type x2\n  type_update ts (to_ct_list t_in) (TopType []) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>consume (Type x2) (to_ct_list t_in) = t_int;\n         t_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  consume (Type x2) (to_ct_list t_in) = t_int\n  t_int \\<noteq> Bot\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ts = Type x2 \\<Longrightarrow>\n       \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n 2. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  consume (Type x2) (to_ct_list t_in) = t_int\n  t_int \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "using c_types_agree_id Type consume_type suffixI ct_suffix_ts_conv_suffix"], ["proof (prove)\nusing this:\n  consume (Type x2) (to_ct_list t_in) = t_int\n  t_int \\<noteq> Bot\n  c_types_agree (Type ?ts) ?ts\n  ts = Type x2\n  \\<lbrakk>consume (Type ?ts) ?ts' = ?c_t; ?c_t \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts''.\n                       ct_list_eq (to_ct_list ?ts)\n                        (to_ct_list ts'' @ ?ts') \\<and>\n                       ?c_t = Type ts''\n  ?ys = ?zs @ ?xs \\<Longrightarrow> suffix ?xs ?ys\n  ct_suffix (to_ct_list ?ts) (to_ct_list ?ts') = suffix ?ts ?ts'\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n\ngoal (1 subgoal):\n 1. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "case Bot"], ["proof (state)\nthis:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. ts = Bot \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "using assms(2)"], ["proof (prove)\nusing this:\n  ts = Bot\n  ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn", "by simp"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> suffix t_in tn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_type_not_bot_sound:\n  assumes \"type_update ts (to_ct_list t_in) (Type t_out) = ts'\"\n          \"ts \\<noteq> Bot\"\n          \"ts' \\<noteq> Bot\"\n          \"c_types_agree ts' tm\"\n          \"\\<C> \\<turnstile> [e] : (t_in _> t_out)\"\n  shows \"\\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using assms b_e_check_single_type_sound"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list t_in) (Type t_out) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n  c_types_agree ts' tm\n  \\<C> \\<turnstile> [e] : t_in _> t_out\n  \\<lbrakk>type_update (Type ?x1.0) (to_ct_list ?t_in) (Type ?t_out) =\n           Type ?x2.0;\n   c_types_agree (Type ?x2.0) ?tm;\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (Type ?x1.0) tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "proof (cases ts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 3. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "case (TopType x1)"], ["proof (state)\nthis:\n  ts = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 3. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  ts = TopType x1", "obtain x1' where x_def:\"TopType x1' = ts'\""], ["proof (prove)\nusing this:\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. (\\<And>x1'.\n        TopType x1' = ts' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ts = TopType x1\n  type_update ts (to_ct_list t_in) (Type t_out) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n  c_types_agree ts' tm\n  \\<C> \\<turnstile> [e] : t_in _> t_out\n\ngoal (1 subgoal):\n 1. (\\<And>x1'.\n        TopType x1' = ts' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, metis (full_types) produce.simps(1) produce.simps(6))"], ["proof (state)\nthis:\n  TopType x1' = ts'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 3. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  TopType x1' = ts'\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using assms b_e_check_single_top_sound TopType"], ["proof (prove)\nusing this:\n  TopType x1' = ts'\n  type_update ts (to_ct_list t_in) (Type t_out) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n  c_types_agree ts' tm\n  \\<C> \\<turnstile> [e] : t_in _> t_out\n  \\<lbrakk>type_update (TopType ?x1.0) (to_ct_list ?t_in) (Type ?t_out) =\n           TopType ?x2.0;\n   c_types_agree (TopType ?x2.0) ?tm;\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (TopType ?x1.0) tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "case (Type x2)"], ["proof (state)\nthis:\n  ts = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  ts = Type x2", "obtain x2' where x_def:\"Type x2' = ts'\""], ["proof (prove)\nusing this:\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. (\\<And>x2'. Type x2' = ts' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ts = Type x2\n  type_update ts (to_ct_list t_in) (Type t_out) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n  c_types_agree ts' tm\n  \\<C> \\<turnstile> [e] : t_in _> t_out\n\ngoal (1 subgoal):\n 1. (\\<And>x2'. Type x2' = ts' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, metis (full_types) produce.simps(2) produce.simps(6))"], ["proof (state)\nthis:\n  Type x2' = ts'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n        ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n        \\<C> \\<turnstile> [e] : t_in _> t_out;\n        \\<And>x1 t_in t_out x2 tm \\<C> e.\n           \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                    Type x2;\n            c_types_agree (Type x2) tm;\n            \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (Type x1) tn \\<and>\n                                \\<C> \\<turnstile> [e] : tn _> tm;\n        ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [e] : tn _> tm\n 2. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  Type x2' = ts'\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using assms b_e_check_single_type_sound Type"], ["proof (prove)\nusing this:\n  Type x2' = ts'\n  type_update ts (to_ct_list t_in) (Type t_out) = ts'\n  ts \\<noteq> Bot\n  ts' \\<noteq> Bot\n  c_types_agree ts' tm\n  \\<C> \\<turnstile> [e] : t_in _> t_out\n  \\<lbrakk>type_update (Type ?x1.0) (to_ct_list ?t_in) (Type ?t_out) =\n           Type ?x2.0;\n   c_types_agree (Type ?x2.0) ?tm;\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (Type ?x1.0) tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "case Bot"], ["proof (state)\nthis:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. \\<lbrakk>type_update ts (to_ct_list t_in) (Type t_out) = ts';\n     ts \\<noteq> Bot; ts' \\<noteq> Bot; c_types_agree ts' tm;\n     \\<C> \\<turnstile> [e] : t_in _> t_out;\n     \\<And>x1 t_in t_out x2 tm \\<C> e.\n        \\<lbrakk>type_update (Type x1) (to_ct_list t_in) (Type t_out) =\n                 Type x2;\n         c_types_agree (Type x2) tm;\n         \\<C> \\<turnstile> [e] : t_in _> t_out\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree (Type x1) tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm;\n     ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [e] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using assms(2)"], ["proof (prove)\nusing this:\n  ts = Bot\n  ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by simp"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_sound_unop_testop_cvtop:\n  assumes \"check_single \\<C> e tn' = tm'\"\n          \"((e = (Unop_i t uu) \\<or> e = (Testop t uv)) \\<and> is_int_t t)\n           \\<or> (e = (Unop_f t uw) \\<and> is_float_t t)\n           \\<or> (e = (Cvtop t1 Convert t sx) \\<and> convert_cond t1 t sx)\n           \\<or> (e = (Cvtop t1 Reinterpret t sx) \\<and> ((t1 \\<noteq> t) \\<and> t_length t1 = t_length t \\<and> sx = None))\"\n          \"c_types_agree tm' tm\"\n          \"tn' \\<noteq> Bot\"\n          \"tm' \\<noteq> Bot\"\n shows \"\\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "have \"(e = (Cvtop t1 Convert t sx) \\<Longrightarrow> convert_cond t1 t sx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = Cvtop t1 Convert t sx \\<Longrightarrow> convert_cond t1 t sx", "using assms(2)"], ["proof (prove)\nusing this:\n  (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n  e = Unop_f t uw \\<and> is_float_t t \\<or>\n  e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n  e = Cvtop t1 Reinterpret t sx \\<and>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None\n\ngoal (1 subgoal):\n 1. e = Cvtop t1 Convert t sx \\<Longrightarrow> convert_cond t1 t sx", "by simp"], ["proof (state)\nthis:\n  e = Cvtop t1 Convert t sx \\<Longrightarrow> convert_cond t1 t sx\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "hence temp0:\"(e = (Cvtop t1 Convert t sx)) \\<Longrightarrow> (type_update tn' [TSome t] (Type [arity_1_result e]) = tm')\""], ["proof (prove)\nusing this:\n  e = Cvtop t1 Convert t sx \\<Longrightarrow> convert_cond t1 t sx\n\ngoal (1 subgoal):\n 1. e = Cvtop t1 Convert t sx \\<Longrightarrow>\n    type_update tn' [TSome t] (Type [arity_1_result e]) = tm'", "using assms(1,5) arity_1_result_def"], ["proof (prove)\nusing this:\n  e = Cvtop t1 Convert t sx \\<Longrightarrow> convert_cond t1 t sx\n  check_single \\<C> e tn' = tm'\n  tm' \\<noteq> Bot\n  arity_1_result ?op1.0 =\n  (case ?op1.0 of Unop_i t x \\<Rightarrow> t | Unop_f t x \\<Rightarrow> t\n   | Testop t x \\<Rightarrow> T_i32 | Cvtop t1 Convert x xa \\<Rightarrow> t1\n   | Cvtop t1 _ x xa \\<Rightarrow> t1)\n\ngoal (1 subgoal):\n 1. e = Cvtop t1 Convert t sx \\<Longrightarrow>\n    type_update tn' [TSome t] (Type [arity_1_result e]) = tm'", "by (simp del: convert_cond.simps)"], ["proof (state)\nthis:\n  e = Cvtop t1 Convert t sx \\<Longrightarrow>\n  type_update tn' [TSome t] (Type [arity_1_result e]) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "have temp1:\"(e = (Cvtop t1 Reinterpret t sx)) \\<Longrightarrow> (type_update tn' [TSome t] (Type [arity_1_result e]) = tm')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = Cvtop t1 Reinterpret t sx \\<Longrightarrow>\n    type_update tn' [TSome t] (Type [arity_1_result e]) = tm'", "using assms(1,2,5) arity_1_result_def"], ["proof (prove)\nusing this:\n  check_single \\<C> e tn' = tm'\n  (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n  e = Unop_f t uw \\<and> is_float_t t \\<or>\n  e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n  e = Cvtop t1 Reinterpret t sx \\<and>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None\n  tm' \\<noteq> Bot\n  arity_1_result ?op1.0 =\n  (case ?op1.0 of Unop_i t x \\<Rightarrow> t | Unop_f t x \\<Rightarrow> t\n   | Testop t x \\<Rightarrow> T_i32 | Cvtop t1 Convert x xa \\<Rightarrow> t1\n   | Cvtop t1 _ x xa \\<Rightarrow> t1)\n\ngoal (1 subgoal):\n 1. e = Cvtop t1 Reinterpret t sx \\<Longrightarrow>\n    type_update tn' [TSome t] (Type [arity_1_result e]) = tm'", "by simp"], ["proof (state)\nthis:\n  e = Cvtop t1 Reinterpret t sx \\<Longrightarrow>\n  type_update tn' [TSome t] (Type [arity_1_result e]) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "have 1:\"type_update tn' (to_ct_list [t]) (Type [arity_1_result e]) = tm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_update tn' (to_ct_list [t]) (Type [arity_1_result e]) = tm'", "using assms arity_1_result_def"], ["proof (prove)\nusing this:\n  check_single \\<C> e tn' = tm'\n  (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n  e = Unop_f t uw \\<and> is_float_t t \\<or>\n  e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n  e = Cvtop t1 Reinterpret t sx \\<and>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None\n  c_types_agree tm' tm\n  tn' \\<noteq> Bot\n  tm' \\<noteq> Bot\n  arity_1_result ?op1.0 =\n  (case ?op1.0 of Unop_i t x \\<Rightarrow> t | Unop_f t x \\<Rightarrow> t\n   | Testop t x \\<Rightarrow> T_i32 | Cvtop t1 Convert x xa \\<Rightarrow> t1\n   | Cvtop t1 _ x xa \\<Rightarrow> t1)\n\ngoal (1 subgoal):\n 1. type_update tn' (to_ct_list [t]) (Type [arity_1_result e]) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> e tn' = tm'\n  (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n  e = Unop_f t uw \\<and> is_float_t t \\<or>\n  e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n  e = Cvtop t1 Reinterpret t sx \\<and>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None\n  c_types_agree tm' tm\n  tn' \\<noteq> Bot\n  tm' \\<noteq> Bot\n  arity_1_result ?op1.0 =\n  (case ?op1.0 of Unop_i t x \\<Rightarrow> t | Unop_f t x \\<Rightarrow> t\n   | Testop t x \\<Rightarrow> T_i32 | Cvtop t1 Convert x xa \\<Rightarrow> t1\n   | Cvtop t1 _ x xa \\<Rightarrow> t1)\n\ngoal (1 subgoal):\n 1. type_update tn' (map TSome [t]) (Type [arity_1_result e]) = tm'", "apply (simp del: convert_cond.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e tn' = tm';\n     (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n     e = Unop_f t uw \\<and> is_float_t t \\<or>\n     e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n     e = Cvtop t1 Reinterpret t sx \\<and>\n     t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None;\n     c_types_agree tm' tm; tn' \\<noteq> Bot; tm' \\<noteq> Bot;\n     \\<And>op1.\n        arity_1_result op1 =\n        (case op1 of Unop_i t x \\<Rightarrow> t | Unop_f t x \\<Rightarrow> t\n         | Testop t x \\<Rightarrow> T_i32\n         | Cvtop t1 Convert x xa \\<Rightarrow> t1\n         | Cvtop t1 _ x xa \\<Rightarrow> t1)\\<rbrakk>\n    \\<Longrightarrow> produce (consume tn' [TSome t])\n                       (Type\n                         [case e of Unop_i t x \\<Rightarrow> t\n                          | Unop_f t x \\<Rightarrow> t\n                          | Testop t x \\<Rightarrow> T_i32\n                          | Cvtop t1 Convert x xa \\<Rightarrow> t1\n                          | Cvtop t1 _ x xa \\<Rightarrow> t1]) =\n                      tm'", "apply (metis (no_types, lifting) temp0 temp1 b_e.simps(978,979,982) check_single.simps(2) check_single.simps(3) check_single.simps(6) type_update.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  type_update tn' (to_ct_list [t]) (Type [arity_1_result e]) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "have \"\\<C> \\<turnstile> [e] : ([t] _> [arity_1_result e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : [t] _> [arity_1_result e]", "using assms(2) b_e_typing.intros(2,3,6,9,10)"], ["proof (prove)\nusing this:\n  (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n  e = Unop_f t uw \\<and> is_float_t t \\<or>\n  e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n  e = Cvtop t1 Reinterpret t sx \\<and>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Unop_i ?t ?uu] : [?t] _> [?t]\n  is_float_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Unop_f ?t ?uv] : [?t] _> [?t]\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Testop ?t ?ux] : [?t] _> [T_i32]\n  \\<lbrakk>?t1.0 \\<noteq> ?t2.0;\n   (?sx = None) =\n   (is_float_t ?t1.0 \\<and> is_float_t ?t2.0 \\<or>\n    is_int_t ?t1.0 \\<and>\n    is_int_t ?t2.0 \\<and> t_length ?t1.0 < t_length ?t2.0)\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Cvtop ?t1.0 Convert ?t2.0\n   ?sx] : [?t2.0] _> [?t1.0]\n  \\<lbrakk>?t1.0 \\<noteq> ?t2.0; t_length ?t1.0 = t_length ?t2.0\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Cvtop ?t1.0 Reinterpret ?t2.0\n   None] : [?t2.0] _> [?t1.0]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : [t] _> [arity_1_result e]", "unfolding arity_1_result_def"], ["proof (prove)\nusing this:\n  (e = Unop_i t uu \\<or> e = Testop t uv) \\<and> is_int_t t \\<or>\n  e = Unop_f t uw \\<and> is_float_t t \\<or>\n  e = Cvtop t1 Convert t sx \\<and> convert_cond t1 t sx \\<or>\n  e = Cvtop t1 Reinterpret t sx \\<and>\n  t1 \\<noteq> t \\<and> t_length t1 = t_length t \\<and> sx = None\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Unop_i ?t ?uu] : [?t] _> [?t]\n  is_float_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Unop_f ?t ?uv] : [?t] _> [?t]\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Testop ?t ?ux] : [?t] _> [T_i32]\n  \\<lbrakk>?t1.0 \\<noteq> ?t2.0;\n   (?sx = None) =\n   (is_float_t ?t1.0 \\<and> is_float_t ?t2.0 \\<or>\n    is_int_t ?t1.0 \\<and>\n    is_int_t ?t2.0 \\<and> t_length ?t1.0 < t_length ?t2.0)\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Cvtop ?t1.0 Convert ?t2.0\n   ?sx] : [?t2.0] _> [?t1.0]\n  \\<lbrakk>?t1.0 \\<noteq> ?t2.0; t_length ?t1.0 = t_length ?t2.0\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Cvtop ?t1.0 Reinterpret ?t2.0\n   None] : [?t2.0] _> [?t1.0]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : [t] _> [case e of Unop_i t x \\<Rightarrow> t\n                                    | Unop_f t x \\<Rightarrow> t\n                                    | Testop t x \\<Rightarrow> T_i32\n                                    | Cvtop t1 Convert x xa \\<Rightarrow> t1\n                                    | Cvtop t1 _ x xa \\<Rightarrow> t1]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [e] : [t] _> [arity_1_result e]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [e] : [t] _> [arity_1_result e]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF 1 assms(4,5,3)]"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [e] : [t] _> [arity_1_result e]\n  ?\\<C> \\<turnstile> [?e] : [t] _> [arity_1_result e] \\<Longrightarrow>\n  \\<exists>tn.\n     c_types_agree tn' tn \\<and> ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_sound_binop_relop:\n  assumes \"check_single \\<C> e tn' = tm'\"\n          \"((e = Binop_i t iop \\<and> is_int_t t)\n            \\<or> (e = Binop_f t fop \\<and> is_float_t t)\n            \\<or> (e = Relop_i t irop \\<and> is_int_t t)\n            \\<or> (e = Relop_f t frop \\<and> is_float_t t))\"\n          \"c_types_agree tm' tm\"\n          \"tn' \\<noteq> Bot\"\n          \"tm' \\<noteq> Bot\"\n shows \"\\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "have \"type_update tn' (to_ct_list [t,t]) (Type [arity_2_result e]) = tm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'", "using assms arity_2_result_def"], ["proof (prove)\nusing this:\n  check_single \\<C> e tn' = tm'\n  e = Binop_i t iop \\<and> is_int_t t \\<or>\n  e = Binop_f t fop \\<and> is_float_t t \\<or>\n  e = Relop_i t irop \\<and> is_int_t t \\<or>\n  e = Relop_f t frop \\<and> is_float_t t\n  c_types_agree tm' tm\n  tn' \\<noteq> Bot\n  tm' \\<noteq> Bot\n  arity_2_result ?op2.0 =\n  (case ?op2.0 of Binop_i t x \\<Rightarrow> t | Binop_f t x \\<Rightarrow> t\n   | Relop_i t x \\<Rightarrow> T_i32 | Relop_f t x \\<Rightarrow> T_i32)\n\ngoal (1 subgoal):\n 1. type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> e tn' = tm'\n  e = Binop_i t iop \\<and> is_int_t t \\<or>\n  e = Binop_f t fop \\<and> is_float_t t \\<or>\n  e = Relop_i t irop \\<and> is_int_t t \\<or>\n  e = Relop_f t frop \\<and> is_float_t t\n  c_types_agree tm' tm\n  tn' \\<noteq> Bot\n  tm' \\<noteq> Bot\n  arity_2_result ?op2.0 =\n  (case ?op2.0 of Binop_i t x \\<Rightarrow> t | Binop_f t x \\<Rightarrow> t\n   | Relop_i t x \\<Rightarrow> T_i32 | Relop_f t x \\<Rightarrow> T_i32)\n\ngoal (1 subgoal):\n 1. type_update tn' (map TSome [t, t]) (Type [arity_2_result e]) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "have \"\\<C> \\<turnstile> [e] : ([t,t] _> [arity_2_result e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : [t, t] _> [arity_2_result e]", "using assms(2) b_e_typing.intros(4,5,7,8)"], ["proof (prove)\nusing this:\n  e = Binop_i t iop \\<and> is_int_t t \\<or>\n  e = Binop_f t fop \\<and> is_float_t t \\<or>\n  e = Relop_i t irop \\<and> is_int_t t \\<or>\n  e = Relop_f t frop \\<and> is_float_t t\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Binop_i ?t ?iop] : [?t, ?t] _> [?t]\n  is_float_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Binop_f ?t ?uw] : [?t, ?t] _> [?t]\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Relop_i ?t ?uy] : [?t, ?t] _> [T_i32]\n  is_float_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Relop_f ?t ?uz] : [?t, ?t] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : [t, t] _> [arity_2_result e]", "unfolding arity_2_result_def"], ["proof (prove)\nusing this:\n  e = Binop_i t iop \\<and> is_int_t t \\<or>\n  e = Binop_f t fop \\<and> is_float_t t \\<or>\n  e = Relop_i t irop \\<and> is_int_t t \\<or>\n  e = Relop_f t frop \\<and> is_float_t t\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Binop_i ?t ?iop] : [?t, ?t] _> [?t]\n  is_float_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Binop_f ?t ?uw] : [?t, ?t] _> [?t]\n  is_int_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Relop_i ?t ?uy] : [?t, ?t] _> [T_i32]\n  is_float_t ?t \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Relop_f ?t ?uz] : [?t, ?t] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [e] : [t, t] _> [case e of Binop_i t x \\<Rightarrow> t\n | Binop_f t x \\<Rightarrow> t | Relop_i t x \\<Rightarrow> T_i32\n | Relop_f t x \\<Rightarrow> T_i32]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [e] : [t, t] _> [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'\n  \\<C> \\<turnstile> [e] : [t, t] _> [arity_2_result e]", "show ?thesis"], ["proof (prove)\nusing this:\n  type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'\n  \\<C> \\<turnstile> [e] : [t, t] _> [arity_2_result e]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ assms(4,5,3)]"], ["proof (prove)\nusing this:\n  type_update tn' (to_ct_list [t, t]) (Type [arity_2_result e]) = tm'\n  \\<C> \\<turnstile> [e] : [t, t] _> [arity_2_result e]\n  \\<lbrakk>type_update tn' (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_type_checker_sound:\n  assumes \"b_e_type_checker \\<C> es (tn _> tm)\"\n  shows \"\\<C> \\<turnstile> es : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm", "fix e tn'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm", "have \"b_e_type_checker \\<C> es (tn _> tm) \\<Longrightarrow>\n          \\<C> \\<turnstile> es : (tn _> tm)\"\n  and \"\\<And>tm' tm.\n       check \\<C> es tn' = tm' \\<Longrightarrow>\n       c_types_agree tm' tm \\<Longrightarrow>\n         \\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> es : (tn _> tm)\"\n  and \"\\<And>tm' tm.\n       check_single \\<C> e tn' = tm' \\<Longrightarrow>\n       c_types_agree tm' tm \\<Longrightarrow>\n       tn' \\<noteq> Bot \\<Longrightarrow>\n       tm' \\<noteq> Bot \\<Longrightarrow>\n         \\<exists>tn. c_types_agree tn' tn \\<and> \\<C> \\<turnstile> [e] : (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b_e_type_checker \\<C> es (tn _> tm) \\<Longrightarrow>\n     \\<C> \\<turnstile> es : tn _> tm) &&&\n    (\\<And>tm' tm.\n        \\<lbrakk>check \\<C> es tn' = tm'; c_types_agree tm' tm\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree tn' tn \\<and>\n                             \\<C> \\<turnstile> es : tn _> tm) &&&\n    (\\<And>tm' tm.\n        \\<lbrakk>check_single \\<C> e tn' = tm'; c_types_agree tm' tm;\n         tn' \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree tn' tn \\<and>\n                             \\<C> \\<turnstile> [e] : tn _> tm)", "proof (induction rule: b_e_type_checker_check_check_single.induct)"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>\\<C> es tn tm.\n       \\<lbrakk>\\<And>tm' tm.\n                   \\<lbrakk>check \\<C> es (Type tn) = tm';\n                    c_types_agree tm' tm\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tna.\n  c_types_agree (Type tn) tna \\<and> \\<C> \\<turnstile> es : tna _> tm;\n        b_e_type_checker \\<C> es (tn _> tm)\\<rbrakk>\n       \\<Longrightarrow> \\<C> \\<turnstile> es : tn _> tm\n 2. \\<And>\\<C> es ts tm' tm.\n       \\<lbrakk>\\<And>x21 x22 x1 tm' tm.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n                    ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tn.\n  c_types_agree ts tn \\<and> \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x1 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n            ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree ts tn \\<and>\n                                \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        check \\<C> es ts = tm'; c_types_agree tm' tm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es : tn _> tm\n 3. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 4. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 5. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 6. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 7. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 8. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 9. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 10. \\<And>\\<C> t va_ ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\nA total of 34 subgoals...", "case (1 \\<C> es tn' tm)"], ["proof (state)\nthis:\n  \\<lbrakk>check \\<C> es (Type tn') = ?tm'; c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (Type tn') tn \\<and>\n                       \\<C> \\<turnstile> es : tn _> ?tm\n  b_e_type_checker \\<C> es (tn' _> tm)\n\ngoal (34 subgoals):\n 1. \\<And>\\<C> es tn tm.\n       \\<lbrakk>\\<And>tm' tm.\n                   \\<lbrakk>check \\<C> es (Type tn) = tm';\n                    c_types_agree tm' tm\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tna.\n  c_types_agree (Type tn) tna \\<and> \\<C> \\<turnstile> es : tna _> tm;\n        b_e_type_checker \\<C> es (tn _> tm)\\<rbrakk>\n       \\<Longrightarrow> \\<C> \\<turnstile> es : tn _> tm\n 2. \\<And>\\<C> es ts tm' tm.\n       \\<lbrakk>\\<And>x21 x22 x1 tm' tm.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n                    ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tn.\n  c_types_agree ts tn \\<and> \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x1 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n            ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree ts tn \\<and>\n                                \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        check \\<C> es ts = tm'; c_types_agree tm' tm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es : tn _> tm\n 3. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 4. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 5. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 6. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 7. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 8. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 9. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 10. \\<And>\\<C> t va_ ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\nA total of 34 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>check \\<C> es (Type tn') = ?tm'; c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (Type tn') tn \\<and>\n                       \\<C> \\<turnstile> es : tn _> ?tm\n  b_e_type_checker \\<C> es (tn' _> tm)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn' _> tm", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : tn' _> tm\n\ngoal (33 subgoals):\n 1. \\<And>\\<C> es ts tm' tm.\n       \\<lbrakk>\\<And>x21 x22 x1 tm' tm.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n                    ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tn.\n  c_types_agree ts tn \\<and> \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x1 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n            ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree ts tn \\<and>\n                                \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        check \\<C> es ts = tm'; c_types_agree tm' tm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es : tn _> tm\n 2. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 3. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 4. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 5. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 6. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 7. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 8. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 9. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Convert t2\n           sx] : tn _> tm\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>\\<C> es ts tm' tm.\n       \\<lbrakk>\\<And>x21 x22 x1 tm' tm.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n                    ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tn.\n  c_types_agree ts tn \\<and> \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x1 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n            ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree ts tn \\<and>\n                                \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        check \\<C> es ts = tm'; c_types_agree tm' tm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es : tn _> tm\n 2. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 3. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 4. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 5. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 6. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 7. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 8. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 9. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Convert t2\n           sx] : tn _> tm\nA total of 33 subgoals...", "case (2 \\<C> es' ts)"], ["proof (state)\nthis:\n  \\<lbrakk>es' = ?x21.0 # ?x22.0; ts = TopType ?x1.0;\n   check_single \\<C> ?x21.0 ts = ?tm'; c_types_agree ?tm' ?tm;\n   ts \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       \\<C> \\<turnstile> [?x21.0] : tn _> ?tm\n  \\<lbrakk>es' = ?x21.0 # ?x22.0; ts = TopType ?x1.0;\n   check \\<C> ?x22.0 (check_single \\<C> ?x21.0 ts) = ?tm';\n   c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (check_single \\<C> ?x21.0 ts) tn \\<and>\n                       \\<C> \\<turnstile> ?x22.0 : tn _> ?tm\n  \\<lbrakk>es' = ?x21.0 # ?x22.0; ts = Type ?x2.0;\n   check_single \\<C> ?x21.0 ts = ?tm'; c_types_agree ?tm' ?tm;\n   ts \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       \\<C> \\<turnstile> [?x21.0] : tn _> ?tm\n  \\<lbrakk>es' = ?x21.0 # ?x22.0; ts = Type ?x2.0;\n   check \\<C> ?x22.0 (check_single \\<C> ?x21.0 ts) = ?tm';\n   c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree (check_single \\<C> ?x21.0 ts) tn \\<and>\n                       \\<C> \\<turnstile> ?x22.0 : tn _> ?tm\n  check \\<C> es' ts = tm'\n  c_types_agree tm' tm\n\ngoal (33 subgoals):\n 1. \\<And>\\<C> es ts tm' tm.\n       \\<lbrakk>\\<And>x21 x22 x1 tm' tm.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n                    ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>tn.\n  c_types_agree ts tn \\<and> \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x1 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ts = tm'; c_types_agree tm' tm;\n            ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree ts tn \\<and>\n                                \\<C> \\<turnstile> [x21] : tn _> tm;\n        \\<And>x21 x22 x2 tm' tm.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check \\<C> x22 (check_single \\<C> x21 ts) = tm';\n            c_types_agree tm' tm\\<rbrakk>\n           \\<Longrightarrow> \\<exists>tn.\n                                c_types_agree (check_single \\<C> x21 ts)\n                                 tn \\<and>\n                                \\<C> \\<turnstile> x22 : tn _> tm;\n        check \\<C> es ts = tm'; c_types_agree tm' tm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es : tn _> tm\n 2. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 3. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 4. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 5. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 6. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 7. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 8. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 9. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Convert t2\n           sx] : tn _> tm\nA total of 33 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "proof (cases es')"], ["proof (state)\ngoal (2 subgoals):\n 1. es' = [] \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>a list.\n       es' = a # list \\<Longrightarrow>\n       \\<exists>tn.\n          c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "case Nil"], ["proof (state)\nthis:\n  es' = []\n\ngoal (2 subgoals):\n 1. es' = [] \\<Longrightarrow>\n    \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>a list.\n       es' = a # list \\<Longrightarrow>\n       \\<exists>tn.\n          c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  es' = []\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "using 2(5,6)"], ["proof (prove)\nusing this:\n  es' = []\n  check \\<C> es' ts = tm'\n  c_types_agree tm' tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "by (simp add: b_e_type_empty)"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es' = a # list \\<Longrightarrow>\n       \\<exists>tn.\n          c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es' = a # list \\<Longrightarrow>\n       \\<exists>tn.\n          c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "case (Cons e es)"], ["proof (state)\nthis:\n  es' = e # es\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es' = a # list \\<Longrightarrow>\n       \\<exists>tn.\n          c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  es' = e # es\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "proof (cases ts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>es' = e # es; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 3. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "case (TopType x1)"], ["proof (state)\nthis:\n  ts = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>es' = e # es; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 3. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "have check_expand:\"check \\<C> es (check_single \\<C> e ts) = tm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es (check_single \\<C> e ts) = tm'", "using 2(5,6) TopType Cons"], ["proof (prove)\nusing this:\n  check \\<C> es' ts = tm'\n  c_types_agree tm' tm\n  ts = TopType x1\n  es' = e # es\n\ngoal (1 subgoal):\n 1. check \\<C> es (check_single \\<C> e ts) = tm'", "by simp"], ["proof (state)\nthis:\n  check \\<C> es (check_single \\<C> e ts) = tm'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>es' = e # es; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 3. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "obtain ts' where ts'_def:\"check_single \\<C> e ts = ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'.\n        check_single \\<C> e ts = ts' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e ts = ts'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>es' = e # es; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 3. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "obtain t_int where t_int_def:\"\\<C> \\<turnstile> es : (t_int _> tm)\"\n                                     \"c_types_agree ts' t_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>\\<C> \\<turnstile> es : t_int _> tm;\n         c_types_agree ts' t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2(2)[OF Cons TopType check_expand 2(6)] ts'_def"], ["proof (prove)\nusing this:\n  \\<exists>tn.\n     c_types_agree (check_single \\<C> e ts) tn \\<and>\n     \\<C> \\<turnstile> es : tn _> tm\n  check_single \\<C> e ts = ts'\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>\\<C> \\<turnstile> es : t_int _> tm;\n         c_types_agree ts' t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : t_int _> tm\n  c_types_agree ts' t_int\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>es' = e # es; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 3. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "obtain t_int' where \"c_types_agree ts t_int'\" \"\\<C> \\<turnstile> [e] : (t_int' _> t_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t_int'.\n        \\<lbrakk>c_types_agree ts t_int';\n         \\<C> \\<turnstile> [e] : t_int' _> t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2(1)[OF Cons _ ts'_def] TopType c_types_agree.simps(3) t_int_def(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ts = TopType ?x1.0; c_types_agree ts' ?tm; ts \\<noteq> Bot;\n   ts' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       \\<C> \\<turnstile> [e] : tn _> ?tm\n  ts = TopType x1\n  c_types_agree Bot ?uu = False\n  c_types_agree ts' t_int\n\ngoal (1 subgoal):\n 1. (\\<And>t_int'.\n        \\<lbrakk>c_types_agree ts t_int';\n         \\<C> \\<turnstile> [e] : t_int' _> t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c_types_agree ts t_int'\n  \\<C> \\<turnstile> [e] : t_int' _> t_int\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>es' = e # es; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 3. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree ts t_int'\n  \\<C> \\<turnstile> [e] : t_int' _> t_int\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "using t_int_def(1) b_e_type_comp_conc Cons"], ["proof (prove)\nusing this:\n  c_types_agree ts t_int'\n  \\<C> \\<turnstile> [e] : t_int' _> t_int\n  \\<C> \\<turnstile> es : t_int _> tm\n  \\<lbrakk>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> ?es @ ?es' : ?t1s _> ?t3s\n  es' = e # es\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "case (Type x2)"], ["proof (state)\nthis:\n  ts = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "have check_expand:\"check \\<C> es (check_single \\<C> e ts) = tm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es (check_single \\<C> e ts) = tm'", "using 2(5,6) Type Cons"], ["proof (prove)\nusing this:\n  check \\<C> es' ts = tm'\n  c_types_agree tm' tm\n  ts = Type x2\n  es' = e # es\n\ngoal (1 subgoal):\n 1. check \\<C> es (check_single \\<C> e ts) = tm'", "by simp"], ["proof (state)\nthis:\n  check \\<C> es (check_single \\<C> e ts) = tm'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "obtain ts' where ts'_def:\"check_single \\<C> e ts = ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'.\n        check_single \\<C> e ts = ts' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e ts = ts'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "obtain t_int where t_int_def:\"\\<C> \\<turnstile> es : (t_int _> tm)\"\n                                     \"c_types_agree ts' t_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>\\<C> \\<turnstile> es : t_int _> tm;\n         c_types_agree ts' t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2(4)[OF Cons Type check_expand 2(6)] ts'_def"], ["proof (prove)\nusing this:\n  \\<exists>tn.\n     c_types_agree (check_single \\<C> e ts) tn \\<and>\n     \\<C> \\<turnstile> es : tn _> tm\n  check_single \\<C> e ts = ts'\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        \\<lbrakk>\\<C> \\<turnstile> es : t_int _> tm;\n         c_types_agree ts' t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : t_int _> tm\n  c_types_agree ts' t_int\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "obtain t_int' where \"c_types_agree ts t_int'\" \"\\<C> \\<turnstile> [e] : (t_int' _> t_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t_int'.\n        \\<lbrakk>c_types_agree ts t_int';\n         \\<C> \\<turnstile> [e] : t_int' _> t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2(3)[OF Cons _ ts'_def] Type c_types_agree.simps(3) t_int_def(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ts = Type ?x2.0; c_types_agree ts' ?tm; ts \\<noteq> Bot;\n   ts' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       \\<C> \\<turnstile> [e] : tn _> ?tm\n  ts = Type x2\n  c_types_agree Bot ?uu = False\n  c_types_agree ts' t_int\n\ngoal (1 subgoal):\n 1. (\\<And>t_int'.\n        \\<lbrakk>c_types_agree ts t_int';\n         \\<C> \\<turnstile> [e] : t_int' _> t_int\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c_types_agree ts t_int'\n  \\<C> \\<turnstile> [e] : t_int' _> t_int\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>es' = e # es; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> es' : tn _> tm\n 2. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree ts t_int'\n  \\<C> \\<turnstile> [e] : t_int' _> t_int\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "using t_int_def(1) b_e_type_comp_conc Cons"], ["proof (prove)\nusing this:\n  c_types_agree ts t_int'\n  \\<C> \\<turnstile> [e] : t_int' _> t_int\n  \\<C> \\<turnstile> es : t_int _> tm\n  \\<lbrakk>?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s;\n   ?\\<C> \\<turnstile> ?es' : ?t2s _> ?t3s\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> ?es @ ?es' : ?t1s _> ?t3s\n  es' = e # es\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "case Bot"], ["proof (state)\nthis:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. \\<lbrakk>es' = e # es; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> es' : tn _> tm", "then"], ["proof (chain)\npicking this:\n  ts = Bot", "show ?thesis"], ["proof (prove)\nusing this:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "using 2(5,6) Cons"], ["proof (prove)\nusing this:\n  ts = Bot\n  check \\<C> es' ts = tm'\n  c_types_agree tm' tm\n  es' = e # es\n\ngoal (1 subgoal):\n 1. \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm", "by auto"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> es' : tn _> tm\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 2. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 3. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 4. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 5. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 6. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 7. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 8. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n           sx] : tn _> tm\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 2. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 3. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 4. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 5. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 6. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 7. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 8. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n           sx] : tn _> tm\nA total of 32 subgoals...", "case (3 \\<C> v ts)"], ["proof (state)\nthis:\n  check_single \\<C> (C v) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 2. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 3. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 4. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 5. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 6. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 7. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 8. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n           sx] : tn _> tm\nA total of 32 subgoals...", "hence \"type_update ts [] (Type [typeof v]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (C v) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts [] (Type [typeof v]) = tm'", "by simp"], ["proof (state)\nthis:\n  type_update ts [] (Type [typeof v]) = tm'\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 2. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 3. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 4. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 5. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 6. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 7. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 8. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n           sx] : tn _> tm\nA total of 32 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts [] (Type [typeof v]) = tm'\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 2. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 3. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 4. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 5. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 6. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 7. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 8. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n           sx] : tn _> tm\nA total of 32 subgoals...", "have \"\\<C> \\<turnstile> [C v] : ([] _> [typeof v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [typeof v]", "using b_e_typing.intros(1)"], ["proof (prove)\nusing this:\n  ?\\<C> \\<turnstile> [C ?v] : [] _> [typeof ?v]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [C v] : [] _> [typeof v]", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [C v] : [] _> [typeof v]\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts tm' tm.\n       \\<lbrakk>check_single \\<C> (C v) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [C v] : tn _> tm\n 2. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 3. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 4. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 5. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 6. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 7. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 8. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> t1 t2 sx ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n           sx] : tn _> tm\nA total of 32 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts [] (Type [typeof v]) = tm'\n  \\<C> \\<turnstile> [C v] : [] _> [typeof v]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [typeof v]) = tm'\n  \\<C> \\<turnstile> [C v] : [] _> [typeof v]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [C v] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 3(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [typeof v]) = tm'\n  \\<C> \\<turnstile> [C v] : [] _> [typeof v]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [C v] : tn _> tm", "by (metis list.simps(8) to_ct_list_def)"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [C v] : tn _> tm\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 2. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 3. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 4. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 5. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 6. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 7. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Unreachable] : tn _> tm\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 2. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 3. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 4. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 5. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 6. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 7. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Unreachable] : tn _> tm\nA total of 31 subgoals...", "case (4 \\<C> t uu ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Unop_i t uu) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 2. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 3. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 4. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 5. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 6. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 7. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Unreachable] : tn _> tm\nA total of 31 subgoals...", "hence \"is_int_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Unop_i t uu) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_int_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_int_t t\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_i t uu_] : tn _> tm\n 2. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 3. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 4. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 5. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 6. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 7. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Unreachable] : tn _> tm\nA total of 31 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unop_i t uu] : tn _> tm", "using b_e_check_single_sound_unop_testop_cvtop 4"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   (?e = Unop_i ?t ?uu \\<or> ?e = Testop ?t ?uv) \\<and> is_int_t ?t \\<or>\n   ?e = Unop_f ?t ?uw \\<and> is_float_t ?t \\<or>\n   ?e = Cvtop ?t1.0 Convert ?t ?sx \\<and> convert_cond ?t1.0 ?t ?sx \\<or>\n   ?e = Cvtop ?t1.0 Reinterpret ?t ?sx \\<and>\n   ?t1.0 \\<noteq> ?t \\<and> t_length ?t1.0 = t_length ?t \\<and> ?sx = None;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Unop_i t uu) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unop_i t uu] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unop_i t uu] : tn _> tm\n\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 2. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 3. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 4. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 5. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 6. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Nop] : tn _> tm\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 2. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 3. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 4. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 5. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 6. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Nop] : tn _> tm\nA total of 30 subgoals...", "case (5 \\<C> t uv ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Unop_f t uv) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 2. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 3. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 4. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 5. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 6. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Nop] : tn _> tm\nA total of 30 subgoals...", "hence \"is_float_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Unop_f t uv) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_float_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_float_t t\n\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unop_f t uv_] : tn _> tm\n 2. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 3. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 4. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 5. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 6. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Nop] : tn _> tm\nA total of 30 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_float_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unop_f t uv] : tn _> tm", "using b_e_check_single_sound_unop_testop_cvtop 5"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   (?e = Unop_i ?t ?uu \\<or> ?e = Testop ?t ?uv) \\<and> is_int_t ?t \\<or>\n   ?e = Unop_f ?t ?uw \\<and> is_float_t ?t \\<or>\n   ?e = Cvtop ?t1.0 Convert ?t ?sx \\<and> convert_cond ?t1.0 ?t ?sx \\<or>\n   ?e = Cvtop ?t1.0 Reinterpret ?t ?sx \\<and>\n   ?t1.0 \\<noteq> ?t \\<and> t_length ?t1.0 = t_length ?t \\<and> ?sx = None;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Unop_f t uv) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unop_f t uv] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unop_f t uv] : tn _> tm\n\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 2. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 3. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 4. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 5. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Drop] : tn _> tm\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 2. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 3. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 4. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 5. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Drop] : tn _> tm\nA total of 29 subgoals...", "case (6 \\<C> t uw ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Binop_i t uw) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 2. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 3. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 4. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 5. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Drop] : tn _> tm\nA total of 29 subgoals...", "hence \"is_int_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Binop_i t uw) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_int_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_int_t t\n\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_i t uw_] : tn _> tm\n 2. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 3. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 4. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 5. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Drop] : tn _> tm\nA total of 29 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Binop_i t uw] : tn _> tm", "using b_e_check_single_sound_binop_relop 6"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   ?e = Binop_i ?t ?iop \\<and> is_int_t ?t \\<or>\n   ?e = Binop_f ?t ?fop \\<and> is_float_t ?t \\<or>\n   ?e = Relop_i ?t ?irop \\<and> is_int_t ?t \\<or>\n   ?e = Relop_f ?t ?frop \\<and> is_float_t ?t;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Binop_i t uw) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Binop_i t uw] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Binop_i t uw] : tn _> tm\n\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 2. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 3. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 4. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Select] : tn _> tm\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 2. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 3. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 4. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Select] : tn _> tm\nA total of 28 subgoals...", "case (7 \\<C> t ux ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Binop_f t ux) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 2. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 3. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 4. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Select] : tn _> tm\nA total of 28 subgoals...", "hence \"is_float_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Binop_f t ux) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_float_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_float_t t\n\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Binop_f t ux_] : tn _> tm\n 2. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 3. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 4. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Select] : tn _> tm\nA total of 28 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_float_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Binop_f t ux] : tn _> tm", "using b_e_check_single_sound_binop_relop 7"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   ?e = Binop_i ?t ?iop \\<and> is_int_t ?t \\<or>\n   ?e = Binop_f ?t ?fop \\<and> is_float_t ?t \\<or>\n   ?e = Relop_i ?t ?irop \\<and> is_int_t ?t \\<or>\n   ?e = Relop_f ?t ?frop \\<and> is_float_t ?t;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Binop_f t ux) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Binop_f t ux] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Binop_f t ux] : tn _> tm\n\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 2. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 3. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Block (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Block (tn _> tm)\n           es] : tna _> tma\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 2. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 3. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Block (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Block (tn _> tm)\n           es] : tna _> tma\nA total of 27 subgoals...", "case (8 \\<C> t uy ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Testop t uy) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 2. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 3. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Block (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Block (tn _> tm)\n           es] : tna _> tma\nA total of 27 subgoals...", "hence \"is_int_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Testop t uy) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_int_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_int_t t\n\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Testop t uy_] : tn _> tm\n 2. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 3. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Block (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Block (tn _> tm)\n           es] : tna _> tma\nA total of 27 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Testop t uy] : tn _> tm", "using b_e_check_single_sound_unop_testop_cvtop 8"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   (?e = Unop_i ?t ?uu \\<or> ?e = Testop ?t ?uv) \\<and> is_int_t ?t \\<or>\n   ?e = Unop_f ?t ?uw \\<and> is_float_t ?t \\<or>\n   ?e = Cvtop ?t1.0 Convert ?t ?sx \\<and> convert_cond ?t1.0 ?t ?sx \\<or>\n   ?e = Cvtop ?t1.0 Reinterpret ?t ?sx \\<and>\n   ?t1.0 \\<noteq> ?t \\<and> t_length ?t1.0 = t_length ?t \\<and> ?sx = None;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Testop t uy) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Testop t uy] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Testop t uy] : tn _> tm\n\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 2. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tn] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Loop (tn _> tm)\n           es] : tna _> tma\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 2. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tn] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Loop (tn _> tm)\n           es] : tna _> tma\nA total of 26 subgoals...", "case (9 \\<C> t uz ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Relop_i t uz) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 2. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tn] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Loop (tn _> tm)\n           es] : tna _> tma\nA total of 26 subgoals...", "hence \"is_int_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Relop_i t uz) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_int_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_int_t t\n\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_i t uz_] : tn _> tm\n 2. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tn] @\n                           label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n         check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [Loop (tn _> tm)\n           es] : tna _> tma\nA total of 26 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Relop_i t uz] : tn _> tm", "using b_e_check_single_sound_binop_relop 9"], ["proof (prove)\nusing this:\n  is_int_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   ?e = Binop_i ?t ?iop \\<and> is_int_t ?t \\<or>\n   ?e = Binop_f ?t ?fop \\<and> is_float_t ?t \\<or>\n   ?e = Relop_i ?t ?irop \\<and> is_int_t ?t \\<or>\n   ?e = Relop_f ?t ?frop \\<and> is_float_t ?t;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Relop_i t uz) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Relop_i t uz] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Relop_i t uz] : tn _> tm\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n          es2 (tn _> tm) \\<Longrightarrow>\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n           es2] : tna _> tma\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n          es2 (tn _> tm) \\<Longrightarrow>\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n           es2] : tna _> tma\nA total of 25 subgoals...", "case (10 \\<C> t va ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Relop_f t va) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n          es2 (tn _> tm) \\<Longrightarrow>\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n           es2] : tna _> tma\nA total of 25 subgoals...", "hence \"is_float_t t\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Relop_f t va) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. is_float_t t", "by (simp, meson)"], ["proof (state)\nthis:\n  is_float_t t\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Relop_f t va_] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 10. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n        \\<lbrakk>b_e_type_checker\n                  (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                  (tn _> tm) \\<Longrightarrow>\n                 \\<C>\n                 \\<lparr>label :=\n                           [tm] @\n                           label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n         b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n          es2 (tn _> tm) \\<Longrightarrow>\n         \\<C>\n         \\<lparr>label :=\n                   [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n         c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tna.\n                             c_types_agree ts tna \\<and>\n                             \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n           es2] : tna _> tma\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  is_float_t t\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Relop_f t va] : tn _> tm", "using b_e_check_single_sound_binop_relop 10"], ["proof (prove)\nusing this:\n  is_float_t t\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   ?e = Binop_i ?t ?iop \\<and> is_int_t ?t \\<or>\n   ?e = Binop_f ?t ?fop \\<and> is_float_t ?t \\<or>\n   ?e = Relop_i ?t ?irop \\<and> is_int_t ?t \\<or>\n   ?e = Relop_f ?t ?frop \\<and> is_float_t ?t;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Relop_f t va) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Relop_f t va] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Relop_f t va] : tn _> tm\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br i] : tn _> tm\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br i] : tn _> tm\nA total of 24 subgoals...", "case (11 \\<C> t1 t2 sx ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br i] : tn _> tm\nA total of 24 subgoals...", "hence \"convert_cond t1 t2 sx\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. convert_cond t1 t2 sx", "by (simp del: convert_cond.simps, meson)"], ["proof (state)\nthis:\n  convert_cond t1 t2 sx\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Convert t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 9. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br i] : tn _> tm\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  convert_cond t1 t2 sx\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Cvtop t1 Convert t2 sx] : tn _> tm", "using b_e_check_single_sound_unop_testop_cvtop 11"], ["proof (prove)\nusing this:\n  convert_cond t1 t2 sx\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   (?e = Unop_i ?t ?uu \\<or> ?e = Testop ?t ?uv) \\<and> is_int_t ?t \\<or>\n   ?e = Unop_f ?t ?uw \\<and> is_float_t ?t \\<or>\n   ?e = Cvtop ?t1.0 Convert ?t ?sx \\<and> convert_cond ?t1.0 ?t ?sx \\<or>\n   ?e = Cvtop ?t1.0 Reinterpret ?t ?sx \\<and>\n   ?t1.0 \\<noteq> ?t \\<and> t_length ?t1.0 = t_length ?t \\<and> ?sx = None;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Cvtop t1 Convert t2 sx) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Cvtop t1 Convert t2 sx] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Cvtop t1 Convert t2 sx] : tn _> tm\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_if i] : tn _> tm\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_if i] : tn _> tm\nA total of 23 subgoals...", "case (12 \\<C> t1 t2 sx ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_if i] : tn _> tm\nA total of 23 subgoals...", "hence \"t1 \\<noteq> t2 \\<and>  t_length t1 = t_length t2 \\<and> sx = None\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> t2 \\<and> t_length t1 = t_length t2 \\<and> sx = None", "by (simp, presburger)"], ["proof (state)\nthis:\n  t1 \\<noteq> t2 \\<and> t_length t1 = t_length t2 \\<and> sx = None\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2\n          sx] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 8. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_if i] : tn _> tm\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  t1 \\<noteq> t2 \\<and> t_length t1 = t_length t2 \\<and> sx = None\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2 sx] : tn _> tm", "using b_e_check_single_sound_unop_testop_cvtop 12"], ["proof (prove)\nusing this:\n  t1 \\<noteq> t2 \\<and> t_length t1 = t_length t2 \\<and> sx = None\n  \\<lbrakk>check_single ?\\<C> ?e ?tn' = ?tm';\n   (?e = Unop_i ?t ?uu \\<or> ?e = Testop ?t ?uv) \\<and> is_int_t ?t \\<or>\n   ?e = Unop_f ?t ?uw \\<and> is_float_t ?t \\<or>\n   ?e = Cvtop ?t1.0 Convert ?t ?sx \\<and> convert_cond ?t1.0 ?t ?sx \\<or>\n   ?e = Cvtop ?t1.0 Reinterpret ?t ?sx \\<and>\n   ?t1.0 \\<noteq> ?t \\<and> t_length ?t1.0 = t_length ?t \\<and> ?sx = None;\n   c_types_agree ?tm' ?tm; ?tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ?tn' tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> ?tm\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2 sx] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Cvtop t1 Reinterpret t2 sx] : tn _> tm\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 5. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 10. \\<And>\\<C> is i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_table is i] : tn _> tm\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 5. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 10. \\<And>\\<C> is i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_table is i] : tn _> tm\nA total of 22 subgoals...", "case (13 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Unreachable ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Unreachable ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Unreachable] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 5. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 6. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 7. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 10. \\<And>\\<C> is i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Br_table is i] : tn _> tm\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Unreachable ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unreachable] : tn _> tm", "using b_e_typing.intros(11) c_types_agree_not_bot_exists"], ["proof (prove)\nusing this:\n  check_single \\<C> Unreachable ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ?\\<C> \\<turnstile> [Unreachable] : ?ts _> ?ts'\n  ?ts \\<noteq> Bot \\<Longrightarrow> \\<exists>ts_c. c_types_agree ?ts ts_c\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unreachable] : tn _> tm", "by blast"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Unreachable] : tn _> tm\n\ngoal (21 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 4. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 5. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 6. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 9. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Return] : tn _> tm\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 4. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 5. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 6. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 9. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Return] : tn _> tm\nA total of 21 subgoals...", "case (14 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Nop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (21 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Nop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Nop] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 4. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 5. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 6. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 9. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Return] : tn _> tm\nA total of 21 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Nop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Nop] : tn _> tm", "using b_e_typing.intros(12,35)"], ["proof (prove)\nusing this:\n  check_single \\<C> Nop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ?\\<C> \\<turnstile> [Nop] : [] _> []\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Nop] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Nop] : tn _> tm\n\ngoal (20 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 3. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 4. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 5. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 8. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Call i] : tn _> tm\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 3. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 4. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 5. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 8. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Call i] : tn _> tm\nA total of 20 subgoals...", "case (15 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Drop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (20 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 3. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 4. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 5. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 8. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n         ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Call i] : tn _> tm\nA total of 20 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Drop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "proof (cases ts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 3. \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm", "case (TopType x1)"], ["proof (state)\nthis:\n  ts = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 3. \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "proof (cases x1 rule: List.rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = TopType x1; x1 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "case Nil"], ["proof (state)\nthis:\n  x1 = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = TopType x1; x1 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "have \"\\<C> \\<turnstile> [Drop] : (tm@[T_i32] _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Drop] : tm @ [T_i32] _> tm", "using b_e_typing.intros(13,35)"], ["proof (prove)\nusing this:\n  ?\\<C> \\<turnstile> [Drop] : [?t] _> []\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Drop] : tm @ [T_i32] _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Drop] : tm @ [T_i32] _> tm\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = TopType x1; x1 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Drop] : tm @ [T_i32] _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "using c_types_agree_top1 Nil TopType"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Drop] : tm @ [T_i32] _> tm\n  c_types_agree (TopType []) ?ts\n  x1 = []\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "case (snoc ys y)"], ["proof (state)\nthis:\n  x1 = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence temp1:\"(consume (TopType (ys@[y])) [TAny]) = tm'\""], ["proof (prove)\nusing this:\n  x1 = ys @ [y]\n\ngoal (1 subgoal):\n 1. consume (TopType (ys @ [y])) [TAny] = tm'", "using 15 TopType type_update_empty"], ["proof (prove)\nusing this:\n  x1 = ys @ [y]\n  check_single \\<C> Drop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = TopType x1\n  type_update ?ts ?cons (Type []) = consume ?ts ?cons\n\ngoal (1 subgoal):\n 1. consume (TopType (ys @ [y])) [TAny] = tm'", "by (metis check_single.simps(13))"], ["proof (state)\nthis:\n  consume (TopType (ys @ [y])) [TAny] = tm'\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence temp2:\"c_types_agree (TopType ys) tm\""], ["proof (prove)\nusing this:\n  consume (TopType (ys @ [y])) [TAny] = tm'\n\ngoal (1 subgoal):\n 1. c_types_agree (TopType ys) tm", "using consume_top_geq[OF temp1] 15(2,3,4)"], ["proof (prove)\nusing this:\n  consume (TopType (ys @ [y])) [TAny] = tm'\n  \\<lbrakk>length [TAny] \\<le> length (ys @ [y]); tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as bs.\n                       ys @ [y] = as @ bs \\<and>\n                       ct_list_eq bs [TAny] \\<and> tm' = TopType as\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. c_types_agree (TopType ys) tm", "by (metis Suc_leI add_diff_cancel_right' append_eq_conv_conj consume.simps(2)\n                        ct_suffix_def length_Cons length_append list.size(3) trans_le_add2\n                        zero_less_Suc)"], ["proof (state)\nthis:\n  c_types_agree (TopType ys) tm\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "obtain t where \"ct_list_eq [y] (to_ct_list [t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        ct_list_eq [y] (to_ct_list [t]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ct_list_eq_exists"], ["proof (prove)\nusing this:\n  \\<exists>ys. ct_list_eq ?xs (to_ct_list ys)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        ct_list_eq [y] (to_ct_list [t]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding ct_list_eq_def to_ct_list_def list_all2_map2"], ["proof (prove)\nusing this:\n  \\<exists>ys. list_all2 (\\<lambda>x y. ct_eq x (TSome y)) ?xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        list_all2 (\\<lambda>x y. ct_eq x (TSome y)) [y]\n         [t] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis list_all2_Cons1 list_all2_Nil)"], ["proof (state)\nthis:\n  ct_list_eq [y] (to_ct_list [t])\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence \"c_types_agree ts (tm@[t])\""], ["proof (prove)\nusing this:\n  ct_list_eq [y] (to_ct_list [t])\n\ngoal (1 subgoal):\n 1. c_types_agree ts (tm @ [t])", "using temp2 ct_suffix_extend_ct_list_eq snoc TopType"], ["proof (prove)\nusing this:\n  ct_list_eq [y] (to_ct_list [t])\n  c_types_agree (TopType ys) tm\n  \\<lbrakk>ct_suffix ?xs ?ys; ct_list_eq ?xs' ?ys'\\<rbrakk>\n  \\<Longrightarrow> ct_suffix (?xs @ ?xs') (?ys @ ?ys')\n  x1 = ys @ [y]\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. c_types_agree ts (tm @ [t])", "by (simp add: to_ct_list_def)"], ["proof (state)\nthis:\n  c_types_agree ts (tm @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = TopType x1; x1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree ts (tm @ [t])\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "using b_e_typing.intros(13,35)"], ["proof (prove)\nusing this:\n  c_types_agree ts (tm @ [t])\n  ?\\<C> \\<turnstile> [Drop] : [?t] _> []\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm", "case (Type x2)"], ["proof (state)\nthis:\n  ts = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "proof (cases x2 rule: List.rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = Type x2; x2 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "case Nil"], ["proof (state)\nthis:\n  x2 = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = Type x2; x2 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence \"(consume (Type []) [TAny]) = tm'\""], ["proof (prove)\nusing this:\n  x2 = []\n\ngoal (1 subgoal):\n 1. consume (Type []) [TAny] = tm'", "using 15 Type type_update_empty"], ["proof (prove)\nusing this:\n  x2 = []\n  check_single \\<C> Drop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = Type x2\n  type_update ?ts ?cons (Type []) = consume ?ts ?cons\n\ngoal (1 subgoal):\n 1. consume (Type []) [TAny] = tm'", "by fastforce"], ["proof (state)\nthis:\n  consume (Type []) [TAny] = tm'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = Type x2; x2 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm\n 2. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  consume (Type []) [TAny] = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "using 15(4) ct_list_eq_def ct_suffix_def to_ct_list_def"], ["proof (prove)\nusing this:\n  consume (Type []) [TAny] = tm'\n  tm' \\<noteq> Bot\n  ct_list_eq ?ct1s ?ct2s = list_all2 ct_eq ?ct1s ?ct2s\n  ct_suffix ?xs ?ys =\n  (\\<exists>as bs. ?ys = as @ bs \\<and> ct_list_eq bs ?xs)\n  to_ct_list ?ts = map TSome ?ts\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "by simp"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "case (snoc ys y)"], ["proof (state)\nthis:\n  x2 = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence temp1:\"(consume (Type (ys@[y])) [TAny]) = tm'\""], ["proof (prove)\nusing this:\n  x2 = ys @ [y]\n\ngoal (1 subgoal):\n 1. consume (Type (ys @ [y])) [TAny] = tm'", "using 15 Type type_update_empty"], ["proof (prove)\nusing this:\n  x2 = ys @ [y]\n  check_single \\<C> Drop ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = Type x2\n  type_update ?ts ?cons (Type []) = consume ?ts ?cons\n\ngoal (1 subgoal):\n 1. consume (Type (ys @ [y])) [TAny] = tm'", "by (metis check_single.simps(13))"], ["proof (state)\nthis:\n  consume (Type (ys @ [y])) [TAny] = tm'\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence temp2:\"c_types_agree (Type ys) tm\""], ["proof (prove)\nusing this:\n  consume (Type (ys @ [y])) [TAny] = tm'\n\ngoal (1 subgoal):\n 1. c_types_agree (Type ys) tm", "using 15(2,3,4) ct_suffix_def"], ["proof (prove)\nusing this:\n  consume (Type (ys @ [y])) [TAny] = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ct_suffix ?xs ?ys =\n  (\\<exists>as bs. ?ys = as @ bs \\<and> ct_list_eq bs ?xs)\n\ngoal (1 subgoal):\n 1. c_types_agree (Type ys) tm", "by (simp, metis One_nat_def butlast_conv_take butlast_snoc c_types_agree.simps(1)\n                              length_Cons list.size(3))"], ["proof (state)\nthis:\n  c_types_agree (Type ys) tm\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "obtain t where \"ct_list_eq [TSome y] (to_ct_list [t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        ct_list_eq [TSome y] (to_ct_list [t]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ct_list_eq_exists"], ["proof (prove)\nusing this:\n  \\<exists>ys. ct_list_eq ?xs (to_ct_list ys)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        ct_list_eq [TSome y] (to_ct_list [t]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding ct_list_eq_def to_ct_list_def list_all2_map2"], ["proof (prove)\nusing this:\n  \\<exists>ys. list_all2 (\\<lambda>x y. ct_eq x (TSome y)) ?xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        list_all2 (\\<lambda>x y. ct_eq x (TSome y)) [TSome y]\n         [t] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis list_all2_Cons1 list_all2_Nil)"], ["proof (state)\nthis:\n  ct_list_eq [TSome y] (to_ct_list [t])\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "hence \"c_types_agree ts (tm@[t])\""], ["proof (prove)\nusing this:\n  ct_list_eq [TSome y] (to_ct_list [t])\n\ngoal (1 subgoal):\n 1. c_types_agree ts (tm @ [t])", "using temp2 ct_suffix_extend_ct_list_eq snoc Type"], ["proof (prove)\nusing this:\n  ct_list_eq [TSome y] (to_ct_list [t])\n  c_types_agree (Type ys) tm\n  \\<lbrakk>ct_suffix ?xs ?ys; ct_list_eq ?xs' ?ys'\\<rbrakk>\n  \\<Longrightarrow> ct_suffix (?xs @ ?xs') (?ys @ ?ys')\n  x2 = ys @ [y]\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. c_types_agree ts (tm @ [t])", "by (simp add: ct_list_eq_def to_ct_list_def)"], ["proof (state)\nthis:\n  c_types_agree ts (tm @ [t])\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ts = Type x2; x2 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Drop] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree ts (tm @ [t])\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "using b_e_typing.intros(13,35)"], ["proof (prove)\nusing this:\n  c_types_agree ts (tm @ [t])\n  ?\\<C> \\<turnstile> [Drop] : [?t] _> []\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> Drop ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Drop] : tn _> tm", "qed simp"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Drop] : tn _> tm\n\ngoal (19 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 4. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 7. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 4. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 7. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\nA total of 19 subgoals...", "case (16 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (19 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 4. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 7. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "proof (cases ts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 3. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "case (TopType x1)"], ["proof (state)\nthis:\n  ts = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 3. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "consider\n          (1) \"length x1 = 0\"\n        | (2) \"length x1 = 1\"\n        | (3) \"length x1 = 2\"\n        | (4) \"length x1 \\<ge> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = 0 \\<Longrightarrow> thesis;\n     length x1 = 1 \\<Longrightarrow> thesis;\n     length x1 = 2 \\<Longrightarrow> thesis;\n     3 \\<le> length x1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length x1 = 0 \\<Longrightarrow> ?thesis;\n   length x1 = 1 \\<Longrightarrow> ?thesis;\n   length x1 = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> length x1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 3. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length x1 = 0 \\<Longrightarrow> ?thesis;\n   length x1 = 1 \\<Longrightarrow> ?thesis;\n   length x1 = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> length x1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "case 1"], ["proof (state)\nthis:\n  length x1 = 0\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence \"tm' = TopType [TAny]\""], ["proof (prove)\nusing this:\n  length x1 = 0\n\ngoal (1 subgoal):\n 1. tm' = TopType [TAny]", "using TopType 16"], ["proof (prove)\nusing this:\n  length x1 = 0\n  ts = TopType x1\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. tm' = TopType [TAny]", "by simp"], ["proof (state)\nthis:\n  tm' = TopType [TAny]\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  tm' = TopType [TAny]", "obtain t'' tm'' where tm_def:\"tm = tm''@[t'']\""], ["proof (prove)\nusing this:\n  tm' = TopType [TAny]\n\ngoal (1 subgoal):\n 1. (\\<And>tm'' t''.\n        tm = tm'' @ [t''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 16(2) ct_suffix_def"], ["proof (prove)\nusing this:\n  tm' = TopType [TAny]\n  c_types_agree tm' tm\n  ct_suffix ?xs ?ys =\n  (\\<exists>as bs. ?ys = as @ bs \\<and> ct_list_eq bs ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>tm'' t''.\n        tm = tm'' @ [t''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp, metis Nil_is_append_conv append_butlast_last_id checker_type.inject(1)\n                          ct_prefixI ct_prefix_nil(2) produce.simps(1) produce_nil)"], ["proof (state)\nthis:\n  tm = tm'' @ [t'']\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "have \"\\<C> \\<turnstile> [Select] : ([t'',t'',T_i32] _> [t''])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Select] : [t'', t'', T_i32] _> [t'']", "using b_e_typing.intros(14)"], ["proof (prove)\nusing this:\n  ?\\<C> \\<turnstile> [Select] : [?t, ?t, T_i32] _> [?t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Select] : [t'', t'', T_i32] _> [t'']", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Select] : [t'', t'', T_i32] _> [t'']\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Select] : [t'', t'', T_i32] _> [t'']\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "using TopType 16 1 tm_def b_e_typing.intros(35) c_types_agree.simps(2) c_types_agree_top1"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> [Select] : [t'', t'', T_i32] _> [t'']\n  ts = TopType x1\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  length x1 = 0\n  tm = tm'' @ [t'']\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  c_types_agree (TopType ?ts) ?ts' = ct_suffix ?ts (to_ct_list ?ts')\n  c_types_agree (TopType []) ?ts\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "case 2"], ["proof (state)\nthis:\n  length x1 = 1\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "have \"type_update_select (TopType x1) = tm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "using 16 TopType"], ["proof (prove)\nusing this:\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "unfolding check_single.simps"], ["proof (prove)\nusing this:\n  type_update_select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "by simp"], ["proof (state)\nthis:\n  type_update_select (TopType x1) = tm'\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence x1_def:\"ct_list_eq x1 [TSome T_i32]\" \"tm' = TopType [TAny]\""], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n\ngoal (1 subgoal):\n 1. ct_list_eq x1 [TSome T_i32] &&& tm' = TopType [TAny]", "using type_update_select_length1[OF _ 2 16(4)]"], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n  type_update_select (TopType x1) = tm' \\<Longrightarrow>\n  ct_list_eq x1 [TSome T_i32]\n  type_update_select (TopType x1) = tm' \\<Longrightarrow>\n  tm' = TopType [TAny]\n\ngoal (1 subgoal):\n 1. ct_list_eq x1 [TSome T_i32] &&& tm' = TopType [TAny]", "by simp_all"], ["proof (state)\nthis:\n  ct_list_eq x1 [TSome T_i32]\n  tm' = TopType [TAny]\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  ct_list_eq x1 [TSome T_i32]\n  tm' = TopType [TAny]", "obtain t'' tm'' where tm_def:\"tm = tm''@[t'']\""], ["proof (prove)\nusing this:\n  ct_list_eq x1 [TSome T_i32]\n  tm' = TopType [TAny]\n\ngoal (1 subgoal):\n 1. (\\<And>tm'' t''.\n        tm = tm'' @ [t''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 16(2) ct_suffix_def"], ["proof (prove)\nusing this:\n  ct_list_eq x1 [TSome T_i32]\n  tm' = TopType [TAny]\n  c_types_agree tm' tm\n  ct_suffix ?xs ?ys =\n  (\\<exists>as bs. ?ys = as @ bs \\<and> ct_list_eq bs ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>tm'' t''.\n        tm = tm'' @ [t''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Nil_is_append_conv append_butlast_last_id c_types_agree.simps(2) ct_prefixI\n                    ct_prefix_nil(2) list.simps(8) to_ct_list_def)"], ["proof (state)\nthis:\n  tm = tm'' @ [t'']\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "have \"c_types_agree (TopType x1) ((tm''@[t'',t''])@[T_i32])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_types_agree (TopType x1) ((tm'' @ [t'', t'']) @ [T_i32])", "using x1_def(1)"], ["proof (prove)\nusing this:\n  ct_list_eq x1 [TSome T_i32]\n\ngoal (1 subgoal):\n 1. c_types_agree (TopType x1) ((tm'' @ [t'', t'']) @ [T_i32])", "by (metis c_types_agree_top2 list.simps(8,9) to_ct_list_def)"], ["proof (state)\nthis:\n  c_types_agree (TopType x1) ((tm'' @ [t'', t'']) @ [T_i32])\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree (TopType x1) ((tm'' @ [t'', t'']) @ [T_i32])\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "using TopType b_e_typing.intros(14,35) tm_def"], ["proof (prove)\nusing this:\n  c_types_agree (TopType x1) ((tm'' @ [t'', t'']) @ [T_i32])\n  ts = TopType x1\n  ?\\<C> \\<turnstile> [Select] : [?t, ?t, T_i32] _> [?t]\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  tm = tm'' @ [t'']\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "by auto"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "case 3"], ["proof (state)\nthis:\n  length x1 = 2\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "have \"type_update_select (TopType x1) = tm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "using 16 TopType"], ["proof (prove)\nusing this:\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "unfolding check_single.simps"], ["proof (prove)\nusing this:\n  type_update_select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "by simp"], ["proof (state)\nthis:\n  type_update_select (TopType x1) = tm'\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  type_update_select (TopType x1) = tm'", "obtain ct1 ct2 where x1_def:\"x1 = [ct1, ct2]\"\n                                         \"ct_eq ct2 (TSome T_i32)\"\n                                         \"tm' = TopType [ct1]\""], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n\ngoal (1 subgoal):\n 1. (\\<And>ct1 ct2.\n        \\<lbrakk>x1 = [ct1, ct2]; ct_eq ct2 (TSome T_i32);\n         tm' = TopType [ct1]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using type_update_select_length2[OF _ 3 16(4)]"], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n  type_update_select (TopType x1) = tm' \\<Longrightarrow>\n  \\<exists>t1 t2.\n     x1 = [t1, t2] \\<and> ct_eq t2 (TSome T_i32) \\<and> tm' = TopType [t1]\n\ngoal (1 subgoal):\n 1. (\\<And>ct1 ct2.\n        \\<lbrakk>x1 = [ct1, ct2]; ct_eq ct2 (TSome T_i32);\n         tm' = TopType [ct1]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x1 = [ct1, ct2]\n  ct_eq ct2 (TSome T_i32)\n  tm' = TopType [ct1]\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  x1 = [ct1, ct2]\n  ct_eq ct2 (TSome T_i32)\n  tm' = TopType [ct1]", "obtain t'' tm'' where tm_def:\"tm = tm''@[t'']\"\n                                          \"ct_list_eq [ct1] [(TSome t'')]\""], ["proof (prove)\nusing this:\n  x1 = [ct1, ct2]\n  ct_eq ct2 (TSome T_i32)\n  tm' = TopType [ct1]\n\ngoal (1 subgoal):\n 1. (\\<And>tm'' t''.\n        \\<lbrakk>tm = tm'' @ [t'']; ct_list_eq [ct1] [TSome t'']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 16(2) c_types_agree_imp_ct_list_eq[of \"[ct1]\" tm]"], ["proof (prove)\nusing this:\n  x1 = [ct1, ct2]\n  ct_eq ct2 (TSome T_i32)\n  tm' = TopType [ct1]\n  c_types_agree tm' tm\n  c_types_agree (TopType [ct1]) tm \\<Longrightarrow>\n  \\<exists>ts' ts''.\n     tm = ts' @ ts'' \\<and> ct_list_eq [ct1] (to_ct_list ts'')\n\ngoal (1 subgoal):\n 1. (\\<And>tm'' t''.\n        \\<lbrakk>tm = tm'' @ [t'']; ct_list_eq [ct1] [TSome t'']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Nil2 append_butlast_last_id append_eq_append_conv_if append_eq_conv_conj\n                    ct_list_eq_length diff_Suc_1 length_Cons length_butlast length_map\n                    list.simps(8,9) list.size(3) nat.distinct(2) to_ct_list_def)"], ["proof (state)\nthis:\n  tm = tm'' @ [t'']\n  ct_list_eq [ct1] [TSome t'']\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence \"ct_list_eq x1 (to_ct_list [ t'', T_i32])\""], ["proof (prove)\nusing this:\n  tm = tm'' @ [t'']\n  ct_list_eq [ct1] [TSome t'']\n\ngoal (1 subgoal):\n 1. ct_list_eq x1 (to_ct_list [t'', T_i32])", "using x1_def(1,2)"], ["proof (prove)\nusing this:\n  tm = tm'' @ [t'']\n  ct_list_eq [ct1] [TSome t'']\n  x1 = [ct1, ct2]\n  ct_eq ct2 (TSome T_i32)\n\ngoal (1 subgoal):\n 1. ct_list_eq x1 (to_ct_list [t'', T_i32])", "unfolding ct_list_eq_def to_ct_list_def"], ["proof (prove)\nusing this:\n  tm = tm'' @ [t'']\n  list_all2 ct_eq [ct1] [TSome t'']\n  x1 = [ct1, ct2]\n  ct_eq ct2 (TSome T_i32)\n\ngoal (1 subgoal):\n 1. list_all2 ct_eq x1 (map TSome [t'', T_i32])", "by fastforce"], ["proof (state)\nthis:\n  ct_list_eq x1 (to_ct_list [t'', T_i32])\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence \"c_types_agree (TopType x1) ((tm''@[t''])@[t'',T_i32])\""], ["proof (prove)\nusing this:\n  ct_list_eq x1 (to_ct_list [t'', T_i32])\n\ngoal (1 subgoal):\n 1. c_types_agree (TopType x1) ((tm'' @ [t'']) @ [t'', T_i32])", "using c_types_agree_top2"], ["proof (prove)\nusing this:\n  ct_list_eq x1 (to_ct_list [t'', T_i32])\n  ct_list_eq ?ts (to_ct_list ?ts'') \\<Longrightarrow>\n  c_types_agree (TopType ?ts) (?ts' @ ?ts'')\n\ngoal (1 subgoal):\n 1. c_types_agree (TopType x1) ((tm'' @ [t'']) @ [t'', T_i32])", "by blast"], ["proof (state)\nthis:\n  c_types_agree (TopType x1) ((tm'' @ [t'']) @ [t'', T_i32])\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree (TopType x1) ((tm'' @ [t'']) @ [t'', T_i32])\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "using TopType b_e_typing.intros(14,35) tm_def"], ["proof (prove)\nusing this:\n  c_types_agree (TopType x1) ((tm'' @ [t'']) @ [t'', T_i32])\n  ts = TopType x1\n  ?\\<C> \\<turnstile> [Select] : [?t, ?t, T_i32] _> [?t]\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  tm = tm'' @ [t'']\n  ct_list_eq [ct1] [TSome t'']\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "by auto"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "case 4"], ["proof (state)\nthis:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  3 \\<le> length x1", "obtain nat where nat_def:\"length x1 = Suc (Suc (Suc nat))\""], ["proof (prove)\nusing this:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. (\\<And>nat.\n        length x1 = Suc (Suc (Suc nat)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis add_eq_if diff_Suc_1 le_Suc_ex numeral_3_eq_3 nat.distinct(2))"], ["proof (state)\nthis:\n  length x1 = Suc (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence tm'_def:\"type_update_select (TopType x1) = tm'\""], ["proof (prove)\nusing this:\n  length x1 = Suc (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "using 16 TopType"], ["proof (prove)\nusing this:\n  length x1 = Suc (Suc (Suc nat))\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = TopType x1\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) = tm'", "by simp"], ["proof (state)\nthis:\n  type_update_select (TopType x1) = tm'\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  type_update_select (TopType x1) = tm'", "obtain tm_int where \"(select_return_top x1\n                                    (x1 ! (length x1 - 2))\n                                    (x1 ! (length x1 - 3))) = tm_int\"\n                                 \"tm_int \\<noteq> Bot\""], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n\ngoal (1 subgoal):\n 1. (\\<And>tm_int.\n        \\<lbrakk>select_return_top x1 (x1 ! (length x1 - 2))\n                  (x1 ! (length x1 - 3)) =\n                 tm_int;\n         tm_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nat_def 16(4)"], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n  length x1 = Suc (Suc (Suc nat))\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>tm_int.\n        \\<lbrakk>select_return_top x1 (x1 ! (length x1 - 2))\n                  (x1 ! (length x1 - 3)) =\n                 tm_int;\n         tm_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding type_update_select.simps"], ["proof (prove)\nusing this:\n  (case length x1 of 0 \\<Rightarrow> TopType [TAny]\n   | Suc 0 \\<Rightarrow>\n       type_update (TopType x1) [TSome T_i32] (TopType [TAny])\n   | Suc (Suc 0) \\<Rightarrow> consume (TopType x1) [TSome T_i32]\n   | Suc (Suc (Suc nat)) \\<Rightarrow>\n       type_update (TopType x1) [TAny, TAny, TSome T_i32]\n        (select_return_top x1 (x1 ! (length x1 - 2))\n          (x1 ! (length x1 - 3)))) =\n  tm'\n  length x1 = Suc (Suc (Suc nat))\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>tm_int.\n        \\<lbrakk>select_return_top x1 (x1 ! (length x1 - 2))\n                  (x1 ! (length x1 - 3)) =\n                 tm_int;\n         tm_int \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  tm_int\n  tm_int \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  tm_int\n  tm_int \\<noteq> Bot", "obtain x2 where x2_def:\"(select_return_top x1\n                                       (x1 ! (length x1 - 2))\n                                       (x1 ! (length x1 - 3))) = TopType x2\""], ["proof (prove)\nusing this:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  tm_int\n  tm_int \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n        TopType x2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using select_return_top_exists"], ["proof (prove)\nusing this:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  tm_int\n  tm_int \\<noteq> Bot\n  \\<lbrakk>select_return_top ?cts ?c1.0 ?c2.0 = ?ctm;\n   ?ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. ?ctm = TopType xs\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n        TopType x2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType x2\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "have \"ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or> ct_suffix [TAny, TAny, TSome T_i32] x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n    ct_suffix [TAny, TAny, TSome T_i32] x1", "using tm'_def nat_def 16(4)"], ["proof (prove)\nusing this:\n  type_update_select (TopType x1) = tm'\n  length x1 = Suc (Suc (Suc nat))\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n    ct_suffix [TAny, TAny, TSome T_i32] x1", "by (simp, metis (full_types) produce.simps(6))"], ["proof (state)\nthis:\n  ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  ct_suffix [TAny, TAny, TSome T_i32] x1\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence tm'_eq:\"tm' = TopType x2\""], ["proof (prove)\nusing this:\n  ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  ct_suffix [TAny, TAny, TSome T_i32] x1\n\ngoal (1 subgoal):\n 1. tm' = TopType x2", "using tm'_def nat_def 16(4) x2_def"], ["proof (prove)\nusing this:\n  ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  ct_suffix [TAny, TAny, TSome T_i32] x1\n  type_update_select (TopType x1) = tm'\n  length x1 = Suc (Suc (Suc nat))\n  tm' \\<noteq> Bot\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType x2\n\ngoal (1 subgoal):\n 1. tm' = TopType x2", "by force"], ["proof (state)\nthis:\n  tm' = TopType x2\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  tm' = TopType x2", "obtain cts' ct1 ct2 ct3 where cts'_def:\"x1 = cts'@[ct1, ct2, ct3]\"\n                                                    \"ct_eq ct3 (TSome T_i32)\""], ["proof (prove)\nusing this:\n  tm' = TopType x2\n\ngoal (1 subgoal):\n 1. (\\<And>cts' ct1 ct2 ct3.\n        \\<lbrakk>x1 = cts' @ [ct1, ct2, ct3];\n         ct_eq ct3 (TSome T_i32)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using type_update_select_length3 tm'_def 4"], ["proof (prove)\nusing this:\n  tm' = TopType x2\n  \\<lbrakk>type_update_select (TopType ?cts) = TopType ?ctm;\n   3 \\<le> length ?cts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cts' ct1 ct2 ct3.\n                       ?cts = cts' @ [ct1, ct2, ct3] \\<and>\n                       ct_eq ct3 (TSome T_i32)\n  type_update_select (TopType x1) = tm'\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. (\\<And>cts' ct1 ct2 ct3.\n        \\<lbrakk>x1 = cts' @ [ct1, ct2, ct3];\n         ct_eq ct3 (TSome T_i32)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)", "obtain c' cm' where tm_def:\"tm = cm'@[c']\"\n                                        \"ct_suffix cts' (to_ct_list cm')\"\n                                        \"ct_eq (x1 ! (length x1 - 2)) (TSome c')\"\n                                        \"ct_eq (x1 ! (length x1 - 3)) (TSome c')\""], ["proof (prove)\nusing this:\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)\n\ngoal (1 subgoal):\n 1. (\\<And>cm' c'.\n        \\<lbrakk>tm = cm' @ [c']; ct_suffix cts' (to_ct_list cm');\n         ct_eq (x1 ! (length x1 - 2)) (TSome c');\n         ct_eq (x1 ! (length x1 - 3)) (TSome c')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using select_return_top_ct_eq[OF x2_def 4] tm'_eq 4 16(2)"], ["proof (prove)\nusing this:\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)\n  c_types_agree (TopType x2) ?cm \\<Longrightarrow>\n  \\<exists>c' cm'.\n     ?cm = cm' @ [c'] \\<and>\n     ct_suffix (take (length x1 - 3) x1) (to_ct_list cm') \\<and>\n     ct_eq (x1 ! (length x1 - 2)) (TSome c') \\<and>\n     ct_eq (x1 ! (length x1 - 3)) (TSome c')\n  tm' = TopType x2\n  3 \\<le> length x1\n  c_types_agree tm' tm\n\ngoal (1 subgoal):\n 1. (\\<And>cm' c'.\n        \\<lbrakk>tm = cm' @ [c']; ct_suffix cts' (to_ct_list cm');\n         ct_eq (x1 ! (length x1 - 2)) (TSome c');\n         ct_eq (x1 ! (length x1 - 3)) (TSome c')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  tm = cm' @ [c']\n  ct_suffix cts' (to_ct_list cm')\n  ct_eq (x1 ! (length x1 - 2)) (TSome c')\n  ct_eq (x1 ! (length x1 - 3)) (TSome c')\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  tm = cm' @ [c']\n  ct_suffix cts' (to_ct_list cm')\n  ct_eq (x1 ! (length x1 - 2)) (TSome c')\n  ct_eq (x1 ! (length x1 - 3)) (TSome c')", "obtain as bs where cm'_def:\"cm' = as@bs\"\n                                        \"ct_list_eq (to_ct_list bs) cts'\""], ["proof (prove)\nusing this:\n  tm = cm' @ [c']\n  ct_suffix cts' (to_ct_list cm')\n  ct_eq (x1 ! (length x1 - 2)) (TSome c')\n  ct_eq (x1 ! (length x1 - 3)) (TSome c')\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>cm' = as @ bs; ct_list_eq (to_ct_list bs) cts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ct_list_eq_cons_ct_list1 ct_list_eq_ts_conv_eq"], ["proof (prove)\nusing this:\n  tm = cm' @ [c']\n  ct_suffix cts' (to_ct_list cm')\n  ct_eq (x1 ! (length x1 - 2)) (TSome c')\n  ct_eq (x1 ! (length x1 - 3)) (TSome c')\n  ct_list_eq (to_ct_list ?as) (?xs @ to_ct_list ?ys) \\<Longrightarrow>\n  \\<exists>bs. ?as = bs @ ?ys \\<and> ct_list_eq (to_ct_list bs) ?xs\n  ct_list_eq (to_ct_list ?ts) (to_ct_list ?ts') = (?ts = ?ts')\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>cm' = as @ bs; ct_list_eq (to_ct_list bs) cts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ct_suffix_def to_ct_list_append(2))"], ["proof (state)\nthis:\n  cm' = as @ bs\n  ct_list_eq (to_ct_list bs) cts'\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence \"ct_eq ct1 (TSome c')\"\n              \"ct_eq ct2 (TSome c')\""], ["proof (prove)\nusing this:\n  cm' = as @ bs\n  ct_list_eq (to_ct_list bs) cts'\n\ngoal (1 subgoal):\n 1. ct_eq ct1 (TSome c') &&& ct_eq ct2 (TSome c')", "using cts'_def tm_def"], ["proof (prove)\nusing this:\n  cm' = as @ bs\n  ct_list_eq (to_ct_list bs) cts'\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)\n  tm = cm' @ [c']\n  ct_suffix cts' (to_ct_list cm')\n  ct_eq (x1 ! (length x1 - 2)) (TSome c')\n  ct_eq (x1 ! (length x1 - 3)) (TSome c')\n\ngoal (1 subgoal):\n 1. ct_eq ct1 (TSome c') &&& ct_eq ct2 (TSome c')", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cm' = as @ bs; ct_list_eq (to_ct_list bs) cts';\n     x1 = cts' @ [ct1, ct2, ct3]; ct_eq ct3 (TSome T_i32);\n     tm = as @ bs @ [c']; ct_suffix cts' (to_ct_list (as @ bs));\n     ct_eq ((cts' @ [ct1, ct2, ct3]) ! Suc (length cts')) (TSome c');\n     ct_eq ct1 (TSome c')\\<rbrakk>\n    \\<Longrightarrow> ct_eq ct2 (TSome c')", "apply (metis append.assoc append_Cons append_Nil length_append_singleton nth_append_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ct_eq ct1 (TSome c')\n  ct_eq ct2 (TSome c')\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "hence \"c_types_agree ts (cm'@[c',c',T_i32])\""], ["proof (prove)\nusing this:\n  ct_eq ct1 (TSome c')\n  ct_eq ct2 (TSome c')\n\ngoal (1 subgoal):\n 1. c_types_agree ts (cm' @ [c', c', T_i32])", "using c_types_agree_top2[of _ _ as] cm'_def(1) TopType\n                ct_list_eq_concat[OF ct_list_eq_commute[OF cm'_def(2)]] cts'_def"], ["proof (prove)\nusing this:\n  ct_eq ct1 (TSome c')\n  ct_eq ct2 (TSome c')\n  ct_list_eq ?ts (to_ct_list ?ts'') \\<Longrightarrow>\n  c_types_agree (TopType ?ts) (as @ ?ts'')\n  cm' = as @ bs\n  ts = TopType x1\n  ct_list_eq ?xs' ?ys' \\<Longrightarrow>\n  ct_list_eq (cts' @ ?xs') (to_ct_list bs @ ?ys')\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)\n\ngoal (1 subgoal):\n 1. c_types_agree ts (cm' @ [c', c', T_i32])", "unfolding to_ct_list_def ct_list_eq_def"], ["proof (prove)\nusing this:\n  ct_eq ct1 (TSome c')\n  ct_eq ct2 (TSome c')\n  list_all2 ct_eq ?ts (map TSome ?ts'') \\<Longrightarrow>\n  c_types_agree (TopType ?ts) (as @ ?ts'')\n  cm' = as @ bs\n  ts = TopType x1\n  list_all2 ct_eq ?xs' ?ys' \\<Longrightarrow>\n  list_all2 ct_eq (cts' @ ?xs') (map TSome bs @ ?ys')\n  x1 = cts' @ [ct1, ct2, ct3]\n  ct_eq ct3 (TSome T_i32)\n\ngoal (1 subgoal):\n 1. c_types_agree ts (cm' @ [c', c', T_i32])", "by fastforce"], ["proof (state)\nthis:\n  c_types_agree ts (cm' @ [c', c', T_i32])\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree ts (cm' @ [c', c', T_i32])\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "using b_e_typing.intros(14,35) tm_def"], ["proof (prove)\nusing this:\n  c_types_agree ts (cm' @ [c', c', T_i32])\n  ?\\<C> \\<turnstile> [Select] : [?t, ?t, T_i32] _> [?t]\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  tm = cm' @ [c']\n  ct_suffix cts' (to_ct_list cm')\n  ct_eq (x1 ! (length x1 - 2)) (TSome c')\n  ct_eq (x1 ! (length x1 - 3)) (TSome c')\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "by auto"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "(* TODO: refactor *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "case (Type x2)"], ["proof (state)\nthis:\n  ts = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "hence x2_cond:\"(length x2 \\<ge> 3 \\<and> (x2!(length x2-2)) = (x2!(length x2-3)))\""], ["proof (prove)\nusing this:\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)", "using 16"], ["proof (prove)\nusing this:\n  ts = Type x2\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)", "by (simp, meson)"], ["proof (state)\nthis:\n  3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "hence tm'_def:\"consume (Type x2) [TAny, TSome T_i32] = tm'\""], ["proof (prove)\nusing this:\n  3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)\n\ngoal (1 subgoal):\n 1. consume (Type x2) [TAny, TSome T_i32] = tm'", "using 16 Type"], ["proof (prove)\nusing this:\n  3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)\n  check_single \\<C> Select ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n  ts = Type x2\n\ngoal (1 subgoal):\n 1. consume (Type x2) [TAny, TSome T_i32] = tm'", "by simp"], ["proof (state)\nthis:\n  consume (Type x2) [TAny, TSome T_i32] = tm'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "obtain ts' ts'' where cts_def:\"x2 = ts'@ ts''\" \"length ts'' = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>x2 = ts' @ ts''; length ts'' = 3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using x2_cond"], ["proof (prove)\nusing this:\n  3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)\n\ngoal (1 subgoal):\n 1. (\\<And>ts' ts''.\n        \\<lbrakk>x2 = ts' @ ts''; length ts'' = 3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_take_drop_id diff_diff_cancel length_drop)"], ["proof (state)\nthis:\n  x2 = ts' @ ts''\n  length ts'' = 3\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  x2 = ts' @ ts''\n  length ts'' = 3", "obtain t1 ts''2 where \"ts'' = t1#ts''2\" \"length ts''2 = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  x2 = ts' @ ts''\n  length ts'' = 3\n\ngoal (1 subgoal):\n 1. (\\<And>t1 ts''2.\n        \\<lbrakk>ts'' = t1 # ts''2; length ts''2 = Suc (Suc 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using List.length_Suc_conv[of ts' \"Suc (Suc 0)\"]"], ["proof (prove)\nusing this:\n  x2 = ts' @ ts''\n  length ts'' = 3\n  (length ts' = Suc (Suc (Suc 0))) =\n  (\\<exists>y ys. ts' = y # ys \\<and> length ys = Suc (Suc 0))\n\ngoal (1 subgoal):\n 1. (\\<And>t1 ts''2.\n        \\<lbrakk>ts'' = t1 # ts''2; length ts''2 = Suc (Suc 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv numeral_3_eq_3)"], ["proof (state)\nthis:\n  ts'' = t1 # ts''2\n  length ts''2 = Suc (Suc 0)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  ts'' = t1 # ts''2\n  length ts''2 = Suc (Suc 0)", "obtain t2 t3 where \"ts'' = [t1,t2,t3]\""], ["proof (prove)\nusing this:\n  ts'' = t1 # ts''2\n  length ts''2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t2 t3.\n        ts'' = [t1, t2, t3] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using List.length_Suc_conv[of ts''2 \"Suc 0\"]"], ["proof (prove)\nusing this:\n  ts'' = t1 # ts''2\n  length ts''2 = Suc (Suc 0)\n  (length ts''2 = Suc (Suc 0)) =\n  (\\<exists>y ys. ts''2 = y # ys \\<and> length ys = Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t2 t3.\n        ts'' = [t1, t2, t3] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  ts'' = [t1, t2, t3]\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "hence cts_def2:\"x2 = ts'@ [t1,t2,t3]\""], ["proof (prove)\nusing this:\n  ts'' = [t1, t2, t3]\n\ngoal (1 subgoal):\n 1. x2 = ts' @ [t1, t2, t3]", "using cts_def"], ["proof (prove)\nusing this:\n  ts'' = [t1, t2, t3]\n  x2 = ts' @ ts''\n  length ts'' = 3\n\ngoal (1 subgoal):\n 1. x2 = ts' @ [t1, t2, t3]", "by simp"], ["proof (state)\nthis:\n  x2 = ts' @ [t1, t2, t3]\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "have ts'_suffix:\"ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))", "using tm'_def 16(4)"], ["proof (prove)\nusing this:\n  consume (Type x2) [TAny, TSome T_i32] = tm'\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))", "by (simp, metis cts_def2)"], ["proof (state)\nthis:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "hence tm'_def:\"tm' = Type (ts'@[t1])\""], ["proof (prove)\nusing this:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))\n\ngoal (1 subgoal):\n 1. tm' = Type (ts' @ [t1])", "using tm'_def 16(4) cts_def2"], ["proof (prove)\nusing this:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))\n  consume (Type x2) [TAny, TSome T_i32] = tm'\n  tm' \\<noteq> Bot\n  x2 = ts' @ [t1, t2, t3]\n\ngoal (1 subgoal):\n 1. tm' = Type (ts' @ [t1])", "by simp"], ["proof (state)\nthis:\n  tm' = Type (ts' @ [t1])\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "obtain as bs where \"(to_ct_list (ts' @ [t1])) @ (to_ct_list ([t2, t3])) = as@bs\"\n                         \"ct_list_eq bs [TAny, TSome T_i32]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>to_ct_list (ts' @ [t1]) @ to_ct_list [t2, t3] = as @ bs;\n         ct_list_eq bs [TAny, TSome T_i32]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ts'_suffix"], ["proof (prove)\nusing this:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list (ts' @ [t1, t2, t3]))\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>to_ct_list (ts' @ [t1]) @ to_ct_list [t2, t3] = as @ bs;\n         ct_list_eq bs [TAny, TSome T_i32]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ct_suffix_def to_ct_list_def"], ["proof (prove)\nusing this:\n  \\<exists>as bs.\n     map TSome (ts' @ [t1, t2, t3]) = as @ bs \\<and>\n     ct_list_eq bs [TAny, TSome T_i32]\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        \\<lbrakk>map TSome (ts' @ [t1]) @ map TSome [t2, t3] = as @ bs;\n         ct_list_eq bs [TAny, TSome T_i32]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  to_ct_list (ts' @ [t1]) @ to_ct_list [t2, t3] = as @ bs\n  ct_list_eq bs [TAny, TSome T_i32]\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "hence \"t3 = T_i32\""], ["proof (prove)\nusing this:\n  to_ct_list (ts' @ [t1]) @ to_ct_list [t2, t3] = as @ bs\n  ct_list_eq bs [TAny, TSome T_i32]\n\ngoal (1 subgoal):\n 1. t3 = T_i32", "unfolding to_ct_list_def ct_list_eq_def"], ["proof (prove)\nusing this:\n  map TSome (ts' @ [t1]) @ map TSome [t2, t3] = as @ bs\n  list_all2 ct_eq bs [TAny, TSome T_i32]\n\ngoal (1 subgoal):\n 1. t3 = T_i32", "by (metis (no_types, lifting) Nil_is_map_conv append_eq_append_conv ct_eq.simps(1)\n                  length_Cons list.sel(1,3) list.simps(9) list_all2_Cons2 list_all2_lengthD)"], ["proof (state)\nthis:\n  t3 = T_i32\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  t3 = T_i32\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "have \"t1 = t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 = t2", "using x2_cond cts_def2"], ["proof (prove)\nusing this:\n  3 \\<le> length x2 \\<and> x2 ! (length x2 - 2) = x2 ! (length x2 - 3)\n  x2 = ts' @ [t1, t2, t3]\n\ngoal (1 subgoal):\n 1. t1 = t2", "by (simp, metis append.left_neutral append_Cons append_assoc length_append_singleton\n                        nth_append_length)"], ["proof (state)\nthis:\n  t1 = t2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  t3 = T_i32\n  t1 = t2", "have \"c_types_agree (Type x2) ((ts'@[t1,t1])@[T_i32])\""], ["proof (prove)\nusing this:\n  t3 = T_i32\n  t1 = t2\n\ngoal (1 subgoal):\n 1. c_types_agree (Type x2) ((ts' @ [t1, t1]) @ [T_i32])", "using cts_def2"], ["proof (prove)\nusing this:\n  t3 = T_i32\n  t1 = t2\n  x2 = ts' @ [t1, t2, t3]\n\ngoal (1 subgoal):\n 1. c_types_agree (Type x2) ((ts' @ [t1, t1]) @ [T_i32])", "by simp"], ["proof (state)\nthis:\n  c_types_agree (Type x2) ((ts' @ [t1, t1]) @ [T_i32])\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Select] : tn _> tm\n 2. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree (Type x2) ((ts' @ [t1, t1]) @ [T_i32])\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "using b_e_typing.intros(14,35) Type tm'_def 16(2)"], ["proof (prove)\nusing this:\n  c_types_agree (Type x2) ((ts' @ [t1, t1]) @ [T_i32])\n  ?\\<C> \\<turnstile> [Select] : [?t, ?t, T_i32] _> [?t]\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n  ts = Type x2\n  tm' = Type (ts' @ [t1])\n  c_types_agree tm' tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> Select ts = tm'; c_types_agree tm' tm;\n     ts \\<noteq> Bot; tm' \\<noteq> Bot; ts = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn.\n                         c_types_agree ts tn \\<and>\n                         \\<C> \\<turnstile> [Select] : tn _> tm", "qed simp"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Select] : tn _> tm\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "case (17 \\<C> tn'' tm'' es ts)"], ["proof (state)\nthis:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es : tn'' _> tm''\n  check_single \\<C> (Block (tn'' _> tm'') es) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "hence \"type_update ts (to_ct_list tn'') (Type tm'') = tm'\""], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es : tn'' _> tm''\n  check_single \\<C> (Block (tn'' _> tm'') es) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list tn'') (Type tm'') = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "have \"(b_e_type_checker (\\<C>\\<lparr>label := ([tm''] @ (label \\<C>))\\<rparr>) es (tn'' _> tm''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n     (tn'' _> tm'')", "using 17"], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es : tn'' _> tm''\n  check_single \\<C> (Block (tn'' _> tm'') es) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n     (tn'' _> tm'')", "by (simp, meson)"], ["proof (state)\nthis:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'')\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "hence \"\\<C> \\<turnstile> [Block (tn'' _> tm'') es] : (tn'' _> tm'')\""], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'')\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn'' _> tm''", "using b_e_typing.intros(15)[OF _ 17(1)]"], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'')\n  \\<lbrakk>?tf = tn'' _> tm'';\n   b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es\n    (tn'' _> tm'')\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Block ?tf es] : tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn'' _> tm''", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn'' _> tm''\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Block (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Block (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 3. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 6. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_local i] : tn _> tm\nA total of 18 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn'' _> tm''", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 17(4,5,3)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn'' _> tm''\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn _> tm", "by blast"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Block (tn'' _> tm'') es] : tn _> tm\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "case (18 \\<C> tn'' tm'' es ts)"], ["proof (state)\nthis:\n  b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tn''] @ label \\<C>\\<rparr> \\<turnstile> es : tn'' _> tm''\n  check_single \\<C> (Loop (tn'' _> tm'') es) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "hence \"type_update ts (to_ct_list tn'') (Type tm'') = tm'\""], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tn''] @ label \\<C>\\<rparr> \\<turnstile> es : tn'' _> tm''\n  check_single \\<C> (Loop (tn'' _> tm'') es) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list tn'') (Type tm'') = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "have \"(b_e_type_checker (\\<C>\\<lparr>label := ([tn''] @ (label \\<C>))\\<rparr>) es (tn'' _> tm''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n     (tn'' _> tm'')", "using 18"], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tn''] @ label \\<C>\\<rparr> \\<turnstile> es : tn'' _> tm''\n  check_single \\<C> (Loop (tn'' _> tm'') es) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n     (tn'' _> tm'')", "by (simp, meson)"], ["proof (state)\nthis:\n  b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'')\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "hence \"\\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : (tn'' _> tm'')\""], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'')\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn'' _> tm''", "using b_e_typing.intros(16)[OF _ 18(1)]"], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n   (tn'' _> tm'')\n  \\<lbrakk>?tf = tn'' _> tm'';\n   b_e_type_checker (\\<C>\\<lparr>label := [tn''] @ label \\<C>\\<rparr>) es\n    (tn'' _> tm'')\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Loop ?tf es] : tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn'' _> tm''", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn'' _> tm''\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tn] @ label \\<C>\\<rparr>) es\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tn] @\n                          label \\<C>\\<rparr> \\<turnstile> es : tn _> tm;\n        check_single \\<C> (Loop (tn _> tm) es) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [Loop (tn _> tm)\n          es] : tna _> tma\n 2. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 5. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_local i] : tn _> tm\nA total of 17 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn'' _> tm''", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 18(4,5,3)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn'' _> tm''\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn _> tm", "by blast"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Loop (tn'' _> tm'') es] : tn _> tm\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "case (19 \\<C> tn'' tm'' es1 es2 ts)"], ["proof (state)\nthis:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn'' _> tm''\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn'' _> tm''\n  check_single \\<C> (b_e.If (tn'' _> tm'') es1 es2) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "hence \"type_update ts (to_ct_list (tn''@[T_i32])) (Type tm'') = tm'\""], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn'' _> tm''\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn'' _> tm''\n  check_single \\<C> (b_e.If (tn'' _> tm'') es1 es2) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "have \"(b_e_type_checker (\\<C>\\<lparr>label := ([tm''] @ (label \\<C>))\\<rparr>) es1 (tn'' _> tm''))\"\n         \"(b_e_type_checker (\\<C>\\<lparr>label := ([tm''] @ (label \\<C>))\\<rparr>) es2 (tn'' _> tm''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n     (tn'' _> tm'') &&&\n    b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n     (tn'' _> tm'')", "using 19"], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es1 : tn'' _> tm''\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n   (tn'' _> tm'') \\<Longrightarrow>\n  \\<C>\n  \\<lparr>label :=\n            [tm''] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn'' _> tm''\n  check_single \\<C> (b_e.If (tn'' _> tm'') es1 es2) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n     (tn'' _> tm'') &&&\n    b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n     (tn'' _> tm'')", "by (simp, meson)+"], ["proof (state)\nthis:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n   (tn'' _> tm'')\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n   (tn'' _> tm'')\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "hence \"\\<C> \\<turnstile> [If (tn'' _> tm'') es1 es2] : (tn''@[T_i32] _> tm'')\""], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n   (tn'' _> tm'')\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n   (tn'' _> tm'')\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1\n                        es2] : tn'' @ [T_i32] _> tm''", "using b_e_typing.intros(17)[OF _ 19(1,2)]"], ["proof (prove)\nusing this:\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n   (tn'' _> tm'')\n  b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n   (tn'' _> tm'')\n  \\<lbrakk>?tf = tn'' _> tm'';\n   b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es1\n    (tn'' _> tm'');\n   b_e_type_checker (\\<C>\\<lparr>label := [tm''] @ label \\<C>\\<rparr>) es2\n    (tn'' _> tm'')\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [b_e.If ?tf es1\n  es2] : tn'' @ [T_i32] _> tm''\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1\n                        es2] : tn'' @ [T_i32] _> tm''", "by blast"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn'' @ [T_i32] _> tm''\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts tm' tma.\n       \\<lbrakk>b_e_type_checker\n                 (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>) es1\n                 (tn _> tm) \\<Longrightarrow>\n                \\<C>\n                \\<lparr>label :=\n                          [tm] @\n                          label \\<C>\\<rparr> \\<turnstile> es1 : tn _> tm;\n        b_e_type_checker (\\<C>\\<lparr>label := [tm] @ label \\<C>\\<rparr>)\n         es2 (tn _> tm) \\<Longrightarrow>\n        \\<C>\n        \\<lparr>label :=\n                  [tm] @ label \\<C>\\<rparr> \\<turnstile> es2 : tn _> tm;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ts = tm';\n        c_types_agree tm' tma; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tna.\n                            c_types_agree ts tna \\<and>\n                            \\<C> \\<turnstile> [b_e.If (tn _> tm) es1\n          es2] : tna _> tma\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 4. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Tee_local i] : tn _> tm\nA total of 16 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n  \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn'' @ [T_i32] _> tm''", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n  \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn'' @ [T_i32] _> tm''\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 19(5,6,4)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n  \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn'' @ [T_i32] _> tm''\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn _> tm", "by blast"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [b_e.If (tn'' _> tm'') es1 es2] : tn _> tm\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 3. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_global i] : tn _> tm\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 3. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_global i] : tn _> tm\nA total of 15 subgoals...", "case (20 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Br i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 3. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_global i] : tn _> tm\nA total of 15 subgoals...", "hence \"type_update ts (to_ct_list ((label \\<C>)!i)) (TopType []) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Br i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (label \\<C> ! i)) (TopType []) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (label \\<C> ! i)) (TopType []) = tm'\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 3. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_global i] : tn _> tm\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (label \\<C> ! i)) (TopType []) = tm'\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 3. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_global i] : tn _> tm\nA total of 15 subgoals...", "have \"i < length (label \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (label \\<C>)", "using 20"], ["proof (prove)\nusing this:\n  check_single \\<C> (Br i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (label \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (label \\<C>)\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 3. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Get_global i] : tn _> tm\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list (label \\<C> ! i)) (TopType []) = tm'\n  i < length (label \\<C>)", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (label \\<C> ! i)) (TopType []) = tm'\n  i < length (label \\<C>)\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br i] : tn _> tm", "using b_e_check_single_top_not_bot_sound[OF _ 20(3,4)]\n            b_e_typing.intros(18)\n            b_e_typing.intros(35)"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (label \\<C> ! i)) (TopType []) = tm'\n  i < length (label \\<C>)\n  type_update ts (to_ct_list ?t_in) (TopType []) = tm' \\<Longrightarrow>\n  \\<exists>tn. c_types_agree ts tn \\<and> suffix ?t_in tn\n  \\<lbrakk>?i < length (label ?\\<C>); label ?\\<C> ! ?i = ?ts\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Br ?i] : ?t1s @ ?ts _> ?t2s\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br i] : tn _> tm", "by (metis suffix_def)"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br i] : tn _> tm\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "case (21 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Br_if i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "hence \"type_update ts (to_ct_list ((label \\<C>)!i @ [T_i32])) (Type ((label \\<C>)!i)) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Br_if i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (label \\<C> ! i @ [T_i32]))\n     (Type (label \\<C> ! i)) =\n    tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (label \\<C> ! i @ [T_i32]))\n   (Type (label \\<C> ! i)) =\n  tm'\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (label \\<C> ! i @ [T_i32]))\n   (Type (label \\<C> ! i)) =\n  tm'\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "have \"i < length (label \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (label \\<C>)", "using 21"], ["proof (prove)\nusing this:\n  check_single \\<C> (Br_if i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (label \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (label \\<C>)\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "hence \"\\<C> \\<turnstile> [Br_if i] : ((label \\<C>)!i @ [T_i32] _> (label \\<C>)!i)\""], ["proof (prove)\nusing this:\n  i < length (label \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Br_if i] : label \\<C> ! i @ [T_i32] _> label \\<C> ! i", "using b_e_typing.intros(19)"], ["proof (prove)\nusing this:\n  i < length (label \\<C>)\n  \\<lbrakk>?i < length (label ?\\<C>); label ?\\<C> ! ?i = ?ts\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Br_if ?i] : ?ts @ [T_i32] _> ?ts\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Br_if i] : label \\<C> ! i @ [T_i32] _> label \\<C> ! i", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Br_if i] : label \\<C> ! i @ [T_i32] _> label \\<C> ! i\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_if i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_if i] : tn _> tm\n 2. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 10. \\<And>\\<C> i ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Set_global i] : tn _> tm\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list (label \\<C> ! i @ [T_i32]))\n   (Type (label \\<C> ! i)) =\n  tm'\n  \\<C> \\<turnstile> [Br_if i] : label \\<C> ! i @ [T_i32] _> label \\<C> ! i", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (label \\<C> ! i @ [T_i32]))\n   (Type (label \\<C> ! i)) =\n  tm'\n  \\<C> \\<turnstile> [Br_if i] : label \\<C> ! i @ [T_i32] _> label \\<C> ! i\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br_if i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 21(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (label \\<C> ! i @ [T_i32]))\n   (Type (label \\<C> ! i)) =\n  tm'\n  \\<C> \\<turnstile> [Br_if i] : label \\<C> ! i @ [T_i32] _> label \\<C> ! i\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br_if i] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br_if i] : tn _> tm\n\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 10. \\<And>\\<C> t tp_sx a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Load t tp_sx a\n           off] : tn _> tm\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 10. \\<And>\\<C> t tp_sx a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Load t tp_sx a\n           off] : tn _> tm\nA total of 13 subgoals...", "case (22 \\<C> \"is\" i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Br_table is i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 10. \\<And>\\<C> t tp_sx a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Load t tp_sx a\n           off] : tn _> tm\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_single \\<C> (Br_table is i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot", "obtain tls where tls_def:\"(same_lab (is@[i]) (label \\<C>)) = Some tls\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Br_table is i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>tls.\n        same_lab (is @ [i]) (label \\<C>) = Some tls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  same_lab (is @ [i]) (label \\<C>) = Some tls\n\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 10. \\<And>\\<C> t tp_sx a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Load t tp_sx a\n           off] : tn _> tm\nA total of 13 subgoals...", "hence \"type_update ts (to_ct_list (tls @ [T_i32])) (TopType []) = tm'\""], ["proof (prove)\nusing this:\n  same_lab (is @ [i]) (label \\<C>) = Some tls\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (tls @ [T_i32])) (TopType []) = tm'", "using 22"], ["proof (prove)\nusing this:\n  same_lab (is @ [i]) (label \\<C>) = Some tls\n  check_single \\<C> (Br_table is i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (tls @ [T_i32])) (TopType []) = tm'", "by simp"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (tls @ [T_i32])) (TopType []) = tm'\n\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 9. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 10. \\<And>\\<C> t tp_sx a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Load t tp_sx a\n           off] : tn _> tm\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (tls @ [T_i32])) (TopType []) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Br_table is i] : tn _> tm", "using b_e_check_single_top_not_bot_sound[OF _ 22(3,4)]\n            b_e_typing.intros(20)[OF same_lab_conv_list_all[OF tls_def]]\n            b_e_typing.intros(35)"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (tls @ [T_i32])) (TopType []) = tm'\n  type_update ts (to_ct_list ?t_in) (TopType []) = tm' \\<Longrightarrow>\n  \\<exists>tn. c_types_agree ts tn \\<and> suffix ?t_in tn\n  \\<C> \\<turnstile> [Br_table is i] : ?t1s @ tls @ [T_i32] _> ?t2s\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Br_table is i] : tn _> tm", "by (metis suffix_def)"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Br_table is i] : tn _> tm\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 9. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 10. \\<And>\\<C> t tp a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 9. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 10. \\<And>\\<C> t tp a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\nA total of 12 subgoals...", "case (23 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Return ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 9. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 10. \\<And>\\<C> t tp a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_single \\<C> Return ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot", "obtain ts_r where \"(return \\<C>) = Some ts_r\""], ["proof (prove)\nusing this:\n  check_single \\<C> Return ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>ts_r.\n        return \\<C> = Some ts_r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  return \\<C> = Some ts_r\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 9. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 10. \\<And>\\<C> t tp a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  return \\<C> = Some ts_r\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 9. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 10. \\<And>\\<C> t tp a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\nA total of 12 subgoals...", "hence \"type_update ts (to_ct_list ts_r) (TopType []) = tm'\""], ["proof (prove)\nusing this:\n  return \\<C> = Some ts_r\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list ts_r) (TopType []) = tm'", "using 23"], ["proof (prove)\nusing this:\n  return \\<C> = Some ts_r\n  check_single \\<C> Return ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list ts_r) (TopType []) = tm'", "by simp"], ["proof (state)\nthis:\n  type_update ts (to_ct_list ts_r) (TopType []) = tm'\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Return ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Return] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 8. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 9. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 10. \\<And>\\<C> t tp a off ts tm' tm.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  return \\<C> = Some ts_r\n  type_update ts (to_ct_list ts_r) (TopType []) = tm'", "show ?case"], ["proof (prove)\nusing this:\n  return \\<C> = Some ts_r\n  type_update ts (to_ct_list ts_r) (TopType []) = tm'\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Return] : tn _> tm", "using b_e_check_single_top_not_bot_sound[OF _ 23(3,4)]\n            b_e_typing.intros(21,35)"], ["proof (prove)\nusing this:\n  return \\<C> = Some ts_r\n  type_update ts (to_ct_list ts_r) (TopType []) = tm'\n  type_update ts (to_ct_list ?t_in) (TopType []) = tm' \\<Longrightarrow>\n  \\<exists>tn. c_types_agree ts tn \\<and> suffix ?t_in tn\n  return ?\\<C> = Some ?ts \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Return] : ?t1s @ ?ts _> ?t2s\n  ?\\<C> \\<turnstile> ?es : ?t1s _> ?t2s \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?ts @ ?t1s _> ?ts @ ?t2s\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Return] : tn _> tm", "by (metis suffix_def)"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Return] : tn _> tm\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "case (24 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Call i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "obtain tn'' tm'' where func_def:\"(func_t \\<C>)!i = (tn'' _> tm'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tn'' tm''.\n        func_t \\<C> ! i = tn'' _> tm'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using tf.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = x1 _> x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>tn'' tm''.\n        func_t \\<C> ! i = tn'' _> tm'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  func_t \\<C> ! i = tn'' _> tm''\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "hence \"type_update ts (to_ct_list tn'') (Type tm'') = tm'\""], ["proof (prove)\nusing this:\n  func_t \\<C> ! i = tn'' _> tm''\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list tn'') (Type tm'') = tm'", "using 24"], ["proof (prove)\nusing this:\n  func_t \\<C> ! i = tn'' _> tm''\n  check_single \\<C> (Call i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list tn'') (Type tm'') = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "have \"i < length (func_t \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (func_t \\<C>)", "using 24"], ["proof (prove)\nusing this:\n  check_single \\<C> (Call i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (func_t \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (func_t \\<C>)\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "hence \"\\<C> \\<turnstile> [Call i] : (tn'' _> tm'')\""], ["proof (prove)\nusing this:\n  i < length (func_t \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Call i] : tn'' _> tm''", "using b_e_typing.intros(22) func_def"], ["proof (prove)\nusing this:\n  i < length (func_t \\<C>)\n  \\<lbrakk>?i < length (func_t ?\\<C>); func_t ?\\<C> ! ?i = ?tf\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Call ?i] : ?tf\n  func_t \\<C> ! i = tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Call i] : tn'' _> tm''", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Call i] : tn'' _> tm''\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call i) ts = tm'; c_types_agree tm' tm;\n        ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 7. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 8. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 9. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Current_memory] : tn _> tm\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Call i] : tn'' _> tm''", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Call i] : tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Call i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 24(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list tn'') (Type tm'') = tm'\n  \\<C> \\<turnstile> [Call i] : tn'' _> tm''\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Call i] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Call i] : tn _> tm\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (25 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Call_indirect i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "obtain tn'' tm'' where type_def:\"(types_t \\<C>)!i = (tn'' _> tm'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tn'' tm''.\n        types_t \\<C> ! i = tn'' _> tm'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using tf.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = x1 _> x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>tn'' tm''.\n        types_t \\<C> ! i = tn'' _> tm'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  types_t \\<C> ! i = tn'' _> tm''\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list (tn''@[T_i32])) (Type tm'') = tm'\""], ["proof (prove)\nusing this:\n  types_t \\<C> ! i = tn'' _> tm''\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'", "using 25"], ["proof (prove)\nusing this:\n  types_t \\<C> ! i = tn'' _> tm''\n  check_single \\<C> (Call_indirect i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"(table \\<C>) \\<noteq> None \\<and> i < length (types_t \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table \\<C> \\<noteq> None \\<and> i < length (types_t \\<C>)", "using 25"], ["proof (prove)\nusing this:\n  check_single \\<C> (Call_indirect i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. table \\<C> \\<noteq> None \\<and> i < length (types_t \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  table \\<C> \\<noteq> None \\<and> i < length (types_t \\<C>)\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Call_indirect i] : (tn''@[T_i32] _> tm'')\""], ["proof (prove)\nusing this:\n  table \\<C> \\<noteq> None \\<and> i < length (types_t \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Call_indirect i] : tn'' @ [T_i32] _> tm''", "using b_e_typing.intros(23) type_def"], ["proof (prove)\nusing this:\n  table \\<C> \\<noteq> None \\<and> i < length (types_t \\<C>)\n  \\<lbrakk>?i < length (types_t ?\\<C>); types_t ?\\<C> ! ?i = ?t1s _> ?t2s;\n   table ?\\<C> \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Call_indirect\n   ?i] : ?t1s @ [T_i32] _> ?t2s\n  types_t \\<C> ! i = tn'' _> tm''\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Call_indirect i] : tn'' @ [T_i32] _> tm''", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Call_indirect i] : tn'' @ [T_i32] _> tm''\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 6. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 7. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 8. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 10. \\<And>\\<C> ts tm' tm.\n        \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n         c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> \\<exists>tn.\n                             c_types_agree ts tn \\<and>\n                             \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n  \\<C> \\<turnstile> [Call_indirect i] : tn'' @ [T_i32] _> tm''", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n  \\<C> \\<turnstile> [Call_indirect i] : tn'' @ [T_i32] _> tm''\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Call_indirect i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 25(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list (tn'' @ [T_i32])) (Type tm'') = tm'\n  \\<C> \\<turnstile> [Call_indirect i] : tn'' @ [T_i32] _> tm''\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Call_indirect i] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Call_indirect i] : tn _> tm\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (26 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Get_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts [] (Type [(local \\<C>)!i]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Get_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts [] (Type [local \\<C> ! i]) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts [] (Type [local \\<C> ! i]) = tm'\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts [] (Type [local \\<C> ! i]) = tm'\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"i < length (local \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (local \\<C>)", "using 26"], ["proof (prove)\nusing this:\n  check_single \\<C> (Get_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (local \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (local \\<C>)\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Get_local i] : ([] _> [(local \\<C>)!i])\""], ["proof (prove)\nusing this:\n  i < length (local \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]", "using b_e_typing.intros(24)"], ["proof (prove)\nusing this:\n  i < length (local \\<C>)\n  \\<lbrakk>?i < length (local ?\\<C>); local ?\\<C> ! ?i = ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Get_local ?i] : [] _> [?t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 5. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 6. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 7. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 9. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts [] (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Get_local i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 26(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Get_local i] : tn _> tm", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Get_local i] : [] _> [local \\<C> ! i]\n  \\<lbrakk>type_update ts (map TSome ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Get_local i] : tn _> tm", "by (metis list.map_disc_iff)"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Get_local i] : tn _> tm\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (27 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Set_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list [(local \\<C>)!i]) (Type []) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list [local \\<C> ! i]) (Type []) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (map TSome [local \\<C> ! i]) (Type []) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type []) = tm'\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type []) = tm'\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"i < length (local \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (local \\<C>)", "using 27"], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (local \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (local \\<C>)\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Set_local i] : ([(local \\<C>)!i] _> [])\""], ["proof (prove)\nusing this:\n  i < length (local \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_local i] : [local \\<C> ! i] _> []", "using b_e_typing.intros(25)"], ["proof (prove)\nusing this:\n  i < length (local \\<C>)\n  \\<lbrakk>?i < length (local ?\\<C>); local ?\\<C> ! ?i = ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Set_local ?i] : [?t] _> []\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_local i] : [local \\<C> ! i] _> []", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Set_local i] : [local \\<C> ! i] _> []\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 4. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 5. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 6. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 8. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type []) = tm'\n  \\<C> \\<turnstile> [Set_local i] : [local \\<C> ! i] _> []", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type []) = tm'\n  \\<C> \\<turnstile> [Set_local i] : [local \\<C> ! i] _> []\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Set_local i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 27(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type []) = tm'\n  \\<C> \\<turnstile> [Set_local i] : [local \\<C> ! i] _> []\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Set_local i] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Set_local i] : tn _> tm\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (28 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Tee_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list [(local \\<C>)!i]) (Type [(local \\<C>)!i]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Tee_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list [local \\<C> ! i]) (Type [local \\<C> ! i]) =\n    tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> (Tee_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (map TSome [local \\<C> ! i]) (Type [local \\<C> ! i]) =\n    tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type [local \\<C> ! i]) = tm'\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type [local \\<C> ! i]) = tm'\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"i < length (local \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (local \\<C>)", "using 28"], ["proof (prove)\nusing this:\n  check_single \\<C> (Tee_local i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (local \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (local \\<C>)\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Tee_local i] : ([(local \\<C>)!i] _> [(local \\<C>)!i])\""], ["proof (prove)\nusing this:\n  i < length (local \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Tee_local i] : [local \\<C> ! i] _> [local \\<C> ! i]", "using b_e_typing.intros(26)"], ["proof (prove)\nusing this:\n  i < length (local \\<C>)\n  \\<lbrakk>?i < length (local ?\\<C>); local ?\\<C> ! ?i = ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Tee_local ?i] : [?t] _> [?t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Tee_local i] : [local \\<C> ! i] _> [local \\<C> ! i]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Tee_local i] : [local \\<C> ! i] _> [local \\<C> ! i]\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 3. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 4. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 5. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 7. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Tee_local i] : [local \\<C> ! i] _> [local \\<C> ! i]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Tee_local i] : [local \\<C> ! i] _> [local \\<C> ! i]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Tee_local i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 28(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [local \\<C> ! i]) (Type [local \\<C> ! i]) = tm'\n  \\<C> \\<turnstile> [Tee_local i] : [local \\<C> ! i] _> [local \\<C> ! i]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Tee_local i] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Tee_local i] : tn _> tm\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (29 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Get_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts [] (Type [tg_t ((global \\<C>)!i)]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Get_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"i < length (global \\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (global \\<C>)", "using 29"], ["proof (prove)\nusing this:\n  check_single \\<C> (Get_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (global \\<C>)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (global \\<C>)\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Get_global i] : ([] _> [tg_t ((global \\<C>)!i)])\""], ["proof (prove)\nusing this:\n  i < length (global \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]", "using b_e_typing.intros(27)"], ["proof (prove)\nusing this:\n  i < length (global \\<C>)\n  \\<lbrakk>?i < length (global ?\\<C>);\n   tg_t (global ?\\<C> ! ?i) = ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Get_global ?i] : [] _> [?t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Get_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Get_global i] : tn _> tm\n 2. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 3. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 4. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 6. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'\n  \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'\n  \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Get_global i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 29(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'\n  \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Get_global i] : tn _> tm", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [tg_t (global \\<C> ! i)]) = tm'\n  \\<C> \\<turnstile> [Get_global i] : [] _> [tg_t (global \\<C> ! i)]\n  \\<lbrakk>type_update ts (map TSome ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Get_global i] : tn _> tm", "by (metis list.map_disc_iff)"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Get_global i] : tn _> tm\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (30 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Set_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list [tg_t ((global \\<C>)!i)]) (Type []) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list [tg_t (global \\<C> ! i)]) (Type []) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (map TSome [tg_t (global \\<C> ! i)]) (Type []) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [tg_t (global \\<C> ! i)]) (Type []) = tm'\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [tg_t (global \\<C> ! i)]) (Type []) = tm'\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"i < length (global \\<C>) \\<and> is_mut (global \\<C> ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (global \\<C>) \\<and> is_mut (global \\<C> ! i)", "using 30"], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_global i) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. i < length (global \\<C>) \\<and> is_mut (global \\<C> ! i)", "by (simp, meson)"], ["proof (state)\nthis:\n  i < length (global \\<C>) \\<and> is_mut (global \\<C> ! i)\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "then"], ["proof (chain)\npicking this:\n  i < length (global \\<C>) \\<and> is_mut (global \\<C> ! i)", "obtain t where \"(global \\<C> ! i) = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>\" \"i < length (global \\<C>)\""], ["proof (prove)\nusing this:\n  i < length (global \\<C>) \\<and> is_mut (global \\<C> ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>global \\<C> ! i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>;\n         i < length (global \\<C>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_mut_def"], ["proof (prove)\nusing this:\n  i < length (global \\<C>) \\<and> tg_mut (global \\<C> ! i) = T_mut\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>global \\<C> ! i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>;\n         i < length (global \\<C>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"global \\<C> ! i\", auto)"], ["proof (state)\nthis:\n  global \\<C> ! i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>\n  i < length (global \\<C>)\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Set_global i] : ([tg_t (global \\<C> ! i)] _> [])\""], ["proof (prove)\nusing this:\n  global \\<C> ! i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>\n  i < length (global \\<C>)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_global i] : [tg_t (global \\<C> ! i)] _> []", "using b_e_typing.intros(28)[of i \\<C> \"tg_t (global \\<C> ! i)\"]"], ["proof (prove)\nusing this:\n  global \\<C> ! i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>\n  i < length (global \\<C>)\n  \\<lbrakk>i < length (global \\<C>);\n   tg_t (global \\<C> ! i) = tg_t (global \\<C> ! i);\n   is_mut (global \\<C> ! i)\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Set_global\n  i] : [tg_t (global \\<C> ! i)] _> []\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_global i] : [tg_t (global \\<C> ! i)] _> []", "unfolding is_mut_def tg_t_def"], ["proof (prove)\nusing this:\n  global \\<C> ! i = \\<lparr>tg_mut = T_mut, tg_t = t\\<rparr>\n  i < length (global \\<C>)\n  \\<lbrakk>i < length (global \\<C>);\n   (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_fst tg_ext_Tuple_Iso)\n    (global \\<C> ! i) =\n   (id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n    Record.iso_tuple_fst tg_ext_Tuple_Iso)\n    (global \\<C> ! i);\n   tg_mut (global \\<C> ! i) = T_mut\\<rbrakk>\n  \\<Longrightarrow> \\<C> \\<turnstile> [Set_global\n  i] : [(id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n         Record.iso_tuple_fst tg_ext_Tuple_Iso)\n         (global \\<C> ! i)] _> []\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Set_global\n                        i] : [(id \\<circ>\n                               Record.iso_tuple_snd\n                                Record.tuple_iso_tuple \\<circ>\n                               Record.iso_tuple_fst tg_ext_Tuple_Iso)\n                               (global \\<C> ! i)] _> []", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Set_global i] : [tg_t (global \\<C> ! i)] _> []\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Set_global i) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Set_global i] : tn _> tm\n 2. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 3. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 5. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list [tg_t (global \\<C> ! i)]) (Type []) = tm'\n  \\<C> \\<turnstile> [Set_global i] : [tg_t (global \\<C> ! i)] _> []", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [tg_t (global \\<C> ! i)]) (Type []) = tm'\n  \\<C> \\<turnstile> [Set_global i] : [tg_t (global \\<C> ! i)] _> []\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Set_global i] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 30(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [tg_t (global \\<C> ! i)]) (Type []) = tm'\n  \\<C> \\<turnstile> [Set_global i] : [tg_t (global \\<C> ! i)] _> []\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Set_global i] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Set_global i] : tn _> tm\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (31 \\<C> t tp_sx a off ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Load t tp_sx a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Load t tp_sx a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> (Load t tp_sx a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (map TSome [T_i32]) (Type [t]) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"(memory \\<C>) \\<noteq> None \\<and> load_store_t_bounds a (option_projl tp_sx) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None \\<and>\n    load_store_t_bounds a (option_projl tp_sx) t", "using 31"], ["proof (prove)\nusing this:\n  check_single \\<C> (Load t tp_sx a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None \\<and>\n    load_store_t_bounds a (option_projl tp_sx) t", "by (simp, meson)"], ["proof (state)\nthis:\n  memory \\<C> \\<noteq> None \\<and>\n  load_store_t_bounds a (option_projl tp_sx) t\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Load t tp_sx a off] : ([T_i32] _> [t])\""], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None \\<and>\n  load_store_t_bounds a (option_projl tp_sx) t\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Load t tp_sx a off] : [T_i32] _> [t]", "using b_e_typing.intros(29)"], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None \\<and>\n  load_store_t_bounds a (option_projl tp_sx) t\n  \\<lbrakk>memory ?\\<C> = Some ?n;\n   load_store_t_bounds ?a (option_projl ?tp_sx) ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Load ?t ?tp_sx ?a\n   ?off] : [T_i32] _> [?t]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Load t tp_sx a off] : [T_i32] _> [t]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Load t tp_sx a off] : [T_i32] _> [t]\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Load t tp_sx a\n          off] : tn _> tm\n 2. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 4. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'\n  \\<C> \\<turnstile> [Load t tp_sx a off] : [T_i32] _> [t]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'\n  \\<C> \\<turnstile> [Load t tp_sx a off] : [T_i32] _> [t]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Load t tp_sx a off] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 31(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [T_i32]) (Type [t]) = tm'\n  \\<C> \\<turnstile> [Load t tp_sx a off] : [T_i32] _> [t]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Load t tp_sx a off] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Load t tp_sx a off] : tn _> tm\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (32 \\<C> t tp a off ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Store t tp a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list [T_i32,t]) (Type []) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> (Store t tp a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list [T_i32, t]) (Type []) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> (Store t tp a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (map TSome [T_i32, t]) (Type []) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [T_i32, t]) (Type []) = tm'\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [T_i32, t]) (Type []) = tm'\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"(memory \\<C>) \\<noteq> None \\<and> load_store_t_bounds a tp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None \\<and> load_store_t_bounds a tp t", "using 32"], ["proof (prove)\nusing this:\n  check_single \\<C> (Store t tp a off) ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None \\<and> load_store_t_bounds a tp t", "by (simp, meson)"], ["proof (state)\nthis:\n  memory \\<C> \\<noteq> None \\<and> load_store_t_bounds a tp t\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Store t tp a off] : ([T_i32,t] _> [])\""], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None \\<and> load_store_t_bounds a tp t\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Store t tp a off] : [T_i32, t] _> []", "using b_e_typing.intros(30)"], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None \\<and> load_store_t_bounds a tp t\n  \\<lbrakk>memory ?\\<C> = Some ?n; load_store_t_bounds ?a ?tp ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<C> \\<turnstile> [Store ?t ?tp ?a\n   ?off] : [T_i32, ?t] _> []\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Store t tp a off] : [T_i32, t] _> []", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Store t tp a off] : [T_i32, t] _> []\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts tm' tm.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 3. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list [T_i32, t]) (Type []) = tm'\n  \\<C> \\<turnstile> [Store t tp a off] : [T_i32, t] _> []", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [T_i32, t]) (Type []) = tm'\n  \\<C> \\<turnstile> [Store t tp a off] : [T_i32, t] _> []\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Store t tp a off] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 32(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [T_i32, t]) (Type []) = tm'\n  \\<C> \\<turnstile> [Store t tp a off] : [T_i32, t] _> []\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Store t tp a off] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Store t tp a off] : tn _> tm\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (33 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Current_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts [] (Type [T_i32]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> Current_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts [] (Type [T_i32]) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts [] (Type [T_i32]) = tm'\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts [] (Type [T_i32]) = tm'\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"memory \\<C> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None", "using 33"], ["proof (prove)\nusing this:\n  check_single \\<C> Current_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None", "by (simp, meson)"], ["proof (state)\nthis:\n  memory \\<C> \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Current_memory] : ([] _> [T_i32])\""], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]", "using b_e_typing.intros(31)"], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None\n  memory ?\\<C> = Some ?n \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Current_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Current_memory] : tn _> tm\n 2. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts [] (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Current_memory] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 33(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Current_memory] : tn _> tm", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  type_update ts [] (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Current_memory] : [] _> [T_i32]\n  \\<lbrakk>type_update ts (map TSome ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and>\n       \\<C> \\<turnstile> [Current_memory] : tn _> tm", "by (metis list.map_disc_iff)"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and>\n     \\<C> \\<turnstile> [Current_memory] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "case (34 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Grow_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'\""], ["proof (prove)\nusing this:\n  check_single \\<C> Grow_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  check_single \\<C> Grow_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. type_update ts (map TSome [T_i32]) (Type [T_i32]) = tm'", "by auto"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "moreover"], ["proof (state)\nthis:\n  type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "have \"memory \\<C> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None", "using 34"], ["proof (prove)\nusing this:\n  check_single \\<C> Grow_memory ts = tm'\n  c_types_agree tm' tm\n  ts \\<noteq> Bot\n  tm' \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. memory \\<C> \\<noteq> None", "by (simp, meson)"], ["proof (state)\nthis:\n  memory \\<C> \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "hence \"\\<C> \\<turnstile> [Grow_memory] : ([T_i32] _> [T_i32])\""], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]", "using b_e_typing.intros(32)"], ["proof (prove)\nusing this:\n  memory \\<C> \\<noteq> None\n  memory ?\\<C> = Some ?n \\<Longrightarrow>\n  ?\\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]", "by fastforce"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts tm' tm.\n       \\<lbrakk>check_single \\<C> Grow_memory ts = tm';\n        c_types_agree tm' tm; ts \\<noteq> Bot; tm' \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn.\n                            c_types_agree ts tn \\<and>\n                            \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "ultimately"], ["proof (chain)\npicking this:\n  type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]", "show ?case"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "using b_e_check_single_type_not_bot_sound[OF _ 34(3,4,2)]"], ["proof (prove)\nusing this:\n  type_update ts (to_ct_list [T_i32]) (Type [T_i32]) = tm'\n  \\<C> \\<turnstile> [Grow_memory] : [T_i32] _> [T_i32]\n  \\<lbrakk>type_update ts (to_ct_list ?t_in) (Type ?t_out) = tm';\n   ?\\<C> \\<turnstile> [?e] : ?t_in _> ?t_out\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree ts tn \\<and>\n                       ?\\<C> \\<turnstile> [?e] : tn _> tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn.\n       c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Grow_memory] : tn _> tm", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn.\n     c_types_agree ts tn \\<and> \\<C> \\<turnstile> [Grow_memory] : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> es (tn _> tm) \\<Longrightarrow>\n  \\<C> \\<turnstile> es : tn _> tm\n  \\<lbrakk>check \\<C> es tn' = ?tm'; c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       \\<C> \\<turnstile> es : tn _> ?tm\n  \\<lbrakk>check_single \\<C> e tn' = ?tm'; c_types_agree ?tm' ?tm;\n   tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       \\<C> \\<turnstile> [e] : tn _> ?tm\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  b_e_type_checker \\<C> es (tn _> tm) \\<Longrightarrow>\n  \\<C> \\<turnstile> es : tn _> tm\n  \\<lbrakk>check \\<C> es tn' = ?tm'; c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       \\<C> \\<turnstile> es : tn _> ?tm\n  \\<lbrakk>check_single \\<C> e tn' = ?tm'; c_types_agree ?tm' ?tm;\n   tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       \\<C> \\<turnstile> [e] : tn _> ?tm\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm", "using assms"], ["proof (prove)\nusing this:\n  b_e_type_checker \\<C> es (tn _> tm) \\<Longrightarrow>\n  \\<C> \\<turnstile> es : tn _> tm\n  \\<lbrakk>check \\<C> es tn' = ?tm'; c_types_agree ?tm' ?tm\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       \\<C> \\<turnstile> es : tn _> ?tm\n  \\<lbrakk>check_single \\<C> e tn' = ?tm'; c_types_agree ?tm' ?tm;\n   tn' \\<noteq> Bot; ?tm' \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tn.\n                       c_types_agree tn' tn \\<and>\n                       \\<C> \\<turnstile> [e] : tn _> ?tm\n  b_e_type_checker \\<C> es (tn _> tm)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm", "by simp"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : tn _> tm\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Completeness\\<close>"], ["", "lemma check_single_imp:\n  assumes \"check_single \\<C> e ctn = ctm\"\n          \"ctm \\<noteq> Bot\"\n  shows \"check_single \\<C> e = id\n         \\<or> check_single \\<C> e = (\\<lambda>ctn. type_update_select ctn)\n         \\<or> (\\<exists>cons prods. (check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_single \\<C> e = id \\<or>\n    check_single \\<C> e = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_single \\<C> e = id \\<or>\n    check_single \\<C> e = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods))", "have True\n  and True\n  and \"check_single \\<C> e ctn = ctm \\<Longrightarrow>\n       ctm \\<noteq> Bot \\<Longrightarrow>\n         ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True &&&\n    True &&&\n    (\\<lbrakk>check_single \\<C> e ctn = ctm; ctm \\<noteq> Bot\\<rbrakk>\n     \\<Longrightarrow> check_single \\<C> e = id \\<or>\n                       check_single \\<C> e = type_update_select \\<or>\n                       (\\<exists>cons prods.\n                           check_single \\<C> e =\n                           (\\<lambda>ctn. type_update ctn cons prods)))", "proof (induction rule: b_e_type_checker_check_check_single.induct)"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>\\<C> es tn tm. True \\<Longrightarrow> True\n 2. \\<And>\\<C> es ts.\n       \\<lbrakk>\\<And>x21 x22 x1.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ctn = ctm;\n                    ctm \\<noteq> ts\\<rbrakk>\n                   \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                                     check_single \\<C> x21 =\n                                     type_update_select \\<or>\n                                     (\\<exists>cons prods.\n   check_single \\<C> x21 = (\\<lambda>ctn. type_update ctn cons prods));\n        \\<And>x21 x22 x1.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1\\<rbrakk>\n           \\<Longrightarrow> True;\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n           \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                             check_single \\<C> x21 =\n                             type_update_select \\<or>\n                             (\\<exists>cons prods.\n                                 check_single \\<C> x21 =\n                                 (\\<lambda>ctn.\n                                     type_update ctn cons prods));\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2\\<rbrakk>\n           \\<Longrightarrow> True\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t va_ ts.\n        \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                          check_single \\<C> (Relop_f t va_) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Relop_f t va_) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 34 subgoals...", "case (1 \\<C> es tn tm)"], ["proof (state)\nthis:\n  True\n\ngoal (34 subgoals):\n 1. \\<And>\\<C> es tn tm. True \\<Longrightarrow> True\n 2. \\<And>\\<C> es ts.\n       \\<lbrakk>\\<And>x21 x22 x1.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ctn = ctm;\n                    ctm \\<noteq> ts\\<rbrakk>\n                   \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                                     check_single \\<C> x21 =\n                                     type_update_select \\<or>\n                                     (\\<exists>cons prods.\n   check_single \\<C> x21 = (\\<lambda>ctn. type_update ctn cons prods));\n        \\<And>x21 x22 x1.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1\\<rbrakk>\n           \\<Longrightarrow> True;\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n           \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                             check_single \\<C> x21 =\n                             type_update_select \\<or>\n                             (\\<exists>cons prods.\n                                 check_single \\<C> x21 =\n                                 (\\<lambda>ctn.\n                                     type_update ctn cons prods));\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2\\<rbrakk>\n           \\<Longrightarrow> True\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t va_ ts.\n        \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                          check_single \\<C> (Relop_f t va_) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Relop_f t va_) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 34 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  True\n\ngoal (1 subgoal):\n 1. True", "by simp"], ["proof (state)\nthis:\n  True\n\ngoal (33 subgoals):\n 1. \\<And>\\<C> es ts.\n       \\<lbrakk>\\<And>x21 x22 x1.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ctn = ctm;\n                    ctm \\<noteq> ts\\<rbrakk>\n                   \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                                     check_single \\<C> x21 =\n                                     type_update_select \\<or>\n                                     (\\<exists>cons prods.\n   check_single \\<C> x21 = (\\<lambda>ctn. type_update ctn cons prods));\n        \\<And>x21 x22 x1.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1\\<rbrakk>\n           \\<Longrightarrow> True;\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n           \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                             check_single \\<C> x21 =\n                             type_update_select \\<or>\n                             (\\<exists>cons prods.\n                                 check_single \\<C> x21 =\n                                 (\\<lambda>ctn.\n                                     type_update ctn cons prods));\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2\\<rbrakk>\n           \\<Longrightarrow> True\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t1 t2 sx ts.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                          id \\<or>\n                          check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>\\<C> es ts.\n       \\<lbrakk>\\<And>x21 x22 x1.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ctn = ctm;\n                    ctm \\<noteq> ts\\<rbrakk>\n                   \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                                     check_single \\<C> x21 =\n                                     type_update_select \\<or>\n                                     (\\<exists>cons prods.\n   check_single \\<C> x21 = (\\<lambda>ctn. type_update ctn cons prods));\n        \\<And>x21 x22 x1.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1\\<rbrakk>\n           \\<Longrightarrow> True;\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n           \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                             check_single \\<C> x21 =\n                             type_update_select \\<or>\n                             (\\<exists>cons prods.\n                                 check_single \\<C> x21 =\n                                 (\\<lambda>ctn.\n                                     type_update ctn cons prods));\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2\\<rbrakk>\n           \\<Longrightarrow> True\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t1 t2 sx ts.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                          id \\<or>\n                          check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 33 subgoals...", "case (2 \\<C> es ts)"], ["proof (state)\nthis:\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = TopType ?x1.0;\n   check_single \\<C> ?x21.0 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> ?x21.0 = id \\<or>\n                    check_single \\<C> ?x21.0 = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> ?x21.0 =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = TopType ?x1.0\\<rbrakk>\n  \\<Longrightarrow> True\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = Type ?x2.0;\n   check_single \\<C> ?x21.0 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> ?x21.0 = id \\<or>\n                    check_single \\<C> ?x21.0 = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> ?x21.0 =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = Type ?x2.0\\<rbrakk>\n  \\<Longrightarrow> True\n\ngoal (33 subgoals):\n 1. \\<And>\\<C> es ts.\n       \\<lbrakk>\\<And>x21 x22 x1.\n                   \\<lbrakk>es = x21 # x22; ts = TopType x1;\n                    check_single \\<C> x21 ctn = ctm;\n                    ctm \\<noteq> ts\\<rbrakk>\n                   \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                                     check_single \\<C> x21 =\n                                     type_update_select \\<or>\n                                     (\\<exists>cons prods.\n   check_single \\<C> x21 = (\\<lambda>ctn. type_update ctn cons prods));\n        \\<And>x21 x22 x1.\n           \\<lbrakk>es = x21 # x22; ts = TopType x1\\<rbrakk>\n           \\<Longrightarrow> True;\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2;\n            check_single \\<C> x21 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n           \\<Longrightarrow> check_single \\<C> x21 = id \\<or>\n                             check_single \\<C> x21 =\n                             type_update_select \\<or>\n                             (\\<exists>cons prods.\n                                 check_single \\<C> x21 =\n                                 (\\<lambda>ctn.\n                                     type_update ctn cons prods));\n        \\<And>x21 x22 x2.\n           \\<lbrakk>es = x21 # x22; ts = Type x2\\<rbrakk>\n           \\<Longrightarrow> True\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t1 t2 sx ts.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                          id \\<or>\n                          check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 33 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = TopType ?x1.0;\n   check_single \\<C> ?x21.0 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> ?x21.0 = id \\<or>\n                    check_single \\<C> ?x21.0 = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> ?x21.0 =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = TopType ?x1.0\\<rbrakk>\n  \\<Longrightarrow> True\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = Type ?x2.0;\n   check_single \\<C> ?x21.0 ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> ?x21.0 = id \\<or>\n                    check_single \\<C> ?x21.0 = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> ?x21.0 =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  \\<lbrakk>es = ?x21.0 # ?x22.0; ts = Type ?x2.0\\<rbrakk>\n  \\<Longrightarrow> True\n\ngoal (1 subgoal):\n 1. True", "by simp"], ["proof (state)\nthis:\n  True\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t1 t2 sx ts.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                          id \\<or>\n                          check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C>\n                               (Cvtop t1 Reinterpret t2 sx) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t1 t2 sx ts.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                          id \\<or>\n                          check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C>\n                               (Cvtop t1 Reinterpret t2 sx) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 32 subgoals...", "case (3 \\<C> v ts)"], ["proof (state)\nthis:\n  check_single \\<C> (C v) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v ts.\n       \\<lbrakk>check_single \\<C> (C v) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (C v) = id \\<or>\n                         check_single \\<C> (C v) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (C v) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t1 t2 sx ts.\n        \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                          id \\<or>\n                          check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C>\n                               (Cvtop t1 Reinterpret t2 sx) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 32 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (C v) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (C v) = id \\<or>\n    check_single \\<C> (C v) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (C v) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by fastforce"], ["proof (state)\nthis:\n  check_single \\<C> (C v) = id \\<or>\n  check_single \\<C> (C v) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (C v) = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                          check_single \\<C> Unreachable =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Unreachable =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                          check_single \\<C> Unreachable =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Unreachable =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 31 subgoals...", "case (4 \\<C> t uu ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Unop_i t uu) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> t uu_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_i t uu_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_i t uu_) = id \\<or>\n                         check_single \\<C> (Unop_i t uu_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_i t uu_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                          check_single \\<C> Unreachable =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Unreachable =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 31 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Unop_i t uu) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Unop_i t uu) = id \\<or>\n    check_single \\<C> (Unop_i t uu) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Unop_i t uu) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Unop_i t uu) = id \\<or>\n  check_single \\<C> (Unop_i t uu) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Unop_i t uu) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                          check_single \\<C> Nop = type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Nop =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                          check_single \\<C> Nop = type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Nop =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 30 subgoals...", "case (5 \\<C> t uv ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Unop_f t uv) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (30 subgoals):\n 1. \\<And>\\<C> t uv_ ts.\n       \\<lbrakk>check_single \\<C> (Unop_f t uv_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Unop_f t uv_) = id \\<or>\n                         check_single \\<C> (Unop_f t uv_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Unop_f t uv_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                          check_single \\<C> Nop = type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Nop =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 30 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Unop_f t uv) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Unop_f t uv) = id \\<or>\n    check_single \\<C> (Unop_f t uv) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Unop_f t uv) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Unop_f t uv) = id \\<or>\n  check_single \\<C> (Unop_f t uv) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Unop_f t uv) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                          check_single \\<C> Drop = type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Drop =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                          check_single \\<C> Drop = type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Drop =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 29 subgoals...", "case (6 \\<C> t uw ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Binop_i t uw) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (29 subgoals):\n 1. \\<And>\\<C> t uw_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_i t uw_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_i t uw_) = id \\<or>\n                         check_single \\<C> (Binop_i t uw_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_i t uw_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                          check_single \\<C> Drop = type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Drop =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 29 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Binop_i t uw) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Binop_i t uw) = id \\<or>\n    check_single \\<C> (Binop_i t uw) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Binop_i t uw) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Binop_i t uw) = id \\<or>\n  check_single \\<C> (Binop_i t uw) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Binop_i t uw) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Select ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                          check_single \\<C> Select =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Select =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Select ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                          check_single \\<C> Select =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Select =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 28 subgoals...", "case (7 \\<C> t ux ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Binop_f t ux) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (28 subgoals):\n 1. \\<And>\\<C> t ux_ ts.\n       \\<lbrakk>check_single \\<C> (Binop_f t ux_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Binop_f t ux_) = id \\<or>\n                         check_single \\<C> (Binop_f t ux_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Binop_f t ux_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Select ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                          check_single \\<C> Select =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Select =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 28 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Binop_f t ux) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Binop_f t ux) = id \\<or>\n    check_single \\<C> (Binop_f t ux) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Binop_f t ux) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Binop_f t ux) = id \\<or>\n  check_single \\<C> (Binop_f t ux) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Binop_f t ux) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es ts.\n        \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                          check_single \\<C> (Block (tn _> tm) es) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Block (tn _> tm) es) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es ts.\n        \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                          check_single \\<C> (Block (tn _> tm) es) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Block (tn _> tm) es) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 27 subgoals...", "case (8 \\<C> t uy ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Testop t uy) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (27 subgoals):\n 1. \\<And>\\<C> t uy_ ts.\n       \\<lbrakk>check_single \\<C> (Testop t uy_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Testop t uy_) = id \\<or>\n                         check_single \\<C> (Testop t uy_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Testop t uy_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es ts.\n        \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                          check_single \\<C> (Block (tn _> tm) es) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Block (tn _> tm) es) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 27 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Testop t uy) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Testop t uy) = id \\<or>\n    check_single \\<C> (Testop t uy) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Testop t uy) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Testop t uy) = id \\<or>\n  check_single \\<C> (Testop t uy) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Testop t uy) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es ts.\n        \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                          check_single \\<C> (Loop (tn _> tm) es) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Loop (tn _> tm) es) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es ts.\n        \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                          check_single \\<C> (Loop (tn _> tm) es) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Loop (tn _> tm) es) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 26 subgoals...", "case (9 \\<C> t uz ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Relop_i t uz) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (26 subgoals):\n 1. \\<And>\\<C> t uz_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_i t uz_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_i t uz_) = id \\<or>\n                         check_single \\<C> (Relop_i t uz_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_i t uz_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es ts.\n        \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                          check_single \\<C> (Loop (tn _> tm) es) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Loop (tn _> tm) es) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 26 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Relop_i t uz) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Relop_i t uz) = id \\<or>\n    check_single \\<C> (Relop_i t uz) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Relop_i t uz) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Relop_i t uz) = id \\<or>\n  check_single \\<C> (Relop_i t uz) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Relop_i t uz) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es1 es2 ts.\n        \\<lbrakk>True; True;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                          id \\<or>\n                          check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C>\n                               (b_e.If (tn _> tm) es1 es2) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es1 es2 ts.\n        \\<lbrakk>True; True;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                          id \\<or>\n                          check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C>\n                               (b_e.If (tn _> tm) es1 es2) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 25 subgoals...", "case (10 \\<C> t va ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Relop_f t va) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (25 subgoals):\n 1. \\<And>\\<C> t va_ ts.\n       \\<lbrakk>check_single \\<C> (Relop_f t va_) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Relop_f t va_) = id \\<or>\n                         check_single \\<C> (Relop_f t va_) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Relop_f t va_) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> tn tm es1 es2 ts.\n        \\<lbrakk>True; True;\n         check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                          id \\<or>\n                          check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C>\n                               (b_e.If (tn _> tm) es1 es2) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Relop_f t va) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Relop_f t va) = id \\<or>\n    check_single \\<C> (Relop_f t va) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Relop_f t va) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Relop_f t va) = id \\<or>\n  check_single \\<C> (Relop_f t va) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Relop_f t va) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Br i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                          check_single \\<C> (Br i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Br i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                          check_single \\<C> (Br i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 24 subgoals...", "case (11 \\<C> t1 t2 sx ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (24 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Cvtop t1 Convert t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Br i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                          check_single \\<C> (Br i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Cvtop t1 Convert t2 sx) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Cvtop t1 Convert t2 sx) = id \\<or>\n    check_single \\<C> (Cvtop t1 Convert t2 sx) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Cvtop t1 Convert t2 sx) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp del: convert_cond.simps, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Cvtop t1 Convert t2 sx) = id \\<or>\n  check_single \\<C> (Cvtop t1 Convert t2 sx) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Cvtop t1 Convert t2 sx) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                          check_single \\<C> (Br_if i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br_if i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                          check_single \\<C> (Br_if i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br_if i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 23 subgoals...", "case (12 \\<C> t1 t2 sx ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (23 subgoals):\n 1. \\<And>\\<C> t1 t2 sx ts.\n       \\<lbrakk>check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         id \\<or>\n                         check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C>\n                              (Cvtop t1 Reinterpret t2 sx) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                          check_single \\<C> (Br_if i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br_if i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Cvtop t1 Reinterpret t2 sx) = id \\<or>\n    check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n    type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) = id \\<or>\n  check_single \\<C> (Cvtop t1 Reinterpret t2 sx) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Cvtop t1 Reinterpret t2 sx) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> is i ts.\n        \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                          check_single \\<C> (Br_table is i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br_table is i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> is i ts.\n        \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                          check_single \\<C> (Br_table is i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br_table is i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 22 subgoals...", "case (13 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Unreachable ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (22 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Unreachable ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Unreachable = id \\<or>\n                         check_single \\<C> Unreachable =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Unreachable =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> is i ts.\n        \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                          check_single \\<C> (Br_table is i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Br_table is i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Unreachable ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Unreachable = id \\<or>\n    check_single \\<C> Unreachable = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Unreachable =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by fastforce"], ["proof (state)\nthis:\n  check_single \\<C> Unreachable = id \\<or>\n  check_single \\<C> Unreachable = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Unreachable =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (21 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Return ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                          check_single \\<C> Return =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Return =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Return ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                          check_single \\<C> Return =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Return =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 21 subgoals...", "case (14 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Nop ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (21 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Nop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Nop = id \\<or>\n                         check_single \\<C> Nop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Nop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Return ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                          check_single \\<C> Return =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Return =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 21 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Nop ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Nop = id \\<or>\n    check_single \\<C> Nop = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Nop = (\\<lambda>ctn. type_update ctn cons prods))", "by fastforce"], ["proof (state)\nthis:\n  check_single \\<C> Nop = id \\<or>\n  check_single \\<C> Nop = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Nop = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (20 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                          check_single \\<C> (Call i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Call i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                          check_single \\<C> (Call i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Call i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 20 subgoals...", "case (15 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Drop ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (20 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Drop ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Drop = id \\<or>\n                         check_single \\<C> Drop = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Drop =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                          check_single \\<C> (Call i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Call i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 20 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Drop ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Drop = id \\<or>\n    check_single \\<C> Drop = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Drop = (\\<lambda>ctn. type_update ctn cons prods))", "by fastforce"], ["proof (state)\nthis:\n  check_single \\<C> Drop = id \\<or>\n  check_single \\<C> Drop = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Drop = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (19 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                          check_single \\<C> (Call_indirect i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Call_indirect i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                          check_single \\<C> (Call_indirect i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Call_indirect i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 19 subgoals...", "case (16 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Select ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (19 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Select ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Select = id \\<or>\n                         check_single \\<C> Select = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Select =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                          check_single \\<C> (Call_indirect i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Call_indirect i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Select ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Select = id \\<or>\n    check_single \\<C> Select = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Select =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by fastforce"], ["proof (state)\nthis:\n  check_single \\<C> Select = id \\<or>\n  check_single \\<C> Select = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Select = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                          check_single \\<C> (Get_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Get_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                          check_single \\<C> (Get_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Get_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 18 subgoals...", "case (17 \\<C> tn tm es ts)"], ["proof (state)\nthis:\n  True\n  check_single \\<C> (Block (tn _> tm) es) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (18 subgoals):\n 1. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Block (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Block (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Block (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                          check_single \\<C> (Get_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Get_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  True\n  check_single \\<C> (Block (tn _> tm) es) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n    check_single \\<C> (Block (tn _> tm) es) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Block (tn _> tm) es) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Block (tn _> tm) es) = id \\<or>\n  check_single \\<C> (Block (tn _> tm) es) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Block (tn _> tm) es) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                          check_single \\<C> (Set_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Set_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                          check_single \\<C> (Set_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Set_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 17 subgoals...", "case (18 \\<C> tn tm es ts)"], ["proof (state)\nthis:\n  True\n  check_single \\<C> (Loop (tn _> tm) es) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (17 subgoals):\n 1. \\<And>\\<C> tn tm es ts.\n       \\<lbrakk>True; check_single \\<C> (Loop (tn _> tm) es) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n                         check_single \\<C> (Loop (tn _> tm) es) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Loop (tn _> tm) es) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                          check_single \\<C> (Set_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Set_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 17 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  True\n  check_single \\<C> (Loop (tn _> tm) es) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n    check_single \\<C> (Loop (tn _> tm) es) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Loop (tn _> tm) es) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Loop (tn _> tm) es) = id \\<or>\n  check_single \\<C> (Loop (tn _> tm) es) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Loop (tn _> tm) es) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                          check_single \\<C> (Tee_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Tee_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                          check_single \\<C> (Tee_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Tee_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 16 subgoals...", "case (19 \\<C> tn tm es1 es2 ts)"], ["proof (state)\nthis:\n  True\n  True\n  check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (16 subgoals):\n 1. \\<And>\\<C> tn tm es1 es2 ts.\n       \\<lbrakk>True; True;\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         id \\<or>\n                         check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                          check_single \\<C> (Tee_local i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Tee_local i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  True\n  True\n  check_single \\<C> (b_e.If (tn _> tm) es1 es2) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (b_e.If (tn _> tm) es1 es2) = id \\<or>\n    check_single \\<C> (b_e.If (tn _> tm) es1 es2) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (b_e.If (tn _> tm) es1 es2) = id \\<or>\n  check_single \\<C> (b_e.If (tn _> tm) es1 es2) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (b_e.If (tn _> tm) es1 es2) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                          check_single \\<C> (Get_global i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Get_global i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                          check_single \\<C> (Get_global i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Get_global i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 15 subgoals...", "case (20 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Br i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (15 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br i) ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br i) = id \\<or>\n                         check_single \\<C> (Br i) = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                          check_single \\<C> (Get_global i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Get_global i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 15 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Br i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Br i) = id \\<or>\n    check_single \\<C> (Br i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Br i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Br i) = id \\<or>\n  check_single \\<C> (Br i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Br i) = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                          check_single \\<C> (Set_global i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Set_global i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                          check_single \\<C> (Set_global i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Set_global i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 14 subgoals...", "case (21 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Br_if i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (14 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Br_if i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_if i) = id \\<or>\n                         check_single \\<C> (Br_if i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_if i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> i ts.\n        \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                          check_single \\<C> (Set_global i) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Set_global i) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 14 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Br_if i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Br_if i) = id \\<or>\n    check_single \\<C> (Br_if i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Br_if i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Br_if i) = id \\<or>\n  check_single \\<C> (Br_if i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Br_if i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t tp_sx a off ts.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                          check_single \\<C> (Load t tp_sx a off) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Load t tp_sx a off) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t tp_sx a off ts.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                          check_single \\<C> (Load t tp_sx a off) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Load t tp_sx a off) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 13 subgoals...", "case (22 \\<C> \"is\" ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Br_table is ts) ctn = ctm\n  ctm \\<noteq> ts_\n\ngoal (13 subgoals):\n 1. \\<And>\\<C> is i ts.\n       \\<lbrakk>check_single \\<C> (Br_table is i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Br_table is i) = id \\<or>\n                         check_single \\<C> (Br_table is i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Br_table is i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t tp_sx a off ts.\n        \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                          check_single \\<C> (Load t tp_sx a off) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Load t tp_sx a off) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Br_table is ts) ctn = ctm\n  ctm \\<noteq> ts_\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Br_table is ts) = id \\<or>\n    check_single \\<C> (Br_table is ts) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Br_table is ts) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, metis assms(2) option.case_eq_if type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Br_table is ts) = id \\<or>\n  check_single \\<C> (Br_table is ts) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Br_table is ts) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t tp a off ts.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                          check_single \\<C> (Store t tp a off) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Store t tp a off) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t tp a off ts.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                          check_single \\<C> (Store t tp a off) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Store t tp a off) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 12 subgoals...", "case (23 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Return ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (12 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Return ctn = ctm; ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Return = id \\<or>\n                         check_single \\<C> Return = type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Return =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> t tp a off ts.\n        \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                          check_single \\<C> (Store t tp a off) =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> (Store t tp a off) =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Return ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Return = id \\<or>\n    check_single \\<C> Return = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Return =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, metis assms(2) option.case_eq_if type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> Return = id \\<or>\n  check_single \\<C> Return = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Return = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                          check_single \\<C> Current_memory =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Current_memory =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                          check_single \\<C> Current_memory =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Current_memory =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 11 subgoals...", "case (24 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Call i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (11 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call i) = id \\<or>\n                         check_single \\<C> (Call i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                          check_single \\<C> Current_memory =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Current_memory =\n                              (\\<lambda>ctn. type_update ctn cons prods))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_single \\<C> (Call i) ctn = ctm\n  ctm \\<noteq> ts", "show ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Call i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Call i) = id \\<or>\n    check_single \\<C> (Call i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Call i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, metis (no_types, lifting) assms(2) tf.case tf.exhaust type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Call i) = id \\<or>\n  check_single \\<C> (Call i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Call i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                          check_single \\<C> Grow_memory =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Grow_memory =\n                              (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                          check_single \\<C> Grow_memory =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Grow_memory =\n                              (\\<lambda>ctn. type_update ctn cons prods))", "case (25 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Call_indirect i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (10 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Call_indirect i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Call_indirect i) = id \\<or>\n                         check_single \\<C> (Call_indirect i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Call_indirect i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 10. \\<And>\\<C> ts.\n        \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n         ctm \\<noteq> ts\\<rbrakk>\n        \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                          check_single \\<C> Grow_memory =\n                          type_update_select \\<or>\n                          (\\<exists>cons prods.\n                              check_single \\<C> Grow_memory =\n                              (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Call_indirect i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Call_indirect i) = id \\<or>\n    check_single \\<C> (Call_indirect i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Call_indirect i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, metis (no_types, lifting) assms(2) tf.case tf.exhaust type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Call_indirect i) = id \\<or>\n  check_single \\<C> (Call_indirect i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Call_indirect i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (26 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Get_local i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (9 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_local i) = id \\<or>\n                         check_single \\<C> (Get_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 9. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Get_local i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Get_local i) = id \\<or>\n    check_single \\<C> (Get_local i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Get_local i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Get_local i) = id \\<or>\n  check_single \\<C> (Get_local i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Get_local i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (27 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Set_local i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (8 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_local i) = id \\<or>\n                         check_single \\<C> (Set_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 8. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_local i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Set_local i) = id \\<or>\n    check_single \\<C> (Set_local i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Set_local i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Set_local i) = id \\<or>\n  check_single \\<C> (Set_local i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Set_local i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (28 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Tee_local i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (7 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Tee_local i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Tee_local i) = id \\<or>\n                         check_single \\<C> (Tee_local i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Tee_local i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 7. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Tee_local i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Tee_local i) = id \\<or>\n    check_single \\<C> (Tee_local i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Tee_local i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Tee_local i) = id \\<or>\n  check_single \\<C> (Tee_local i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Tee_local i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (29 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Get_global i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (6 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Get_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Get_global i) = id \\<or>\n                         check_single \\<C> (Get_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Get_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 6. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Get_global i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Get_global i) = id \\<or>\n    check_single \\<C> (Get_global i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Get_global i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Get_global i) = id \\<or>\n  check_single \\<C> (Get_global i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Get_global i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (30 \\<C> i ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Set_global i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (5 subgoals):\n 1. \\<And>\\<C> i ts.\n       \\<lbrakk>check_single \\<C> (Set_global i) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Set_global i) = id \\<or>\n                         check_single \\<C> (Set_global i) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Set_global i) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 5. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Set_global i) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Set_global i) = id \\<or>\n    check_single \\<C> (Set_global i) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Set_global i) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Set_global i) = id \\<or>\n  check_single \\<C> (Set_global i) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Set_global i) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (31 \\<C> t tp_sx a off ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Load t tp_sx a off) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (4 subgoals):\n 1. \\<And>\\<C> t tp_sx a off ts.\n       \\<lbrakk>check_single \\<C> (Load t tp_sx a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Load t tp_sx a off) = id \\<or>\n                         check_single \\<C> (Load t tp_sx a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Load t tp_sx a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 4. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Load t tp_sx a off) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Load t tp_sx a off) = id \\<or>\n    check_single \\<C> (Load t tp_sx a off) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Load t tp_sx a off) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Load t tp_sx a off) = id \\<or>\n  check_single \\<C> (Load t tp_sx a off) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Load t tp_sx a off) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (32 \\<C> t tp a off ts)"], ["proof (state)\nthis:\n  check_single \\<C> (Store t tp a off) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (3 subgoals):\n 1. \\<And>\\<C> t tp a off ts.\n       \\<lbrakk>check_single \\<C> (Store t tp a off) ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> (Store t tp a off) = id \\<or>\n                         check_single \\<C> (Store t tp a off) =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> (Store t tp a off) =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 3. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> (Store t tp a off) ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> (Store t tp a off) = id \\<or>\n    check_single \\<C> (Store t tp a off) = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> (Store t tp a off) =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> (Store t tp a off) = id \\<or>\n  check_single \\<C> (Store t tp a off) = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> (Store t tp a off) =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (33 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Current_memory ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (2 subgoals):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Current_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Current_memory = id \\<or>\n                         check_single \\<C> Current_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Current_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))\n 2. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Current_memory ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Current_memory = id \\<or>\n    check_single \\<C> Current_memory = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Current_memory =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> Current_memory = id \\<or>\n  check_single \\<C> Current_memory = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Current_memory =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "case (34 \\<C> ts)"], ["proof (state)\nthis:\n  check_single \\<C> Grow_memory ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> ts.\n       \\<lbrakk>check_single \\<C> Grow_memory ctn = ctm;\n        ctm \\<noteq> ts\\<rbrakk>\n       \\<Longrightarrow> check_single \\<C> Grow_memory = id \\<or>\n                         check_single \\<C> Grow_memory =\n                         type_update_select \\<or>\n                         (\\<exists>cons prods.\n                             check_single \\<C> Grow_memory =\n                             (\\<lambda>ctn. type_update ctn cons prods))", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> Grow_memory ctn = ctm\n  ctm \\<noteq> ts\n\ngoal (1 subgoal):\n 1. check_single \\<C> Grow_memory = id \\<or>\n    check_single \\<C> Grow_memory = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> Grow_memory =\n        (\\<lambda>ctn. type_update ctn cons prods))", "by (simp, meson assms(2) type_update.simps)"], ["proof (state)\nthis:\n  check_single \\<C> Grow_memory = id \\<or>\n  check_single \\<C> Grow_memory = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> Grow_memory =\n      (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  True\n  True\n  \\<lbrakk>check_single \\<C> e ctn = ctm; ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> e = id \\<or>\n                    check_single \\<C> e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (1 subgoal):\n 1. check_single \\<C> e = id \\<or>\n    check_single \\<C> e = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods))", "thus ?thesis"], ["proof (prove)\nusing this:\n  True\n  True\n  \\<lbrakk>check_single \\<C> e ctn = ctm; ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> e = id \\<or>\n                    check_single \\<C> e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal (1 subgoal):\n 1. check_single \\<C> e = id \\<or>\n    check_single \\<C> e = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods))", "using assms"], ["proof (prove)\nusing this:\n  True\n  True\n  \\<lbrakk>check_single \\<C> e ctn = ctm; ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single \\<C> e = id \\<or>\n                    check_single \\<C> e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single \\<C> e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  check_single \\<C> e ctn = ctm\n  ctm \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. check_single \\<C> e = id \\<or>\n    check_single \\<C> e = type_update_select \\<or>\n    (\\<exists>cons prods.\n        check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods))", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e = id \\<or>\n  check_single \\<C> e = type_update_select \\<or>\n  (\\<exists>cons prods.\n      check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_equiv_fold:\n  \"check \\<C> es ts = foldl (\\<lambda> ts e. (case ts of Bot \\<Rightarrow> Bot | _ \\<Rightarrow> check_single \\<C> e ts)) ts es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts es", "proof (induction es arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       check \\<C> [] ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts []\n 2. \\<And>a es ts.\n       (\\<And>ts.\n           check \\<C> es ts =\n           foldl\n            (\\<lambda>ts e.\n                case ts of Bot \\<Rightarrow> Bot\n                | _ \\<Rightarrow> check_single \\<C> e ts)\n            ts es) \\<Longrightarrow>\n       check \\<C> (a # es) ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts (a # es)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       check \\<C> [] ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts []\n 2. \\<And>a es ts.\n       (\\<And>ts.\n           check \\<C> es ts =\n           foldl\n            (\\<lambda>ts e.\n                case ts of Bot \\<Rightarrow> Bot\n                | _ \\<Rightarrow> check_single \\<C> e ts)\n            ts es) \\<Longrightarrow>\n       check \\<C> (a # es) ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts (a # es)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> [] ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts []", "by simp"], ["proof (state)\nthis:\n  check \\<C> [] ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts []\n\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       (\\<And>ts.\n           check \\<C> es ts =\n           foldl\n            (\\<lambda>ts e.\n                case ts of Bot \\<Rightarrow> Bot\n                | _ \\<Rightarrow> check_single \\<C> e ts)\n            ts es) \\<Longrightarrow>\n       check \\<C> (a # es) ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts (a # es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       (\\<And>ts.\n           check \\<C> es ts =\n           foldl\n            (\\<lambda>ts e.\n                case ts of Bot \\<Rightarrow> Bot\n                | _ \\<Rightarrow> check_single \\<C> e ts)\n            ts es) \\<Longrightarrow>\n       check \\<C> (a # es) ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts (a # es)", "case (Cons e es)"], ["proof (state)\nthis:\n  check \\<C> es ?ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ?ts es\n\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       (\\<And>ts.\n           check \\<C> es ts =\n           foldl\n            (\\<lambda>ts e.\n                case ts of Bot \\<Rightarrow> Bot\n                | _ \\<Rightarrow> check_single \\<C> e ts)\n            ts es) \\<Longrightarrow>\n       check \\<C> (a # es) ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts (a # es)", "obtain ts' where ts'_def:\"check \\<C> (e # es) ts = ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'.\n        check \\<C> (e # es) ts = ts' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check \\<C> (e # es) ts = ts'\n\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       (\\<And>ts.\n           check \\<C> es ts =\n           foldl\n            (\\<lambda>ts e.\n                case ts of Bot \\<Rightarrow> Bot\n                | _ \\<Rightarrow> check_single \\<C> e ts)\n            ts es) \\<Longrightarrow>\n       check \\<C> (a # es) ts =\n       foldl\n        (\\<lambda>ts e.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        ts (a # es)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "proof (cases \"ts = Bot\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ts = Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)\n 2. ts \\<noteq> Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "case True"], ["proof (state)\nthis:\n  ts = Bot\n\ngoal (2 subgoals):\n 1. ts = Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)\n 2. ts \\<noteq> Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts = Bot\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "using ts'_def"], ["proof (prove)\nusing this:\n  ts = Bot\n  check \\<C> (e # es) ts = ts'\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "by (induction es, simp_all)"], ["proof (state)\nthis:\n  check \\<C> (e # es) ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (e # es)\n\ngoal (1 subgoal):\n 1. ts \\<noteq> Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ts \\<noteq> Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "case False"], ["proof (state)\nthis:\n  ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. ts \\<noteq> Bot \\<Longrightarrow>\n    check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "using ts'_def Cons"], ["proof (prove)\nusing this:\n  ts \\<noteq> Bot\n  check \\<C> (e # es) ts = ts'\n  check \\<C> es ?ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ?ts es\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (e # es)", "by (cases ts, simp_all)"], ["proof (state)\nthis:\n  check \\<C> (e # es) ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (e # es)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check \\<C> (e # es) ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (e # es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_neq_bot_snoc:\n  assumes \"check \\<C> (es@[e]) ts \\<noteq> Bot\"\n  shows \"check \\<C> es ts \\<noteq> Bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es ts \\<noteq> Bot", "using assms"], ["proof (prove)\nusing this:\n  check \\<C> (es @ [e]) ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. check \\<C> es ts \\<noteq> Bot", "proof (induction es arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       check \\<C> ([] @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n       check \\<C> [] ts \\<noteq> Bot\n 2. \\<And>a es ts.\n       \\<lbrakk>\\<And>ts.\n                   check \\<C> (es @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n                   check \\<C> es ts \\<noteq> Bot;\n        check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) ts \\<noteq> Bot", "case Nil"], ["proof (state)\nthis:\n  check \\<C> ([] @ [e]) ts \\<noteq> Bot\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       check \\<C> ([] @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n       check \\<C> [] ts \\<noteq> Bot\n 2. \\<And>a es ts.\n       \\<lbrakk>\\<And>ts.\n                   check \\<C> (es @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n                   check \\<C> es ts \\<noteq> Bot;\n        check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) ts \\<noteq> Bot", "thus ?case"], ["proof (prove)\nusing this:\n  check \\<C> ([] @ [e]) ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. check \\<C> [] ts \\<noteq> Bot", "by (cases ts, simp_all)"], ["proof (state)\nthis:\n  check \\<C> [] ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       \\<lbrakk>\\<And>ts.\n                   check \\<C> (es @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n                   check \\<C> es ts \\<noteq> Bot;\n        check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) ts \\<noteq> Bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       \\<lbrakk>\\<And>ts.\n                   check \\<C> (es @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n                   check \\<C> es ts \\<noteq> Bot;\n        check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) ts \\<noteq> Bot", "case (Cons a es)"], ["proof (state)\nthis:\n  check \\<C> (es @ [e]) ?ts \\<noteq> Bot \\<Longrightarrow>\n  check \\<C> es ?ts \\<noteq> Bot\n  check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. \\<And>a es ts.\n       \\<lbrakk>\\<And>ts.\n                   check \\<C> (es @ [e]) ts \\<noteq> Bot \\<Longrightarrow>\n                   check \\<C> es ts \\<noteq> Bot;\n        check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) ts \\<noteq> Bot", "thus ?case"], ["proof (prove)\nusing this:\n  check \\<C> (es @ [e]) ?ts \\<noteq> Bot \\<Longrightarrow>\n  check \\<C> es ?ts \\<noteq> Bot\n  check \\<C> ((a # es) @ [e]) ts \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. check \\<C> (a # es) ts \\<noteq> Bot", "by (cases ts, simp_all)"], ["proof (state)\nthis:\n  check \\<C> (a # es) ts \\<noteq> Bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_unfold_snoc:\n  assumes \"check \\<C> es ts \\<noteq> Bot\"\n  shows \"check \\<C> (es@[e]) ts = check_single \\<C> e (check \\<C> es ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "obtain f where f_def:\"f = (\\<lambda> e ts. (case ts of Bot \\<Rightarrow> Bot | _ \\<Rightarrow> check_single \\<C> e ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f =\n        (\\<lambda>e ts.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f =\n  (\\<lambda>e ts.\n      case ts of Bot \\<Rightarrow> Bot\n      | _ \\<Rightarrow> check_single \\<C> e ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "have f_simp:\"\\<And>ts. ts \\<noteq> Bot \\<Longrightarrow> (f e ts = check_single \\<C> e ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       ts \\<noteq> Bot \\<Longrightarrow> f e ts = check_single \\<C> e ts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       ts \\<noteq> Bot \\<Longrightarrow> f e ts = check_single \\<C> e ts", "fix ts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       ts \\<noteq> Bot \\<Longrightarrow> f e ts = check_single \\<C> e ts", "show \"ts \\<noteq> Bot \\<Longrightarrow> (f e ts = check_single \\<C> e ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<noteq> Bot \\<Longrightarrow> f e ts = check_single \\<C> e ts", "using f_def"], ["proof (prove)\nusing this:\n  f =\n  (\\<lambda>e ts.\n      case ts of Bot \\<Rightarrow> Bot\n      | _ \\<Rightarrow> check_single \\<C> e ts)\n\ngoal (1 subgoal):\n 1. ts \\<noteq> Bot \\<Longrightarrow> f e ts = check_single \\<C> e ts", "by (cases ts, simp_all)"], ["proof (state)\nthis:\n  ts \\<noteq> Bot \\<Longrightarrow> f e ts = check_single \\<C> e ts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ts \\<noteq> Bot \\<Longrightarrow> f e ?ts = check_single \\<C> e ?ts\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "have \"check \\<C> (es@[e]) ts = foldl (\\<lambda> ts e. (case ts of Bot \\<Rightarrow> Bot | _ \\<Rightarrow> check_single \\<C> e ts)) ts (es@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (es @ [e])", "using check_equiv_fold"], ["proof (prove)\nusing this:\n  check ?\\<C> ?es ?ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single ?\\<C> e ts)\n   ?ts ?es\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts =\n    foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (es @ [e])", "by simp"], ["proof (state)\nthis:\n  check \\<C> (es @ [e]) ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (es @ [e])\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "also"], ["proof (state)\nthis:\n  check \\<C> (es @ [e]) ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (es @ [e])\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "have \"... = foldr (\\<lambda> e ts. (case ts of Bot \\<Rightarrow> Bot | _ \\<Rightarrow> check_single \\<C> e ts)) (rev (es@[e])) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (es @ [e]) =\n    foldr\n     (\\<lambda>e ts.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     (rev (es @ [e])) ts", "using foldl_conv_foldr"], ["proof (prove)\nusing this:\n  foldl ?f ?a ?xs = foldr (\\<lambda>x y. ?f y x) (rev ?xs) ?a\n\ngoal (1 subgoal):\n 1. foldl\n     (\\<lambda>ts e.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     ts (es @ [e]) =\n    foldr\n     (\\<lambda>e ts.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     (rev (es @ [e])) ts", "by fastforce"], ["proof (state)\nthis:\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (es @ [e]) =\n  foldr\n   (\\<lambda>e ts.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   (rev (es @ [e])) ts\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "also"], ["proof (state)\nthis:\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   ts (es @ [e]) =\n  foldr\n   (\\<lambda>e ts.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   (rev (es @ [e])) ts\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "have \"... = f e (foldr (\\<lambda> e ts. (case ts of Bot \\<Rightarrow> Bot | _ \\<Rightarrow> check_single \\<C> e ts)) (rev es) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>e ts.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     (rev (es @ [e])) ts =\n    f e (foldr\n          (\\<lambda>e ts.\n              case ts of Bot \\<Rightarrow> Bot\n              | _ \\<Rightarrow> check_single \\<C> e ts)\n          (rev es) ts)", "using f_def"], ["proof (prove)\nusing this:\n  f =\n  (\\<lambda>e ts.\n      case ts of Bot \\<Rightarrow> Bot\n      | _ \\<Rightarrow> check_single \\<C> e ts)\n\ngoal (1 subgoal):\n 1. foldr\n     (\\<lambda>e ts.\n         case ts of Bot \\<Rightarrow> Bot\n         | _ \\<Rightarrow> check_single \\<C> e ts)\n     (rev (es @ [e])) ts =\n    f e (foldr\n          (\\<lambda>e ts.\n              case ts of Bot \\<Rightarrow> Bot\n              | _ \\<Rightarrow> check_single \\<C> e ts)\n          (rev es) ts)", "by simp"], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>e ts.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   (rev (es @ [e])) ts =\n  f e (foldr\n        (\\<lambda>e ts.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        (rev es) ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "also"], ["proof (state)\nthis:\n  foldr\n   (\\<lambda>e ts.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single \\<C> e ts)\n   (rev (es @ [e])) ts =\n  f e (foldr\n        (\\<lambda>e ts.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        (rev es) ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "have \"... = f e (check \\<C> es ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e (foldr\n          (\\<lambda>e ts.\n              case ts of Bot \\<Rightarrow> Bot\n              | _ \\<Rightarrow> check_single \\<C> e ts)\n          (rev es) ts) =\n    f e (check \\<C> es ts)", "using foldr_conv_foldl[of _ \"(rev es)\" ts] rev_rev_ident[of es] check_equiv_fold"], ["proof (prove)\nusing this:\n  foldr ?f (rev es) ts = foldl (\\<lambda>x y. ?f y x) ts (rev (rev es))\n  rev (rev es) = es\n  check ?\\<C> ?es ?ts =\n  foldl\n   (\\<lambda>ts e.\n       case ts of Bot \\<Rightarrow> Bot\n       | _ \\<Rightarrow> check_single ?\\<C> e ts)\n   ?ts ?es\n\ngoal (1 subgoal):\n 1. f e (foldr\n          (\\<lambda>e ts.\n              case ts of Bot \\<Rightarrow> Bot\n              | _ \\<Rightarrow> check_single \\<C> e ts)\n          (rev es) ts) =\n    f e (check \\<C> es ts)", "by simp"], ["proof (state)\nthis:\n  f e (foldr\n        (\\<lambda>e ts.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        (rev es) ts) =\n  f e (check \\<C> es ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "also"], ["proof (state)\nthis:\n  f e (foldr\n        (\\<lambda>e ts.\n            case ts of Bot \\<Rightarrow> Bot\n            | _ \\<Rightarrow> check_single \\<C> e ts)\n        (rev es) ts) =\n  f e (check \\<C> es ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "have \"... = check_single \\<C> e (check \\<C> es ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f e (check \\<C> es ts) = check_single \\<C> e (check \\<C> es ts)", "using assms f_simp"], ["proof (prove)\nusing this:\n  check \\<C> es ts \\<noteq> Bot\n  ?ts \\<noteq> Bot \\<Longrightarrow> f e ?ts = check_single \\<C> e ?ts\n\ngoal (1 subgoal):\n 1. f e (check \\<C> es ts) = check_single \\<C> e (check \\<C> es ts)", "by simp"], ["proof (state)\nthis:\n  f e (check \\<C> es ts) = check_single \\<C> e (check \\<C> es ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "finally"], ["proof (chain)\npicking this:\n  check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)", "."], ["proof (state)\nthis:\n  check \\<C> (es @ [e]) ts = check_single \\<C> e (check \\<C> es ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_single_imp_weakening:\n  assumes \"check_single \\<C> e (Type t1s) = ctm\"\n          \"ctm \\<noteq> Bot\"\n          \"c_types_agree ctn t1s\"\n          \"c_types_agree ctm t2s\"\n  shows \"\\<exists>ctm'. check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "consider (1) \"check_single \\<C> e = id\" \n         | (2) \"check_single \\<C> e = (\\<lambda>ctn. type_update_select ctn)\"\n         | (3) \"(\\<exists>cons prods. (check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using check_single_imp assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single ?\\<C> ?e ?ctn = ?ctm; ?ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single ?\\<C> ?e = id \\<or>\n                    check_single ?\\<C> ?e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single ?\\<C> ?e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 1"], ["proof (state)\nthis:\n  check_single \\<C> e = id\n\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using assms(1,3,4)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n  check_single \\<C> e (Type t1s) = ctm\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "(* TODO: better proof *)"], ["proof (state)\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 2"], ["proof (state)\nthis:\n  check_single \\<C> e = type_update_select\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "note outer_2 = 2"], ["proof (state)\nthis:\n  check_single \\<C> e = type_update_select\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence t1s_cond:\"(length t1s \\<ge> 3 \\<and> (t1s!(length t1s-2)) = (t1s!(length t1s-3)))\""], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. 3 \\<le> length t1s \\<and>\n    t1s ! (length t1s - 2) = t1s ! (length t1s - 3)", "using assms(1,2)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. 3 \\<le> length t1s \\<and>\n    t1s ! (length t1s - 2) = t1s ! (length t1s - 3)", "by (simp, meson)"], ["proof (state)\nthis:\n  3 \\<le> length t1s \\<and> t1s ! (length t1s - 2) = t1s ! (length t1s - 3)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence ctm_def:\"ctm = consume (Type t1s) [TAny, TSome T_i32]\""], ["proof (prove)\nusing this:\n  3 \\<le> length t1s \\<and> t1s ! (length t1s - 2) = t1s ! (length t1s - 3)\n\ngoal (1 subgoal):\n 1. ctm = consume (Type t1s) [TAny, TSome T_i32]", "using assms(1,2) 2"], ["proof (prove)\nusing this:\n  3 \\<le> length t1s \\<and> t1s ! (length t1s - 2) = t1s ! (length t1s - 3)\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. ctm = consume (Type t1s) [TAny, TSome T_i32]", "by simp"], ["proof (state)\nthis:\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "then"], ["proof (chain)\npicking this:\n  ctm = consume (Type t1s) [TAny, TSome T_i32]", "obtain c_t where c_t_def:\"ctm = Type c_t\""], ["proof (prove)\nusing this:\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n\ngoal (1 subgoal):\n 1. (\\<And>c_t. ctm = Type c_t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n  ctm \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. (\\<And>c_t. ctm = Type c_t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson consume.simps(1))"], ["proof (state)\nthis:\n  ctm = Type c_t\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence t2s_eq:\"t2s = c_t\""], ["proof (prove)\nusing this:\n  ctm = Type c_t\n\ngoal (1 subgoal):\n 1. t2s = c_t", "using assms(4)"], ["proof (prove)\nusing this:\n  ctm = Type c_t\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. t2s = c_t", "by simp"], ["proof (state)\nthis:\n  t2s = c_t\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence t2s_len:\"length t2s > 0\""], ["proof (prove)\nusing this:\n  t2s = c_t\n\ngoal (1 subgoal):\n 1. 0 < length t2s", "using t1s_cond ctm_def c_t_def assms(2)"], ["proof (prove)\nusing this:\n  t2s = c_t\n  3 \\<le> length t1s \\<and> t1s ! (length t1s - 2) = t1s ! (length t1s - 3)\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n  ctm = Type c_t\n  ctm \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. 0 < length t2s", "by (metis Suc_leI Suc_n_not_le_n checker_type.inject(2) consume.simps(1)\n                diff_is_0_eq dual_order.trans length_0_conv length_Cons length_greater_0_conv\n                nat.simps(3) numeral_3_eq_3 take_eq_Nil)"], ["proof (state)\nthis:\n  0 < length t2s\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have t1s_suffix_full:\"ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)", "using assms(2) ctm_def ct_suffix_less"], ["proof (prove)\nusing this:\n  ctm \\<noteq> Bot\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n  ct_suffix (?xs @ ?xs') ?ys \\<Longrightarrow> ct_suffix ?xs' ?ys\n\ngoal (1 subgoal):\n 1. ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)", "by (metis consume.simps(1))"], ["proof (state)\nthis:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence t1s_suffix:\"ct_suffix [TSome T_i32] (to_ct_list t1s)\""], ["proof (prove)\nusing this:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] (to_ct_list t1s)", "using assms(2) ctm_def ct_suffix_less"], ["proof (prove)\nusing this:\n  ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)\n  ctm \\<noteq> Bot\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n  ct_suffix (?xs @ ?xs') ?ys \\<Longrightarrow> ct_suffix ?xs' ?ys\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] (to_ct_list t1s)", "by (metis append_butlast_last_id last.simps list.distinct(1))"], ["proof (state)\nthis:\n  ct_suffix [TSome T_i32] (to_ct_list t1s)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "obtain t t1s' where t1s_suffix2:\"t1s = t1s'@[t,t,T_i32]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1s' t.\n        t1s = t1s' @ [t, t, T_i32] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using type_update_select_type_length3 assms(1) c_t_def outer_2"], ["proof (prove)\nusing this:\n  type_update_select (Type ?tn) = Type ?tm \\<Longrightarrow>\n  \\<exists>t ts'. ?tn = ts' @ [t, t, T_i32]\n  check_single \\<C> e (Type t1s) = ctm\n  ctm = Type c_t\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. (\\<And>t1s' t.\n        t1s = t1s' @ [t, t, T_i32] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  t1s = t1s' @ [t, t, T_i32]\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence t2s_def:\"t2s = t1s'@[t]\""], ["proof (prove)\nusing this:\n  t1s = t1s' @ [t, t, T_i32]\n\ngoal (1 subgoal):\n 1. t2s = t1s' @ [t]", "using ctm_def c_t_def t2s_eq t1s_suffix assms(2) t1s_suffix_full"], ["proof (prove)\nusing this:\n  t1s = t1s' @ [t, t, T_i32]\n  ctm = consume (Type t1s) [TAny, TSome T_i32]\n  ctm = Type c_t\n  t2s = c_t\n  ct_suffix [TSome T_i32] (to_ct_list t1s)\n  ctm \\<noteq> Bot\n  ct_suffix [TAny, TSome T_i32] (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. t2s = t1s' @ [t]", "by simp"], ["proof (state)\nthis:\n  t2s = t1s' @ [t]\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using assms(1,3,4)"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type t1s) = ctm\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof (cases ctn)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 3. \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n     c_types_agree ctm t2s; ctn = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "case (TopType x1)"], ["proof (state)\nthis:\n  ctn = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 3. \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n     c_types_agree ctm t2s; ctn = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "consider\n          (1) \"length x1 = 0\"\n        | (2) \"length x1 = 1\"\n        | (3) \"length x1 = 2\"\n        | (4) \"length x1 \\<ge> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = 0 \\<Longrightarrow> thesis;\n     length x1 = 1 \\<Longrightarrow> thesis;\n     length x1 = 2 \\<Longrightarrow> thesis;\n     3 \\<le> length x1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length x1 = 0 \\<Longrightarrow> ?thesis;\n   length x1 = 1 \\<Longrightarrow> ?thesis;\n   length x1 = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> length x1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 3. \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n     c_types_agree ctm t2s; ctn = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length x1 = 0 \\<Longrightarrow> ?thesis;\n   length x1 = 1 \\<Longrightarrow> ?thesis;\n   length x1 = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> length x1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 1"], ["proof (state)\nthis:\n  length x1 = 0\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"check_single \\<C> e ctn = TopType [TAny]\""], ["proof (prove)\nusing this:\n  length x1 = 0\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn = TopType [TAny]", "using 2 TopType"], ["proof (prove)\nusing this:\n  length x1 = 0\n  check_single \\<C> e = type_update_select\n  ctn = TopType x1\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn = TopType [TAny]", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e ctn = TopType [TAny]\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 4. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e ctn = TopType [TAny]\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using ct_suffix_singleton to_ct_list_def t2s_len"], ["proof (prove)\nusing this:\n  check_single \\<C> e ctn = TopType [TAny]\n  0 < length ?cts \\<Longrightarrow> ct_suffix [TAny] ?cts\n  to_ct_list ?ts = map TSome ?ts\n  0 < length t2s\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by auto"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 2"], ["proof (state)\nthis:\n  length x1 = 1\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"ct_suffix [TSome T_i32] x1\""], ["proof (prove)\nusing this:\n  length x1 = 1\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "using assms(3) TopType ct_suffix_imp_ct_list_eq ct_suffix_shared t1s_suffix"], ["proof (prove)\nusing this:\n  length x1 = 1\n  c_types_agree ctn t1s\n  ctn = TopType x1\n  ct_suffix ?xs ?ys \\<Longrightarrow>\n  ct_list_eq (drop (length ?ys - length ?xs) ?ys) ?xs\n  \\<lbrakk>ct_suffix ?cts (to_ct_list ?ts);\n   ct_suffix ?cts' (to_ct_list ?ts)\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ?cts ?cts' \\<or> ct_suffix ?cts' ?cts\n  ct_suffix [TSome T_i32] (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "by (metis One_nat_def append_Nil c_types_agree.simps(2) ct_list_eq_commute ct_suffix_def\n                    diff_self_eq_0 drop_0 length_Cons list.size(3))"], ["proof (state)\nthis:\n  ct_suffix [TSome T_i32] x1\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"check_single \\<C> e ctn = TopType [TAny]\""], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn = TopType [TAny]", "using outer_2 TopType 2"], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n  check_single \\<C> e = type_update_select\n  ctn = TopType x1\n  length x1 = 1\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn = TopType [TAny]", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e ctn = TopType [TAny]\n\ngoal (3 subgoals):\n 1. length x1 = 1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e ctn = TopType [TAny]\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using t2s_len ct_suffix_singleton"], ["proof (prove)\nusing this:\n  check_single \\<C> e ctn = TopType [TAny]\n  0 < length t2s\n  0 < length ?cts \\<Longrightarrow> ct_suffix [TAny] ?cts\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by (simp add: to_ct_list_def)"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 3"], ["proof (state)\nthis:\n  length x1 = 2\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"ct_list_eq (to_ct_list t1s) (to_ct_list (t1s' @ [t, t, T_i32]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_list_eq (to_ct_list t1s) (to_ct_list (t1s' @ [t, t, T_i32]))", "using t1s_suffix2"], ["proof (prove)\nusing this:\n  t1s = t1s' @ [t, t, T_i32]\n\ngoal (1 subgoal):\n 1. ct_list_eq (to_ct_list t1s) (to_ct_list (t1s' @ [t, t, T_i32]))", "by (simp add: ct_list_eq_ts_conv_eq)"], ["proof (state)\nthis:\n  ct_list_eq (to_ct_list t1s) (to_ct_list (t1s' @ [t, t, T_i32]))\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence temp1:\"to_ct_list t1s = (to_ct_list (t1s' @ [t])) @ (to_ct_list [t, T_i32])\""], ["proof (prove)\nusing this:\n  ct_list_eq (to_ct_list t1s) (to_ct_list (t1s' @ [t, t, T_i32]))\n\ngoal (1 subgoal):\n 1. to_ct_list t1s = to_ct_list (t1s' @ [t]) @ to_ct_list [t, T_i32]", "using t1s_suffix2 to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_list_eq (to_ct_list t1s) (to_ct_list (t1s' @ [t, t, T_i32]))\n  t1s = t1s' @ [t, t, T_i32]\n  to_ct_list ?ts = map TSome ?ts\n\ngoal (1 subgoal):\n 1. to_ct_list t1s = to_ct_list (t1s' @ [t]) @ to_ct_list [t, T_i32]", "by simp"], ["proof (state)\nthis:\n  to_ct_list t1s = to_ct_list (t1s' @ [t]) @ to_ct_list [t, T_i32]\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s)\""], ["proof (prove)\nusing this:\n  to_ct_list t1s = to_ct_list (t1s' @ [t]) @ to_ct_list [t, T_i32]\n\ngoal (1 subgoal):\n 1. ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s)", "using ct_suffix_def[of \"(to_ct_list [t, T_i32])\" \"(to_ct_list t1s)\"]"], ["proof (prove)\nusing this:\n  to_ct_list t1s = to_ct_list (t1s' @ [t]) @ to_ct_list [t, T_i32]\n  ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s) =\n  (\\<exists>as bs.\n      to_ct_list t1s = as @ bs \\<and> ct_list_eq bs (to_ct_list [t, T_i32]))\n\ngoal (1 subgoal):\n 1. ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s)", "by (simp add: ct_suffix_cons_it)"], ["proof (state)\nthis:\n  ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s)\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"ct_suffix (to_ct_list [t, T_i32]) x1\""], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. ct_suffix (to_ct_list [t, T_i32]) x1", "using assms(3) TopType 3"], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list [t, T_i32]) (to_ct_list t1s)\n  c_types_agree ctn t1s\n  ctn = TopType x1\n  length x1 = 2\n\ngoal (1 subgoal):\n 1. ct_suffix (to_ct_list [t, T_i32]) x1", "by (simp, metis temp1 append_Nil ct_suffix_cons2 ct_suffix_def length_Cons length_map\n                          list.size(3) numeral_2_eq_2 to_ct_list_def)"], ["proof (state)\nthis:\n  ct_suffix (to_ct_list [t, T_i32]) x1\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence temp3:\"ct_list_eq (to_ct_list [t, T_i32]) x1\""], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list [t, T_i32]) x1\n\ngoal (1 subgoal):\n 1. ct_list_eq (to_ct_list [t, T_i32]) x1", "using 3 ct_suffix_imp_ct_list_eq"], ["proof (prove)\nusing this:\n  ct_suffix (to_ct_list [t, T_i32]) x1\n  length x1 = 2\n  ct_suffix ?xs ?ys \\<Longrightarrow>\n  ct_list_eq (drop (length ?ys - length ?xs) ?ys) ?xs\n\ngoal (1 subgoal):\n 1. ct_list_eq (to_ct_list [t, T_i32]) x1", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_suffix (map TSome [t, T_i32]) x1\n  length x1 = 2\n  ct_suffix ?xs ?ys \\<Longrightarrow>\n  ct_list_eq (drop (length ?ys - length ?xs) ?ys) ?xs\n\ngoal (1 subgoal):\n 1. ct_list_eq (map TSome [t, T_i32]) x1", "by (metis Suc_leI ct_list_eq_commute diff_is_0_eq drop_0 length_Cons length_map lessI\n                    list.size(3) numeral_2_eq_2)"], ["proof (state)\nthis:\n  ct_list_eq (to_ct_list [t, T_i32]) x1\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence temp4:\"ct_suffix [TSome T_i32] x1\""], ["proof (prove)\nusing this:\n  ct_list_eq (to_ct_list [t, T_i32]) x1\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "using ct_suffix_less[of \"[TSome t]\" \"[TSome T_i32]\" x1]\n                ct_suffix_extend_ct_list_eq[of \"[]\" \"[]\"] ct_suffix_nil"], ["proof (prove)\nusing this:\n  ct_list_eq (to_ct_list [t, T_i32]) x1\n  ct_suffix ([TSome t] @ [TSome T_i32]) x1 \\<Longrightarrow>\n  ct_suffix [TSome T_i32] x1\n  \\<lbrakk>ct_suffix [] []; ct_list_eq ?xs' ?ys'\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ([] @ ?xs') ([] @ ?ys')\n  ct_suffix [] ?ts\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_list_eq (map TSome [t, T_i32]) x1\n  ct_suffix ([TSome t] @ [TSome T_i32]) x1 \\<Longrightarrow>\n  ct_suffix [TSome T_i32] x1\n  \\<lbrakk>ct_suffix [] []; ct_list_eq ?xs' ?ys'\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ([] @ ?xs') ([] @ ?ys')\n  ct_suffix [] ?ts\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "by fastforce"], ["proof (state)\nthis:\n  ct_suffix [TSome T_i32] x1\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"ct_suffix (take 1 x1) (to_ct_list [t])\""], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n\ngoal (1 subgoal):\n 1. ct_suffix (take 1 x1) (to_ct_list [t])", "using temp3 ct_suffix_nil ct_list_eq_commute ct_suffix_extend_ct_list_eq[of \"[]\" \"[]\" \"(take 1 x1)\" \"(to_ct_list [t])\"]"], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n  ct_list_eq (to_ct_list [t, T_i32]) x1\n  ct_suffix [] ?ts\n  ct_list_eq ?xs ?ys \\<Longrightarrow> ct_list_eq ?ys ?xs\n  \\<lbrakk>ct_suffix [] []; ct_list_eq (take 1 x1) (to_ct_list [t])\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ([] @ take 1 x1) ([] @ to_ct_list [t])\n\ngoal (1 subgoal):\n 1. ct_suffix (take 1 x1) (to_ct_list [t])", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n  ct_list_eq (map TSome [t, T_i32]) x1\n  ct_suffix [] ?ts\n  ct_list_eq ?xs ?ys \\<Longrightarrow> ct_list_eq ?ys ?xs\n  \\<lbrakk>ct_suffix [] []; ct_list_eq (take 1 x1) (map TSome [t])\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ([] @ take 1 x1) ([] @ map TSome [t])\n\ngoal (1 subgoal):\n 1. ct_suffix (take 1 x1) (map TSome [t])", "by (simp, metis butlast.simps(2) butlast_conv_take ct_list_eq_take diff_Suc_1 length_Cons\n                          list.distinct(1) list.size(3))"], ["proof (state)\nthis:\n  ct_suffix (take 1 x1) (to_ct_list [t])\n\ngoal (2 subgoals):\n 1. length x1 = 2 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  ct_suffix (take 1 x1) (to_ct_list [t])\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using TopType 2 3 ct_suffix_nil temp3 temp4 t2s_def to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_suffix (take 1 x1) (to_ct_list [t])\n  ctn = TopType x1\n  check_single \\<C> e = type_update_select\n  length x1 = 2\n  ct_suffix [] ?ts\n  ct_list_eq (to_ct_list [t, T_i32]) x1\n  ct_suffix [TSome T_i32] x1\n  t2s = t1s' @ [t]\n  to_ct_list ?ts = map TSome ?ts\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "apply (simp, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ct_suffix (take (Suc 0) x1) [TSome t];\n     check_single \\<C> e = type_update_select; length x1 = 2;\n     \\<And>ts. ct_suffix [] ts; ct_list_eq [TSome t, TSome T_i32] x1;\n     ct_suffix [TSome T_i32] x1; t2s = t1s' @ [t];\n     \\<And>ts. to_ct_list ts = map TSome ts;\n     ct_suffix (take 1 x1) (to_ct_list [t]);\n     check_single \\<C> e = type_update_select; length x1 = 2;\n     \\<And>ts. ct_suffix [] ts; ct_list_eq (to_ct_list [t, T_i32]) x1;\n     ct_suffix [TSome T_i32] x1; \\<And>ts. to_ct_list ts = map TSome ts;\n     ctn = TopType x1\\<rbrakk>\n    \\<Longrightarrow> ct_suffix (take (Suc 0) x1)\n                       (map TSome t1s' @ [TSome t])", "apply (metis append.assoc ct_suffix_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 4"], ["proof (state)\nthis:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "then"], ["proof (chain)\npicking this:\n  3 \\<le> length x1", "obtain nat where nat_def:\"length x1 = Suc (Suc (Suc nat))\""], ["proof (prove)\nusing this:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. (\\<And>nat.\n        length x1 = Suc (Suc (Suc nat)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis add_eq_if diff_Suc_1 le_Suc_ex numeral_3_eq_3 nat.distinct(2))"], ["proof (state)\nthis:\n  length x1 = Suc (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "obtain x1' x x' x'' where x1_split:\"x1 = x1'@[x,x',x'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1' x x' x''.\n        x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x1' x x' x''.\n        x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume local_assms:\"(\\<And>x1' x x' x''. x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis)\""], ["proof (state)\nthis:\n  x1 = ?x1' @ [?x, ?x', ?x''] \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x x' x''.\n        x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain x1' x1'' where tn_split:\"x1 = x1'@x1''\"\n                               \"length x1'' = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1' x1''.\n        \\<lbrakk>x1 = x1' @ x1''; length x1'' = 3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 4"], ["proof (prove)\nusing this:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x1''.\n        \\<lbrakk>x1 = x1' @ x1''; length x1'' = 3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_take_drop_id diff_diff_cancel length_drop)"], ["proof (state)\nthis:\n  x1 = x1' @ x1''\n  length x1'' = 3\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x x' x''.\n        x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x1 = x1' @ x1''\n  length x1'' = 3", "obtain x x1''2 where \"x1'' = x#x1''2\" \"length x1''2 = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  x1 = x1' @ x1''\n  length x1'' = 3\n\ngoal (1 subgoal):\n 1. (\\<And>x x1''2.\n        \\<lbrakk>x1'' = x # x1''2; length x1''2 = Suc (Suc 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv numeral_3_eq_3)"], ["proof (state)\nthis:\n  x1'' = x # x1''2\n  length x1''2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x x' x''.\n        x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x1'' = x # x1''2\n  length x1''2 = Suc (Suc 0)", "obtain x' x'' where tn''_def:\"x1''= [x,x',x'']\""], ["proof (prove)\nusing this:\n  x1'' = x # x1''2\n  length x1''2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x' x''.\n        x1'' = [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using List.length_Suc_conv[of x1''2 \"Suc 0\"]"], ["proof (prove)\nusing this:\n  x1'' = x # x1''2\n  length x1''2 = Suc (Suc 0)\n  (length x1''2 = Suc (Suc 0)) =\n  (\\<exists>y ys. x1''2 = y # ys \\<and> length ys = Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x' x''.\n        x1'' = [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  x1'' = [x, x', x'']\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x x' x''.\n        x1 = x1' @ [x, x', x''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x1'' = [x, x', x'']\n\ngoal (1 subgoal):\n 1. thesis", "using tn_split local_assms"], ["proof (prove)\nusing this:\n  x1'' = [x, x', x'']\n  x1 = x1' @ x1''\n  length x1'' = 3\n  x1 = ?x1' @ [?x, ?x', ?x''] \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 = x1' @ [x, x', x'']\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence a:\"ct_suffix (x1'@[x,x',x'']) (to_ct_list (t1s' @ [t, t, T_i32]))\""], ["proof (prove)\nusing this:\n  x1 = x1' @ [x, x', x'']\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x, x', x'']) (to_ct_list (t1s' @ [t, t, T_i32]))", "using t1s_suffix2 assms(3) TopType"], ["proof (prove)\nusing this:\n  x1 = x1' @ [x, x', x'']\n  t1s = t1s' @ [t, t, T_i32]\n  c_types_agree ctn t1s\n  ctn = TopType x1\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x, x', x'']) (to_ct_list (t1s' @ [t, t, T_i32]))", "by simp"], ["proof (state)\nthis:\n  ct_suffix (x1' @ [x, x', x'']) (to_ct_list (t1s' @ [t, t, T_i32]))\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence b:\"ct_suffix (x1'@[x,x']) (to_ct_list (t1s' @ [t, t])) \\<and> (ct_eq x'' (TSome T_i32))\""], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x, x', x'']) (to_ct_list (t1s' @ [t, t, T_i32]))\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])) \\<and>\n    ct_eq x'' (TSome T_i32)", "using to_ct_list_def ct_suffix_unfold_one[of \"(x1'@[x,x'])\" \"x''\" \"to_ct_list (t1s' @ [t, t])\"]"], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x, x', x'']) (to_ct_list (t1s' @ [t, t, T_i32]))\n  to_ct_list ?ts = map TSome ?ts\n  ct_suffix ((x1' @ [x, x']) @ [x'']) (to_ct_list (t1s' @ [t, t]) @ [?y]) =\n  (ct_eq x'' ?y \\<and>\n   ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])))\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])) \\<and>\n    ct_eq x'' (TSome T_i32)", "by fastforce"], ["proof (state)\nthis:\n  ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])) \\<and>\n  ct_eq x'' (TSome T_i32)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence c:\"ct_suffix (x1'@[x]) (to_ct_list (t1s' @ [t])) \\<and> (ct_eq x' (TSome t))\""], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])) \\<and>\n  ct_eq x'' (TSome T_i32)\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and>\n    ct_eq x' (TSome t)", "using to_ct_list_def ct_suffix_unfold_one[of \"(x1'@[x])\" \"x'\" \"to_ct_list (t1s' @ [t])\"]"], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])) \\<and>\n  ct_eq x'' (TSome T_i32)\n  to_ct_list ?ts = map TSome ?ts\n  ct_suffix ((x1' @ [x]) @ [x']) (to_ct_list (t1s' @ [t]) @ [?y]) =\n  (ct_eq x' ?y \\<and> ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])))\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and>\n    ct_eq x' (TSome t)", "by fastforce"], ["proof (state)\nthis:\n  ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and> ct_eq x' (TSome t)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence d:\"ct_suffix x1' (to_ct_list t1s') \\<and> (ct_eq x (TSome t))\""], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and> ct_eq x' (TSome t)\n\ngoal (1 subgoal):\n 1. ct_suffix x1' (to_ct_list t1s') \\<and> ct_eq x (TSome t)", "using to_ct_list_def ct_suffix_unfold_one[of \"(x1')\" \"x\" \"to_ct_list (t1s')\"]"], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and> ct_eq x' (TSome t)\n  to_ct_list ?ts = map TSome ?ts\n  ct_suffix (x1' @ [x]) (to_ct_list t1s' @ [?y]) =\n  (ct_eq x ?y \\<and> ct_suffix x1' (to_ct_list t1s'))\n\ngoal (1 subgoal):\n 1. ct_suffix x1' (to_ct_list t1s') \\<and> ct_eq x (TSome t)", "by fastforce"], ["proof (state)\nthis:\n  ct_suffix x1' (to_ct_list t1s') \\<and> ct_eq x (TSome t)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"(take (length x1 - 3) x1) = x1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length x1 - 3) x1 = x1'", "using x1_split"], ["proof (prove)\nusing this:\n  x1 = x1' @ [x, x', x'']\n\ngoal (1 subgoal):\n 1. take (length x1 - 3) x1 = x1'", "by simp"], ["proof (state)\nthis:\n  take (length x1 - 3) x1 = x1'\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have x'_ind:\"(x1!(length x1-2)) = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 ! (length x1 - 2) = x'", "using x1_split List.nth_append_length[of \"x1' @ [x]\"]"], ["proof (prove)\nusing this:\n  x1 = x1' @ [x, x', x'']\n  ((x1' @ [x]) @ ?x # ?ys) ! length (x1' @ [x]) = ?x\n\ngoal (1 subgoal):\n 1. x1 ! (length x1 - 2) = x'", "by simp"], ["proof (state)\nthis:\n  x1 ! (length x1 - 2) = x'\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have x_ind:\"(x1!(length x1-3)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 ! (length x1 - 3) = x", "using x1_split"], ["proof (prove)\nusing this:\n  x1 = x1' @ [x, x', x'']\n\ngoal (1 subgoal):\n 1. x1 ! (length x1 - 3) = x", "by simp"], ["proof (state)\nthis:\n  x1 ! (length x1 - 3) = x\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"ct_suffix [TSome T_i32] x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "using b x1_split ct_suffix_def ct_list_eq_def ct_suffixI[of x1 \"x1' @ [x, x']\"]"], ["proof (prove)\nusing this:\n  ct_suffix (x1' @ [x, x']) (to_ct_list (t1s' @ [t, t])) \\<and>\n  ct_eq x'' (TSome T_i32)\n  x1 = x1' @ [x, x', x'']\n  ct_suffix ?xs ?ys =\n  (\\<exists>as bs. ?ys = as @ bs \\<and> ct_list_eq bs ?xs)\n  ct_list_eq ?ct1s ?ct2s = list_all2 ct_eq ?ct1s ?ct2s\n  \\<lbrakk>x1 = (x1' @ [x, x']) @ ?zs; ct_list_eq ?zs ?xs\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ?xs x1\n\ngoal (1 subgoal):\n 1. ct_suffix [TSome T_i32] x1", "by simp"], ["proof (state)\nthis:\n  ct_suffix [TSome T_i32] x1\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"check_single \\<C> e (TopType x1) = (select_return_top x1 (x1!(length x1-2)) (x1!(length x1-3)))\""], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (TopType x1) =\n    select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))", "using type_update_select_conv_select_return_top[OF _ 4]"], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n  ct_suffix [TSome T_i32] x1 \\<Longrightarrow>\n  type_update_select (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (TopType x1) =\n    select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))", "unfolding 2"], ["proof (prove)\nusing this:\n  ct_suffix [TSome T_i32] x1\n  ct_suffix [TSome T_i32] x1 \\<Longrightarrow>\n  type_update_select (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n\ngoal (1 subgoal):\n 1. type_update_select (TopType x1) =\n    select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "moreover"], ["proof (state)\nthis:\n  check_single \\<C> e (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"... = (TopType (x1'@[x])) \\<or> ... = (TopType (x1'@[x']))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n    TopType (x1' @ [x]) \\<or>\n    select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n    TopType (x1' @ [x'])", "apply (cases x; cases x')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x = TAny; x' = TAny\\<rbrakk>\n    \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                       (x1 ! (length x1 - 3)) =\n                      TopType (x1' @ [x]) \\<or>\n                      select_return_top x1 (x1 ! (length x1 - 2))\n                       (x1 ! (length x1 - 3)) =\n                      TopType (x1' @ [x'])\n 2. \\<And>x2.\n       \\<lbrakk>x = TAny; x' = TSome x2\\<rbrakk>\n       \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x]) \\<or>\n                         select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x'])\n 3. \\<And>x2.\n       \\<lbrakk>x = TSome x2; x' = TAny\\<rbrakk>\n       \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x]) \\<or>\n                         select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x'])\n 4. \\<And>x2 x2a.\n       \\<lbrakk>x = TSome x2; x' = TSome x2a\\<rbrakk>\n       \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x]) \\<or>\n                         select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x'])", "using x1_split 4 nat_def 2 x_ind x'_ind c d"], ["proof (prove)\nusing this:\n  x1 = x1' @ [x, x', x'']\n  3 \\<le> length x1\n  length x1 = Suc (Suc (Suc nat))\n  check_single \\<C> e = type_update_select\n  x1 ! (length x1 - 3) = x\n  x1 ! (length x1 - 2) = x'\n  ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and> ct_eq x' (TSome t)\n  ct_suffix x1' (to_ct_list t1s') \\<and> ct_eq x (TSome t)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x = TAny; x' = TAny\\<rbrakk>\n    \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                       (x1 ! (length x1 - 3)) =\n                      TopType (x1' @ [x]) \\<or>\n                      select_return_top x1 (x1 ! (length x1 - 2))\n                       (x1 ! (length x1 - 3)) =\n                      TopType (x1' @ [x'])\n 2. \\<And>x2.\n       \\<lbrakk>x = TAny; x' = TSome x2\\<rbrakk>\n       \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x]) \\<or>\n                         select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x'])\n 3. \\<And>x2.\n       \\<lbrakk>x = TSome x2; x' = TAny\\<rbrakk>\n       \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x]) \\<or>\n                         select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x'])\n 4. \\<And>x2 x2a.\n       \\<lbrakk>x = TSome x2; x' = TSome x2a\\<rbrakk>\n       \\<Longrightarrow> select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x]) \\<or>\n                         select_return_top x1 (x1 ! (length x1 - 2))\n                          (x1 ! (length x1 - 3)) =\n                         TopType (x1' @ [x'])", "by simp_all"], ["proof (state)\nthis:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x]) \\<or>\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x'])\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "moreover"], ["proof (state)\nthis:\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x]) \\<or>\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x'])\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"ct_suffix (x1'@[x]) (to_ct_list t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x]) (to_ct_list t2s)", "by (simp add: c t2s_def)"], ["proof (state)\nthis:\n  ct_suffix (x1' @ [x]) (to_ct_list t2s)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "moreover"], ["proof (state)\nthis:\n  ct_suffix (x1' @ [x]) (to_ct_list t2s)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"ct_suffix (x1'@[x']) (to_ct_list t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x']) (to_ct_list t2s)", "using ct_suffix_unfold_one[symmetric, of x' \"(TSome t)\" x1' \"(to_ct_list t1s')\"] c d\n                t2s_def"], ["proof (prove)\nusing this:\n  (ct_eq x' (TSome t) \\<and> ct_suffix x1' (to_ct_list t1s')) =\n  ct_suffix (x1' @ [x']) (to_ct_list t1s' @ [TSome t])\n  ct_suffix (x1' @ [x]) (to_ct_list (t1s' @ [t])) \\<and> ct_eq x' (TSome t)\n  ct_suffix x1' (to_ct_list t1s') \\<and> ct_eq x (TSome t)\n  t2s = t1s' @ [t]\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x']) (to_ct_list t2s)", "unfolding to_ct_list_def"], ["proof (prove)\nusing this:\n  (ct_eq x' (TSome t) \\<and> ct_suffix x1' (map TSome t1s')) =\n  ct_suffix (x1' @ [x']) (map TSome t1s' @ [TSome t])\n  ct_suffix (x1' @ [x]) (map TSome (t1s' @ [t])) \\<and> ct_eq x' (TSome t)\n  ct_suffix x1' (map TSome t1s') \\<and> ct_eq x (TSome t)\n  t2s = t1s' @ [t]\n\ngoal (1 subgoal):\n 1. ct_suffix (x1' @ [x']) (map TSome t2s)", "by fastforce"], ["proof (state)\nthis:\n  ct_suffix (x1' @ [x']) (to_ct_list t2s)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "ultimately"], ["proof (chain)\npicking this:\n  check_single \\<C> e (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x]) \\<or>\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x'])\n  ct_suffix (x1' @ [x]) (to_ct_list t2s)\n  ct_suffix (x1' @ [x']) (to_ct_list t2s)", "show ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x]) \\<or>\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x'])\n  ct_suffix (x1' @ [x]) (to_ct_list t2s)\n  ct_suffix (x1' @ [x']) (to_ct_list t2s)\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using TopType"], ["proof (prove)\nusing this:\n  check_single \\<C> e (TopType x1) =\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3))\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x]) \\<or>\n  select_return_top x1 (x1 ! (length x1 - 2)) (x1 ! (length x1 - 3)) =\n  TopType (x1' @ [x'])\n  ct_suffix (x1' @ [x]) (to_ct_list t2s)\n  ct_suffix (x1' @ [x']) (to_ct_list t2s)\n  ctn = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by auto"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n        c_types_agree ctm t2s; ctn = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<lbrakk>check_single \\<C> e (Type t1s) = ctm; c_types_agree ctn t1s;\n     c_types_agree ctm t2s; ctn = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case 3"], ["proof (state)\nthis:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "then"], ["proof (chain)\npicking this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)", "obtain cons prods where c_s_def:\"check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\""], ["proof (prove)\nusing this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. (\\<And>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence ctm_def:\"ctm = type_update (Type t1s) cons prods\""], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. ctm = type_update (Type t1s) cons prods", "using assms(1)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  check_single \\<C> e (Type t1s) = ctm\n\ngoal (1 subgoal):\n 1. ctm = type_update (Type t1s) cons prods", "by fastforce"], ["proof (state)\nthis:\n  ctm = type_update (Type t1s) cons prods\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence cons_suffix:\"ct_suffix cons (to_ct_list t1s)\""], ["proof (prove)\nusing this:\n  ctm = type_update (Type t1s) cons prods\n\ngoal (1 subgoal):\n 1. ct_suffix cons (to_ct_list t1s)", "using assms"], ["proof (prove)\nusing this:\n  ctm = type_update (Type t1s) cons prods\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. ct_suffix cons (to_ct_list t1s)", "by (simp, metis (full_types) produce.simps(6))"], ["proof (state)\nthis:\n  ct_suffix cons (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence t_int_def:\"consume (Type t1s) cons = (Type (take (length t1s - length cons) t1s))\""], ["proof (prove)\nusing this:\n  ct_suffix cons (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. consume (Type t1s) cons = Type (take (length t1s - length cons) t1s)", "using ctm_def"], ["proof (prove)\nusing this:\n  ct_suffix cons (to_ct_list t1s)\n  ctm = type_update (Type t1s) cons prods\n\ngoal (1 subgoal):\n 1. consume (Type t1s) cons = Type (take (length t1s - length cons) t1s)", "by simp"], ["proof (state)\nthis:\n  consume (Type t1s) cons = Type (take (length t1s - length cons) t1s)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence ctm_def2:\"ctm = produce (Type (take (length t1s - length cons) t1s)) prods\""], ["proof (prove)\nusing this:\n  consume (Type t1s) cons = Type (take (length t1s - length cons) t1s)\n\ngoal (1 subgoal):\n 1. ctm = produce (Type (take (length t1s - length cons) t1s)) prods", "using ctm_def"], ["proof (prove)\nusing this:\n  consume (Type t1s) cons = Type (take (length t1s - length cons) t1s)\n  ctm = type_update (Type t1s) cons prods\n\ngoal (1 subgoal):\n 1. ctm = produce (Type (take (length t1s - length cons) t1s)) prods", "by simp"], ["proof (state)\nthis:\n  ctm = produce (Type (take (length t1s - length cons) t1s)) prods\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof (cases ctn)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ctn = TopType x1 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case (TopType x1)"], ["proof (state)\nthis:\n  ctn = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ctn = TopType x1 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"ct_suffix x1 (to_ct_list t1s)\""], ["proof (prove)\nusing this:\n  ctn = TopType x1\n\ngoal (1 subgoal):\n 1. ct_suffix x1 (to_ct_list t1s)", "using assms(3)"], ["proof (prove)\nusing this:\n  ctn = TopType x1\n  c_types_agree ctn t1s\n\ngoal (1 subgoal):\n 1. ct_suffix x1 (to_ct_list t1s)", "by simp"], ["proof (state)\nthis:\n  ct_suffix x1 (to_ct_list t1s)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ctn = TopType x1 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 3. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  ct_suffix x1 (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using assms(2) ctm_def2"], ["proof (prove)\nusing this:\n  ct_suffix x1 (to_ct_list t1s)\n  ctm \\<noteq> Bot\n  ctm = produce (Type (take (length t1s - length cons) t1s)) prods\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof (cases prods)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = TopType x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<And>x2.\n       \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 3. \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "case (TopType x1)"], ["proof (state)\nthis:\n  prods = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>ct_suffix x1__ (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = TopType x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<And>x2.\n       \\<lbrakk>ct_suffix x1__ (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 3. \\<lbrakk>ct_suffix x1__ (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  prods = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using consume_c_types_agree[OF t_int_def assms(3)] ctm_def2 assms(4) c_s_def"], ["proof (prove)\nusing this:\n  prods = TopType x1\n  \\<exists>c_t'.\n     consume ctn cons = c_t' \\<and>\n     c_types_agree c_t' (take (length t1s - length cons) t1s)\n  ctm = produce (Type (take (length t1s - length cons) t1s)) prods\n  c_types_agree ctm t2s\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by (metis c_types_agree.elims(2) produce.simps(3,4) type_update.simps)"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>ct_suffix x1__ (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<lbrakk>ct_suffix x1__ (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "case (Type x2)"], ["proof (state)\nthis:\n  prods = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "hence ctm_def3:\"ctm = Type ((take (length t1s - length cons) t1s)@ x2)\""], ["proof (prove)\nusing this:\n  prods = Type x2\n\ngoal (1 subgoal):\n 1. ctm = Type (take (length t1s - length cons) t1s @ x2)", "using ctm_def2"], ["proof (prove)\nusing this:\n  prods = Type x2\n  ctm = produce (Type (take (length t1s - length cons) t1s)) prods\n\ngoal (1 subgoal):\n 1. ctm = Type (take (length t1s - length cons) t1s @ x2)", "by simp"], ["proof (state)\nthis:\n  ctm = Type (take (length t1s - length cons) t1s @ x2)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "have \"ct_suffix x1 cons \\<or> ct_suffix cons x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_suffix x1 cons \\<or> ct_suffix cons x1", "using ct_suffix_shared assms(3) TopType cons_suffix"], ["proof (prove)\nusing this:\n  \\<lbrakk>ct_suffix ?cts (to_ct_list ?ts);\n   ct_suffix ?cts' (to_ct_list ?ts)\\<rbrakk>\n  \\<Longrightarrow> ct_suffix ?cts ?cts' \\<or> ct_suffix ?cts' ?cts\n  c_types_agree ctn t1s\n  ctn = TopType x1\n  ct_suffix cons (to_ct_list t1s)\n\ngoal (1 subgoal):\n 1. ct_suffix x1 cons \\<or> ct_suffix cons x1", "by auto"], ["proof (state)\nthis:\n  ct_suffix x1 cons \\<or> ct_suffix cons x1\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n        ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n        prods = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ctm'.\n                            check_single \\<C> e ctn = ctm' \\<and>\n                            c_types_agree ctm' t2s\n 2. \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  ct_suffix x1 cons \\<or> ct_suffix cons x1\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. ct_suffix x1 cons \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "assume \"ct_suffix x1 cons\""], ["proof (state)\nthis:\n  ct_suffix x1 cons\n\ngoal (2 subgoals):\n 1. ct_suffix x1 cons \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"consume (TopType x1) cons = TopType []\""], ["proof (prove)\nusing this:\n  ct_suffix x1 cons\n\ngoal (1 subgoal):\n 1. consume (TopType x1) cons = TopType []", "by (simp add: ct_suffix_length)"], ["proof (state)\nthis:\n  consume (TopType x1) cons = TopType []\n\ngoal (2 subgoals):\n 1. ct_suffix x1 cons \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"check_single \\<C> e ctn = TopType (to_ct_list x2)\""], ["proof (prove)\nusing this:\n  consume (TopType x1) cons = TopType []\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn = TopType (to_ct_list x2)", "using c_s_def TopType Type"], ["proof (prove)\nusing this:\n  consume (TopType x1) cons = TopType []\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  ctn = TopType x1\n  prods = Type x2\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn = TopType (to_ct_list x2)", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e ctn = TopType (to_ct_list x2)\n\ngoal (2 subgoals):\n 1. ct_suffix x1 cons \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e ctn = TopType (to_ct_list x2)\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using TopType ctm_def3 assms(4) c_types_agree_top2 ct_list_eq_refl"], ["proof (prove)\nusing this:\n  check_single \\<C> e ctn = TopType (to_ct_list x2)\n  ctn = TopType x1\n  ctm = Type (take (length t1s - length cons) t1s @ x2)\n  c_types_agree ctm t2s\n  ct_list_eq ?ts (to_ct_list ?ts'') \\<Longrightarrow>\n  c_types_agree (TopType ?ts) (?ts' @ ?ts'')\n  ct_list_eq ?xs ?xs\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by auto"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "assume \"ct_suffix cons x1\""], ["proof (state)\nthis:\n  ct_suffix cons x1\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence 4:\"consume (TopType x1) cons = TopType (take (length x1 - length cons ) x1)\""], ["proof (prove)\nusing this:\n  ct_suffix cons x1\n\ngoal (1 subgoal):\n 1. consume (TopType x1) cons = TopType (take (length x1 - length cons) x1)", "by (simp add: ct_suffix_length)"], ["proof (state)\nthis:\n  consume (TopType x1) cons = TopType (take (length x1 - length cons) x1)\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence 3:\"check_single \\<C> e ctn = TopType ((take (length x1 - length cons ) x1) @ to_ct_list x2)\""], ["proof (prove)\nusing this:\n  consume (TopType x1) cons = TopType (take (length x1 - length cons) x1)\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn =\n    TopType (take (length x1 - length cons) x1 @ to_ct_list x2)", "using c_s_def TopType Type"], ["proof (prove)\nusing this:\n  consume (TopType x1) cons = TopType (take (length x1 - length cons) x1)\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  ctn = TopType x1\n  prods = Type x2\n\ngoal (1 subgoal):\n 1. check_single \\<C> e ctn =\n    TopType (take (length x1 - length cons) x1 @ to_ct_list x2)", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e ctn =\n  TopType (take (length x1 - length cons) x1 @ to_ct_list x2)\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"((take (length t1s - length cons ) t1s) @  x2) = t2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length t1s - length cons) t1s @ x2 = t2s", "using assms(4) ctm_def3"], ["proof (prove)\nusing this:\n  c_types_agree ctm t2s\n  ctm = Type (take (length t1s - length cons) t1s @ x2)\n\ngoal (1 subgoal):\n 1. take (length t1s - length cons) t1s @ x2 = t2s", "by simp"], ["proof (state)\nthis:\n  take (length t1s - length cons) t1s @ x2 = t2s\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "have \"c_types_agree (TopType (take (length x1 - length cons ) x1)) (take (length t1s - length cons) t1s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_types_agree (TopType (take (length x1 - length cons) x1))\n     (take (length t1s - length cons) t1s)", "using consume_c_types_agree[OF t_int_def assms(3)] 4 TopType"], ["proof (prove)\nusing this:\n  \\<exists>c_t'.\n     consume ctn cons = c_t' \\<and>\n     c_types_agree c_t' (take (length t1s - length cons) t1s)\n  consume (TopType x1) cons = TopType (take (length x1 - length cons) x1)\n  ctn = TopType x1\n\ngoal (1 subgoal):\n 1. c_types_agree (TopType (take (length x1 - length cons) x1))\n     (take (length t1s - length cons) t1s)", "by simp"], ["proof (state)\nthis:\n  c_types_agree (TopType (take (length x1 - length cons) x1))\n   (take (length t1s - length cons) t1s)\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "hence \"c_types_agree (TopType (take (length x1 - length cons ) x1 @ to_ct_list x2)) (take (length t1s - length cons) t1s @ x2)\""], ["proof (prove)\nusing this:\n  c_types_agree (TopType (take (length x1 - length cons) x1))\n   (take (length t1s - length cons) t1s)\n\ngoal (1 subgoal):\n 1. c_types_agree\n     (TopType (take (length x1 - length cons) x1 @ to_ct_list x2))\n     (take (length t1s - length cons) t1s @ x2)", "unfolding c_types_agree.simps to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_suffix (take (length x1 - length cons) x1)\n   (map TSome (take (length t1s - length cons) t1s))\n\ngoal (1 subgoal):\n 1. ct_suffix (take (length x1 - length cons) x1 @ map TSome x2)\n     (map TSome (take (length t1s - length cons) t1s @ x2))", "by (simp add: ct_suffix_cons2 ct_suffix_cons_it ct_suffix_extend_ct_list_eq)"], ["proof (state)\nthis:\n  c_types_agree\n   (TopType (take (length x1 - length cons) x1 @ to_ct_list x2))\n   (take (length t1s - length cons) t1s @ x2)\n\ngoal (1 subgoal):\n 1. ct_suffix cons x1 \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_types_agree\n   (TopType (take (length x1 - length cons) x1 @ to_ct_list x2))\n   (take (length t1s - length cons) t1s @ x2)\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using ctm_def3 assms 3"], ["proof (prove)\nusing this:\n  c_types_agree\n   (TopType (take (length x1 - length cons) x1 @ to_ct_list x2))\n   (take (length t1s - length cons) t1s @ x2)\n  ctm = Type (take (length t1s - length cons) t1s @ x2)\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n  check_single \\<C> e ctn =\n  TopType (take (length x1 - length cons) x1 @ to_ct_list x2)\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by simp"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ct_suffix x1 (to_ct_list t1s); ctm \\<noteq> Bot;\n     ctm = produce (Type (take (length t1s - length cons) t1s)) prods;\n     prods = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ctm'.\n                         check_single \\<C> e ctn = ctm' \\<and>\n                         c_types_agree ctm' t2s", "qed simp"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case (Type x2)"], ["proof (state)\nthis:\n  ctn = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       \\<exists>ctm'.\n          check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n 2. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  ctn = Type x2\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using assms"], ["proof (prove)\nusing this:\n  ctn = Type x2\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by simp"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal (1 subgoal):\n 1. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "case Bot"], ["proof (state)\nthis:\n  ctn = Bot\n\ngoal (1 subgoal):\n 1. ctn = Bot \\<Longrightarrow>\n    \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "thus ?thesis"], ["proof (prove)\nusing this:\n  ctn = Bot\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "using assms"], ["proof (prove)\nusing this:\n  ctn = Bot\n  check_single \\<C> e (Type t1s) = ctm\n  ctm \\<noteq> Bot\n  c_types_agree ctn t1s\n  c_types_agree ctm t2s\n\ngoal (1 subgoal):\n 1. \\<exists>ctm'.\n       check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s", "by simp"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t2s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_type_checker_compose:\n  assumes \"b_e_type_checker \\<C> es (t1s _> t2s)\"\n          \"b_e_type_checker \\<C> [e] (t2s _> t3s)\"\n  shows \"b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "have \"c_types_agree (check_single \\<C> e (Type t2s)) t3s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_types_agree (check_single \\<C> e (Type t2s)) t3s", "using assms(2)"], ["proof (prove)\nusing this:\n  b_e_type_checker \\<C> [e] (t2s _> t3s)\n\ngoal (1 subgoal):\n 1. c_types_agree (check_single \\<C> e (Type t2s)) t3s", "by simp"], ["proof (state)\nthis:\n  c_types_agree (check_single \\<C> e (Type t2s)) t3s\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "then"], ["proof (chain)\npicking this:\n  c_types_agree (check_single \\<C> e (Type t2s)) t3s", "obtain ctm where ctm_def:\"check_single \\<C> e (Type t2s) = ctm\"\n                                \"c_types_agree ctm t3s\"\n                                \"ctm \\<noteq> Bot\""], ["proof (prove)\nusing this:\n  c_types_agree (check_single \\<C> e (Type t2s)) t3s\n\ngoal (1 subgoal):\n 1. (\\<And>ctm.\n        \\<lbrakk>check_single \\<C> e (Type t2s) = ctm;\n         c_types_agree ctm t3s; ctm \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  check_single \\<C> e (Type t2s) = ctm\n  c_types_agree ctm t3s\n  ctm \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "have \"c_types_agree (check \\<C> es (Type t1s)) t2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_types_agree (check \\<C> es (Type t1s)) t2s", "using assms(1)"], ["proof (prove)\nusing this:\n  b_e_type_checker \\<C> es (t1s _> t2s)\n\ngoal (1 subgoal):\n 1. c_types_agree (check \\<C> es (Type t1s)) t2s", "by simp"], ["proof (state)\nthis:\n  c_types_agree (check \\<C> es (Type t1s)) t2s\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "then"], ["proof (chain)\npicking this:\n  c_types_agree (check \\<C> es (Type t1s)) t2s", "obtain ctn where ctn_def:\"check \\<C> es (Type t1s) = ctn\"\n                                \"c_types_agree ctn t2s\"\n                                \"ctn \\<noteq> Bot\""], ["proof (prove)\nusing this:\n  c_types_agree (check \\<C> es (Type t1s)) t2s\n\ngoal (1 subgoal):\n 1. (\\<And>ctn.\n        \\<lbrakk>check \\<C> es (Type t1s) = ctn; c_types_agree ctn t2s;\n         ctn \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  check \\<C> es (Type t1s) = ctn\n  c_types_agree ctn t2s\n  ctn \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  check \\<C> es (Type t1s) = ctn\n  c_types_agree ctn t2s\n  ctn \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "using check_single_imp_weakening[OF ctm_def(1,3) ctn_def(2) ctm_def(2)]\n          check_unfold_snoc[of \\<C> es \"(Type t1s)\" e]"], ["proof (prove)\nusing this:\n  check \\<C> es (Type t1s) = ctn\n  c_types_agree ctn t2s\n  ctn \\<noteq> Bot\n  \\<exists>ctm'.\n     check_single \\<C> e ctn = ctm' \\<and> c_types_agree ctm' t3s\n  check \\<C> es (Type t1s) \\<noteq> Bot \\<Longrightarrow>\n  check \\<C> (es @ [e]) (Type t1s) =\n  check_single \\<C> e (check \\<C> es (Type t1s))\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "by simp"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_type_type:\n  assumes \"check_single \\<C> e xs = (Type tm)\"\n  shows \"\\<exists>tn. xs = (Type tn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "consider (1) \"check_single \\<C> e = id\" \n         | (2) \"check_single \\<C> e = (\\<lambda>ctn. type_update_select ctn)\"\n         | (3) \"(\\<exists>cons prods. (check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using check_single_imp assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single ?\\<C> ?e ?ctn = ?ctm; ?ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single ?\\<C> ?e = id \\<or>\n                    check_single ?\\<C> ?e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single ?\\<C> ?e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  check_single \\<C> e xs = Type tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "case 1"], ["proof (state)\nthis:\n  check_single \\<C> e = id\n\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n  check_single \\<C> e xs = Type tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "by simp"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "case 2"], ["proof (state)\nthis:\n  check_single \\<C> e = type_update_select\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "note outer_2 = 2"], ["proof (state)\nthis:\n  check_single \\<C> e = type_update_select\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms"], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n  check_single \\<C> e xs = Type tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "proof (cases xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. \\<lbrakk>check_single \\<C> e = type_update_select;\n     check_single \\<C> e xs = Type tm; xs = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "case (TopType x1)"], ["proof (state)\nthis:\n  xs = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. \\<lbrakk>check_single \\<C> e = type_update_select;\n     check_single \\<C> e xs = Type tm; xs = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "consider\n          (1) \"length x1 = 0\"\n        | (2) \"length x1 = Suc 0\"\n        | (3) \"length x1 = Suc (Suc 0)\"\n        | (4) \"length x1 \\<ge> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = 0 \\<Longrightarrow> thesis;\n     length x1 = Suc 0 \\<Longrightarrow> thesis;\n     length x1 = Suc (Suc 0) \\<Longrightarrow> thesis;\n     3 \\<le> length x1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length x1 = 0 \\<Longrightarrow> ?thesis;\n   length x1 = Suc 0 \\<Longrightarrow> ?thesis;\n   length x1 = Suc (Suc 0) \\<Longrightarrow> ?thesis;\n   3 \\<le> length x1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = TopType x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. \\<lbrakk>check_single \\<C> e = type_update_select;\n     check_single \\<C> e xs = Type tm; xs = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length x1 = 0 \\<Longrightarrow> ?thesis;\n   length x1 = Suc 0 \\<Longrightarrow> ?thesis;\n   length x1 = Suc (Suc 0) \\<Longrightarrow> ?thesis;\n   3 \\<le> length x1 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. length x1 = Suc 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 4. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "case 1"], ["proof (state)\nthis:\n  length x1 = 0\n\ngoal (4 subgoals):\n 1. length x1 = 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. length x1 = Suc 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 4. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  length x1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms 2 TopType"], ["proof (prove)\nusing this:\n  length x1 = 0\n  check_single \\<C> e xs = Type tm\n  check_single \\<C> e = type_update_select\n  xs = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "by simp"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal (3 subgoals):\n 1. length x1 = Suc 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. length x1 = Suc 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "case 2"], ["proof (state)\nthis:\n  length x1 = Suc 0\n\ngoal (3 subgoals):\n 1. length x1 = Suc 0 \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 3. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  length x1 = Suc 0\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms outer_2 TopType produce_type_type"], ["proof (prove)\nusing this:\n  length x1 = Suc 0\n  check_single \\<C> e xs = Type tm\n  check_single \\<C> e = type_update_select\n  xs = TopType x1\n  produce ?xs ?cons = Type ?tm \\<Longrightarrow> \\<exists>tn. ?xs = Type tn\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal (2 subgoals):\n 1. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "case 3"], ["proof (state)\nthis:\n  length x1 = Suc (Suc 0)\n\ngoal (2 subgoals):\n 1. length x1 = Suc (Suc 0) \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  length x1 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms 2 TopType"], ["proof (prove)\nusing this:\n  length x1 = Suc (Suc 0)\n  check_single \\<C> e xs = Type tm\n  check_single \\<C> e = type_update_select\n  xs = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "by (simp, metis checker_type.distinct(1) checker_type.distinct(5))"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "case 4"], ["proof (state)\nthis:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "then"], ["proof (chain)\npicking this:\n  3 \\<le> length x1", "obtain nat where nat_def:\"length x1 = Suc (Suc (Suc nat))\""], ["proof (prove)\nusing this:\n  3 \\<le> length x1\n\ngoal (1 subgoal):\n 1. (\\<And>nat.\n        length x1 = Suc (Suc (Suc nat)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis add_eq_if diff_Suc_1 le_Suc_ex numeral_3_eq_3 nat.distinct(2))"], ["proof (state)\nthis:\n  length x1 = Suc (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. 3 \\<le> length x1 \\<Longrightarrow> \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  length x1 = Suc (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms 2 TopType"], ["proof (prove)\nusing this:\n  length x1 = Suc (Suc (Suc nat))\n  check_single \\<C> e xs = Type tm\n  check_single \\<C> e = type_update_select\n  xs = TopType x1\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "assume a1: \"produce (if ct_suffix [TAny, TAny, TSome T_i32] x1 then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1) else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot) (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) = Type tm\""], ["proof (state)\nthis:\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "obtain tts :: \"checker_type \\<Rightarrow> t list\" where\n              f2: \"\\<forall>c. (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or> c = Type (tts c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tts.\n        \\<forall>c.\n           (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or>\n           c = Type (tts c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using produce_type_type"], ["proof (prove)\nusing this:\n  produce ?xs ?cons = Type ?tm \\<Longrightarrow> \\<exists>tn. ?xs = Type tn\n\ngoal (1 subgoal):\n 1. (\\<And>tts.\n        \\<forall>c.\n           (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or>\n           c = Type (tts c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>c.\n     (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or> c = Type (tts c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "then"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or> c = Type (tts c)", "have f3: \"\\<And>ts. \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or> Type tm \\<noteq> Type ts\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or> c = Type (tts c)\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n       Type tm \\<noteq> Type ts", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or> c = Type (tts c)\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n       Type tm \\<noteq> Type ts", "by fastforce"], ["proof (state)\nthis:\n  \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n  Type tm \\<noteq> Type ?ts\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "then"], ["proof (chain)\npicking this:\n  \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n  Type tm \\<noteq> Type ?ts", "have \"\\<And>ts. \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or> Type tm \\<noteq> Type ts\""], ["proof (prove)\nusing this:\n  \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n  Type tm \\<noteq> Type ?ts\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n       Type tm \\<noteq> Type ts", "using f2 a1"], ["proof (prove)\nusing this:\n  \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n  Type tm \\<noteq> Type ?ts\n  \\<forall>c.\n     (\\<forall>ca ts. produce c ca \\<noteq> Type ts) \\<or> c = Type (tts c)\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n       Type tm \\<noteq> Type ts", "by fastforce"], ["proof (state)\nthis:\n  \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  Type tm \\<noteq> Type ?ts\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "then"], ["proof (chain)\npicking this:\n  \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  Type tm \\<noteq> Type ?ts", "have False"], ["proof (prove)\nusing this:\n  \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  Type tm \\<noteq> Type ?ts\n\ngoal (1 subgoal):\n 1. False", "using f3 a1"], ["proof (prove)\nusing this:\n  \\<not> ct_suffix x1 [TAny, TAny, TSome T_i32] \\<or>\n  Type tm \\<noteq> Type ?ts\n  \\<not> ct_suffix [TAny, TAny, TSome T_i32] x1 \\<or>\n  Type tm \\<noteq> Type ?ts\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "}"], ["proof (state)\nthis:\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x1 = Suc (Suc (Suc nat));\n     check_single \\<C> e xs = Type tm;\n     check_single \\<C> e = type_update_select; xs = TopType x1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms 2 TopType nat_def"], ["proof (prove)\nusing this:\n  produce\n   (if ct_suffix [TAny, TAny, TSome T_i32] x1\n    then TopType (take (length x1 - length [TAny, TAny, TSome T_i32]) x1)\n    else if ct_suffix x1 [TAny, TAny, TSome T_i32] then TopType [] else Bot)\n   (select_return_top x1 (x1 ! Suc nat) (x1 ! nat)) =\n  Type tm \\<Longrightarrow>\n  False\n  check_single \\<C> e xs = Type tm\n  check_single \\<C> e = type_update_select\n  xs = TopType x1\n  length x1 = Suc (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "by simp"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>check_single \\<C> e = type_update_select;\n        check_single \\<C> e xs = Type tm; xs = Type x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tn. xs = Type tn\n 2. \\<lbrakk>check_single \\<C> e = type_update_select;\n     check_single \\<C> e xs = Type tm; xs = Bot\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tn. xs = Type tn", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "case 3"], ["proof (state)\nthis:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "then"], ["proof (chain)\npicking this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)", "obtain cons prods where check_def:\"check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\""], ["proof (prove)\nusing this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. (\\<And>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "hence \"produce (consume xs cons) prods = (Type tm)\""], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. produce (consume xs cons) prods = Type tm", "using assms(1)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  check_single \\<C> e xs = Type tm\n\ngoal (1 subgoal):\n 1. produce (consume xs cons) prods = Type tm", "by simp"], ["proof (state)\nthis:\n  produce (consume xs cons) prods = Type tm\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    \\<exists>tn. xs = Type tn", "thus ?thesis"], ["proof (prove)\nusing this:\n  produce (consume xs cons) prods = Type tm\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "using assms check_def consume_type_type produce_type_type"], ["proof (prove)\nusing this:\n  produce (consume xs cons) prods = Type tm\n  check_single \\<C> e xs = Type tm\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  consume ?xs ?cons = Type ?t_int \\<Longrightarrow>\n  \\<exists>tn. ?xs = Type tn\n  produce ?xs ?cons = Type ?tm \\<Longrightarrow> \\<exists>tn. ?xs = Type tn\n\ngoal (1 subgoal):\n 1. \\<exists>tn. xs = Type tn", "by blast"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tn. xs = Type tn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_weaken_type:\n  assumes \"check_single \\<C> e (Type tn) = (Type tm)\"\n  shows \"check_single \\<C> e (Type (ts@tn)) = Type (ts@tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "consider (1) \"check_single \\<C> e = id\" \n         | (2) \"check_single \\<C> e = (\\<lambda>ctn. type_update_select ctn)\"\n         | (3) \"(\\<exists>cons prods. (check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using check_single_imp assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single ?\\<C> ?e ?ctn = ?ctm; ?ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single ?\\<C> ?e = id \\<or>\n                    check_single ?\\<C> ?e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single ?\\<C> ?e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  check_single \\<C> e (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "case 1"], ["proof (state)\nthis:\n  check_single \\<C> e = id\n\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "using assms(1)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n  check_single \\<C> e (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "case 2"], ["proof (state)\nthis:\n  check_single \\<C> e = type_update_select\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "hence cond:\"(length tn \\<ge> 3 \\<and> (tn!(length tn-2)) = (tn!(length tn-3)))\""], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. 3 \\<le> length tn \\<and> tn ! (length tn - 2) = tn ! (length tn - 3)", "using assms"], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n  check_single \\<C> e (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. 3 \\<le> length tn \\<and> tn ! (length tn - 2) = tn ! (length tn - 3)", "by (simp, metis checker_type.distinct(5))"], ["proof (state)\nthis:\n  3 \\<le> length tn \\<and> tn ! (length tn - 2) = tn ! (length tn - 3)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "hence \"consume (Type tn) [TAny, TSome T_i32] = (Type tm)\""], ["proof (prove)\nusing this:\n  3 \\<le> length tn \\<and> tn ! (length tn - 2) = tn ! (length tn - 3)\n\ngoal (1 subgoal):\n 1. consume (Type tn) [TAny, TSome T_i32] = Type tm", "using assms 2"], ["proof (prove)\nusing this:\n  3 \\<le> length tn \\<and> tn ! (length tn - 2) = tn ! (length tn - 3)\n  check_single \\<C> e (Type tn) = Type tm\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. consume (Type tn) [TAny, TSome T_i32] = Type tm", "by simp"], ["proof (state)\nthis:\n  consume (Type tn) [TAny, TSome T_i32] = Type tm\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "hence \"consume (Type (ts@tn)) [TAny, TSome T_i32] = (Type (ts@tm))\""], ["proof (prove)\nusing this:\n  consume (Type tn) [TAny, TSome T_i32] = Type tm\n\ngoal (1 subgoal):\n 1. consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)", "using consume_weaken_type"], ["proof (prove)\nusing this:\n  consume (Type tn) [TAny, TSome T_i32] = Type tm\n  consume (Type ?tn) ?cons = Type ?t_int \\<Longrightarrow>\n  consume (Type (?ts @ ?tn)) ?cons = Type (?ts @ ?t_int)\n\ngoal (1 subgoal):\n 1. consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)", "by blast"], ["proof (state)\nthis:\n  consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "moreover"], ["proof (state)\nthis:\n  consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "have \"(length (ts@tn) \\<ge> 3 \\<and> ((ts@tn)!(length (ts@tn)-2)) = ((ts@tn)!(length (ts@tn)-3)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> length (ts @ tn) \\<and>\n    (ts @ tn) ! (length (ts @ tn) - 2) = (ts @ tn) ! (length (ts @ tn) - 3)", "using cond"], ["proof (prove)\nusing this:\n  3 \\<le> length tn \\<and> tn ! (length tn - 2) = tn ! (length tn - 3)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length (ts @ tn) \\<and>\n    (ts @ tn) ! (length (ts @ tn) - 2) = (ts @ tn) ! (length (ts @ tn) - 3)", "by (simp, metis add.commute add_leE nth_append_length_plus numeral_Bit1 numeral_One\n                      one_add_one ordered_cancel_comm_monoid_diff_class.diff_add_assoc2)"], ["proof (state)\nthis:\n  3 \\<le> length (ts @ tn) \\<and>\n  (ts @ tn) ! (length (ts @ tn) - 2) = (ts @ tn) ! (length (ts @ tn) - 3)\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "ultimately"], ["proof (chain)\npicking this:\n  consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)\n  3 \\<le> length (ts @ tn) \\<and>\n  (ts @ tn) ! (length (ts @ tn) - 2) = (ts @ tn) ! (length (ts @ tn) - 3)", "show ?thesis"], ["proof (prove)\nusing this:\n  consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)\n  3 \\<le> length (ts @ tn) \\<and>\n  (ts @ tn) ! (length (ts @ tn) - 2) = (ts @ tn) ! (length (ts @ tn) - 3)\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "using 2"], ["proof (prove)\nusing this:\n  consume (Type (ts @ tn)) [TAny, TSome T_i32] = Type (ts @ tm)\n  3 \\<le> length (ts @ tn) \\<and>\n  (ts @ tn) ! (length (ts @ tn) - 2) = (ts @ tn) ! (length (ts @ tn) - 3)\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "case 3"], ["proof (state)\nthis:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "then"], ["proof (chain)\npicking this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)", "obtain cons prods where check_def:\"check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\""], ["proof (prove)\nusing this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. (\\<And>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "hence \"produce (consume (Type tn) cons) prods = (Type tm)\""], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. produce (consume (Type tn) cons) prods = Type tm", "using assms(1)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  check_single \\<C> e (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. produce (consume (Type tn) cons) prods = Type tm", "by simp"], ["proof (state)\nthis:\n  produce (consume (Type tn) cons) prods = Type tm\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "then"], ["proof (chain)\npicking this:\n  produce (consume (Type tn) cons) prods = Type tm", "obtain t_int where t_int_def:\"consume (Type tn) cons = (Type t_int)\""], ["proof (prove)\nusing this:\n  produce (consume (Type tn) cons) prods = Type tm\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        consume (Type tn) cons = Type t_int \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis consume.simps(1) produce.simps(6))"], ["proof (state)\nthis:\n  consume (Type tn) cons = Type t_int\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "thus ?thesis"], ["proof (prove)\nusing this:\n  consume (Type tn) cons = Type t_int\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "using assms(1) check_def\n            consume_weaken_type[OF t_int_def, of ts]\n            produce_weaken_type[of t_int prods tm ts]"], ["proof (prove)\nusing this:\n  consume (Type tn) cons = Type t_int\n  check_single \\<C> e (Type tn) = Type tm\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  consume (Type (ts @ tn)) cons = Type (ts @ t_int)\n  produce (Type t_int) prods = Type tm \\<Longrightarrow>\n  produce (Type (ts @ t_int)) prods = Type (ts @ tm)\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ tm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_single_weaken_top:\n  assumes \"check_single \\<C> e (Type tn) = TopType tm\"\n  shows \"check_single \\<C> e (Type (ts@tn)) = TopType tm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "consider (1) \"check_single \\<C> e = id\" \n         | (2) \"check_single \\<C> e = (\\<lambda>ctn. type_update_select ctn)\"\n         | (3) \"(\\<exists>cons prods. (check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using check_single_imp assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single ?\\<C> ?e ?ctn = ?ctm; ?ctm \\<noteq> Bot\\<rbrakk>\n  \\<Longrightarrow> check_single ?\\<C> ?e = id \\<or>\n                    check_single ?\\<C> ?e = type_update_select \\<or>\n                    (\\<exists>cons prods.\n                        check_single ?\\<C> ?e =\n                        (\\<lambda>ctn. type_update ctn cons prods))\n  check_single \\<C> e (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> thesis;\n     check_single \\<C> e = type_update_select \\<Longrightarrow> thesis;\n     \\<exists>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_single \\<C> e = id \\<Longrightarrow> ?thesis;\n   check_single \\<C> e = type_update_select \\<Longrightarrow> ?thesis;\n   \\<exists>cons prods.\n      check_single \\<C> e =\n      (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "case 1"], ["proof (state)\nthis:\n  check_single \\<C> e = id\n\ngoal (3 subgoals):\n 1. check_single \\<C> e = id \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 2. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 3. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "using assms"], ["proof (prove)\nusing this:\n  check_single \\<C> e = id\n  check_single \\<C> e (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "by simp"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = TopType tm\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "case 2"], ["proof (state)\nthis:\n  check_single \\<C> e = type_update_select\n\ngoal (2 subgoals):\n 1. check_single \\<C> e = type_update_select \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm\n 2. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "using assms"], ["proof (prove)\nusing this:\n  check_single \\<C> e = type_update_select\n  check_single \\<C> e (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "by (simp, metis checker_type.distinct(1) checker_type.distinct(3) consume.simps(1))"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = TopType tm\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "case 3"], ["proof (state)\nthis:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "then"], ["proof (chain)\npicking this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)", "obtain cons prods where check_def:\"check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\""], ["proof (prove)\nusing this:\n  \\<exists>cons prods.\n     check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. (\\<And>cons prods.\n        check_single \\<C> e =\n        (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "hence \"produce (consume (Type tn) cons) prods = (TopType tm)\""], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n\ngoal (1 subgoal):\n 1. produce (consume (Type tn) cons) prods = TopType tm", "using assms(1)"], ["proof (prove)\nusing this:\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  check_single \\<C> e (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. produce (consume (Type tn) cons) prods = TopType tm", "by simp"], ["proof (state)\nthis:\n  produce (consume (Type tn) cons) prods = TopType tm\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "moreover"], ["proof (state)\nthis:\n  produce (consume (Type tn) cons) prods = TopType tm\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "then"], ["proof (chain)\npicking this:\n  produce (consume (Type tn) cons) prods = TopType tm", "obtain t_int where t_int_def:\"consume (Type tn) cons = (Type t_int)\""], ["proof (prove)\nusing this:\n  produce (consume (Type tn) cons) prods = TopType tm\n\ngoal (1 subgoal):\n 1. (\\<And>t_int.\n        consume (Type tn) cons = Type t_int \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis checker_type.distinct(3) consume.simps(1) produce.simps(6))"], ["proof (state)\nthis:\n  consume (Type tn) cons = Type t_int\n\ngoal (1 subgoal):\n 1. \\<exists>cons prods.\n       check_single \\<C> e =\n       (\\<lambda>ctn. type_update ctn cons prods) \\<Longrightarrow>\n    check_single \\<C> e (Type (ts @ tn)) = TopType tm", "ultimately"], ["proof (chain)\npicking this:\n  produce (consume (Type tn) cons) prods = TopType tm\n  consume (Type tn) cons = Type t_int", "show ?thesis"], ["proof (prove)\nusing this:\n  produce (consume (Type tn) cons) prods = TopType tm\n  consume (Type tn) cons = Type t_int\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "using check_def consume_weaken_type"], ["proof (prove)\nusing this:\n  produce (consume (Type tn) cons) prods = TopType tm\n  consume (Type tn) cons = Type t_int\n  check_single \\<C> e = (\\<lambda>ctn. type_update ctn cons prods)\n  consume (Type ?tn) ?cons = Type ?t_int \\<Longrightarrow>\n  consume (Type (?ts @ ?tn)) ?cons = Type (?ts @ ?t_int)\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType tm", "by (cases prods, auto)"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = TopType tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = TopType tm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_check_weaken_type:\n  assumes \"check \\<C> es (Type tn) = (Type tm)\"\n  shows \"check \\<C> es (Type (ts@tn)) = (Type (ts@tm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es (Type (ts @ tn)) = Type (ts @ tm)", "using assms"], ["proof (prove)\nusing this:\n  check \\<C> es (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. check \\<C> es (Type (ts @ tn)) = Type (ts @ tm)", "proof (induction es arbitrary: tn tm rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tn tm.\n       check \\<C> [] (Type tn) = Type tm \\<Longrightarrow>\n       check \\<C> [] (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<And>x xs tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> xs (Type tn) = Type tm \\<Longrightarrow>\n                   check \\<C> xs (Type (ts @ tn)) = Type (ts @ tm);\n        check \\<C> (xs @ [x]) (Type tn) = Type tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (xs @ [x]) (Type (ts @ tn)) =\n                         Type (ts @ tm)", "case Nil"], ["proof (state)\nthis:\n  check \\<C> [] (Type tn) = Type tm\n\ngoal (2 subgoals):\n 1. \\<And>tn tm.\n       check \\<C> [] (Type tn) = Type tm \\<Longrightarrow>\n       check \\<C> [] (Type (ts @ tn)) = Type (ts @ tm)\n 2. \\<And>x xs tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> xs (Type tn) = Type tm \\<Longrightarrow>\n                   check \\<C> xs (Type (ts @ tn)) = Type (ts @ tm);\n        check \\<C> (xs @ [x]) (Type tn) = Type tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (xs @ [x]) (Type (ts @ tn)) =\n                         Type (ts @ tm)", "thus ?case"], ["proof (prove)\nusing this:\n  check \\<C> [] (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. check \\<C> [] (Type (ts @ tn)) = Type (ts @ tm)", "by simp"], ["proof (state)\nthis:\n  check \\<C> [] (Type (ts @ tn)) = Type (ts @ tm)\n\ngoal (1 subgoal):\n 1. \\<And>x xs tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> xs (Type tn) = Type tm \\<Longrightarrow>\n                   check \\<C> xs (Type (ts @ tn)) = Type (ts @ tm);\n        check \\<C> (xs @ [x]) (Type tn) = Type tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (xs @ [x]) (Type (ts @ tn)) =\n                         Type (ts @ tm)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> xs (Type tn) = Type tm \\<Longrightarrow>\n                   check \\<C> xs (Type (ts @ tn)) = Type (ts @ tm);\n        check \\<C> (xs @ [x]) (Type tn) = Type tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (xs @ [x]) (Type (ts @ tn)) =\n                         Type (ts @ tm)", "case (snoc e es)"], ["proof (state)\nthis:\n  check \\<C> es (Type ?tn) = Type ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = Type (ts @ ?tm)\n  check \\<C> (es @ [e]) (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. \\<And>x xs tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> xs (Type tn) = Type tm \\<Longrightarrow>\n                   check \\<C> xs (Type (ts @ tn)) = Type (ts @ tm);\n        check \\<C> (xs @ [x]) (Type tn) = Type tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (xs @ [x]) (Type (ts @ tn)) =\n                         Type (ts @ tm)", "hence \"check_single \\<C> e (check \\<C> es (Type tn)) = Type tm\""], ["proof (prove)\nusing this:\n  check \\<C> es (Type ?tn) = Type ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = Type (ts @ ?tm)\n  check \\<C> (es @ [e]) (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (check \\<C> es (Type tn)) = Type tm", "using check_unfold_snoc[OF check_neq_bot_snoc]"], ["proof (prove)\nusing this:\n  check \\<C> es (Type ?tn) = Type ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = Type (ts @ ?tm)\n  check \\<C> (es @ [e]) (Type tn) = Type tm\n  check ?\\<C> (?es @ [?e1]) ?ts \\<noteq> Bot \\<Longrightarrow>\n  check ?\\<C> (?es @ [?e]) ?ts = check_single ?\\<C> ?e (check ?\\<C> ?es ?ts)\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (check \\<C> es (Type tn)) = Type tm", "by (metis checker_type.distinct(5))"], ["proof (state)\nthis:\n  check_single \\<C> e (check \\<C> es (Type tn)) = Type tm\n\ngoal (1 subgoal):\n 1. \\<And>x xs tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> xs (Type tn) = Type tm \\<Longrightarrow>\n                   check \\<C> xs (Type (ts @ tn)) = Type (ts @ tm);\n        check \\<C> (xs @ [x]) (Type tn) = Type tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (xs @ [x]) (Type (ts @ tn)) =\n                         Type (ts @ tm)", "thus ?case"], ["proof (prove)\nusing this:\n  check_single \\<C> e (check \\<C> es (Type tn)) = Type tm\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) (Type (ts @ tn)) = Type (ts @ tm)", "using b_e_check_single_weaken_type b_e_check_single_type_type snoc"], ["proof (prove)\nusing this:\n  check_single \\<C> e (check \\<C> es (Type tn)) = Type tm\n  check_single ?\\<C> ?e (Type ?tn) = Type ?tm \\<Longrightarrow>\n  check_single ?\\<C> ?e (Type (?ts @ ?tn)) = Type (?ts @ ?tm)\n  check_single ?\\<C> ?e ?xs = Type ?tm \\<Longrightarrow>\n  \\<exists>tn. ?xs = Type tn\n  check \\<C> es (Type ?tn) = Type ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = Type (ts @ ?tm)\n  check \\<C> (es @ [e]) (Type tn) = Type tm\n\ngoal (1 subgoal):\n 1. check \\<C> (es @ [e]) (Type (ts @ tn)) = Type (ts @ tm)", "by (metis check_unfold_snoc checker_type.distinct(5))"], ["proof (state)\nthis:\n  check \\<C> (es @ [e]) (Type (ts @ tn)) = Type (ts @ tm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_bot: \"check \\<C> es Bot = Bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es Bot = Bot", "by (simp add: list.case_eq_if)"], ["", "lemma b_e_check_weaken_top:\n  assumes \"check \\<C> es (Type tn) = (TopType tm)\"\n  shows \"check \\<C> es (Type (ts@tn)) = (TopType tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> es (Type (ts @ tn)) = TopType tm", "using assms"], ["proof (prove)\nusing this:\n  check \\<C> es (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. check \\<C> es (Type (ts @ tn)) = TopType tm", "proof (induction es arbitrary: tn tm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tn tm.\n       check \\<C> [] (Type tn) = TopType tm \\<Longrightarrow>\n       check \\<C> [] (Type (ts @ tn)) = TopType tm\n 2. \\<And>a es tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> es (Type tn) = TopType tm \\<Longrightarrow>\n                   check \\<C> es (Type (ts @ tn)) = TopType tm;\n        check \\<C> (a # es) (Type tn) = TopType tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) (Type (ts @ tn)) = TopType tm", "case Nil"], ["proof (state)\nthis:\n  check \\<C> [] (Type tn) = TopType tm\n\ngoal (2 subgoals):\n 1. \\<And>tn tm.\n       check \\<C> [] (Type tn) = TopType tm \\<Longrightarrow>\n       check \\<C> [] (Type (ts @ tn)) = TopType tm\n 2. \\<And>a es tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> es (Type tn) = TopType tm \\<Longrightarrow>\n                   check \\<C> es (Type (ts @ tn)) = TopType tm;\n        check \\<C> (a # es) (Type tn) = TopType tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) (Type (ts @ tn)) = TopType tm", "thus ?case"], ["proof (prove)\nusing this:\n  check \\<C> [] (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. check \\<C> [] (Type (ts @ tn)) = TopType tm", "by simp"], ["proof (state)\nthis:\n  check \\<C> [] (Type (ts @ tn)) = TopType tm\n\ngoal (1 subgoal):\n 1. \\<And>a es tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> es (Type tn) = TopType tm \\<Longrightarrow>\n                   check \\<C> es (Type (ts @ tn)) = TopType tm;\n        check \\<C> (a # es) (Type tn) = TopType tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) (Type (ts @ tn)) = TopType tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> es (Type tn) = TopType tm \\<Longrightarrow>\n                   check \\<C> es (Type (ts @ tn)) = TopType tm;\n        check \\<C> (a # es) (Type tn) = TopType tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) (Type (ts @ tn)) = TopType tm", "case (Cons e es)"], ["proof (state)\nthis:\n  check \\<C> es (Type ?tn) = TopType ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = TopType ?tm\n  check \\<C> (e # es) (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. \\<And>a es tn tm.\n       \\<lbrakk>\\<And>tn tm.\n                   check \\<C> es (Type tn) = TopType tm \\<Longrightarrow>\n                   check \\<C> es (Type (ts @ tn)) = TopType tm;\n        check \\<C> (a # es) (Type tn) = TopType tm\\<rbrakk>\n       \\<Longrightarrow> check \\<C> (a # es) (Type (ts @ tn)) = TopType tm", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "proof (cases \"(check_single \\<C> e (Type tn))\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       check_single \\<C> e (Type tn) = TopType x1 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 3. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "case (TopType x1)"], ["proof (state)\nthis:\n  check_single \\<C> e (Type tn) = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       check_single \\<C> e (Type tn) = TopType x1 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 3. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "hence \"check_single \\<C> e (Type (ts@tn)) = TopType x1\""], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type tn) = TopType x1\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType x1", "using b_e_check_single_weaken_top"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type tn) = TopType x1\n  check_single ?\\<C> ?e (Type ?tn) = TopType ?tm \\<Longrightarrow>\n  check_single ?\\<C> ?e (Type (?ts @ ?tn)) = TopType ?tm\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = TopType x1", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       check_single \\<C> e (Type tn) = TopType x1 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 3. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type (ts @ tn)) = TopType x1\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "using TopType Cons"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type (ts @ tn)) = TopType x1\n  check_single \\<C> e (Type tn) = TopType x1\n  check \\<C> es (Type ?tn) = TopType ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = TopType ?tm\n  check \\<C> (e # es) (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "by simp"], ["proof (state)\nthis:\n  check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "case (Type x2)"], ["proof (state)\nthis:\n  check_single \\<C> e (Type tn) = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "hence \"check_single \\<C> e (Type (ts@tn)) = Type (ts@x2)\""], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type tn) = Type x2\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ x2)", "using b_e_check_single_weaken_type"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type tn) = Type x2\n  check_single ?\\<C> ?e (Type ?tn) = Type ?tm \\<Longrightarrow>\n  check_single ?\\<C> ?e (Type (?ts @ ?tn)) = Type (?ts @ ?tm)\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type (ts @ tn)) = Type (ts @ x2)", "by blast"], ["proof (state)\nthis:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ x2)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       check_single \\<C> e (Type tn) = Type x2 \\<Longrightarrow>\n       check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n 2. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ x2)\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "using Cons Type"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type (ts @ tn)) = Type (ts @ x2)\n  check \\<C> es (Type ?tn) = TopType ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = TopType ?tm\n  check \\<C> (e # es) (Type tn) = TopType tm\n  check_single \\<C> e (Type tn) = Type x2\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "by fastforce"], ["proof (state)\nthis:\n  check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "case Bot"], ["proof (state)\nthis:\n  check_single \\<C> e (Type tn) = Bot\n\ngoal (1 subgoal):\n 1. check_single \\<C> e (Type tn) = Bot \\<Longrightarrow>\n    check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "thus ?thesis"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type tn) = Bot\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "using check_bot Cons"], ["proof (prove)\nusing this:\n  check_single \\<C> e (Type tn) = Bot\n  check ?\\<C> ?es Bot = Bot\n  check \\<C> es (Type ?tn) = TopType ?tm \\<Longrightarrow>\n  check \\<C> es (Type (ts @ ?tn)) = TopType ?tm\n  check \\<C> (e # es) (Type tn) = TopType tm\n\ngoal (1 subgoal):\n 1. check \\<C> (e # es) (Type (ts @ tn)) = TopType tm", "by simp"], ["proof (state)\nthis:\n  check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check \\<C> (e # es) (Type (ts @ tn)) = TopType tm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_type_checker_weaken:\n  assumes \"b_e_type_checker \\<C> es (t1s _> t2s)\"\n  shows \"b_e_type_checker \\<C> es (ts@t1s _> ts@t2s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "have \"c_types_agree (check \\<C> es (Type t1s)) t2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_types_agree (check \\<C> es (Type t1s)) t2s", "using assms(1)"], ["proof (prove)\nusing this:\n  b_e_type_checker \\<C> es (t1s _> t2s)\n\ngoal (1 subgoal):\n 1. c_types_agree (check \\<C> es (Type t1s)) t2s", "by simp"], ["proof (state)\nthis:\n  c_types_agree (check \\<C> es (Type t1s)) t2s\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "then"], ["proof (chain)\npicking this:\n  c_types_agree (check \\<C> es (Type t1s)) t2s", "obtain ctn where ctn_def:\"check \\<C> es (Type t1s) = ctn\"\n                                \"c_types_agree ctn t2s\"\n                                \"ctn \\<noteq> Bot\""], ["proof (prove)\nusing this:\n  c_types_agree (check \\<C> es (Type t1s)) t2s\n\ngoal (1 subgoal):\n 1. (\\<And>ctn.\n        \\<lbrakk>check \\<C> es (Type t1s) = ctn; c_types_agree ctn t2s;\n         ctn \\<noteq> Bot\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  check \\<C> es (Type t1s) = ctn\n  c_types_agree ctn t2s\n  ctn \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "proof (cases ctn)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ctn = TopType x1 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 2. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 3. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "case (TopType x1)"], ["proof (state)\nthis:\n  ctn = TopType x1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       ctn = TopType x1 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 2. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 3. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ctn = TopType x1\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "using ctn_def(1,2) b_e_check_weaken_top[of \\<C> es t1s x1 ts]"], ["proof (prove)\nusing this:\n  ctn = TopType x1\n  check \\<C> es (Type t1s) = ctn\n  c_types_agree ctn t2s\n  check \\<C> es (Type t1s) = TopType x1 \\<Longrightarrow>\n  check \\<C> es (Type (ts @ t1s)) = TopType x1\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "by (metis append_assoc b_e_type_checker.simps c_types_agree_imp_ct_list_eq c_types_agree_top2)"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 2. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 2. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "case (Type x2)"], ["proof (state)\nthis:\n  ctn = Type x2\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       ctn = Type x2 \\<Longrightarrow>\n       b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n 2. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ctn = Type x2\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "using ctn_def(1,2) b_e_check_weaken_type[of \\<C> es t1s x2 ts]"], ["proof (prove)\nusing this:\n  ctn = Type x2\n  check \\<C> es (Type t1s) = ctn\n  c_types_agree ctn t2s\n  check \\<C> es (Type t1s) = Type x2 \\<Longrightarrow>\n  check \\<C> es (Type (ts @ t1s)) = Type (ts @ x2)\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "by simp"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n\ngoal (1 subgoal):\n 1. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "case Bot"], ["proof (state)\nthis:\n  ctn = Bot\n\ngoal (1 subgoal):\n 1. ctn = Bot \\<Longrightarrow>\n    b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ctn = Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "using ctn_def(3)"], ["proof (prove)\nusing this:\n  ctn = Bot\n  ctn \\<noteq> Bot\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "by simp"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_e_type_checker_complete:\n  assumes \"\\<C> \\<turnstile> es : (tn _> tm)\"\n  shows \"b_e_type_checker \\<C> es (tn _> tm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (tn _> tm)", "using assms"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> es : tn _> tm\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (tn _> tm)", "proof (induction es \"(tn _> tm)\" arbitrary: tn tm rule: b_e_typing.induct)"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 35 subgoals...", "case (select \\<C> t)"], ["proof (state)\nthis:\n  \n\ngoal (35 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 35 subgoals...", "have \"ct_list_eq [TAny, TSome T_i32] [TSome t, TSome T_i32]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ct_list_eq [TAny, TSome T_i32] [TSome t, TSome T_i32]", "by (simp add: to_ct_list_def ct_list_eq_def)"], ["proof (state)\nthis:\n  ct_list_eq [TAny, TSome T_i32] [TSome t, TSome T_i32]\n\ngoal (35 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 35 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  ct_list_eq [TAny, TSome T_i32] [TSome t, TSome T_i32]\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> [Select] ([t, t, T_i32] _> [t])", "using ct_suffix_extend_ct_list_eq[OF ct_suffix_nil[of \"[TSome t]\"]] to_ct_list_def"], ["proof (prove)\nusing this:\n  ct_list_eq [TAny, TSome T_i32] [TSome t, TSome T_i32]\n  ct_list_eq ?xs' ?ys' \\<Longrightarrow>\n  ct_suffix ([] @ ?xs') ([TSome t] @ ?ys')\n  to_ct_list ?ts = map TSome ?ts\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> [Select] ([t, t, T_i32] _> [t])", "by auto"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> [Select] ([t, t, T_i32] _> [t])\n\ngoal (34 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 34 subgoals...", "case (br_table \\<C> ts \"is\" i t1s t2s)"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length (label \\<C>) \\<and> label \\<C> ! i = ts)\n   (is @ [i])\n\ngoal (34 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 34 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> [Br_table is i] (t1s @ ts @ [T_i32] _> t2s)", "using list_all_conv_same_lab[OF br_table]"], ["proof (prove)\nusing this:\n  same_lab (is @ [i]) (label \\<C>) = Some ts\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> [Br_table is i] (t1s @ ts @ [T_i32] _> t2s)", "by (auto simp add: to_ct_list_def ct_suffix_nil ct_suffix_cons_it)"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> [Br_table is i] (t1s @ ts @ [T_i32] _> t2s)\n\ngoal (33 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 33 subgoals...", "case (set_global i \\<C> t)"], ["proof (state)\nthis:\n  i < length (global \\<C>)\n  tg_t (global \\<C> ! i) = t\n  is_mut (global \\<C> ! i)\n\ngoal (33 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 33 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  i < length (global \\<C>)\n  tg_t (global \\<C> ! i) = t\n  is_mut (global \\<C> ! i)\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> [Set_global i] ([t] _> [])", "using to_ct_list_def ct_suffix_refl is_mut_def tg_t_def"], ["proof (prove)\nusing this:\n  i < length (global \\<C>)\n  tg_t (global \\<C> ! i) = t\n  is_mut (global \\<C> ! i)\n  to_ct_list ?ts = map TSome ?ts\n  ct_suffix ?ts ?ts\n  is_mut ?tg = (tg_mut ?tg = T_mut)\n  tg_t \\<equiv>\n  id \\<circ> Record.iso_tuple_snd Record.tuple_iso_tuple \\<circ>\n  Record.iso_tuple_fst tg_ext_Tuple_Iso\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> [Set_global i] ([t] _> [])", "by auto"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> [Set_global i] ([t] _> [])\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 32 subgoals...", "case (composition \\<C> es t1s t2s e t3s)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  b_e_type_checker \\<C> es (t1s _> t2s)\n  \\<C> \\<turnstile> [e] : t2s _> t3s\n  b_e_type_checker \\<C> [e] (t2s _> t3s)\n\ngoal (32 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 32 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  b_e_type_checker \\<C> es (t1s _> t2s)\n  \\<C> \\<turnstile> [e] : t2s _> t3s\n  b_e_type_checker \\<C> [e] (t2s _> t3s)\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "using b_e_type_checker_compose"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  b_e_type_checker \\<C> es (t1s _> t2s)\n  \\<C> \\<turnstile> [e] : t2s _> t3s\n  b_e_type_checker \\<C> [e] (t2s _> t3s)\n  \\<lbrakk>b_e_type_checker ?\\<C> ?es (?t1s _> ?t2s);\n   b_e_type_checker ?\\<C> [?e] (?t2s _> ?t3s)\\<rbrakk>\n  \\<Longrightarrow> b_e_type_checker ?\\<C> (?es @ [?e]) (?t1s _> ?t3s)\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)", "by simp"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> (es @ [e]) (t1s _> t3s)\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 31 subgoals...", "case (weakening \\<C> es t1s t2s ts)"], ["proof (state)\nthis:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  b_e_type_checker \\<C> es (t1s _> t2s)\n\ngoal (31 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 31 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  b_e_type_checker \\<C> es (t1s _> t2s)\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "using b_e_type_checker_weaken"], ["proof (prove)\nusing this:\n  \\<C> \\<turnstile> es : t1s _> t2s\n  b_e_type_checker \\<C> es (t1s _> t2s)\n  b_e_type_checker ?\\<C> ?es (?t1s _> ?t2s) \\<Longrightarrow>\n  b_e_type_checker ?\\<C> ?es (?ts @ ?t1s _> ?ts @ ?t2s)\n\ngoal (1 subgoal):\n 1. b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)", "by simp"], ["proof (state)\nthis:\n  b_e_type_checker \\<C> es (ts @ t1s _> ts @ t2s)\n\ngoal (30 subgoals):\n 1. \\<And>\\<C> v. b_e_type_checker \\<C> [C v] ([] _> [typeof v])\n 2. \\<And>t \\<C> uu_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_i t uu_] ([t] _> [t])\n 3. \\<And>t \\<C> uv_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Unop_f t uv_] ([t] _> [t])\n 4. \\<And>t \\<C> iop.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_i t iop] ([t, t] _> [t])\n 5. \\<And>t \\<C> uw_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Binop_f t uw_] ([t, t] _> [t])\n 6. \\<And>t \\<C> ux_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Testop t ux_] ([t] _> [T_i32])\n 7. \\<And>t \\<C> uy_.\n       is_int_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_i t uy_] ([t, t] _> [T_i32])\n 8. \\<And>t \\<C> uz_.\n       is_float_t t \\<Longrightarrow>\n       b_e_type_checker \\<C> [Relop_f t uz_] ([t, t] _> [T_i32])\n 9. \\<And>t1 t2 sx \\<C>.\n       \\<lbrakk>t1 \\<noteq> t2;\n        (sx = None) =\n        (is_float_t t1 \\<and> is_float_t t2 \\<or>\n         is_int_t t1 \\<and>\n         is_int_t t2 \\<and> t_length t1 < t_length t2)\\<rbrakk>\n       \\<Longrightarrow> b_e_type_checker \\<C> [Cvtop t1 Convert t2 sx]\n                          ([t2] _> [t1])\n 10. \\<And>t1 t2 \\<C>.\n        \\<lbrakk>t1 \\<noteq> t2; t_length t1 = t_length t2\\<rbrakk>\n        \\<Longrightarrow> b_e_type_checker \\<C>\n                           [Cvtop t1 Reinterpret t2 None] ([t2] _> [t1])\nA total of 30 subgoals...", "qed (auto simp add: to_ct_list_def ct_suffix_refl ct_suffix_nil ct_suffix_cons_it\n                    ct_suffix_singleton_any)"], ["", "theorem b_e_typing_equiv_b_e_type_checker:\n  shows \"(\\<C> \\<turnstile> es : (tn _> tm)) = (b_e_type_checker \\<C> es (tn _> tm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm = b_e_type_checker \\<C> es (tn _> tm)", "using b_e_type_checker_sound b_e_type_checker_complete"], ["proof (prove)\nusing this:\n  b_e_type_checker ?\\<C> ?es (?tn _> ?tm) \\<Longrightarrow>\n  ?\\<C> \\<turnstile> ?es : ?tn _> ?tm\n  ?\\<C> \\<turnstile> ?es : ?tn _> ?tm \\<Longrightarrow>\n  b_e_type_checker ?\\<C> ?es (?tn _> ?tm)\n\ngoal (1 subgoal):\n 1. \\<C> \\<turnstile> es : tn _> tm = b_e_type_checker \\<C> es (tn _> tm)", "by blast"], ["", "end"]]}