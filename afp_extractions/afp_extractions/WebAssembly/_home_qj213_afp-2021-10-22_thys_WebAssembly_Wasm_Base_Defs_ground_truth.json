{"file_name": "/home/qj213/afp-2021-10-22/thys/WebAssembly/Wasm_Base_Defs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WebAssembly", "problem_names": ["lemma is_int_t_exists:\n  assumes \"is_int_t t\"\n  shows \"t = T_i32 \\<or> t = T_i64\"", "lemma is_float_t_exists:\n  assumes \"is_float_t t\"\n  shows \"t = T_f32 \\<or> t = T_f64\"", "lemma int_float_disjoint: \"is_int_t t = -(is_float_t t)\"", "lemma stab_unfold:\n  assumes \"stab s i j = Some cl\"\n  shows \"\\<exists>k. inst.tab ((inst s)!i) = Some k \\<and> length ((tab s)!k) > j \\<and>((tab s)!k)!j = Some cl\"", "lemma inj_basic: \"inj Basic\"", "lemma inj_basic_econst: \"inj (\\<lambda>v. $C v)\"", "lemma to_e_list_1:\"[$ a] = $* [a]\"", "lemma to_e_list_2:\"[$ a, $ b] = $* [a, b]\"", "lemma to_e_list_3:\"[$ a, $ b, $ c] = $* [a, b, c]\"", "lemma v_exists_b_e:\"\\<exists>ves. ($$*vs) = ($*ves)\"", "lemma Lfilled_exact_imp_Lfilled:\n  assumes \"Lfilled_exact n lholed es LI\"\n  shows \"Lfilled n lholed es LI\"", "lemma Lfilled_exact_app_imp_exists_Lfilled:\n  assumes \"const_list ves\"\n          \"Lfilled_exact n lholed (ves@es) LI\"\n  shows \"\\<exists>lholed'. Lfilled n lholed' es LI\"", "lemma Lfilled_imp_exists_Lfilled_exact:\n  assumes \"Lfilled n lholed es LI\"\n  shows \"\\<exists>lholed' ves es_c. const_list ves \\<and> Lfilled_exact n lholed' (ves@es@es_c) LI\"", "lemma n_zeros_typeof:\n  \"n_zeros ts = vs \\<Longrightarrow> (ts = map typeof vs)\""], "translations": [["", "lemma is_int_t_exists:\n  assumes \"is_int_t t\"\n  shows \"t = T_i32 \\<or> t = T_i64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = T_i32 \\<or> t = T_i64", "using assms"], ["proof (prove)\nusing this:\n  is_int_t t\n\ngoal (1 subgoal):\n 1. t = T_i32 \\<or> t = T_i64", "by (cases t) (auto simp add: is_int_t_def)"], ["", "lemma is_float_t_exists:\n  assumes \"is_float_t t\"\n  shows \"t = T_f32 \\<or> t = T_f64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = T_f32 \\<or> t = T_f64", "using assms"], ["proof (prove)\nusing this:\n  is_float_t t\n\ngoal (1 subgoal):\n 1. t = T_f32 \\<or> t = T_f64", "by (cases t) (auto simp add: is_float_t_def)"], ["", "lemma int_float_disjoint: \"is_int_t t = -(is_float_t t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_int_t t = - is_float_t t", "by simp (metis is_float_t_def is_int_t_def t.exhaust t.simps(13-16))"], ["", "lemma stab_unfold:\n  assumes \"stab s i j = Some cl\"\n  shows \"\\<exists>k. inst.tab ((inst s)!i) = Some k \\<and> length ((tab s)!k) > j \\<and>((tab s)!k)!j = Some cl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "obtain k where have_k:\"(inst.tab ((inst s)!i)) = Some k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inst.tab (inst s ! i) = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  stab s i j = Some cl\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inst.tab (inst s ! i) = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding stab_def"], ["proof (prove)\nusing this:\n  (case inst.tab (inst s ! i) of None \\<Rightarrow> None\n   | Some k \\<Rightarrow> stab_s s k j) =\n  Some cl\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inst.tab (inst s ! i) = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  inst.tab (inst s ! i) = Some k\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "hence s_o:\"stab s i j = stab_s s k j\""], ["proof (prove)\nusing this:\n  inst.tab (inst s ! i) = Some k\n\ngoal (1 subgoal):\n 1. stab s i j = stab_s s k j", "using assms"], ["proof (prove)\nusing this:\n  inst.tab (inst s ! i) = Some k\n  stab s i j = Some cl\n\ngoal (1 subgoal):\n 1. stab s i j = stab_s s k j", "unfolding stab_def"], ["proof (prove)\nusing this:\n  inst.tab (inst s ! i) = Some k\n  (case inst.tab (inst s ! i) of None \\<Rightarrow> None\n   | Some k \\<Rightarrow> stab_s s k j) =\n  Some cl\n\ngoal (1 subgoal):\n 1. (case inst.tab (inst s ! i) of None \\<Rightarrow> None\n     | Some k \\<Rightarrow> stab_s s k j) =\n    stab_s s k j", "by simp"], ["proof (state)\nthis:\n  stab s i j = stab_s s k j\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "then"], ["proof (chain)\npicking this:\n  stab s i j = stab_s s k j", "obtain stabinst where stabinst_def:\"stabinst = ((tab s)!k)\""], ["proof (prove)\nusing this:\n  stab s i j = stab_s s k j\n\ngoal (1 subgoal):\n 1. (\\<And>stabinst.\n        stabinst = s.tab s ! k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  stabinst = s.tab s ! k\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "hence \"stab_s s k j = (stabinst!j) \\<and> (length stabinst > j)\""], ["proof (prove)\nusing this:\n  stabinst = s.tab s ! k\n\ngoal (1 subgoal):\n 1. stab_s s k j = stabinst ! j \\<and> j < length stabinst", "using assms s_o"], ["proof (prove)\nusing this:\n  stabinst = s.tab s ! k\n  stab s i j = Some cl\n  stab s i j = stab_s s k j\n\ngoal (1 subgoal):\n 1. stab_s s k j = stabinst ! j \\<and> j < length stabinst", "unfolding stab_s_def"], ["proof (prove)\nusing this:\n  stabinst = s.tab s ! k\n  stab s i j = Some cl\n  stab s i j =\n  (let stabinst = s.tab s ! k\n   in if j < length stabinst then stabinst ! j else None)\n\ngoal (1 subgoal):\n 1. (let stabinst = s.tab s ! k\n     in if j < length stabinst then stabinst ! j else None) =\n    stabinst ! j \\<and>\n    j < length stabinst", "by (cases \"(length stabinst > j)\", auto)"], ["proof (state)\nthis:\n  stab_s s k j = stabinst ! j \\<and> j < length stabinst\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "thus ?thesis"], ["proof (prove)\nusing this:\n  stab_s s k j = stabinst ! j \\<and> j < length stabinst\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "using have_k stabinst_def assms s_o"], ["proof (prove)\nusing this:\n  stab_s s k j = stabinst ! j \\<and> j < length stabinst\n  inst.tab (inst s ! i) = Some k\n  stabinst = s.tab s ! k\n  stab s i j = Some cl\n  stab s i j = stab_s s k j\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       inst.tab (inst s ! i) = Some k \\<and>\n       j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl", "by auto"], ["proof (state)\nthis:\n  \\<exists>k.\n     inst.tab (inst s ! i) = Some k \\<and>\n     j < length (s.tab s ! k) \\<and> s.tab s ! k ! j = Some cl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_basic: \"inj Basic\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj Basic", "by (meson e.inject(1) injI)"], ["", "lemma inj_basic_econst: \"inj (\\<lambda>v. $C v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>v. $C v)", "by (meson b_e.inject(16) e.inject(1) injI)"], ["", "lemma to_e_list_1:\"[$ a] = $* [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [$a] = $* [a]", "by simp"], ["", "lemma to_e_list_2:\"[$ a, $ b] = $* [a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [$a, $b] = $* [a, b]", "by simp"], ["", "lemma to_e_list_3:\"[$ a, $ b, $ c] = $* [a, b, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [$a, $b, $c] = $* [a, b, c]", "by simp"], ["", "lemma v_exists_b_e:\"\\<exists>ves. ($$*vs) = ($*ves)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ves. $$* vs = $* ves", "proof (induction vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>ves. $$* [] = $* ves\n 2. \\<And>a vs.\n       \\<exists>ves. $$* vs = $* ves \\<Longrightarrow>\n       \\<exists>ves. $$* a # vs = $* ves", "case (Cons a vs)"], ["proof (state)\nthis:\n  \\<exists>ves. $$* vs = $* ves\n\ngoal (2 subgoals):\n 1. \\<exists>ves. $$* [] = $* ves\n 2. \\<And>a vs.\n       \\<exists>ves. $$* vs = $* ves \\<Longrightarrow>\n       \\<exists>ves. $$* a # vs = $* ves", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>ves. $$* vs = $* ves\n\ngoal (1 subgoal):\n 1. \\<exists>ves. $$* a # vs = $* ves", "by (metis list.simps(9))"], ["proof (state)\nthis:\n  \\<exists>ves. $$* a # vs = $* ves\n\ngoal (1 subgoal):\n 1. \\<exists>ves. $$* [] = $* ves", "qed auto"], ["", "lemma Lfilled_exact_imp_Lfilled:\n  assumes \"Lfilled_exact n lholed es LI\"\n  shows \"Lfilled n lholed es LI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lfilled n lholed es LI", "using assms"], ["proof (prove)\nusing this:\n  Lfilled_exact n lholed es LI\n\ngoal (1 subgoal):\n 1. Lfilled n lholed es LI", "proof (induction rule: Lfilled_exact.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lholed es.\n       lholed = LBase [] [] \\<Longrightarrow> Lfilled 0 lholed es es\n 2. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l es lfilledk; Lfilled k l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> Lfilled (k + 1) lholed es\n                          (vs @ [Label n es' lfilledk] @ es'')", "case (L0 lholed es)"], ["proof (state)\nthis:\n  lholed = LBase [] []\n\ngoal (2 subgoals):\n 1. \\<And>lholed es.\n       lholed = LBase [] [] \\<Longrightarrow> Lfilled 0 lholed es es\n 2. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l es lfilledk; Lfilled k l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> Lfilled (k + 1) lholed es\n                          (vs @ [Label n es' lfilledk] @ es'')", "thus ?case"], ["proof (prove)\nusing this:\n  lholed = LBase [] []\n\ngoal (1 subgoal):\n 1. Lfilled 0 lholed es es", "using const_list_def Lfilled.intros(1)"], ["proof (prove)\nusing this:\n  lholed = LBase [] []\n  const_list ?xs = list_all is_const ?xs\n  \\<lbrakk>const_list ?vs; ?lholed = LBase ?vs ?es'\\<rbrakk>\n  \\<Longrightarrow> Lfilled 0 ?lholed ?es (?vs @ ?es @ ?es')\n\ngoal (1 subgoal):\n 1. Lfilled 0 lholed es es", "by fastforce"], ["proof (state)\nthis:\n  Lfilled 0 lholed es es\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l es lfilledk; Lfilled k l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> Lfilled (k + 1) lholed es\n                          (vs @ [Label n es' lfilledk] @ es'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l es lfilledk; Lfilled k l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> Lfilled (k + 1) lholed es\n                          (vs @ [Label n es' lfilledk] @ es'')", "case (LN vs lholed n es' l es'' k es lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled_exact k l es lfilledk\n  Lfilled k l es lfilledk\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k es lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l es lfilledk; Lfilled k l es lfilledk\\<rbrakk>\n       \\<Longrightarrow> Lfilled (k + 1) lholed es\n                          (vs @ [Label n es' lfilledk] @ es'')", "thus ?case"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled_exact k l es lfilledk\n  Lfilled k l es lfilledk\n\ngoal (1 subgoal):\n 1. Lfilled (k + 1) lholed es (vs @ [Label n es' lfilledk] @ es'')", "using Lfilled.intros(2)"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled_exact k l es lfilledk\n  Lfilled k l es lfilledk\n  \\<lbrakk>const_list ?vs; ?lholed = LRec ?vs ?n ?es' ?l ?es'';\n   Lfilled ?k ?l ?es ?lfilledk\\<rbrakk>\n  \\<Longrightarrow> Lfilled (?k + 1) ?lholed ?es\n                     (?vs @ [Label ?n ?es' ?lfilledk] @ ?es'')\n\ngoal (1 subgoal):\n 1. Lfilled (k + 1) lholed es (vs @ [Label n es' lfilledk] @ es'')", "by fastforce"], ["proof (state)\nthis:\n  Lfilled (k + 1) lholed es (vs @ [Label n es' lfilledk] @ es'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lfilled_exact_app_imp_exists_Lfilled:\n  assumes \"const_list ves\"\n          \"Lfilled_exact n lholed (ves@es) LI\"\n  shows \"\\<exists>lholed'. Lfilled n lholed' es LI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled n lholed' es LI", "using assms(2,1)"], ["proof (prove)\nusing this:\n  Lfilled_exact n lholed (ves @ es) LI\n  const_list ves\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled n lholed' es LI", "proof (induction \"(ves@es)\" LI rule: Lfilled_exact.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       \\<lbrakk>lholed = LBase [] []; const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'. Lfilled 0 lholed' es (ves @ es)\n 2. \\<And>vs lholed n es' l es'' k lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l (ves @ es) lfilledk;\n        const_list ves \\<Longrightarrow>\n        \\<exists>lholed'. Lfilled k lholed' es lfilledk;\n        const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled (k + 1) lholed' es\n                             (vs @ [Label n es' lfilledk] @ es'')", "case (L0 lholed)"], ["proof (state)\nthis:\n  lholed = LBase [] []\n  const_list ves\n\ngoal (2 subgoals):\n 1. \\<And>lholed.\n       \\<lbrakk>lholed = LBase [] []; const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'. Lfilled 0 lholed' es (ves @ es)\n 2. \\<And>vs lholed n es' l es'' k lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l (ves @ es) lfilledk;\n        const_list ves \\<Longrightarrow>\n        \\<exists>lholed'. Lfilled k lholed' es lfilledk;\n        const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled (k + 1) lholed' es\n                             (vs @ [Label n es' lfilledk] @ es'')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' es (ves @ es)", "using Lfilled.intros(1)[OF L0(2), of _ \"[]\"]"], ["proof (prove)\nusing this:\n  ?lholed = LBase ves [] \\<Longrightarrow>\n  Lfilled 0 ?lholed ?es (ves @ ?es @ [])\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'. Lfilled 0 lholed' es (ves @ es)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed'. Lfilled 0 lholed' es (ves @ es)\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l (ves @ es) lfilledk;\n        const_list ves \\<Longrightarrow>\n        \\<exists>lholed'. Lfilled k lholed' es lfilledk;\n        const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled (k + 1) lholed' es\n                             (vs @ [Label n es' lfilledk] @ es'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l (ves @ es) lfilledk;\n        const_list ves \\<Longrightarrow>\n        \\<exists>lholed'. Lfilled k lholed' es lfilledk;\n        const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled (k + 1) lholed' es\n                             (vs @ [Label n es' lfilledk] @ es'')", "case (LN vs lholed n es' l es'' k lfilledk)"], ["proof (state)\nthis:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled_exact k l (ves @ es) lfilledk\n  const_list ves \\<Longrightarrow>\n  \\<exists>lholed'. Lfilled k lholed' es lfilledk\n  const_list ves\n\ngoal (1 subgoal):\n 1. \\<And>vs lholed n es' l es'' k lfilledk.\n       \\<lbrakk>const_list vs; lholed = LRec vs n es' l es'';\n        Lfilled_exact k l (ves @ es) lfilledk;\n        const_list ves \\<Longrightarrow>\n        \\<exists>lholed'. Lfilled k lholed' es lfilledk;\n        const_list ves\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lholed'.\n                            Lfilled (k + 1) lholed' es\n                             (vs @ [Label n es' lfilledk] @ es'')", "thus ?case"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled_exact k l (ves @ es) lfilledk\n  const_list ves \\<Longrightarrow>\n  \\<exists>lholed'. Lfilled k lholed' es lfilledk\n  const_list ves\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled (k + 1) lholed' es (vs @ [Label n es' lfilledk] @ es'')", "using Lfilled.intros(2)"], ["proof (prove)\nusing this:\n  const_list vs\n  lholed = LRec vs n es' l es''\n  Lfilled_exact k l (ves @ es) lfilledk\n  const_list ves \\<Longrightarrow>\n  \\<exists>lholed'. Lfilled k lholed' es lfilledk\n  const_list ves\n  \\<lbrakk>const_list ?vs; ?lholed = LRec ?vs ?n ?es' ?l ?es'';\n   Lfilled ?k ?l ?es ?lfilledk\\<rbrakk>\n  \\<Longrightarrow> Lfilled (?k + 1) ?lholed ?es\n                     (?vs @ [Label ?n ?es' ?lfilledk] @ ?es'')\n\ngoal (1 subgoal):\n 1. \\<exists>lholed'.\n       Lfilled (k + 1) lholed' es (vs @ [Label n es' lfilledk] @ es'')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>lholed'.\n     Lfilled (k + 1) lholed' es (vs @ [Label n es' lfilledk] @ es'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lfilled_imp_exists_Lfilled_exact:\n  assumes \"Lfilled n lholed es LI\"\n  shows \"\\<exists>lholed' ves es_c. const_list ves \\<and> Lfilled_exact n lholed' (ves@es@es_c) LI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lholed' ves es_c.\n       const_list ves \\<and> Lfilled_exact n lholed' (ves @ es @ es_c) LI", "using assms Lfilled_exact.intros"], ["proof (prove)\nusing this:\n  Lfilled n lholed es LI\n  ?lholed = LBase [] [] \\<Longrightarrow> Lfilled_exact 0 ?lholed ?es ?es\n  \\<lbrakk>const_list ?vs; ?lholed = LRec ?vs ?n ?es' ?l ?es'';\n   Lfilled_exact ?k ?l ?es ?lfilledk\\<rbrakk>\n  \\<Longrightarrow> Lfilled_exact (?k + 1) ?lholed ?es\n                     (?vs @ [Label ?n ?es' ?lfilledk] @ ?es'')\n\ngoal (1 subgoal):\n 1. \\<exists>lholed' ves es_c.\n       const_list ves \\<and> Lfilled_exact n lholed' (ves @ es @ es_c) LI", "by (induction rule: Lfilled.induct) fastforce+"], ["", "lemma n_zeros_typeof:\n  \"n_zeros ts = vs \\<Longrightarrow> (ts = map typeof vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs", "proof (induction ts arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs. n_zeros [] = vs \\<Longrightarrow> [] = map typeof vs\n 2. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "case Nil"], ["proof (state)\nthis:\n  n_zeros [] = vs\n\ngoal (2 subgoals):\n 1. \\<And>vs. n_zeros [] = vs \\<Longrightarrow> [] = map typeof vs\n 2. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "thus ?case"], ["proof (prove)\nusing this:\n  n_zeros [] = vs\n\ngoal (1 subgoal):\n 1. [] = map typeof vs", "unfolding n_zeros_def"], ["proof (prove)\nusing this:\n  map bitzero [] = vs\n\ngoal (1 subgoal):\n 1. [] = map typeof vs", "by simp"], ["proof (state)\nthis:\n  [] = map typeof vs\n\ngoal (1 subgoal):\n 1. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "case (Cons t ts)"], ["proof (state)\nthis:\n  n_zeros ts = ?vs \\<Longrightarrow> ts = map typeof ?vs\n  n_zeros (t # ts) = vs\n\ngoal (1 subgoal):\n 1. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "obtain vs' where \"n_zeros ts = vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs'. n_zeros ts = vs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n_zeros_def"], ["proof (prove)\nusing this:\n  n_zeros ?ts = map bitzero ?ts\n\ngoal (1 subgoal):\n 1. (\\<And>vs'. n_zeros ts = vs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n_zeros ts = vs'\n\ngoal (1 subgoal):\n 1. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "moreover"], ["proof (state)\nthis:\n  n_zeros ts = vs'\n\ngoal (1 subgoal):\n 1. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "have \"typeof (bitzero t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof (bitzero t) = t", "unfolding typeof_def bitzero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case t of T_i32 \\<Rightarrow> ConstInt32 0\n          | T_i64 \\<Rightarrow> ConstInt64 0\n          | T_f32 \\<Rightarrow> ConstFloat32 0\n          | T_f64 \\<Rightarrow> ConstFloat64 0 of\n     ConstInt32 x \\<Rightarrow> T_i32 | ConstInt64 x \\<Rightarrow> T_i64\n     | ConstFloat32 x \\<Rightarrow> T_f32\n     | ConstFloat64 x \\<Rightarrow> T_f64) =\n    t", "by (cases t, simp_all)"], ["proof (state)\nthis:\n  typeof (bitzero t) = t\n\ngoal (1 subgoal):\n 1. \\<And>a ts vs.\n       \\<lbrakk>\\<And>vs.\n                   n_zeros ts = vs \\<Longrightarrow> ts = map typeof vs;\n        n_zeros (a # ts) = vs\\<rbrakk>\n       \\<Longrightarrow> a # ts = map typeof vs", "ultimately"], ["proof (chain)\npicking this:\n  n_zeros ts = vs'\n  typeof (bitzero t) = t", "show ?case"], ["proof (prove)\nusing this:\n  n_zeros ts = vs'\n  typeof (bitzero t) = t\n\ngoal (1 subgoal):\n 1. t # ts = map typeof vs", "using Cons"], ["proof (prove)\nusing this:\n  n_zeros ts = vs'\n  typeof (bitzero t) = t\n  n_zeros ts = ?vs \\<Longrightarrow> ts = map typeof ?vs\n  n_zeros (t # ts) = vs\n\ngoal (1 subgoal):\n 1. t # ts = map typeof vs", "unfolding n_zeros_def"], ["proof (prove)\nusing this:\n  map bitzero ts = vs'\n  typeof (bitzero t) = t\n  map bitzero ts = ?vs \\<Longrightarrow> ts = map typeof ?vs\n  map bitzero (t # ts) = vs\n\ngoal (1 subgoal):\n 1. t # ts = map typeof vs", "by auto"], ["proof (state)\nthis:\n  t # ts = map typeof vs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}