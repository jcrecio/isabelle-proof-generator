{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative_Test.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma \"\\<And>f x::'a af. f \\<diamondop> x = x\"", "lemma \"(X :: _ :: semigroup_add set) + Y + Z = X + (Y + Z)\"", "lemma \"Inl plus \\<diamondop> (x :: nat + 'e list) \\<diamondop> x = Inl (\\<lambda>x. 2 * x) \\<diamondop> x\"", "lemma \"rel_sum (\\<le>) (\\<le>) (x :: nat + nat) (Inl Suc \\<diamondop> x)\"", "lemma \"(x::int stream) * sconst 0 = sconst 0\"", "lemma \"(x::int stream) * (y + z) = x * y + x * z\"", "lemma lift_streams_Nil[applicative_unfold]: \"lift_streams [] = sconst []\"", "lemma lift_streams_Cons[applicative_unfold]:\n  \"lift_streams (x # xs) = smap2 Cons x (lift_streams xs)\"", "lemma stream_append_Cons: \"smap2 append (smap2 Cons x ys) zs = smap2 Cons x (smap2 append ys zs)\"", "lemma lift_streams_append[applicative_unfold]:\n  \"lift_streams (xs @ ys) = smap2 append (lift_streams xs) (lift_streams ys)\"", "lemma \"lift_streams (rev x) = smap rev (lift_streams x)\"", "lemma \"sconcat (lift_streams [sconst ''Hello '', sconst ''world!'']) = sconst ''Hello world!''\"", "lemma \"rel_fun (=) (\\<le>) (const (0::nat)) x\"", "lemma \"list_all2 (\\<subseteq>) (map (\\<lambda>_. {}) x) (map set x)\"", "lemma \"x = Some a \\<Longrightarrow> rel_option (\\<le>) (map_option (\\<lambda>_. a) x) (map_option Suc x)\""], "translations": [["", "lemma \"\\<And>f x::'a af. f \\<diamondop> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x. f \\<diamondop> x = x", "apply applicative_nf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. pure (\\<lambda>x. x) \\<diamondop> f = pure (\\<lambda>x. x)", "oops"], ["", "subsection \\<open>Sets\\<close>"], ["", "instantiation set :: (plus) plus\nbegin"], ["", "definition set_plus_def[applicative_unfold]: \"(X::('a::plus)set) + Y = {plus} \\<diamondop> X \\<diamondop> Y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, plus_class)", ".."], ["", "end"], ["", "lemma \"(X :: _ :: semigroup_add set) + Y + Z = X + (Y + Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X + Y + Z = X + (Y + Z)", "by (fact add.assoc[applicative_lifted set])"], ["", "instantiation set :: (semigroup_add) semigroup_add begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "fix X Y Z :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "from add.assoc"], ["proof (chain)\npicking this:\n  ?a + ?b + ?c = ?a + (?b + ?c)", "show \"X + Y + Z = X + (Y + Z)\""], ["proof (prove)\nusing this:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. X + Y + Z = X + (Y + Z)", "by applicative_lifting"], ["proof (state)\nthis:\n  X + Y + Z = X + (Y + Z)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation set :: (ab_semigroup_add) ab_semigroup_add begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, ab_semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a + b = b + a", "fix X Y :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a + b = b + a", "from add.commute"], ["proof (chain)\npicking this:\n  ?a + ?b = ?b + ?a", "show \"X + Y = Y + X\""], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. X + Y = Y + X", "by applicative_lifting"], ["proof (state)\nthis:\n  X + Y = Y + X\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Sum type (a.k.a. either)\\<close>"], ["", "lemma \"Inl plus \\<diamondop> (x :: nat + 'e list) \\<diamondop> x = Inl (\\<lambda>x. 2 * x) \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl (+) \\<diamondop> x \\<diamondop> x = Inl ((*) 2) \\<diamondop> x", "by applicative_lifting simp"], ["", "lemma \"rel_sum (\\<le>) (\\<le>) (x :: nat + nat) (Inl Suc \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_sum (\\<le>) (\\<le>) x (Inl Suc \\<diamondop> x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_sum (\\<le>) (\\<le>) x (Inl Suc \\<diamondop> x)", "interpret either_af \"(\\<le>) :: nat \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. either_af (\\<le>)", "by unfold_locales (rule reflpI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_sum (\\<le>) (\\<le>) x (Inl Suc \\<diamondop> x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_sum (\\<le>) (\\<le>) x (Inl Suc \\<diamondop> x)", "by applicative_lifting simp"], ["proof (state)\nthis:\n  rel_sum (\\<le>) (\\<le>) x (Inl Suc \\<diamondop> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Streams\\<close>"], ["", "lemma \"(x::int stream) * sconst 0 = sconst 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * pure 0 = pure 0", "by applicative_lifting simp"], ["", "lemma \"(x::int stream) * (y + z) = x * y + x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by applicative_lifting algebra"], ["", "definition \"lift_streams xs = foldr (smap2 Cons) xs (sconst [])\""], ["", "lemma lift_streams_Nil[applicative_unfold]: \"lift_streams [] = sconst []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_streams [] = pure []", "unfolding lift_streams_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (smap2 (#)) [] (pure []) = pure []", "by simp"], ["", "lemma lift_streams_Cons[applicative_unfold]:\n  \"lift_streams (x # xs) = smap2 Cons x (lift_streams xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_streams (x # xs) = smap2 (#) x (lift_streams xs)", "unfolding lift_streams_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (smap2 (#)) (x # xs) (pure []) =\n    smap2 (#) x (foldr (smap2 (#)) xs (pure []))", "by applicative_unfold"], ["", "lemma stream_append_Cons: \"smap2 append (smap2 Cons x ys) zs = smap2 Cons x (smap2 append ys zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap2 (@) (smap2 (#) x ys) zs = smap2 (#) x (smap2 (@) ys zs)", "by applicative_lifting simp"], ["", "lemma lift_streams_append[applicative_unfold]:\n  \"lift_streams (xs @ ys) = smap2 append (lift_streams xs) (lift_streams ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_streams (xs @ ys) = smap2 (@) (lift_streams xs) (lift_streams ys)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. lift_streams ([] @ ys) = smap2 (@) (lift_streams []) (lift_streams ys)\n 2. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lift_streams ([] @ ys) = smap2 (@) (lift_streams []) (lift_streams ys)\n 2. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "(*\n    case could be proved directly if \"lift_streams ([] @ ys) = lift_streams ys\" is solved\n    in head_cong_tac (invoke simplifier?) -- but only with applicative_nf\n  *)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lift_streams ([] @ ys) = smap2 (@) (lift_streams []) (lift_streams ys)\n 2. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "have \"lift_streams ys = sconst append \\<diamondop> lift_streams [] \\<diamondop> lift_streams ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_streams ys =\n    pure (@) \\<diamondop> lift_streams [] \\<diamondop> lift_streams ys", "by applicative_lifting simp"], ["proof (state)\nthis:\n  lift_streams ys =\n  pure (@) \\<diamondop> lift_streams [] \\<diamondop> lift_streams ys\n\ngoal (2 subgoals):\n 1. lift_streams ([] @ ys) = smap2 (@) (lift_streams []) (lift_streams ys)\n 2. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "thus ?case"], ["proof (prove)\nusing this:\n  lift_streams ys =\n  pure (@) \\<diamondop> lift_streams [] \\<diamondop> lift_streams ys\n\ngoal (1 subgoal):\n 1. lift_streams ([] @ ys) = smap2 (@) (lift_streams []) (lift_streams ys)", "by applicative_unfold"], ["proof (state)\nthis:\n  lift_streams ([] @ ys) = smap2 (@) (lift_streams []) (lift_streams ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  lift_streams (xs @ ys) = smap2 (@) (lift_streams xs) (lift_streams ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       lift_streams (xs @ ys) =\n       smap2 (@) (lift_streams xs) (lift_streams ys) \\<Longrightarrow>\n       lift_streams ((a # xs) @ ys) =\n       smap2 (@) (lift_streams (a # xs)) (lift_streams ys)", "with stream_append_Cons"], ["proof (chain)\npicking this:\n  smap2 (@) (smap2 (#) ?x ?ys) ?zs = smap2 (#) ?x (smap2 (@) ?ys ?zs)\n  lift_streams (xs @ ys) = smap2 (@) (lift_streams xs) (lift_streams ys)", "(* the actual lifted fact *)"], ["proof (chain)\npicking this:\n  smap2 (@) (smap2 (#) ?x ?ys) ?zs = smap2 (#) ?x (smap2 (@) ?ys ?zs)\n  lift_streams (xs @ ys) = smap2 (@) (lift_streams xs) (lift_streams ys)", "show ?case"], ["proof (prove)\nusing this:\n  smap2 (@) (smap2 (#) ?x ?ys) ?zs = smap2 (#) ?x (smap2 (@) ?ys ?zs)\n  lift_streams (xs @ ys) = smap2 (@) (lift_streams xs) (lift_streams ys)\n\ngoal (1 subgoal):\n 1. lift_streams ((x # xs) @ ys) =\n    smap2 (@) (lift_streams (x # xs)) (lift_streams ys)", "by applicative_unfold (rule sym)"], ["proof (state)\nthis:\n  lift_streams ((x # xs) @ ys) =\n  smap2 (@) (lift_streams (x # xs)) (lift_streams ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"lift_streams (rev x) = smap rev (lift_streams x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_streams (rev x) = smap rev (lift_streams x)", "proof (induction x)"], ["proof (state)\ngoal (2 subgoals):\n 1. lift_streams (rev []) = smap rev (lift_streams [])\n 2. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lift_streams (rev []) = smap rev (lift_streams [])\n 2. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "have \"lift_streams [] = smap rev (lift_streams [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_streams [] = smap rev (lift_streams [])", "by applicative_lifting simp"], ["proof (state)\nthis:\n  lift_streams [] = smap rev (lift_streams [])\n\ngoal (2 subgoals):\n 1. lift_streams (rev []) = smap rev (lift_streams [])\n 2. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "thus ?case"], ["proof (prove)\nusing this:\n  lift_streams [] = smap rev (lift_streams [])\n\ngoal (1 subgoal):\n 1. lift_streams (rev []) = smap rev (lift_streams [])", "by simp"], ["proof (state)\nthis:\n  lift_streams (rev []) = smap rev (lift_streams [])\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "case (Cons x xs)"], ["proof (state)\nthis:\n  lift_streams (rev xs) = smap rev (lift_streams xs)\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "have \"\\<forall>y ys. rev ys @ [y] = rev (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y ys. rev ys @ [y] = rev (y # ys)", "by simp"], ["proof (state)\nthis:\n  \\<forall>y ys. rev ys @ [y] = rev (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "hence \"\\<forall>y ys. smap2 append (smap rev ys) (smap2 Cons y (sconst [])) = smap rev (smap2 Cons y ys)\""], ["proof (prove)\nusing this:\n  \\<forall>y ys. rev ys @ [y] = rev (y # ys)\n\ngoal (1 subgoal):\n 1. \\<forall>y ys.\n       smap2 (@) (smap rev ys) (smap2 (#) y (pure [])) =\n       smap rev (smap2 (#) y ys)", "by applicative_lifting simp"], ["proof (state)\nthis:\n  \\<forall>y ys.\n     smap2 (@) (smap rev ys) (smap2 (#) y (pure [])) =\n     smap rev (smap2 (#) y ys)\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       lift_streams (rev x) = smap rev (lift_streams x) \\<Longrightarrow>\n       lift_streams (rev (a # x)) = smap rev (lift_streams (a # x))", "with Cons.IH"], ["proof (chain)\npicking this:\n  lift_streams (rev xs) = smap rev (lift_streams xs)\n  \\<forall>y ys.\n     smap2 (@) (smap rev ys) (smap2 (#) y (pure [])) =\n     smap rev (smap2 (#) y ys)", "show ?case"], ["proof (prove)\nusing this:\n  lift_streams (rev xs) = smap rev (lift_streams xs)\n  \\<forall>y ys.\n     smap2 (@) (smap rev ys) (smap2 (#) y (pure [])) =\n     smap rev (smap2 (#) y ys)\n\ngoal (1 subgoal):\n 1. lift_streams (rev (x # xs)) = smap rev (lift_streams (x # xs))", "by applicative_unfold blast"], ["proof (state)\nthis:\n  lift_streams (rev (x # xs)) = smap rev (lift_streams (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition [applicative_unfold]: \"sconcat xs = smap concat xs\""], ["", "lemma \"sconcat (lift_streams [sconst ''Hello '', sconst ''world!'']) = sconst ''Hello world!''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcat (lift_streams [pure ''Hello '', pure ''world!'']) =\n    pure ''Hello world!''", "by applicative_lifting simp"], ["", "subsection \\<open>Relators\\<close>"], ["", "lemma \"rel_fun (=) (\\<le>) (const (0::nat)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) (\\<le>) (pure 0) x", "by applicative_lifting simp"], ["", "lemma \"list_all2 (\\<subseteq>) (map (\\<lambda>_. {}) x) (map set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<subseteq>) (map (\\<lambda>_. {}) x) (map set x)", "by applicative_nf simp"], ["", "lemma \"x = Some a \\<Longrightarrow> rel_option (\\<le>) (map_option (\\<lambda>_. a) x) (map_option Suc x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Some a \\<Longrightarrow>\n    rel_option (\\<le>) (map_option (\\<lambda>_. a) x) (map_option Suc x)", "by applicative_lifting simp"], ["", "schematic_goal \"\\<forall>g f x. rel_sum ?R (=) (ap_either f x) (ap_either (ap_either (Inl g) f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g f x.\n       rel_sum ?R (=) (f \\<diamondop> x)\n        (Inl g \\<diamondop> f \\<diamondop> x)", "apply applicative_lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g fa xa. ?R (fa xa) (g fa xa)", "oops"], ["", "schematic_goal \"stream_all2 ?R (?f \\<diamondop> (pure ?g \\<diamondop> ?x + ?y)) (?x + ?z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 ?R (?f \\<diamondop> (pure ?g \\<diamondop> ?x + ?y))\n     (?x + ?z)", "apply applicative_lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z f x y.\n       \\<lbrakk>z \\<in> sset ?z; f \\<in> sset ?f; x \\<in> sset ?x;\n        y \\<in> sset ?y\\<rbrakk>\n       \\<Longrightarrow> ?R (f (?g x + y)) (x + z)", "oops"], ["", "print_applicative"], ["", "end"]]}