{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative_PMF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma ap_pmf_id: \"pure_pmf (\\<lambda>x. x) \\<diamondop> x = x\"", "lemma ap_pmf_comp: \"pure_pmf (\\<circ>) \\<diamondop> u \\<diamondop> v \\<diamondop> w = u \\<diamondop> (v \\<diamondop> w)\"", "lemma ap_pmf_homo: \"pure_pmf f \\<diamondop> pure_pmf x = pure_pmf (f x)\"", "lemma ap_pmf_interchange: \"u \\<diamondop> pure_pmf x = pure_pmf (\\<lambda>f. f x) \\<diamondop> u\"", "lemma ap_pmf_K: \"return_pmf (\\<lambda>x _. x) \\<diamondop> x \\<diamondop> y = x\"", "lemma ap_pmf_C: \"return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop> x \\<diamondop> y = f \\<diamondop> y \\<diamondop> x\"", "lemma ap_pmf_transfer[transfer_rule]:\n  \"rel_fun (rel_pmf (rel_fun A B)) (rel_fun (rel_pmf A) (rel_pmf B)) ap_pmf ap_pmf\""], "translations": [["", "lemma ap_pmf_id: \"pure_pmf (\\<lambda>x. x) \\<diamondop> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (\\<lambda>x. x) \\<diamondop> x = x", "by(simp add: ap_pmf_def pair_return_pmf1 pmf.map_comp o_def)"], ["", "lemma ap_pmf_comp: \"pure_pmf (\\<circ>) \\<diamondop> u \\<diamondop> v \\<diamondop> w = u \\<diamondop> (v \\<diamondop> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (\\<circ>) \\<diamondop> u \\<diamondop> v \\<diamondop> w =\n    u \\<diamondop> (v \\<diamondop> w)", "by(simp add: ap_pmf_def pair_return_pmf1 pair_map_pmf1 pair_map_pmf2 pmf.map_comp o_def split_def pair_pair_pmf)"], ["", "lemma ap_pmf_homo: \"pure_pmf f \\<diamondop> pure_pmf x = pure_pmf (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)", "by(simp add: ap_pmf_def pair_return_pmf1)"], ["", "lemma ap_pmf_interchange: \"u \\<diamondop> pure_pmf x = pure_pmf (\\<lambda>f. f x) \\<diamondop> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<diamondop> return_pmf x =\n    return_pmf (\\<lambda>f. f x) \\<diamondop> u", "by(simp add: ap_pmf_def pair_return_pmf1 pair_return_pmf2 pmf.map_comp o_def)"], ["", "lemma ap_pmf_K: \"return_pmf (\\<lambda>x _. x) \\<diamondop> x \\<diamondop> y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (\\<lambda>x _. x) \\<diamondop> x \\<diamondop> y = x", "by(simp add: ap_pmf_def pair_map_pmf1 pmf.map_comp pair_return_pmf1 o_def split_def map_fst_pair_pmf)"], ["", "lemma ap_pmf_C: \"return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop> x \\<diamondop> y = f \\<diamondop> y \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n    x \\<diamondop>\n    y =\n    f \\<diamondop> y \\<diamondop> x", "apply(simp add: ap_pmf_def pair_map_pmf1 pmf.map_comp pair_return_pmf1 pair_pair_pmf o_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. fst x (snd (snd x)) (fst (snd x)))\n     (pair_pmf f (pair_pmf x y)) =\n    map_pmf (\\<lambda>x. fst x (fst (snd x)) (snd (snd x)))\n     (pair_pmf f (pair_pmf y x))", "apply(subst (2) pair_commute_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>x. fst x (snd (snd x)) (fst (snd x)))\n     (pair_pmf f (map_pmf (\\<lambda>(x, y). (y, x)) (pair_pmf y x))) =\n    map_pmf (\\<lambda>x. fst x (fst (snd x)) (snd (snd x)))\n     (pair_pmf f (pair_pmf y x))", "apply(simp add: pair_map_pmf2 pmf.map_comp o_def split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ap_pmf_transfer[transfer_rule]:\n  \"rel_fun (rel_pmf (rel_fun A B)) (rel_fun (rel_pmf A) (rel_pmf B)) ap_pmf ap_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_pmf (rel_fun A B)) (rel_fun (rel_pmf A) (rel_pmf B))\n     (\\<diamondop>) (\\<diamondop>)", "unfolding ap_pmf_def[abs_def] pair_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_pmf (rel_fun A B)) (rel_fun (rel_pmf A) (rel_pmf B))\n     (\\<lambda>f x.\n         map_pmf (\\<lambda>(f, y). f y)\n          (f \\<bind>\n           (\\<lambda>xa. x \\<bind> (\\<lambda>y. return_pmf (xa, y)))))\n     (\\<lambda>f x.\n         map_pmf (\\<lambda>(f, y). f y)\n          (f \\<bind>\n           (\\<lambda>xa. x \\<bind> (\\<lambda>y. return_pmf (xa, y)))))", "by transfer_prover"], ["", "applicative pmf (C, K)\nfor\n  pure: pure_pmf\n  ap: ap_pmf\n  rel: rel_pmf\n  set: set_pmf"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R. rel_fun R (rel_pmf R) return_pmf return_pmf\n 6. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R. rel_fun R (rel_pmf R) return_pmf return_pmf\n 6. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R. rel_fun R (rel_pmf R) return_pmf return_pmf\n 6. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"rel_fun R (rel_pmf R) pure_pmf pure_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun R (rel_pmf R) return_pmf return_pmf", "by transfer_prover"], ["proof (state)\nthis:\n  rel_fun R (rel_pmf R) return_pmf return_pmf\n\ngoal (5 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R and f :: \"('a \\<Rightarrow> 'b) pmf\" and g :: \"('a \\<Rightarrow> 'c) pmf\" and x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "assume [transfer_rule]: \"rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g\""], ["proof (state)\nthis:\n  rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g\n\ngoal (5 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "have [transfer_rule]: \"rel_pmf (eq_on (set_pmf x)) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf (eq_on (set_pmf x)) x x", "by (simp add: pmf.rel_refl_strong)"], ["proof (state)\nthis:\n  rel_pmf (eq_on (set_pmf x)) x x\n\ngoal (5 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\n 5. \\<And>R f g x.\n       rel_pmf (rel_fun (eq_on (set_pmf x)) R) f g \\<Longrightarrow>\n       rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"rel_pmf R (ap_pmf f x) (ap_pmf g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)", "by transfer_prover"], ["proof (state)\nthis:\n  rel_pmf R (f \\<diamondop> x) (g \\<diamondop> x)\n\ngoal (4 subgoals):\n 1. \\<And>f x. return_pmf f \\<diamondop> return_pmf x = return_pmf (f x)\n 2. \\<And>g f x.\n       return_pmf (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       return_pmf (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x y.\n       return_pmf (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x", "qed(rule ap_pmf_comp[unfolded o_def[abs_def]] ap_pmf_homo ap_pmf_C ap_pmf_K)+"], ["", "end"], ["", "end"]]}