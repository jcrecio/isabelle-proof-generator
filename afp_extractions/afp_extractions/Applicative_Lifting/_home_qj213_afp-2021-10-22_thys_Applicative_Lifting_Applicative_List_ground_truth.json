{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma Nil_ap[simp]: \"ap_list [] xs = []\"", "lemma ap_Nil[simp]: \"ap_list fs [] = []\"", "lemma ap_list_transfer[transfer_rule]:\n  \"rel_fun (list_all2 (rel_fun A B)) (rel_fun (list_all2 A) (list_all2 B)) ap_list ap_list\"", "lemma cons_ap_list: \"(f # fs) \\<diamondop> xs = map f xs @ fs \\<diamondop> xs\"", "lemma append_ap_distrib: \"(fs @ gs) \\<diamondop> xs = fs \\<diamondop> xs @ gs \\<diamondop> xs\"", "lemma map_ap_conv[applicative_unfold]: \"map f x = [f] \\<diamondop> x\""], "translations": [["", "lemma Nil_ap[simp]: \"ap_list [] xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative.ap [] xs = []", "unfolding ap_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.bind [] (\\<lambda>f. List.bind xs (\\<lambda>x. [f x])) = []", "by simp"], ["", "lemma ap_Nil[simp]: \"ap_list fs [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative.ap fs [] = []", "unfolding ap_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.bind fs (\\<lambda>f. List.bind [] (\\<lambda>x. [f x])) = []", "by (induction fs) simp_all"], ["", "lemma ap_list_transfer[transfer_rule]:\n  \"rel_fun (list_all2 (rel_fun A B)) (rel_fun (list_all2 A) (list_all2 B)) ap_list ap_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (list_all2 (rel_fun A B)) (rel_fun (list_all2 A) (list_all2 B))\n     Applicative.ap Applicative.ap", "unfolding ap_list_def[abs_def] List.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (list_all2 (rel_fun A B)) (rel_fun (list_all2 A) (list_all2 B))\n     (\\<lambda>fs xs.\n         concat (map (\\<lambda>f. concat (map (\\<lambda>x. [f x]) xs)) fs))\n     (\\<lambda>fs xs.\n         concat (map (\\<lambda>f. concat (map (\\<lambda>x. [f x]) xs)) fs))", "by transfer_prover"], ["", "context includes applicative_syntax\nbegin"], ["", "lemma cons_ap_list: \"(f # fs) \\<diamondop> xs = map f xs @ fs \\<diamondop> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f # fs) \\<diamondop> xs = map f xs @ fs \\<diamondop> xs", "unfolding ap_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.bind (f # fs) (\\<lambda>f. List.bind xs (\\<lambda>x. [f x])) =\n    map f xs @ List.bind fs (\\<lambda>f. List.bind xs (\\<lambda>x. [f x]))", "by (induction xs) simp_all"], ["", "lemma append_ap_distrib: \"(fs @ gs) \\<diamondop> xs = fs \\<diamondop> xs @ gs \\<diamondop> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs @ gs) \\<diamondop> xs = fs \\<diamondop> xs @ gs \\<diamondop> xs", "unfolding ap_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.bind (fs @ gs) (\\<lambda>f. List.bind xs (\\<lambda>x. [f x])) =\n    List.bind fs (\\<lambda>f. List.bind xs (\\<lambda>x. [f x])) @\n    List.bind gs (\\<lambda>f. List.bind xs (\\<lambda>x. [f x]))", "by (induction fs) simp_all"], ["", "applicative list\nfor\n  pure: \"\\<lambda>x. [x]\"\n  ap: ap_list\n  rel: list_all2\n  set: set"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. [\\<lambda>x. x] \\<diamondop> x = x\n 4. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 5. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 6. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. [\\<lambda>x. x] \\<diamondop> x = x\n 4. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 5. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 6. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "fix x :: \"'a list\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. [\\<lambda>x. x] \\<diamondop> x = x\n 4. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 5. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 6. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"[\\<lambda>x. x] \\<diamondop> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>x. x] \\<diamondop> x = x", "unfolding ap_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.bind [\\<lambda>x. x]\n     (\\<lambda>f. List.bind x (\\<lambda>x. [f x])) =\n    x", "by (induction x) simp_all"], ["proof (state)\nthis:\n  [\\<lambda>x. x] \\<diamondop> x = x\n\ngoal (5 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 4. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 5. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 4. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 5. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "fix g :: \"('b \\<Rightarrow> 'c) list\" and f :: \"('a \\<Rightarrow> 'b) list\" and x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 4. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 5. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "let ?B = \"\\<lambda>g f x. g (f x)\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>g f x.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 4. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 5. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"[?B] \\<diamondop> g \\<diamondop> f \\<diamondop> x = g \\<diamondop> (f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop> x =\n    g \\<diamondop> (f \\<diamondop> x)", "proof (induction g)"], ["proof (state)\ngoal (2 subgoals):\n 1. [\\<lambda>g f x. g (f x)] \\<diamondop> [] \\<diamondop> f \\<diamondop>\n    x =\n    [] \\<diamondop> (f \\<diamondop> x)\n 2. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [\\<lambda>g f x. g (f x)] \\<diamondop> [] \\<diamondop> f \\<diamondop>\n    x =\n    [] \\<diamondop> (f \\<diamondop> x)\n 2. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>g f x. g (f x)] \\<diamondop> [] \\<diamondop> f \\<diamondop>\n    x =\n    [] \\<diamondop> (f \\<diamondop> x)", "by simp"], ["proof (state)\nthis:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> [] \\<diamondop> f \\<diamondop> x =\n  [] \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "case (Cons g gs)"], ["proof (state)\nthis:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x =\n  gs \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "have g_comp: \"[?B g] \\<diamondop> f \\<diamondop> x = [g] \\<diamondop> (f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n    [g] \\<diamondop> (f \\<diamondop> x)", "proof (induction f)"], ["proof (state)\ngoal (2 subgoals):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> [] \\<diamondop> x =\n    [g] \\<diamondop> ([] \\<diamondop> x)\n 2. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> [] \\<diamondop> x =\n    [g] \\<diamondop> ([] \\<diamondop> x)\n 2. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> [] \\<diamondop> x =\n    [g] \\<diamondop> ([] \\<diamondop> x)", "by simp"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> [] \\<diamondop> x =\n  [g] \\<diamondop> ([] \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "case (Cons f fs)"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x =\n  [g] \\<diamondop> (fs \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "have \"[?B g] \\<diamondop> (f # fs) \\<diamondop> x = [g] \\<diamondop> ([f] \\<diamondop> x) @ [?B g] \\<diamondop> fs \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n    [g] \\<diamondop> ([f] \\<diamondop> x) @\n    [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x", "by (simp add: cons_ap_list)"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "also"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "have \"... = [g] \\<diamondop> ([f] \\<diamondop> x) @ [g] \\<diamondop> (fs \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [g] \\<diamondop> ([f] \\<diamondop> x) @\n    [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x =\n    [g] \\<diamondop> ([f] \\<diamondop> x) @\n    [g] \\<diamondop> (fs \\<diamondop> x)", "using Cons.IH"], ["proof (prove)\nusing this:\n  [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x =\n  [g] \\<diamondop> (fs \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. [g] \\<diamondop> ([f] \\<diamondop> x) @\n    [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x =\n    [g] \\<diamondop> ([f] \\<diamondop> x) @\n    [g] \\<diamondop> (fs \\<diamondop> x)", ".."], ["proof (state)\nthis:\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x =\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [g] \\<diamondop> (fs \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "also"], ["proof (state)\nthis:\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [\\<lambda>f x. g (f x)] \\<diamondop> fs \\<diamondop> x =\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [g] \\<diamondop> (fs \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "have \"... = [g] \\<diamondop> ((f # fs) \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [g] \\<diamondop> ([f] \\<diamondop> x) @\n    [g] \\<diamondop> (fs \\<diamondop> x) =\n    [g] \\<diamondop> ((f # fs) \\<diamondop> x)", "by (simp add: cons_ap_list)"], ["proof (state)\nthis:\n  [g] \\<diamondop> ([f] \\<diamondop> x) @\n  [g] \\<diamondop> (fs \\<diamondop> x) =\n  [g] \\<diamondop> ((f # fs) \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n       [g] \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>f x. g (f x)] \\<diamondop> (a # f) \\<diamondop> x =\n       [g] \\<diamondop> ((a # f) \\<diamondop> x)", "finally"], ["proof (chain)\npicking this:\n  [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n  [g] \\<diamondop> ((f # fs) \\<diamondop> x)", "show ?case"], ["proof (prove)\nusing this:\n  [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n  [g] \\<diamondop> ((f # fs) \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n    [g] \\<diamondop> ((f # fs) \\<diamondop> x)", "."], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> (f # fs) \\<diamondop> x =\n  [g] \\<diamondop> ((f # fs) \\<diamondop> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n  [g] \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "have \"[?B] \\<diamondop> (g # gs) \\<diamondop> f \\<diamondop> x = [?B g] \\<diamondop> f \\<diamondop> x @ [?B] \\<diamondop> gs \\<diamondop> f \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n    f \\<diamondop>\n    x =\n    [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n    [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x", "by (simp add: cons_ap_list append_ap_distrib)"], ["proof (state)\nthis:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n  f \\<diamondop>\n  x =\n  [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n  [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "also"], ["proof (state)\nthis:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n  f \\<diamondop>\n  x =\n  [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n  [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "have \"... = [g] \\<diamondop> (f \\<diamondop> x) @ gs \\<diamondop> (f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n    [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop>\n    x =\n    [g] \\<diamondop> (f \\<diamondop> x) @ gs \\<diamondop> (f \\<diamondop> x)", "using g_comp Cons.IH"], ["proof (prove)\nusing this:\n  [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x =\n  [g] \\<diamondop> (f \\<diamondop> x)\n  [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x =\n  gs \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n    [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop>\n    x =\n    [g] \\<diamondop> (f \\<diamondop> x) @ gs \\<diamondop> (f \\<diamondop> x)", "by simp"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n  [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x =\n  [g] \\<diamondop> (f \\<diamondop> x) @ gs \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "also"], ["proof (state)\nthis:\n  [\\<lambda>f x. g (f x)] \\<diamondop> f \\<diamondop> x @\n  [\\<lambda>g f x. g (f x)] \\<diamondop> gs \\<diamondop> f \\<diamondop> x =\n  [g] \\<diamondop> (f \\<diamondop> x) @ gs \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "have \"... = (g # gs) \\<diamondop> (f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [g] \\<diamondop> (f \\<diamondop> x) @\n    gs \\<diamondop> (f \\<diamondop> x) =\n    (g # gs) \\<diamondop> (f \\<diamondop> x)", "by (simp add: cons_ap_list)"], ["proof (state)\nthis:\n  [g] \\<diamondop> (f \\<diamondop> x) @ gs \\<diamondop> (f \\<diamondop> x) =\n  (g # gs) \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x) \\<Longrightarrow>\n       [\\<lambda>g f x. g (f x)] \\<diamondop> (a # g) \\<diamondop>\n       f \\<diamondop>\n       x =\n       (a # g) \\<diamondop> (f \\<diamondop> x)", "finally"], ["proof (chain)\npicking this:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n  f \\<diamondop>\n  x =\n  (g # gs) \\<diamondop> (f \\<diamondop> x)", "show ?case"], ["proof (prove)\nusing this:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n  f \\<diamondop>\n  x =\n  (g # gs) \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n    f \\<diamondop>\n    x =\n    (g # gs) \\<diamondop> (f \\<diamondop> x)", "."], ["proof (state)\nthis:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> (g # gs) \\<diamondop>\n  f \\<diamondop>\n  x =\n  (g # gs) \\<diamondop> (f \\<diamondop> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop> x =\n  g \\<diamondop> (f \\<diamondop> x)\n\ngoal (4 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 3. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 4. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 3. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 4. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "fix f :: \"('a \\<Rightarrow> 'b) list\" and x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>f x. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n 3. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 4. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f", "unfolding ap_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.bind f (\\<lambda>f. List.bind [x] (\\<lambda>x. [f x])) =\n    List.bind [\\<lambda>f. f x]\n     (\\<lambda>fa. List.bind f (\\<lambda>x. [fa x]))", "by simp"], ["proof (state)\nthis:\n  f \\<diamondop> [x] = [\\<lambda>f. f x] \\<diamondop> f\n\ngoal (3 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 3. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 3. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n 3. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])", "by transfer_prover"], ["proof (state)\nthis:\n  rel_fun R (list_all2 R) (\\<lambda>x. [x]) (\\<lambda>x. [x])\n\ngoal (2 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R and f :: \"('a \\<Rightarrow> 'b) list\" and g :: \"('a \\<Rightarrow> 'c) list\" and x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "assume [transfer_rule]: \"list_all2 (rel_fun (eq_on (set x)) R) f g\""], ["proof (state)\nthis:\n  list_all2 (rel_fun (eq_on (set x)) R) f g\n\ngoal (2 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "have [transfer_rule]: \"list_all2 (eq_on (set x)) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (eq_on (set x)) x x", "by (simp add: list_all2_same)"], ["proof (state)\nthis:\n  list_all2 (eq_on (set x)) x x\n\ngoal (2 subgoals):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]\n 2. \\<And>R f g x.\n       list_all2 (rel_fun (eq_on (set x)) R) f g \\<Longrightarrow>\n       list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (f \\<diamondop> x) (g \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>f x. [f] \\<diamondop> [x] = [f x]", "qed (simp add: cons_ap_list)"], ["", "lemma map_ap_conv[applicative_unfold]: \"map f x = [f] \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f x = [f] \\<diamondop> x", "unfolding ap_list_def List.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f x =\n    concat (map (\\<lambda>f. concat (map (\\<lambda>x. [f x]) x)) [f])", "by simp"], ["", "end"], ["", "end"]]}