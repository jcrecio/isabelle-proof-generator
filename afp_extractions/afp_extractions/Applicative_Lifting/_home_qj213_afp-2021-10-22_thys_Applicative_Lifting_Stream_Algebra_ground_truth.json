{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Stream_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma plus_stream_shd: \"shd (x + y) = shd x + shd y\"", "lemma plus_stream_stl: \"stl (x + y) = stl x + stl y\"", "lemma pure_stream_inject [simp]: \"sconst x = sconst y \\<longleftrightarrow> x = y\"", "lemma of_nat_stream [applicative_unfold]: \"of_nat n = sconst (of_nat n)\"", "lemma pure_stream_numeral [applicative_unfold]: \"numeral n = pure (numeral n)\""], "translations": [["", "lemma plus_stream_shd: \"shd (x + y) = shd x + shd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (x + y) = shd x + shd y", "unfolding plus_stream_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (Applicative.ap (Applicative.ap (pure (+)) x) y) = shd x + shd y", "by simp"], ["", "lemma plus_stream_stl: \"stl (x + y) = stl x + stl y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stl (x + y) = stl x + stl y", "unfolding plus_stream_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stl (Applicative.ap (Applicative.ap (pure (+)) x) y) =\n    Applicative.ap (Applicative.ap (pure (+)) (stl x)) (stl y)", "by simp"], ["", "instance stream :: (cancel_semigroup_add) cancel_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, cancel_semigroup_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "fix a b c :: \"'a stream\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "assume \"a + b = a + c\""], ["proof (state)\nthis:\n  a + b = a + c\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "thus \"b = c\""], ["proof (prove)\nusing this:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. b = c", "proof (coinduction arbitrary: a b c)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a + b = a + c \\<Longrightarrow>\n       shd b = shd c \\<and>\n       (\\<exists>a ba ca.\n           stl b = ba \\<and> stl c = ca \\<and> a + ba = a + ca)", "case (Eq_stream a b c)"], ["proof (state)\nthis:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a + b = a + c \\<Longrightarrow>\n       shd b = shd c \\<and>\n       (\\<exists>a ba ca.\n           stl b = ba \\<and> stl c = ca \\<and> a + ba = a + ca)", "hence \"shd (a + b) = shd (a + c)\" \"stl (a + b) = stl (a + c)\""], ["proof (prove)\nusing this:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. shd (a + b) = shd (a + c) &&& stl (a + b) = stl (a + c)", "by simp_all"], ["proof (state)\nthis:\n  shd (a + b) = shd (a + c)\n  stl (a + b) = stl (a + c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       a + b = a + c \\<Longrightarrow>\n       shd b = shd c \\<and>\n       (\\<exists>a ba ca.\n           stl b = ba \\<and> stl c = ca \\<and> a + ba = a + ca)", "thus ?case"], ["proof (prove)\nusing this:\n  shd (a + b) = shd (a + c)\n  stl (a + b) = stl (a + c)\n\ngoal (1 subgoal):\n 1. shd b = shd c \\<and>\n    (\\<exists>a b c. stl b = b \\<and> stl c = c \\<and> a + b = a + c)", "by (auto simp add: plus_stream_shd plus_stream_stl)"], ["proof (state)\nthis:\n  shd b = shd c \\<and>\n  (\\<exists>a b c. stl b = b \\<and> stl c = c \\<and> a + b = a + c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = c\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "fix a b c :: \"'a stream\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "assume \"b + a = c + a\""], ["proof (state)\nthis:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "thus \"b = c\""], ["proof (prove)\nusing this:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. b = c", "proof (coinduction arbitrary: a b c)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       b + a = c + a \\<Longrightarrow>\n       shd b = shd c \\<and>\n       (\\<exists>a ba ca.\n           stl b = ba \\<and> stl c = ca \\<and> ba + a = ca + a)", "case (Eq_stream a b c)"], ["proof (state)\nthis:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       b + a = c + a \\<Longrightarrow>\n       shd b = shd c \\<and>\n       (\\<exists>a ba ca.\n           stl b = ba \\<and> stl c = ca \\<and> ba + a = ca + a)", "hence \"shd (b + a) = shd (c + a)\" \"stl (b + a) = stl (c + a)\""], ["proof (prove)\nusing this:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. shd (b + a) = shd (c + a) &&& stl (b + a) = stl (c + a)", "by simp_all"], ["proof (state)\nthis:\n  shd (b + a) = shd (c + a)\n  stl (b + a) = stl (c + a)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       b + a = c + a \\<Longrightarrow>\n       shd b = shd c \\<and>\n       (\\<exists>a ba ca.\n           stl b = ba \\<and> stl c = ca \\<and> ba + a = ca + a)", "thus ?case"], ["proof (prove)\nusing this:\n  shd (b + a) = shd (c + a)\n  stl (b + a) = stl (c + a)\n\ngoal (1 subgoal):\n 1. shd b = shd c \\<and>\n    (\\<exists>a b c. stl b = b \\<and> stl c = c \\<and> b + a = c + a)", "by (auto simp add: plus_stream_shd plus_stream_stl)"], ["proof (state)\nthis:\n  shd b = shd c \\<and>\n  (\\<exists>a b c. stl b = b \\<and> stl c = c \\<and> b + a = c + a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = c\n\ngoal:\nNo subgoals!", "qed"], ["", "instance stream :: (cancel_ab_semigroup_add) cancel_ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, cancel_ab_semigroup_add_class)", "by intro_classes (applicative_lifting, simp add: diff_diff_eq)+"], ["", "instance stream :: (cancel_comm_monoid_add) cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, cancel_comm_monoid_add_class)", ".."], ["", "instance stream :: (group_add) group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, group_add_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance stream :: (ab_group_add) ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, ab_group_add_class)", "by intro_classes simp_all"], ["", "instance stream :: (semiring) semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_class)", "by intro_classes (applicative_lifting, simp add: ring_distribs)+"], ["", "instance stream :: (mult_zero) mult_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, mult_zero_class)", "by intro_classes (applicative_lifting, simp)+"], ["", "instance stream :: (semiring_0) semiring_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_0_class)", ".."], ["", "instance stream :: (semiring_0_cancel) semiring_0_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_0_cancel_class)", ".."], ["", "instance stream :: (comm_semiring) comm_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_semiring_class)", "by intro_classes(rule distrib_right)"], ["", "instance stream :: (comm_semiring_0) comm_semiring_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_semiring_0_class)", ".."], ["", "instance stream :: (comm_semiring_0_cancel) comm_semiring_0_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_semiring_0_cancel_class)", ".."], ["", "lemma pure_stream_inject [simp]: \"sconst x = sconst y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pure x = pure y) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pure x = pure y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> pure x = pure y", "assume \"sconst x = sconst y\""], ["proof (state)\nthis:\n  pure x = pure y\n\ngoal (2 subgoals):\n 1. pure x = pure y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> pure x = pure y", "hence \"shd (sconst x) = shd (sconst y)\""], ["proof (prove)\nusing this:\n  pure x = pure y\n\ngoal (1 subgoal):\n 1. shd (pure x) = shd (pure y)", "by simp"], ["proof (state)\nthis:\n  shd (pure x) = shd (pure y)\n\ngoal (2 subgoals):\n 1. pure x = pure y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> pure x = pure y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  shd (pure x) = shd (pure y)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> pure x = pure y", "qed auto"], ["", "instance stream :: (zero_neq_one) zero_neq_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, zero_neq_one_class)", "by intro_classes (applicative_unfold stream)"], ["", "instance stream :: (semiring_1) semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_1_class)", ".."], ["", "instance stream :: (comm_semiring_1) comm_semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_semiring_1_class)", ".."], ["", "instance stream :: (semiring_1_cancel) semiring_1_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_1_cancel_class)", ".."], ["", "instance stream :: (comm_semiring_1_cancel) comm_semiring_1_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_semiring_1_cancel_class)", "by(intro_classes; applicative_lifting, rule right_diff_distrib')"], ["", "instance stream :: (ring) ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, ring_class)", ".."], ["", "instance stream :: (comm_ring) comm_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_ring_class)", ".."], ["", "instance stream :: (ring_1) ring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, ring_1_class)", ".."], ["", "instance stream :: (comm_ring_1) comm_ring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, comm_ring_1_class)", ".."], ["", "instance stream :: (numeral) numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, numeral_class)", ".."], ["", "instance stream :: (neg_numeral) neg_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, neg_numeral_class)", ".."], ["", "instance stream :: (semiring_numeral) semiring_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_numeral_class)", ".."], ["", "lemma of_nat_stream [applicative_unfold]: \"of_nat n = sconst (of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = pure (of_nat n)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. of_nat 0 = sconst (of_nat 0)\n 2. \\<And>n.\n       of_nat n = sconst (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = sconst (of_nat (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. of_nat 0 = sconst (of_nat 0)\n 2. \\<And>n.\n       of_nat n = sconst (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = sconst (of_nat (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat 0 = sconst (of_nat 0)", "by (simp add: zero_stream_def del: id_apply)"], ["proof (state)\nthis:\n  of_nat 0 = sconst (of_nat 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = sconst (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = sconst (of_nat (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = sconst (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = sconst (of_nat (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  of_nat n = sconst (of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = sconst (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = sconst (of_nat (Suc n))", "have \"1 + pure (of_nat n) = pure (1 + of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + pure (of_nat n) = pure ((1::'b) + of_nat n)", "by applicative_nf rule"], ["proof (state)\nthis:\n  1 + pure (of_nat n) = pure ((1::?'b1) + of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = sconst (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = sconst (of_nat (Suc n))", "with Suc.IH"], ["proof (chain)\npicking this:\n  of_nat n = sconst (of_nat n)\n  1 + pure (of_nat n) = pure ((1::?'b1) + of_nat n)", "show ?case"], ["proof (prove)\nusing this:\n  of_nat n = sconst (of_nat n)\n  1 + pure (of_nat n) = pure ((1::?'b1) + of_nat n)\n\ngoal (1 subgoal):\n 1. of_nat (Suc n) = sconst (of_nat (Suc n))", "by (simp del: id_apply)"], ["proof (state)\nthis:\n  of_nat (Suc n) = sconst (of_nat (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "instance stream :: (semiring_char_0) semiring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, semiring_char_0_class)", "by intro_classes (simp add: inj_on_def of_nat_stream)"], ["", "lemma pure_stream_numeral [applicative_unfold]: \"numeral n = pure (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n = pure (numeral n)", "by(induction n)(simp_all only: numeral.simps one_stream_def plus_stream_def ap_stream_homo)"], ["", "instance stream :: (ring_char_0) ring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stream, ring_char_0_class)", ".."], ["", "end"]]}