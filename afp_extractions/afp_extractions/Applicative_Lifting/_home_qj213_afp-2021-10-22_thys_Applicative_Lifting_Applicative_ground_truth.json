{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma rel_fun_eq_onI: \"(\\<And>x. x \\<in> A \\<Longrightarrow> R (f x) (g x)) \\<Longrightarrow> rel_fun (eq_on A) R f g\"", "lemma rel_fun_map_fun2: \"rel_fun (eq_on (range h)) A f g \\<Longrightarrow> rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> A f (map_fun h id g)\"", "lemma rel_fun_refl_eq_onp:\n  \"(\\<And>z. z \\<in> f ` X \\<Longrightarrow> A z z) \\<Longrightarrow> rel_fun (eq_on X) A f f\"", "lemma eq_onE: \"\\<lbrakk> eq_on X a b; \\<lbrakk> b \\<in> X; a = b \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma Domainp_eq_on [simp]: \"Domainp (eq_on X) = (\\<lambda>x. x \\<in> X)\"", "lemma arg1_cong: \"x = y \\<Longrightarrow> f x z = f y z\"", "lemma UNIV_E: \"x \\<in> UNIV \\<Longrightarrow> P \\<Longrightarrow> P\"", "lemmas [abs_def, combinator_unfold] = B_def C_def I_def K_def S_def T_def W_def", "lemmas [combinator_repr] = combinator_unfold", "lemma uncurry_pair: \"cuncurry f (cpair x y) = f x y\"", "lemma [combinator_eq]: \"B \\<equiv> S (K S) K\"", "lemma [combinator_eq]: \"C \\<equiv> S (S (K (S (K S) K)) S) (K K)\"", "lemma [combinator_eq]: \"I \\<equiv> W K\"", "lemma [combinator_eq]: \"I \\<equiv> C K ()\"", "lemma [combinator_eq]: \"S \\<equiv> B (B W) (B B C)\"", "lemma [combinator_eq]: \"T \\<equiv> C I\"", "lemma [combinator_eq]: \"W \\<equiv> S S (S K)\"", "lemma [combinator_eq weak: C]:\n  \"C \\<equiv> C (B B (B B (B W (C (B C (B (B B) (C B (cuncurry (K I))))) (cuncurry K))))) cpair\""], "translations": [["", "lemma rel_fun_eq_onI: \"(\\<And>x. x \\<in> A \\<Longrightarrow> R (f x) (g x)) \\<Longrightarrow> rel_fun (eq_on A) R f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> R (f x) (g x)) \\<Longrightarrow>\n    rel_fun (eq_on A) R f g", "by auto"], ["", "lemma rel_fun_map_fun2: \"rel_fun (eq_on (range h)) A f g \\<Longrightarrow> rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> A f (map_fun h id g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (eq_on (range h)) A f g \\<Longrightarrow>\n    rel_fun (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> A f (map_fun h id g)", "by(auto simp add: rel_fun_def Grp_def eq_onp_def)"], ["", "lemma rel_fun_refl_eq_onp:\n  \"(\\<And>z. z \\<in> f ` X \\<Longrightarrow> A z z) \\<Longrightarrow> rel_fun (eq_on X) A f f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. z \\<in> f ` X \\<Longrightarrow> A z z) \\<Longrightarrow>\n    rel_fun (eq_on X) A f f", "by(auto simp add: rel_fun_def eq_onp_def)"], ["", "lemma eq_onE: \"\\<lbrakk> eq_on X a b; \\<lbrakk> b \\<in> X; a = b \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_on X a b;\n     \\<lbrakk>b \\<in> X; a = b\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma Domainp_eq_on [simp]: \"Domainp (eq_on X) = (\\<lambda>x. x \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (eq_on X) = (\\<lambda>x. x \\<in> X)", "by auto"], ["", "subsection \\<open>Proof automation\\<close>"], ["", "lemma arg1_cong: \"x = y \\<Longrightarrow> f x z = f y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> f x z = f y z", "by (rule arg_cong)"], ["", "lemma UNIV_E: \"x \\<in> UNIV \\<Longrightarrow> P \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> UNIV; P\\<rbrakk> \\<Longrightarrow> P", "."], ["", "context begin"], ["", "private"], ["", "named_theorems combinator_unfold"], ["", "private"], ["", "named_theorems combinator_repr"], ["", "private"], ["", "definition \"B g f x \\<equiv> g (f x)\""], ["", "private"], ["", "definition \"C f x y \\<equiv> f y x\""], ["", "private"], ["", "definition \"I x \\<equiv> x\""], ["", "private"], ["", "definition \"K x y \\<equiv> x\""], ["", "private"], ["", "definition \"S f g x \\<equiv> (f x) (g x)\""], ["", "private"], ["", "definition \"T x f \\<equiv> f x\""], ["", "private"], ["", "definition \"W f x \\<equiv> f x x\""], ["", "lemmas [abs_def, combinator_unfold] = B_def C_def I_def K_def S_def T_def W_def"], ["", "lemmas [combinator_repr] = combinator_unfold"], ["", "private"], ["", "definition \"cpair \\<equiv> Pair\""], ["", "private"], ["", "definition \"cuncurry \\<equiv> case_prod\""], ["", "private"], ["", "lemma uncurry_pair: \"cuncurry f (cpair x y) = f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cuncurry f (cpair x y) = f x y", "unfolding cpair_def cuncurry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x, y) of (x, xa) \\<Rightarrow> f x xa) = f x y", "by simp"], ["", "ML_file \"applicative.ML\""], ["", "local_setup \\<open>Applicative.setup_combinators\n [(\"B\", @{thm B_def}),\n  (\"C\", @{thm C_def}),\n  (\"I\", @{thm I_def}),\n  (\"K\", @{thm K_def}),\n  (\"S\", @{thm S_def}),\n  (\"T\", @{thm T_def}),\n  (\"W\", @{thm W_def})]\\<close>"], ["", "private"], ["", "attribute_setup combinator_eq =\n  \\<open>Scan.lift (Scan.option (Args.$$$ \"weak\" |--\n    Scan.optional (Args.colon |-- Scan.repeat1 Args.name) []) >>\n    Applicative.combinator_rule_attrib)\\<close>"], ["", "lemma [combinator_eq]: \"B \\<equiv> S (K S) K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<equiv> S (K S) K", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>g f x. g (f x) \\<equiv> \\<lambda>x g xa. x (g xa)", "."], ["", "lemma [combinator_eq]: \"C \\<equiv> S (S (K (S (K S) K)) S) (K K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<equiv> S (S (K (S (K S) K)) S) (K K)", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>f x y. f y x \\<equiv> \\<lambda>x xa xb. x xb xa", "."], ["", "lemma [combinator_eq]: \"I \\<equiv> W K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<equiv> W K", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x. x \\<equiv> \\<lambda>x. x", "."], ["", "lemma [combinator_eq]: \"I \\<equiv> C K ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<equiv> C K ()", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x. x \\<equiv> \\<lambda>y. y", "."], ["", "lemma [combinator_eq]: \"S \\<equiv> B (B W) (B B C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<equiv> B (B W) (B B C)", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>f g x. f x (g x) \\<equiv> \\<lambda>x xa xb. x xb (xa xb)", "."], ["", "lemma [combinator_eq]: \"T \\<equiv> C I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<equiv> C I", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x f. f x \\<equiv> \\<lambda>x y. y x", "."], ["", "lemma [combinator_eq]: \"W \\<equiv> S S (S K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<equiv> S S (S K)", "unfolding combinator_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>f x. f x x \\<equiv> \\<lambda>x xa. x xa xa", "."], ["", "lemma [combinator_eq weak: C]:\n  \"C \\<equiv> C (B B (B B (B W (C (B C (B (B B) (C B (cuncurry (K I))))) (cuncurry K))))) cpair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<equiv>\n    C (B B (B B (B W (C (B C (B (B B) (C B (cuncurry (K I)))))\n                       (cuncurry K)))))\n     cpair", "unfolding combinator_unfold uncurry_pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>f x y. f y x \\<equiv> \\<lambda>y x xa. y xa x", "."], ["", "end"], ["", "(* context *)"], ["", "method_setup applicative_unfold =\n  \\<open>Applicative.parse_opt_afun >> (fn opt_af => fn ctxt =>\n    SIMPLE_METHOD' (Applicative.unfold_wrapper_tac ctxt opt_af))\\<close>\n  \"unfold into an applicative expression\""], ["", "method_setup applicative_fold =\n  \\<open>Applicative.parse_opt_afun >> (fn opt_af => fn ctxt =>\n    SIMPLE_METHOD' (Applicative.fold_wrapper_tac ctxt opt_af))\\<close>\n  \"fold an applicative expression\""], ["", "method_setup applicative_nf =\n  \\<open>Applicative.parse_opt_afun >> (fn opt_af => fn ctxt =>\n    SIMPLE_METHOD' (Applicative.normalize_wrapper_tac ctxt opt_af))\\<close>\n  \"prove an equation that has been lifted to an applicative functor, using normal forms\""], ["", "method_setup applicative_lifting =\n  \\<open>Applicative.parse_opt_afun >> (fn opt_af => fn ctxt =>\n    SIMPLE_METHOD' (Applicative.lifting_wrapper_tac ctxt opt_af))\\<close>\n  \"prove an equation that has been lifted to an applicative functor\""], ["", "ML \\<open>Outer_Syntax.local_theory_to_proof @{command_keyword \"applicative\"}\n  \"register applicative functors\"\n  (Parse.binding --\n    Scan.optional (@{keyword \"(\"} |-- Parse.list Parse.short_ident --| @{keyword \")\"}) [] --\n    (@{keyword \"for\"} |-- Parse.reserved \"pure\" |-- @{keyword \":\"} |-- Parse.term) --\n    (Parse.reserved \"ap\" |-- @{keyword \":\"} |-- Parse.term) --\n    Scan.option (Parse.reserved \"rel\" |-- @{keyword \":\"} |-- Parse.term) --\n    Scan.option (Parse.reserved \"set\" |-- @{keyword \":\"} |-- Parse.term) >>\n    Applicative.applicative_cmd)\\<close>"], ["", "ML \\<open>Outer_Syntax.command @{command_keyword \"print_applicative\"}\n  \"print registered applicative functors\"\n  (Scan.succeed (Toplevel.keep (Applicative.print_afuns o Toplevel.context_of)))\\<close>"], ["", "attribute_setup applicative_unfold =\n  \\<open>Scan.lift (Scan.option Parse.name >> Applicative.add_unfold_attrib)\\<close>\n  \"register rules for unfolding into applicative expressions\""], ["", "attribute_setup applicative_lifted =\n  \\<open>Scan.lift (Parse.name >> Applicative.forward_lift_attrib)\\<close>\n  \"lift an equation to an applicative functor\""], ["", "subsection \\<open>Overloaded applicative operators\\<close>"], ["", "consts\n  pure :: \"'a \\<Rightarrow> 'b\"\n  ap :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c\""], ["", "bundle applicative_syntax\nbegin"], ["", "notation ap (infixl \"\\<diamondop>\" 70)"], ["", "end"], ["", "hide_const (open) ap"], ["", "end"]]}