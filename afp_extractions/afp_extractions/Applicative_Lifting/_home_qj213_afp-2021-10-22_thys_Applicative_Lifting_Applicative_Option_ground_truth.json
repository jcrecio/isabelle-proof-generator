{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative_Option.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma some_ap_option: \"ap_option (Some f) x = map_option f x\"", "lemma ap_some_option: \"ap_option f (Some x) = map_option (\\<lambda>g. g x) f\"", "lemma ap_option_transfer[transfer_rule]:\n  \"rel_fun (rel_option (rel_fun A B)) (rel_fun (rel_option A) (rel_option B)) ap_option ap_option\"", "lemma map_option_ap_conv[applicative_unfold]: \"map_option f x = ap_option (pure f) x\""], "translations": [["", "lemma some_ap_option: \"ap_option (Some f) x = map_option f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative.ap (pure f) x = map_option f x", "by (cases x) simp_all"], ["", "lemma ap_some_option: \"ap_option f (Some x) = map_option (\\<lambda>g. g x) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative.ap f (pure x) = map_option (\\<lambda>g. g x) f", "by (cases f) simp_all"], ["", "lemma ap_option_transfer[transfer_rule]:\n  \"rel_fun (rel_option (rel_fun A B)) (rel_fun (rel_option A) (rel_option B)) ap_option ap_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_option (rel_fun A B))\n     (rel_fun (rel_option A) (rel_option B)) Applicative.ap Applicative.ap", "by(auto elim!: option.rel_cases simp add: rel_fun_def)"], ["", "applicative option (C, W)\nfor\n  pure: Some\n  ap: ap_option\n  rel: rel_option\n  set: set_option"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x. Applicative.ap (pure f) (pure x) = pure (f x)\n 2. \\<And>g f x.\n       Applicative.ap\n        (Applicative.ap (Applicative.ap (pure (\\<lambda>g f x. g (f x))) g)\n          f)\n        x =\n       Applicative.ap g (Applicative.ap f x)\n 3. \\<And>f x y.\n       Applicative.ap\n        (Applicative.ap (Applicative.ap (pure (\\<lambda>f x y. f y x)) f) x)\n        y =\n       Applicative.ap (Applicative.ap f y) x\n 4. \\<And>x. Applicative.ap (pure (\\<lambda>x. x)) x = x\n 5. \\<And>f x.\n       Applicative.ap (Applicative.ap (pure (\\<lambda>f x. f x x)) f) x =\n       Applicative.ap (Applicative.ap f x) x\n 6. \\<And>R. rel_fun R (rel_option R) pure pure\n 7. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (Applicative.ap f x) (Applicative.ap g x)", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f x. Applicative.ap (pure f) (pure x) = pure (f x)\n 2. \\<And>g f x.\n       Applicative.ap\n        (Applicative.ap (Applicative.ap (pure (\\<lambda>g f x. g (f x))) g)\n          f)\n        x =\n       Applicative.ap g (Applicative.ap f x)\n 3. \\<And>f x y.\n       Applicative.ap\n        (Applicative.ap (Applicative.ap (pure (\\<lambda>f x y. f y x)) f) x)\n        y =\n       Applicative.ap (Applicative.ap f y) x\n 4. \\<And>x. Applicative.ap (pure (\\<lambda>x. x)) x = x\n 5. \\<And>f x.\n       Applicative.ap (Applicative.ap (pure (\\<lambda>f x. f x x)) f) x =\n       Applicative.ap (Applicative.ap f x) x\n 6. \\<And>R. rel_fun R (rel_option R) pure pure\n 7. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (Applicative.ap f x) (Applicative.ap g x)", "include applicative_syntax"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x. pure (\\<lambda>x. x) \\<diamondop> x = x\n 5. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 6. \\<And>R. rel_fun R (rel_option R) pure pure\n 7. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "{"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x. pure (\\<lambda>x. x) \\<diamondop> x = x\n 5. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 6. \\<And>R. rel_fun R (rel_option R) pure pure\n 7. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "fix x :: \"'a option\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>x. pure (\\<lambda>x. x) \\<diamondop> x = x\n 5. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 6. \\<And>R. rel_fun R (rel_option R) pure pure\n 7. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"pure (\\<lambda>x. x) \\<diamondop> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>x. x) \\<diamondop> x = x", "by (cases x) simp_all"], ["proof (state)\nthis:\n  pure (\\<lambda>x. x) \\<diamondop> x = x\n\ngoal (6 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>R. rel_fun R (rel_option R) pure pure\n 6. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>R. rel_fun R (rel_option R) pure pure\n 6. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "fix g :: \"('b \\<Rightarrow> 'c) option\" and f :: \"('a \\<Rightarrow> 'b) option\" and x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 4. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 5. \\<And>R. rel_fun R (rel_option R) pure pure\n 6. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop> f \\<diamondop> x = g \\<diamondop> (f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n    f \\<diamondop>\n    x =\n    g \\<diamondop> (f \\<diamondop> x)", "by (cases g f x rule: option.exhaust[case_product option.exhaust, case_product option.exhaust]) simp_all"], ["proof (state)\nthis:\n  pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop> f \\<diamondop>\n  x =\n  g \\<diamondop> (f \\<diamondop> x)\n\ngoal (5 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 3. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 4. \\<And>R. rel_fun R (rel_option R) pure pure\n 5. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 3. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 4. \\<And>R. rel_fun R (rel_option R) pure pure\n 5. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "fix f :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'c) option\" and x y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>f x y.\n       pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop>\n       x \\<diamondop>\n       y =\n       f \\<diamondop> y \\<diamondop> x\n 3. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 4. \\<And>R. rel_fun R (rel_option R) pure pure\n 5. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop> x \\<diamondop> y = f \\<diamondop> y \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop> x \\<diamondop>\n    y =\n    f \\<diamondop> y \\<diamondop> x", "by (cases f x y rule: option.exhaust[case_product option.exhaust, case_product option.exhaust]) simp_all"], ["proof (state)\nthis:\n  pure (\\<lambda>f x y. f y x) \\<diamondop> f \\<diamondop> x \\<diamondop>\n  y =\n  f \\<diamondop> y \\<diamondop> x\n\ngoal (4 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 3. \\<And>R. rel_fun R (rel_option R) pure pure\n 4. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 3. \\<And>R. rel_fun R (rel_option R) pure pure\n 4. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "fix f :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'b) option\" and x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>f x.\n       pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n       f \\<diamondop> x \\<diamondop> x\n 3. \\<And>R. rel_fun R (rel_option R) pure pure\n 4. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x = f \\<diamondop> x \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n    f \\<diamondop> x \\<diamondop> x", "by (cases f x rule: option.exhaust[case_product option.exhaust]) simp_all"], ["proof (state)\nthis:\n  pure (\\<lambda>f x. f x x) \\<diamondop> f \\<diamondop> x =\n  f \\<diamondop> x \\<diamondop> x\n\ngoal (3 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R. rel_fun R (rel_option R) pure pure\n 3. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R. rel_fun R (rel_option R) pure pure\n 3. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R. rel_fun R (rel_option R) pure pure\n 3. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"rel_fun R (rel_option R) pure pure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun R (rel_option R) pure pure", "by transfer_prover"], ["proof (state)\nthis:\n  rel_fun R (rel_option R) pure pure\n\ngoal (2 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "fix R and f :: \"('a \\<Rightarrow> 'b) option\" and g :: \"('a \\<Rightarrow> 'c) option\" and x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "assume [transfer_rule]: \"rel_option (rel_fun (eq_on (set_option x)) R) f g\""], ["proof (state)\nthis:\n  rel_option (rel_fun (eq_on (set_option x)) R) f g\n\ngoal (2 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "have [transfer_rule]: \"rel_option (eq_on (set_option x)) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (eq_on (set_option x)) x x", "by (auto intro: option.rel_refl_strong)"], ["proof (state)\nthis:\n  rel_option (eq_on (set_option x)) x x\n\ngoal (2 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>R f g x.\n       rel_option (rel_fun (eq_on (set_option x)) R) f g \\<Longrightarrow>\n       rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "show \"rel_option R (f \\<diamondop> x) (g \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option R (f \\<diamondop> x) (g \\<diamondop> x)", "by transfer_prover"], ["proof (state)\nthis:\n  rel_option R (f \\<diamondop> x) (g \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)", "}"], ["proof (state)\nthis:\n  rel_option (rel_fun (eq_on (set_option ?x2)) ?R2) ?f2\n   ?g2 \\<Longrightarrow>\n  rel_option ?R2 (?f2 \\<diamondop> ?x2) (?g2 \\<diamondop> ?x2)\n\ngoal (1 subgoal):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)", "qed (simp add: some_ap_option ap_some_option)"], ["", "lemma map_option_ap_conv[applicative_unfold]: \"map_option f x = ap_option (pure f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option f x = Applicative.ap (pure f) x", "by (cases x rule: option.exhaust) simp_all"], ["", "no_adhoc_overloading Applicative.pure pure_option \\<comment> \\<open>We do not want to print all occurrences of @{const \"Some\"} as @{const \"pure\"}\\<close>"], ["", "end"]]}