{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Tree_Relabelling.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma leaves_simps [simp]:\n  \"leaves (Leaf x) = Suc 0\"\n  \"leaves (Node l r) = leaves l + leaves r\"", "lemma labels_simps [simp]:\n  \"labels (Leaf x) = [x]\"\n  \"labels (Node l r) = labels l @ labels r\"", "lemma label_tree_simps [simp]:\n  \"label_tree (Leaf x) = pure Leaf \\<diamondop> fresh\"\n  \"label_tree (Node l r) = pure Node \\<diamondop> label_tree l \\<diamondop> label_tree r\"", "lemma label_append: \"label_list (a @ b) = pure (@) \\<diamondop> label_list a \\<diamondop> label_list b\"\n  \\<comment> \\<open>The proof lifts the defining equations of @{const append} to the state monad.\\<close>", "lemma label_tree_list: \"pure labels \\<diamondop> label_tree t = label_list (labels t)\"", "lemma correctness_pure:\n  fixes t :: \"'a tree\"\n  assumes distinct: \"\\<And>xs :: 'a list. distinct (fst (run_state (label_list xs) s))\"\n  shows \"distinct (labels (fst (run_state (label_tree t) s)))\"", "lemma ap_state_rev_B: \"B f \\<diamondop> B x = B (State_Monad.return (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)\"", "lemma ap_state_rev_pure_B: \"pure f \\<diamondop> B x = B (State_Monad.return f \\<diamondop> x)\"", "lemma ap_state_rev_rev_B: \"B f \\<diamondop> B x = B (pure_state_rev (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)\"", "lemma ap_state_rev_rev_pure_B: \"pure f \\<diamondop> B x = B (pure_state_rev f \\<diamondop> x)\"", "lemma ap_conv_bind_state: \"State_Monad.ap f x = State_Monad.bind f (\\<lambda>f. State_Monad.bind x (State_Monad.return \\<circ> f))\"", "lemma ap_pure_bind_state: \"pure x \\<diamondop> State_Monad.bind y f = State_Monad.bind y ((\\<diamondop>) (pure x) \\<circ> f)\"", "lemma recurse_Leaf: \"recurse f (Leaf x) = pure Leaf \\<diamondop> f x\"", "lemma recurse_Node:\n  \"recurse f (Node l r) = pure (\\<lambda>r l. Node l r) \\<diamondop> recurse f r \\<diamondop> recurse f l\"", "lemma traverse_pure: \"traverse pure t = pure t\"", "lemma B_pure: \"pure x = B (State_Monad.return x)\"", "lemma BB_pure: \"pure x = B (B (pure x))\"", "lemma BB_ap: \"B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))\"", "lemma traverse_B_B: \"traverse_rev_rev (B \\<circ> B \\<circ> f) = B \\<circ> B \\<circ> traverse f\" (is \"?lhs = ?rhs\")", "lemma traverse_recurse: \"traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)\" (is \"?lhs = ?rhs\")", "lemma recurse_traverse:\n  assumes \"f \\<bullet> g = pure\"\n  shows \"recurse f \\<bullet> traverse g = pure\"\n\\<comment> \\<open>Gibbons and Bird impose this as an additional requirement on traversals, but they write\n  that they have not found a way to derive this fact from other axioms. So we prove it directly.\\<close>", "lemma strip_adorn: \"strip \\<bullet> adorn = pure\"", "lemma correctness_monadic: \"unlabel \\<bullet> label = pure\"", "lemma repeatM_plus: \"repeatM (n + m) f = pure append \\<diamondop> repeatM n f \\<diamondop> repeatM m f\"", "lemma dlabels_simps [simp]:\n  \"dlabels (Leaf x) = pure [x]\"\n  \"dlabels (Node l r) = pure (case_prod append) \\<diamondop> (assert (case_prod disjoint) (pure Pair \\<diamondop> dlabels l \\<diamondop> dlabels r))\"", "lemma correctness_applicative:\n  assumes distinct: \"\\<And>n. pure (assert distinct) \\<diamondop> symbols n = symbols n\"\n  shows \"State_Monad.return dlabels \\<diamondop> label_tree t = symbols (leaves t)\"", "lemma plabel_mirror: \"plabel (mirror t) = pure mirror \\<diamondop> plabel t\"", "lemma plabel_subtree: \"plabel (subtree path t) = pure (subtree path) \\<diamondop> plabel t\""], "translations": [["", "lemma leaves_simps [simp]:\n  \"leaves (Leaf x) = Suc 0\"\n  \"leaves (Node l r) = leaves l + leaves r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leaves (Tree_Relabelling.tree.Leaf x) = Suc 0 &&&\n    leaves (Tree_Relabelling.tree.Node l r) = leaves l + leaves r", "by(simp_all add: leaves_def)"], ["", "subsubsection \\<open>Pure correctness statement\\<close>"], ["", "definition labels :: \"'a tree \\<Rightarrow> 'a list\"\nwhere \"labels = fold_tree (\\<lambda>x. [x]) append\""], ["", "lemma labels_simps [simp]:\n  \"labels (Leaf x) = [x]\"\n  \"labels (Node l r) = labels l @ labels r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (Tree_Relabelling.tree.Leaf x) = [x] &&&\n    labels (Tree_Relabelling.tree.Node l r) = labels l @ labels r", "by(simp_all add: labels_def)"], ["", "locale labelling =\n  fixes fresh :: \"('s, 'x) state\"\nbegin"], ["", "declare [[show_variants]]"], ["", "definition label_tree :: \"'a tree \\<Rightarrow> ('s, 'x tree) state\"\nwhere \"label_tree = fold_tree (\\<lambda>_ :: 'a. pure Leaf \\<diamondop> fresh) (\\<lambda>l r. pure Node \\<diamondop> l \\<diamondop> r)\""], ["", "lemma label_tree_simps [simp]:\n  \"label_tree (Leaf x) = pure Leaf \\<diamondop> fresh\"\n  \"label_tree (Node l r) = pure Node \\<diamondop> label_tree l \\<diamondop> label_tree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. label_tree (Tree_Relabelling.tree.Leaf x) =\n    State_Monad.ap (State_Monad.return Tree_Relabelling.tree.Leaf) fresh &&&\n    label_tree (Tree_Relabelling.tree.Node l r) =\n    State_Monad.ap\n     (State_Monad.ap (State_Monad.return Tree_Relabelling.tree.Node)\n       (label_tree l))\n     (label_tree r)", "by(simp_all add: label_tree_def)"], ["", "primrec label_list :: \"'a list \\<Rightarrow> ('s, 'x list) state\"\nwhere\n    \"label_list [] = pure []\"\n  | \"label_list (x # xs) = pure (#) \\<diamondop> fresh \\<diamondop> label_list xs\""], ["", "lemma label_append: \"label_list (a @ b) = pure (@) \\<diamondop> label_list a \\<diamondop> label_list b\"\n  \\<comment> \\<open>The proof lifts the defining equations of @{const append} to the state monad.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. label_list (a @ b) =\n    State_Monad.ap (State_Monad.ap (State_Monad.return (@)) (label_list a))\n     (label_list b)", "proof (induction a)"], ["proof (state)\ngoal (2 subgoals):\n 1. label_list ([] @ b) =\n    State_Monad.ap (State_Monad.ap (State_Monad.return (@)) (label_list []))\n     (label_list b)\n 2. \\<And>a1 a2.\n       label_list (a2 @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n        (label_list b) \\<Longrightarrow>\n       label_list ((a1 # a2) @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n        (label_list b)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. label_list ([] @ b) =\n    State_Monad.ap (State_Monad.ap (State_Monad.return (@)) (label_list []))\n     (label_list b)\n 2. \\<And>a1 a2.\n       label_list (a2 @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n        (label_list b) \\<Longrightarrow>\n       label_list ((a1 # a2) @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n        (label_list b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. label_list ([] @ b) =\n    State_Monad.ap (State_Monad.ap (State_Monad.return (@)) (label_list []))\n     (label_list b)", "unfolding append.simps label_list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. label_list b =\n    State_Monad.ap\n     (State_Monad.ap (State_Monad.return (@)) (State_Monad.return []))\n     (label_list b)", "by applicative_nf simp"], ["proof (state)\nthis:\n  label_list ([] @ b) =\n  State_Monad.ap (State_Monad.ap (State_Monad.return (@)) (label_list []))\n   (label_list b)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       label_list (a2 @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n        (label_list b) \\<Longrightarrow>\n       label_list ((a1 # a2) @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n        (label_list b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       label_list (a2 @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n        (label_list b) \\<Longrightarrow>\n       label_list ((a1 # a2) @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n        (label_list b)", "case (Cons a1 a2)"], ["proof (state)\nthis:\n  label_list (a2 @ b) =\n  State_Monad.ap (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n   (label_list b)\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       label_list (a2 @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n        (label_list b) \\<Longrightarrow>\n       label_list ((a1 # a2) @ b) =\n       State_Monad.ap\n        (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n        (label_list b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. label_list ((a1 # a2) @ b) =\n    State_Monad.ap\n     (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n     (label_list b)", "unfolding append.simps label_list.simps Cons.IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.ap (State_Monad.return (#)) fresh)\n     (State_Monad.ap\n       (State_Monad.ap (State_Monad.return (@)) (label_list a2))\n       (label_list b)) =\n    State_Monad.ap\n     (State_Monad.ap (State_Monad.return (@))\n       (State_Monad.ap (State_Monad.ap (State_Monad.return (#)) fresh)\n         (label_list a2)))\n     (label_list b)", "by applicative_nf simp"], ["proof (state)\nthis:\n  label_list ((a1 # a2) @ b) =\n  State_Monad.ap\n   (State_Monad.ap (State_Monad.return (@)) (label_list (a1 # a2)))\n   (label_list b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_tree_list: \"pure labels \\<diamondop> label_tree t = label_list (labels t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return labels) (label_tree t) =\n    label_list (labels t)", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       State_Monad.ap (State_Monad.return labels)\n        (label_tree (Tree_Relabelling.tree.Leaf x)) =\n       label_list (labels (Tree_Relabelling.tree.Leaf x))\n 2. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return labels) (label_tree t1) =\n                label_list (labels t1);\n        State_Monad.ap (State_Monad.return labels) (label_tree t2) =\n        label_list (labels t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return labels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         label_list\n                          (labels (Tree_Relabelling.tree.Node t1 t2))", "case Leaf"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       State_Monad.ap (State_Monad.return labels)\n        (label_tree (Tree_Relabelling.tree.Leaf x)) =\n       label_list (labels (Tree_Relabelling.tree.Leaf x))\n 2. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return labels) (label_tree t1) =\n                label_list (labels t1);\n        State_Monad.ap (State_Monad.return labels) (label_tree t2) =\n        label_list (labels t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return labels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         label_list\n                          (labels (Tree_Relabelling.tree.Node t1 t2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return labels)\n     (label_tree (Tree_Relabelling.tree.Leaf x_)) =\n    label_list (labels (Tree_Relabelling.tree.Leaf x_))", "unfolding label_tree_simps labels_simps label_list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return labels)\n     (State_Monad.ap (State_Monad.return Tree_Relabelling.tree.Leaf)\n       fresh) =\n    State_Monad.ap (State_Monad.ap (State_Monad.return (#)) fresh)\n     (State_Monad.return [])", "by applicative_nf simp"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return labels)\n   (label_tree (Tree_Relabelling.tree.Leaf x_)) =\n  label_list (labels (Tree_Relabelling.tree.Leaf x_))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return labels) (label_tree t1) =\n                label_list (labels t1);\n        State_Monad.ap (State_Monad.return labels) (label_tree t2) =\n        label_list (labels t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return labels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         label_list\n                          (labels (Tree_Relabelling.tree.Node t1 t2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return labels) (label_tree t1) =\n                label_list (labels t1);\n        State_Monad.ap (State_Monad.return labels) (label_tree t2) =\n        label_list (labels t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return labels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         label_list\n                          (labels (Tree_Relabelling.tree.Node t1 t2))", "case Node"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return labels) (label_tree t1_) =\n  label_list (labels t1_)\n  State_Monad.ap (State_Monad.return labels) (label_tree t2_) =\n  label_list (labels t2_)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return labels) (label_tree t1) =\n                label_list (labels t1);\n        State_Monad.ap (State_Monad.return labels) (label_tree t2) =\n        label_list (labels t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return labels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         label_list\n                          (labels (Tree_Relabelling.tree.Node t1 t2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return labels)\n     (label_tree (Tree_Relabelling.tree.Node t1_ t2_)) =\n    label_list (labels (Tree_Relabelling.tree.Node t1_ t2_))", "unfolding label_tree_simps labels_simps label_append Node.IH[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return labels)\n     (State_Monad.ap\n       (State_Monad.ap (State_Monad.return Tree_Relabelling.tree.Node)\n         (label_tree t1_))\n       (label_tree t2_)) =\n    State_Monad.ap\n     (State_Monad.ap (State_Monad.return (@))\n       (State_Monad.ap (State_Monad.return labels) (label_tree t1_)))\n     (State_Monad.ap (State_Monad.return labels) (label_tree t2_))", "by applicative_nf simp"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return labels)\n   (label_tree (Tree_Relabelling.tree.Node t1_ t2_)) =\n  label_list (labels (Tree_Relabelling.tree.Node t1_ t2_))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We directly show correctness without going via streams like Hutton and Fulger \\cite{HuttonFulger2008TFP}. \\<close>"], ["", "lemma correctness_pure:\n  fixes t :: \"'a tree\"\n  assumes distinct: \"\\<And>xs :: 'a list. distinct (fst (run_state (label_list xs) s))\"\n  shows \"distinct (labels (fst (run_state (label_tree t) s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (labels (fst (run_state (label_tree t) s)))", "using label_tree_list[of t, THEN arg_cong, of \"\\<lambda>f. run_state f s\"] assms[of \"labels t\"]"], ["proof (prove)\nusing this:\n  run_state (State_Monad.ap (State_Monad.return labels) (label_tree t)) s =\n  run_state (label_list (labels t)) s\n  distinct (fst (run_state (label_list (labels t)) s))\n\ngoal (1 subgoal):\n 1. distinct (labels (fst (run_state (label_tree t) s)))", "by(cases \"run_state (label_list (labels t)) s\")(simp add: State_Monad.ap_def split_beta)"], ["", "end"], ["", "subsubsection \\<open>Correctness via monadic traversals\\<close>"], ["", "text \\<open>Dual version of an applicative functor with effects composed in the opposite order\\<close>"], ["", "typedef 'a dual = \"UNIV :: 'a set\" morphisms un_B B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", "by blast"], ["", "setup_lifting type_definition_dual"], ["", "lift_definition pure_dual :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b dual\"\nis \"\\<lambda>pure. pure\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition ap_dual :: \"(('a \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b) \\<Rightarrow> 'af1) \\<Rightarrow> ('af1 \\<Rightarrow> 'af3 \\<Rightarrow> 'af13) \\<Rightarrow> ('af13 \\<Rightarrow> 'af2 \\<Rightarrow> 'af) \\<Rightarrow> 'af2 dual \\<Rightarrow> 'af3 dual \\<Rightarrow> 'af dual\"\nis \"\\<lambda>pure ap1 ap2 f x. ap2 (ap1 (pure (\\<lambda>x f. f x)) x) f\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "type_synonym ('s, 'a) state_rev = \"('s, 'a) state dual\""], ["", "definition pure_state_rev :: \"'a \\<Rightarrow> ('s, 'a) state_rev\"\nwhere \"pure_state_rev = pure_dual State_Monad.return\""], ["", "definition ap_state_rev :: \"('s, 'a \\<Rightarrow> 'b) state_rev \\<Rightarrow> ('s, 'a) state_rev \\<Rightarrow> ('s, 'b) state_rev\"\nwhere \"ap_state_rev = ap_dual State_Monad.return State_Monad.ap State_Monad.ap\""], ["", "adhoc_overloading Applicative.pure pure_state_rev"], ["", "adhoc_overloading Applicative.ap ap_state_rev"], ["", "applicative state_rev\nfor\n  pure: pure_state_rev\n  ap: ap_state_rev"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. pure (\\<lambda>x. x) \\<diamondop> x = x\n 4. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f", "unfolding pure_state_rev_def ap_state_rev_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>) (pure_dual pure f)\n        (pure_dual pure x) =\n       pure_dual pure (f x)\n 2. \\<And>g f x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>)\n        (ap_dual pure (\\<diamondop>) (\\<diamondop>)\n          (ap_dual pure (\\<diamondop>) (\\<diamondop>)\n            (pure_dual pure (\\<lambda>g f x. g (f x))) g)\n          f)\n        x =\n       ap_dual pure (\\<diamondop>) (\\<diamondop>) g\n        (ap_dual pure (\\<diamondop>) (\\<diamondop>) f x)\n 3. \\<And>x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>)\n        (pure_dual pure (\\<lambda>x. x)) x =\n       x\n 4. \\<And>f x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>) f (pure_dual pure x) =\n       ap_dual pure (\\<diamondop>) (\\<diamondop>)\n        (pure_dual pure (\\<lambda>f. f x)) f", "by(transfer, applicative_nf, rule refl)+"], ["", "type_synonym ('s, 'a) state_rev_rev = \"('s, 'a) state_rev dual\""], ["", "definition pure_state_rev_rev :: \"'a \\<Rightarrow> ('s, 'a) state_rev_rev\"\nwhere \"pure_state_rev_rev = pure_dual pure_state_rev\""], ["", "definition ap_state_rev_rev :: \"('s, 'a \\<Rightarrow> 'b) state_rev_rev \\<Rightarrow> ('s, 'a) state_rev_rev \\<Rightarrow> ('s, 'b) state_rev_rev\"\nwhere \"ap_state_rev_rev = ap_dual pure_state_rev ap_state_rev ap_state_rev\""], ["", "adhoc_overloading Applicative.pure pure_state_rev_rev"], ["", "adhoc_overloading Applicative.ap ap_state_rev_rev"], ["", "applicative state_rev_rev\nfor\n  pure: pure_state_rev_rev\n  ap: ap_state_rev_rev"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x. pure f \\<diamondop> pure x = pure (f x)\n 2. \\<And>g f x.\n       pure (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. pure (\\<lambda>x. x) \\<diamondop> x = x\n 4. \\<And>f x. f \\<diamondop> pure x = pure (\\<lambda>f. f x) \\<diamondop> f", "unfolding pure_state_rev_rev_def ap_state_rev_rev_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>) (pure_dual pure f)\n        (pure_dual pure x) =\n       pure_dual pure (f x)\n 2. \\<And>g f x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>)\n        (ap_dual pure (\\<diamondop>) (\\<diamondop>)\n          (ap_dual pure (\\<diamondop>) (\\<diamondop>)\n            (pure_dual pure (\\<lambda>g f x. g (f x))) g)\n          f)\n        x =\n       ap_dual pure (\\<diamondop>) (\\<diamondop>) g\n        (ap_dual pure (\\<diamondop>) (\\<diamondop>) f x)\n 3. \\<And>x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>)\n        (pure_dual pure (\\<lambda>x. x)) x =\n       x\n 4. \\<And>f x.\n       ap_dual pure (\\<diamondop>) (\\<diamondop>) f (pure_dual pure x) =\n       ap_dual pure (\\<diamondop>) (\\<diamondop>)\n        (pure_dual pure (\\<lambda>f. f x)) f", "by(transfer, applicative_nf, rule refl)+"], ["", "lemma ap_state_rev_B: \"B f \\<diamondop> B x = B (State_Monad.return (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B f \\<diamondop> B x =\n    B (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)", "unfolding ap_state_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ap_dual pure (\\<diamondop>) (\\<diamondop>) (B f) (B x) =\n    B (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)", "by(fact ap_dual.abs_eq)"], ["", "lemma ap_state_rev_pure_B: \"pure f \\<diamondop> B x = B (State_Monad.return f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure f \\<diamondop> B x = B (pure f \\<diamondop> x)", "unfolding ap_state_rev_def pure_state_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ap_dual pure (\\<diamondop>) (\\<diamondop>) (pure_dual pure f) (B x) =\n    B (pure f \\<diamondop> x)", "by transfer(applicative_nf, rule refl)"], ["", "lemma ap_state_rev_rev_B: \"B f \\<diamondop> B x = B (pure_state_rev (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B f \\<diamondop> B x =\n    B (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)", "unfolding ap_state_rev_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ap_dual pure (\\<diamondop>) (\\<diamondop>) (B f) (B x) =\n    B (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> f)", "by(fact ap_dual.abs_eq)"], ["", "lemma ap_state_rev_rev_pure_B: \"pure f \\<diamondop> B x = B (pure_state_rev f \\<diamondop> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure f \\<diamondop> B x = B (pure f \\<diamondop> x)", "unfolding ap_state_rev_rev_def pure_state_rev_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ap_dual pure (\\<diamondop>) (\\<diamondop>) (pure_dual pure f) (B x) =\n    B (pure f \\<diamondop> x)", "by transfer(applicative_nf, rule refl)"], ["", "text \\<open>\n  The formulation by Gibbons and Bird \\cite{backwards} crucially depends on Kleisli composition,\n  so we need the state monad rather than the applicative functor only.\n\\<close>"], ["", "lemma ap_conv_bind_state: \"State_Monad.ap f x = State_Monad.bind f (\\<lambda>f. State_Monad.bind x (State_Monad.return \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<diamondop> x = f \\<bind> (\\<lambda>f. x \\<bind> pure \\<circ> f)", "by(simp add: State_Monad.ap_def State_Monad.bind_def Let_def split_def o_def fun_eq_iff)"], ["", "lemma ap_pure_bind_state: \"pure x \\<diamondop> State_Monad.bind y f = State_Monad.bind y ((\\<diamondop>) (pure x) \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure x \\<diamondop> (y \\<bind> f) =\n    y \\<bind> (\\<diamondop>) (pure x) \\<circ> f", "by(simp add: ap_conv_bind_state o_def)"], ["", "definition kleisli_state :: \"('b \\<Rightarrow> ('s, 'c) state) \\<Rightarrow> ('a \\<Rightarrow> ('s, 'b) state) \\<Rightarrow> 'a \\<Rightarrow> ('s, 'c) state\" (infixl \"\\<bullet>\" 55)\nwhere [simp]: \"kleisli_state g f a = State_Monad.bind (f a) g\""], ["", "definition fetch :: \"('a stream, 'a) state\"\nwhere \"fetch = State_Monad.bind State_Monad.get (\\<lambda>s. State_Monad.bind (State_Monad.set (stl s)) (\\<lambda>_. State_Monad.return (shd s)))\""], ["", "primrec traverse :: \"('a \\<Rightarrow> ('s, 'b) state) \\<Rightarrow> 'a tree \\<Rightarrow> ('s, 'b tree) state\"\nwhere\n  \"traverse f (Leaf x) = pure Leaf \\<diamondop> f x\"\n| \"traverse f (Node l r) = pure Node \\<diamondop> traverse f l \\<diamondop> traverse f r\""], ["", "text \\<open>As we cannot abstract over the applicative functor in definitions, we define\n  traversal on the transformed applicative function once again.\\<close>"], ["", "primrec traverse_rev :: \"('a \\<Rightarrow> ('s, 'b) state_rev) \\<Rightarrow> 'a tree \\<Rightarrow> ('s, 'b tree) state_rev\"\nwhere\n  \"traverse_rev f (Leaf x) = pure Leaf \\<diamondop> f x\"\n| \"traverse_rev f (Node l r) = pure Node \\<diamondop> traverse_rev f l \\<diamondop> traverse_rev f r\""], ["", "definition recurse :: \"('a \\<Rightarrow> ('s, 'b) state) \\<Rightarrow> 'a tree \\<Rightarrow> ('s, 'b tree) state\"\nwhere \"recurse f = un_B \\<circ> traverse_rev (B \\<circ> f)\""], ["", "lemma recurse_Leaf: \"recurse f (Leaf x) = pure Leaf \\<diamondop> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Leaf x) =\n    pure Tree_Relabelling.tree.Leaf \\<diamondop> f x", "unfolding recurse_def traverse_rev.simps o_def ap_state_rev_pure_B"], ["proof (prove)\ngoal (1 subgoal):\n 1. un_B (B (pure Tree_Relabelling.tree.Leaf \\<diamondop> f x)) =\n    pure Tree_Relabelling.tree.Leaf \\<diamondop> f x", "by(simp add: B_inverse)"], ["", "lemma recurse_Node:\n  \"recurse f (Node l r) = pure (\\<lambda>r l. Node l r) \\<diamondop> recurse f r \\<diamondop> recurse f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "have \"recurse f (Node l r) = un_B (pure Node \\<diamondop> traverse_rev (B \\<circ> f) l \\<diamondop> traverse_rev (B \\<circ> f) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    un_B\n     (pure Tree_Relabelling.tree.Node \\<diamondop>\n      traverse_rev (B \\<circ> f) l \\<diamondop>\n      traverse_rev (B \\<circ> f) r)", "by(simp add: recurse_def)"], ["proof (state)\nthis:\n  recurse f (Tree_Relabelling.tree.Node l r) =\n  un_B\n   (pure Tree_Relabelling.tree.Node \\<diamondop>\n    traverse_rev (B \\<circ> f) l \\<diamondop>\n    traverse_rev (B \\<circ> f) r)\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "also"], ["proof (state)\nthis:\n  recurse f (Tree_Relabelling.tree.Node l r) =\n  un_B\n   (pure Tree_Relabelling.tree.Node \\<diamondop>\n    traverse_rev (B \\<circ> f) l \\<diamondop>\n    traverse_rev (B \\<circ> f) r)\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "have \"\\<dots> = un_B (B (pure Node) \\<diamondop> B (recurse f l) \\<diamondop> B (recurse f r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. un_B\n     (pure Tree_Relabelling.tree.Node \\<diamondop>\n      traverse_rev (B \\<circ> f) l \\<diamondop>\n      traverse_rev (B \\<circ> f) r) =\n    un_B\n     (B (pure Tree_Relabelling.tree.Node) \\<diamondop>\n      B (recurse f l) \\<diamondop>\n      B (recurse f r))", "by(simp add: un_B_inverse recurse_def pure_state_rev_def pure_dual_def)"], ["proof (state)\nthis:\n  un_B\n   (pure Tree_Relabelling.tree.Node \\<diamondop>\n    traverse_rev (B \\<circ> f) l \\<diamondop>\n    traverse_rev (B \\<circ> f) r) =\n  un_B\n   (B (pure Tree_Relabelling.tree.Node) \\<diamondop>\n    B (recurse f l) \\<diamondop>\n    B (recurse f r))\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "also"], ["proof (state)\nthis:\n  un_B\n   (pure Tree_Relabelling.tree.Node \\<diamondop>\n    traverse_rev (B \\<circ> f) l \\<diamondop>\n    traverse_rev (B \\<circ> f) r) =\n  un_B\n   (B (pure Tree_Relabelling.tree.Node) \\<diamondop>\n    B (recurse f l) \\<diamondop>\n    B (recurse f r))\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "have \"\\<dots> = pure (\\<lambda>x f. f x) \\<diamondop> recurse f r \\<diamondop> (pure (\\<lambda>x f. f x) \\<diamondop> recurse f l \\<diamondop> pure Node)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. un_B\n     (B (pure Tree_Relabelling.tree.Node) \\<diamondop>\n      B (recurse f l) \\<diamondop>\n      B (recurse f r)) =\n    pure (\\<lambda>x f. f x) \\<diamondop> recurse f r \\<diamondop>\n    (pure (\\<lambda>x f. f x) \\<diamondop> recurse f l \\<diamondop>\n     pure Tree_Relabelling.tree.Node)", "by(simp add: ap_state_rev_B B_inverse)"], ["proof (state)\nthis:\n  un_B\n   (B (pure Tree_Relabelling.tree.Node) \\<diamondop>\n    B (recurse f l) \\<diamondop>\n    B (recurse f r)) =\n  pure (\\<lambda>x f. f x) \\<diamondop> recurse f r \\<diamondop>\n  (pure (\\<lambda>x f. f x) \\<diamondop> recurse f l \\<diamondop>\n   pure Tree_Relabelling.tree.Node)\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "also"], ["proof (state)\nthis:\n  un_B\n   (B (pure Tree_Relabelling.tree.Node) \\<diamondop>\n    B (recurse f l) \\<diamondop>\n    B (recurse f r)) =\n  pure (\\<lambda>x f. f x) \\<diamondop> recurse f r \\<diamondop>\n  (pure (\\<lambda>x f. f x) \\<diamondop> recurse f l \\<diamondop>\n   pure Tree_Relabelling.tree.Node)\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "have \"\\<dots> = pure (\\<lambda>r l. Node l r) \\<diamondop> recurse f r \\<diamondop> recurse f l\"\n    \\<comment> \\<open>This step expands to 13 steps in \\cite{backwards}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>x f. f x) \\<diamondop> recurse f r \\<diamondop>\n    (pure (\\<lambda>x f. f x) \\<diamondop> recurse f l \\<diamondop>\n     pure Tree_Relabelling.tree.Node) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "by(applicative_nf) simp"], ["proof (state)\nthis:\n  pure (\\<lambda>x f. f x) \\<diamondop> recurse f r \\<diamondop>\n  (pure (\\<lambda>x f. f x) \\<diamondop> recurse f l \\<diamondop>\n   pure Tree_Relabelling.tree.Node) =\n  pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n  recurse f r \\<diamondop>\n  recurse f l\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "finally"], ["proof (chain)\npicking this:\n  recurse f (Tree_Relabelling.tree.Node l r) =\n  pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n  recurse f r \\<diamondop>\n  recurse f l", "show ?thesis"], ["proof (prove)\nusing this:\n  recurse f (Tree_Relabelling.tree.Node l r) =\n  pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n  recurse f r \\<diamondop>\n  recurse f l\n\ngoal (1 subgoal):\n 1. recurse f (Tree_Relabelling.tree.Node l r) =\n    pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n    recurse f r \\<diamondop>\n    recurse f l", "."], ["proof (state)\nthis:\n  recurse f (Tree_Relabelling.tree.Node l r) =\n  pure (\\<lambda>r l. Tree_Relabelling.tree.Node l r) \\<diamondop>\n  recurse f r \\<diamondop>\n  recurse f l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma traverse_pure: \"traverse pure t = pure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse pure t = pure t", "proof(induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       traverse pure (Tree_Relabelling.tree.Leaf x) =\n       pure (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       traverse pure (Tree_Relabelling.tree.Leaf x) =\n       pure (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "case Leaf"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       traverse pure (Tree_Relabelling.tree.Leaf x) =\n       pure (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse pure (Tree_Relabelling.tree.Leaf x_) =\n    pure (Tree_Relabelling.tree.Leaf x_)", "unfolding traverse.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Tree_Relabelling.tree.Leaf \\<diamondop> pure x_ =\n    pure (Tree_Relabelling.tree.Leaf x_)", "by applicative_nf simp"], ["proof (state)\nthis:\n  traverse pure (Tree_Relabelling.tree.Leaf x_) =\n  pure (Tree_Relabelling.tree.Leaf x_)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "}"], ["proof (state)\nthis:\n  traverse pure (Tree_Relabelling.tree.Leaf ?x3) =\n  pure (Tree_Relabelling.tree.Leaf ?x3)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "{"], ["proof (state)\nthis:\n  traverse pure (Tree_Relabelling.tree.Leaf ?x3) =\n  pure (Tree_Relabelling.tree.Leaf ?x3)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "case Node"], ["proof (state)\nthis:\n  traverse pure t1_ = pure t1_\n  traverse pure t2_ = pure t2_\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse pure t1 = pure t1;\n        traverse pure t2 = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node t1 t2) =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse pure (Tree_Relabelling.tree.Node t1_ t2_) =\n    pure (Tree_Relabelling.tree.Node t1_ t2_)", "unfolding traverse.simps Node.IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Tree_Relabelling.tree.Node \\<diamondop> pure t1_ \\<diamondop>\n    pure t2_ =\n    pure (Tree_Relabelling.tree.Node t1_ t2_)", "by applicative_nf simp"], ["proof (state)\nthis:\n  traverse pure (Tree_Relabelling.tree.Node t1_ t2_) =\n  pure (Tree_Relabelling.tree.Node t1_ t2_)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>traverse pure ?t1.3 = pure ?t1.3;\n   traverse pure ?t2.3 = pure ?t2.3\\<rbrakk>\n  \\<Longrightarrow> traverse pure (Tree_Relabelling.tree.Node ?t1.3 ?t2.3) =\n                    pure (Tree_Relabelling.tree.Node ?t1.3 ?t2.3)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{term \"B \\<circ> B\"} is an idiom morphism\\<close>"], ["", "lemma B_pure: \"pure x = B (State_Monad.return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure x = B (pure x)", "unfolding pure_state_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure_dual pure x = B (pure x)", "by transfer simp"], ["", "lemma BB_pure: \"pure x = B (B (pure x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure x = B (B (pure x))", "unfolding pure_state_rev_rev_def B_pure[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure_dual pure x = B (pure x)", "by transfer(rule refl)"], ["", "lemma BB_ap: \"B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "have \"B (B f) \\<diamondop> B (B x) = B (B (pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop> (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop> pure (\\<lambda>x f. f x))))\"\n    (is \"_ = B (B ?exp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) =\n    B (B (pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n          (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n           pure (\\<lambda>x f. f x))))", "unfolding ap_state_rev_rev_B B_pure ap_state_rev_B"], ["proof (prove)\ngoal (1 subgoal):\n 1. B (B (pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n          (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n           pure (\\<lambda>x f. f x)))) =\n    B (B (pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n          (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n           pure (\\<lambda>x f. f x))))", ".."], ["proof (state)\nthis:\n  B (B f) \\<diamondop> B (B x) =\n  B (B (pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n        (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n         pure (\\<lambda>x f. f x))))\n\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "also"], ["proof (state)\nthis:\n  B (B f) \\<diamondop> B (B x) =\n  B (B (pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n        (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n         pure (\\<lambda>x f. f x))))\n\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "have \"?exp = f \\<diamondop> x\" \\<comment> \\<open>This step takes 15 steps in \\cite{backwards}.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n    (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n     pure (\\<lambda>x f. f x)) =\n    f \\<diamondop> x", "by(applicative_nf)(rule refl)"], ["proof (state)\nthis:\n  pure (\\<lambda>x f. f x) \\<diamondop> f \\<diamondop>\n  (pure (\\<lambda>x f. f x) \\<diamondop> x \\<diamondop>\n   pure (\\<lambda>x f. f x)) =\n  f \\<diamondop> x\n\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "finally"], ["proof (chain)\npicking this:\n  B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "show ?thesis"], ["proof (prove)\nusing this:\n  B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))\n\ngoal (1 subgoal):\n 1. B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))", "."], ["proof (state)\nthis:\n  B (B f) \\<diamondop> B (B x) = B (B (f \\<diamondop> x))\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec traverse_rev_rev :: \"('a \\<Rightarrow> ('s, 'b) state_rev_rev) \\<Rightarrow> 'a tree \\<Rightarrow> ('s, 'b tree) state_rev_rev\"\nwhere\n  \"traverse_rev_rev f (Leaf x) = pure Leaf \\<diamondop> f x\"\n| \"traverse_rev_rev f (Node l r) = pure Node \\<diamondop> traverse_rev_rev f l \\<diamondop> traverse_rev_rev f r\""], ["", "definition recurse_rev :: \"('a \\<Rightarrow> ('s, 'b) state_rev) \\<Rightarrow> 'a tree \\<Rightarrow> ('s, 'b tree) state_rev\"\nwhere \"recurse_rev f = un_B \\<circ> traverse_rev_rev (B \\<circ> f)\""], ["", "lemma traverse_B_B: \"traverse_rev_rev (B \\<circ> B \\<circ> f) = B \\<circ> B \\<circ> traverse f\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_rev_rev (B \\<circ> B \\<circ> f) =\n    B \\<circ> B \\<circ> traverse f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       traverse_rev_rev (B \\<circ> B \\<circ> f) x =\n       (B \\<circ> B \\<circ> traverse f) x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       traverse_rev_rev (B \\<circ> B \\<circ> f) x =\n       (B \\<circ> B \\<circ> traverse f) x", "show \"?lhs t = ?rhs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse_rev_rev (B \\<circ> B \\<circ> f) t =\n    (B \\<circ> B \\<circ> traverse f) t", "by(induction t)(simp_all add: BB_pure BB_ap)"], ["proof (state)\nthis:\n  traverse_rev_rev (B \\<circ> B \\<circ> f) t =\n  (B \\<circ> B \\<circ> traverse f) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma traverse_recurse: \"traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "have \"?lhs = un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f", "by(simp add: o_def B_inverse)"], ["proof (state)\nthis:\n  traverse f = un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f\n\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "also"], ["proof (state)\nthis:\n  traverse f = un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f\n\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "have \"\\<dots> = un_B \\<circ> un_B \\<circ> traverse_rev_rev (B \\<circ> B \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f =\n    un_B \\<circ> un_B \\<circ> traverse_rev_rev (B \\<circ> B \\<circ> f)", "unfolding traverse_B_B"], ["proof (prove)\ngoal (1 subgoal):\n 1. un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f =\n    un_B \\<circ> un_B \\<circ> (B \\<circ> B \\<circ> traverse f)", "by(simp add: o_assoc)"], ["proof (state)\nthis:\n  un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f =\n  un_B \\<circ> un_B \\<circ> traverse_rev_rev (B \\<circ> B \\<circ> f)\n\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "also"], ["proof (state)\nthis:\n  un_B \\<circ> un_B \\<circ> B \\<circ> B \\<circ> traverse f =\n  un_B \\<circ> un_B \\<circ> traverse_rev_rev (B \\<circ> B \\<circ> f)\n\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. un_B \\<circ> un_B \\<circ> traverse_rev_rev (B \\<circ> B \\<circ> f) =\n    un_B \\<circ> recurse_rev (B \\<circ> f)", "by(simp add: recurse_rev_def o_assoc)"], ["proof (state)\nthis:\n  un_B \\<circ> un_B \\<circ> traverse_rev_rev (B \\<circ> B \\<circ> f) =\n  un_B \\<circ> recurse_rev (B \\<circ> f)\n\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "finally"], ["proof (chain)\npicking this:\n  traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "show ?thesis"], ["proof (prove)\nusing this:\n  traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)\n\ngoal (1 subgoal):\n 1. traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)", "."], ["proof (state)\nthis:\n  traverse f = un_B \\<circ> recurse_rev (B \\<circ> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma recurse_traverse:\n  assumes \"f \\<bullet> g = pure\"\n  shows \"recurse f \\<bullet> traverse g = pure\"\n\\<comment> \\<open>Gibbons and Bird impose this as an additional requirement on traversals, but they write\n  that they have not found a way to derive this fact from other axioms. So we prove it directly.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. recurse f \\<bullet> traverse g = pure", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (recurse f \\<bullet> traverse g) x = pure x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (recurse f \\<bullet> traverse g) x = pure x", "from assms"], ["proof (chain)\npicking this:\n  f \\<bullet> g = pure", "have *: \"\\<And>x. State_Monad.bind (g x) f = State_Monad.return x\""], ["proof (prove)\nusing this:\n  f \\<bullet> g = pure\n\ngoal (1 subgoal):\n 1. \\<And>x. g x \\<bind> f = pure x", "by(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  g ?x \\<bind> f = pure ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. (recurse f \\<bullet> traverse g) x = pure x", "hence **: \"\\<And>x h. State_Monad.bind (g x) (\\<lambda>x. State_Monad.bind (f x) h) = h x\""], ["proof (prove)\nusing this:\n  g ?x \\<bind> f = pure ?x\n\ngoal (1 subgoal):\n 1. \\<And>x h. g x \\<bind> (\\<lambda>x. f x \\<bind> h) = h x", "by(fold State_Monad.bind_assoc)(simp)"], ["proof (state)\nthis:\n  g ?x \\<bind> (\\<lambda>x. f x \\<bind> ?h) = ?h ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. (recurse f \\<bullet> traverse g) x = pure x", "show \"(recurse f \\<bullet> traverse g) t = pure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (recurse f \\<bullet> traverse g) t = pure t", "unfolding kleisli_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse g t \\<bind> recurse f = pure t", "proof(induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       traverse g (Tree_Relabelling.tree.Leaf x) \\<bind> recurse f =\n       pure (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>traverse g t1 \\<bind> recurse f = pure t1;\n        traverse g t2 \\<bind> recurse f = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse g\n                          (Tree_Relabelling.tree.Node t1 t2) \\<bind>\n                         recurse f =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "case (Leaf x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       traverse g (Tree_Relabelling.tree.Leaf x) \\<bind> recurse f =\n       pure (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>traverse g t1 \\<bind> recurse f = pure t1;\n        traverse g t2 \\<bind> recurse f = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse g\n                          (Tree_Relabelling.tree.Node t1 t2) \\<bind>\n                         recurse f =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse g (Tree_Relabelling.tree.Leaf x) \\<bind> recurse f =\n    pure (Tree_Relabelling.tree.Leaf x)", "by(simp add: ap_conv_bind_state recurse_Leaf **)"], ["proof (state)\nthis:\n  traverse g (Tree_Relabelling.tree.Leaf x) \\<bind> recurse f =\n  pure (Tree_Relabelling.tree.Leaf x)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse g t1 \\<bind> recurse f = pure t1;\n        traverse g t2 \\<bind> recurse f = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse g\n                          (Tree_Relabelling.tree.Node t1 t2) \\<bind>\n                         recurse f =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse g t1 \\<bind> recurse f = pure t1;\n        traverse g t2 \\<bind> recurse f = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse g\n                          (Tree_Relabelling.tree.Node t1 t2) \\<bind>\n                         recurse f =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "case (Node l r)"], ["proof (state)\nthis:\n  traverse g l \\<bind> recurse f = pure l\n  traverse g r \\<bind> recurse f = pure r\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>traverse g t1 \\<bind> recurse f = pure t1;\n        traverse g t2 \\<bind> recurse f = pure t2\\<rbrakk>\n       \\<Longrightarrow> traverse g\n                          (Tree_Relabelling.tree.Node t1 t2) \\<bind>\n                         recurse f =\n                         pure (Tree_Relabelling.tree.Node t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse g (Tree_Relabelling.tree.Node l r) \\<bind> recurse f =\n    pure (Tree_Relabelling.tree.Node l r)", "by(simp add: ap_conv_bind_state recurse_Node)(simp add: State_Monad.bind_assoc[symmetric] Node.IH)"], ["proof (state)\nthis:\n  traverse g (Tree_Relabelling.tree.Node l r) \\<bind> recurse f =\n  pure (Tree_Relabelling.tree.Node l r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (recurse f \\<bullet> traverse g) t = pure t\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Apply traversals to labelling\\<close>"], ["", "definition strip :: \"'a \\<times> 'b \\<Rightarrow> ('b stream, 'a) state\"\nwhere \"strip = (\\<lambda>(a, b). State_Monad.bind (State_Monad.update (SCons b)) (\\<lambda>_. State_Monad.return a))\""], ["", "definition adorn :: \"'a \\<Rightarrow> ('b stream, 'a \\<times> 'b) state\"\nwhere \"adorn a = pure (Pair a) \\<diamondop> fetch\""], ["", "abbreviation label :: \"'a tree \\<Rightarrow> ('b stream, ('a \\<times> 'b) tree) state\"\nwhere \"label \\<equiv> traverse adorn\""], ["", "abbreviation unlabel :: \"('a \\<times> 'b) tree \\<Rightarrow> ('b stream, 'a tree) state\"\nwhere \"unlabel \\<equiv> recurse strip\""], ["", "lemma strip_adorn: \"strip \\<bullet> adorn = pure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip \\<bullet> adorn = pure", "by(simp add: strip_def adorn_def fun_eq_iff fetch_def[abs_def] ap_conv_bind_state)"], ["", "lemma correctness_monadic: \"unlabel \\<bullet> label = pure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlabel \\<bullet> label = pure", "by(rule recurse_traverse)(rule strip_adorn)"], ["", "subsubsection \\<open>Applicative correctness statement\\<close>"], ["", "text \\<open>Repeating an effect\\<close>"], ["", "primrec repeatM :: \"nat \\<Rightarrow> ('s, 'x) state \\<Rightarrow> ('s, 'x list) state\"\nwhere\n  \"repeatM 0 f = State_Monad.return []\"\n| \"repeatM (Suc n) f = pure (#) \\<diamondop> f \\<diamondop> repeatM n f\""], ["", "lemma repeatM_plus: \"repeatM (n + m) f = pure append \\<diamondop> repeatM n f \\<diamondop> repeatM m f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeatM (n + m) f =\n    pure (@) \\<diamondop> repeatM n f \\<diamondop> repeatM m f", "by(induction n)(simp; applicative_nf; simp)+"], ["", "abbreviation (input) fail :: \"'a option\" where \"fail \\<equiv> None\""], ["", "definition lift_state :: \"('s, 'a) state \\<Rightarrow> ('s, 'a option) state\"\nwhere [applicative_unfold]: \"lift_state x = pure pure \\<diamondop> x\""], ["", "definition lift_option :: \"'a option \\<Rightarrow> ('s, 'a option) state\"\nwhere [applicative_unfold]: \"lift_option x = pure x\""], ["", "fun assert :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a option \\<Rightarrow> 'a option\"\nwhere\n  assert_fail: \"assert P fail = fail\"\n| assert_pure: \"assert P (pure x) = (if P x then pure x else fail)\""], ["", "context labelling begin"], ["", "abbreviation symbols :: \"nat \\<Rightarrow> ('s, 'x list option) state\"\nwhere \"symbols n \\<equiv> lift_state (repeatM n fresh)\""], ["", "abbreviation (input) disjoint :: \"'x list \\<Rightarrow> 'x list \\<Rightarrow> bool\"\nwhere \"disjoint xs ys \\<equiv> set xs \\<inter> set ys = {}\""], ["", "definition dlabels :: \"'x tree \\<Rightarrow> 'x list option\"\nwhere \"dlabels = fold_tree (\\<lambda>x. pure [x])\n     (\\<lambda>l r. pure (case_prod append) \\<diamondop> (assert (case_prod disjoint) (pure Pair \\<diamondop> l \\<diamondop> r)))\""], ["", "lemma dlabels_simps [simp]:\n  \"dlabels (Leaf x) = pure [x]\"\n  \"dlabels (Node l r) = pure (case_prod append) \\<diamondop> (assert (case_prod disjoint) (pure Pair \\<diamondop> dlabels l \\<diamondop> dlabels r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlabels (Tree_Relabelling.tree.Leaf x) = Some [x] &&&\n    dlabels (Tree_Relabelling.tree.Node l r) =\n    ap_option (Some (\\<lambda>(x, y). x @ y))\n     (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n       (ap_option (ap_option (Some Pair) (dlabels l)) (dlabels r)))", "by(simp_all add: dlabels_def)"], ["", "lemma correctness_applicative:\n  assumes distinct: \"\\<And>n. pure (assert distinct) \\<diamondop> symbols n = symbols n\"\n  shows \"State_Monad.return dlabels \\<diamondop> label_tree t = symbols (leaves t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return dlabels) (label_tree t) =\n    symbols (leaves t)", "proof(induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       State_Monad.ap (State_Monad.return dlabels)\n        (label_tree (Tree_Relabelling.tree.Leaf x)) =\n       symbols (leaves (Tree_Relabelling.tree.Leaf x))\n 2. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "show \"pure dlabels \\<diamondop> label_tree (Leaf x) = symbols (leaves (Leaf x))\" for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return dlabels)\n     (label_tree (Tree_Relabelling.tree.Leaf x)) =\n    symbols (leaves (Tree_Relabelling.tree.Leaf x))", "unfolding label_tree_simps leaves_simps repeatM.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return dlabels)\n     (State_Monad.ap (State_Monad.return Tree_Relabelling.tree.Leaf)\n       fresh) =\n    lift_state\n     (State_Monad.ap (State_Monad.ap (State_Monad.return (#)) fresh)\n       (State_Monad.return []))", "by applicative_nf simp"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return dlabels)\n   (label_tree (Tree_Relabelling.tree.Leaf ?x2)) =\n  symbols (leaves (Tree_Relabelling.tree.Leaf ?x2))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "fix l r :: \"'a tree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "assume IH: \"pure dlabels \\<diamondop> label_tree l = symbols (leaves l)\" \"pure dlabels \\<diamondop> label_tree r = symbols (leaves r)\""], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return dlabels) (label_tree l) =\n  symbols (leaves l)\n  State_Monad.ap (State_Monad.return dlabels) (label_tree r) =\n  symbols (leaves r)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "let ?cat = \"case_prod append\" and ?disj = \"case_prod disjoint\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "let ?f = \"\\<lambda>l r. pure ?cat \\<diamondop> (assert ?disj (pure Pair \\<diamondop> l \\<diamondop> r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "have \"State_Monad.return dlabels \\<diamondop> label_tree (Node l r) =\n        pure ?f \\<diamondop> (pure dlabels \\<diamondop> label_tree l) \\<diamondop> (pure dlabels \\<diamondop> label_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return dlabels)\n     (label_tree (Tree_Relabelling.tree.Node l r)) =\n    State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree r))", "unfolding label_tree_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return dlabels)\n     (State_Monad.ap\n       (State_Monad.ap (State_Monad.return Tree_Relabelling.tree.Node)\n         (label_tree l))\n       (label_tree r)) =\n    State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree r))", "by applicative_nf simp"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return dlabels)\n   (label_tree (Tree_Relabelling.tree.Node l r)) =\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n   (State_Monad.ap (State_Monad.return dlabels) (label_tree r))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "also"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return dlabels)\n   (label_tree (Tree_Relabelling.tree.Node l r)) =\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n   (State_Monad.ap (State_Monad.return dlabels) (label_tree r))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "have \"\\<dots> = pure ?f \\<diamondop> (pure (assert distinct) \\<diamondop> symbols (leaves l)) \\<diamondop> (pure (assert distinct) \\<diamondop> symbols (leaves r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree r)) =\n    State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (State_Monad.ap (State_Monad.return (assert distinct))\n         (symbols (leaves l))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves r)))", "unfolding IH distinct"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (symbols (leaves l)))\n     (symbols (leaves r)) =\n    State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (symbols (leaves l)))\n     (symbols (leaves r))", ".."], ["proof (state)\nthis:\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n   (State_Monad.ap (State_Monad.return dlabels) (label_tree r)) =\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves l))))\n   (State_Monad.ap (State_Monad.return (assert distinct))\n     (symbols (leaves r)))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "also"], ["proof (state)\nthis:\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return dlabels) (label_tree l)))\n   (State_Monad.ap (State_Monad.return dlabels) (label_tree r)) =\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves l))))\n   (State_Monad.ap (State_Monad.return (assert distinct))\n     (symbols (leaves r)))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "have \"\\<dots> = pure (assert distinct) \\<diamondop> symbols (leaves (Node l r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (State_Monad.ap (State_Monad.return (assert distinct))\n         (symbols (leaves l))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves r))) =\n    State_Monad.ap (State_Monad.return (assert distinct))\n     (symbols (leaves (Tree_Relabelling.tree.Node l r)))", "unfolding leaves_simps repeatM_plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap\n     (State_Monad.ap\n       (State_Monad.return\n         (\\<lambda>l r.\n             ap_option (Some (\\<lambda>(x, y). x @ y))\n              (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n                (ap_option (ap_option (Some Pair) l) r))))\n       (State_Monad.ap (State_Monad.return (assert distinct))\n         (symbols (leaves l))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves r))) =\n    State_Monad.ap (State_Monad.return (assert distinct))\n     (lift_state\n       (State_Monad.ap\n         (State_Monad.ap (State_Monad.return (@))\n           (repeatM (leaves l) fresh))\n         (repeatM (leaves r) fresh)))", "by applicative_nf simp"], ["proof (state)\nthis:\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves l))))\n   (State_Monad.ap (State_Monad.return (assert distinct))\n     (symbols (leaves r))) =\n  State_Monad.ap (State_Monad.return (assert distinct))\n   (symbols (leaves (Tree_Relabelling.tree.Node l r)))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "also"], ["proof (state)\nthis:\n  State_Monad.ap\n   (State_Monad.ap\n     (State_Monad.return\n       (\\<lambda>l r.\n           ap_option (Some (\\<lambda>(x, y). x @ y))\n            (assert (\\<lambda>(xs, ys). set xs \\<inter> set ys = {})\n              (ap_option (ap_option (Some Pair) l) r))))\n     (State_Monad.ap (State_Monad.return (assert distinct))\n       (symbols (leaves l))))\n   (State_Monad.ap (State_Monad.return (assert distinct))\n     (symbols (leaves r))) =\n  State_Monad.ap (State_Monad.return (assert distinct))\n   (symbols (leaves (Tree_Relabelling.tree.Node l r)))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "have \"\\<dots> = symbols (leaves (Node l r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return (assert distinct))\n     (symbols (leaves (Tree_Relabelling.tree.Node l r))) =\n    symbols (leaves (Tree_Relabelling.tree.Node l r))", "by(rule distinct)"], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return (assert distinct))\n   (symbols (leaves (Tree_Relabelling.tree.Node l r))) =\n  symbols (leaves (Tree_Relabelling.tree.Node l r))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>State_Monad.ap (State_Monad.return dlabels)\n                 (label_tree t1) =\n                symbols (leaves t1);\n        State_Monad.ap (State_Monad.return dlabels) (label_tree t2) =\n        symbols (leaves t2)\\<rbrakk>\n       \\<Longrightarrow> State_Monad.ap (State_Monad.return dlabels)\n                          (label_tree (Tree_Relabelling.tree.Node t1 t2)) =\n                         symbols (leaves (Tree_Relabelling.tree.Node t1 t2))", "finally"], ["proof (chain)\npicking this:\n  State_Monad.ap (State_Monad.return dlabels)\n   (label_tree (Tree_Relabelling.tree.Node l r)) =\n  symbols (leaves (Tree_Relabelling.tree.Node l r))", "show \"pure dlabels \\<diamondop> label_tree (Node l r) = symbols (leaves (Node l r))\""], ["proof (prove)\nusing this:\n  State_Monad.ap (State_Monad.return dlabels)\n   (label_tree (Tree_Relabelling.tree.Node l r)) =\n  symbols (leaves (Tree_Relabelling.tree.Node l r))\n\ngoal (1 subgoal):\n 1. State_Monad.ap (State_Monad.return dlabels)\n     (label_tree (Tree_Relabelling.tree.Node l r)) =\n    symbols (leaves (Tree_Relabelling.tree.Node l r))", "."], ["proof (state)\nthis:\n  State_Monad.ap (State_Monad.return dlabels)\n   (label_tree (Tree_Relabelling.tree.Node l r)) =\n  symbols (leaves (Tree_Relabelling.tree.Node l r))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Probabilistic tree relabelling\\<close>"], ["", "primrec mirror :: \"'a tree \\<Rightarrow> 'a tree\"\nwhere\n  \"mirror (Leaf x) = Leaf x\"\n| \"mirror (Node l r) = Node (mirror r) (mirror l)\""], ["", "datatype dir = Left | Right"], ["", "hide_const (open) path"], ["", "function (sequential) subtree :: \"dir list \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\"\nwhere\n  \"subtree (Left # path)  (Node l r) = subtree path l\"\n| \"subtree (Right # path) (Node l r) = subtree path r\"\n| \"subtree _              (Leaf x)   = Leaf x\"\n| \"subtree []             t          = t\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>path l r.\n                   x =\n                   (dir.Left # path,\n                    Tree_Relabelling.tree.Node l r) \\<Longrightarrow>\n                   P;\n        \\<And>path l r.\n           x =\n           (dir.Right # path,\n            Tree_Relabelling.tree.Node l r) \\<Longrightarrow>\n           P;\n        \\<And>uu_ xa.\n           x = (uu_, Tree_Relabelling.tree.Leaf xa) \\<Longrightarrow> P;\n        \\<And>v va.\n           x = ([], Tree_Relabelling.tree.Node v va) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>path l r patha la ra.\n       (dir.Left # path, Tree_Relabelling.tree.Node l r) =\n       (dir.Left # patha,\n        Tree_Relabelling.tree.Node la ra) \\<Longrightarrow>\n       subtree_sumC (path, l) = subtree_sumC (patha, la)\n 3. \\<And>path l r patha la ra.\n       (dir.Left # path, Tree_Relabelling.tree.Node l r) =\n       (dir.Right # patha,\n        Tree_Relabelling.tree.Node la ra) \\<Longrightarrow>\n       subtree_sumC (path, l) = subtree_sumC (patha, ra)\n 4. \\<And>path l r uu_ x.\n       (dir.Left # path, Tree_Relabelling.tree.Node l r) =\n       (uu_, Tree_Relabelling.tree.Leaf x) \\<Longrightarrow>\n       subtree_sumC (path, l) = Tree_Relabelling.tree.Leaf x\n 5. \\<And>path l r v va.\n       (dir.Left # path, Tree_Relabelling.tree.Node l r) =\n       ([], Tree_Relabelling.tree.Node v va) \\<Longrightarrow>\n       subtree_sumC (path, l) = Tree_Relabelling.tree.Node v va\n 6. \\<And>path l r patha la ra.\n       (dir.Right # path, Tree_Relabelling.tree.Node l r) =\n       (dir.Right # patha,\n        Tree_Relabelling.tree.Node la ra) \\<Longrightarrow>\n       subtree_sumC (path, r) = subtree_sumC (patha, ra)\n 7. \\<And>path l r uu_ x.\n       (dir.Right # path, Tree_Relabelling.tree.Node l r) =\n       (uu_, Tree_Relabelling.tree.Leaf x) \\<Longrightarrow>\n       subtree_sumC (path, r) = Tree_Relabelling.tree.Leaf x\n 8. \\<And>path l r v va.\n       (dir.Right # path, Tree_Relabelling.tree.Node l r) =\n       ([], Tree_Relabelling.tree.Node v va) \\<Longrightarrow>\n       subtree_sumC (path, r) = Tree_Relabelling.tree.Node v va\n 9. \\<And>uu_ x uua_ xa.\n       (uu_, Tree_Relabelling.tree.Leaf x) =\n       (uua_, Tree_Relabelling.tree.Leaf xa) \\<Longrightarrow>\n       Tree_Relabelling.tree.Leaf x = Tree_Relabelling.tree.Leaf xa\n 10. \\<And>uu_ x v va.\n        (uu_, Tree_Relabelling.tree.Leaf x) =\n        ([], Tree_Relabelling.tree.Node v va) \\<Longrightarrow>\n        Tree_Relabelling.tree.Leaf x = Tree_Relabelling.tree.Node v va\nA total of 11 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All subtree_dom", "by lexicographic_order"], ["", "adhoc_overloading Applicative.pure pure_pmf"], ["", "context fixes p :: \"'a \\<Rightarrow> 'b pmf\" begin"], ["", "primrec plabel :: \"'a tree \\<Rightarrow> 'b tree pmf\"\nwhere\n  \"plabel (Leaf x)   = pure Leaf \\<diamondop> p x\"\n| \"plabel (Node l r) = pure Node \\<diamondop> plabel l \\<diamondop> plabel r\""], ["", "lemma plabel_mirror: \"plabel (mirror t) = pure mirror \\<diamondop> plabel t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel (Tree_Relabelling.mirror t) =\n    pure Tree_Relabelling.mirror \\<diamondop> local.plabel t", "proof(induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       local.plabel\n        (Tree_Relabelling.mirror (Tree_Relabelling.tree.Leaf x)) =\n       pure Tree_Relabelling.mirror \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>local.plabel (Tree_Relabelling.mirror t1) =\n                pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1;\n        local.plabel (Tree_Relabelling.mirror t2) =\n        pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2\\<rbrakk>\n       \\<Longrightarrow> local.plabel\n                          (Tree_Relabelling.mirror\n                            (Tree_Relabelling.tree.Node t1 t2)) =\n                         pure Tree_Relabelling.mirror \\<diamondop>\n                         local.plabel (Tree_Relabelling.tree.Node t1 t2)", "case (Leaf x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       local.plabel\n        (Tree_Relabelling.mirror (Tree_Relabelling.tree.Leaf x)) =\n       pure Tree_Relabelling.mirror \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>local.plabel (Tree_Relabelling.mirror t1) =\n                pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1;\n        local.plabel (Tree_Relabelling.mirror t2) =\n        pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2\\<rbrakk>\n       \\<Longrightarrow> local.plabel\n                          (Tree_Relabelling.mirror\n                            (Tree_Relabelling.tree.Node t1 t2)) =\n                         pure Tree_Relabelling.mirror \\<diamondop>\n                         local.plabel (Tree_Relabelling.tree.Node t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel (Tree_Relabelling.mirror (Tree_Relabelling.tree.Leaf x)) =\n    pure Tree_Relabelling.mirror \\<diamondop>\n    local.plabel (Tree_Relabelling.tree.Leaf x)", "unfolding plabel.simps mirror.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Tree_Relabelling.tree.Leaf \\<diamondop> p x =\n    pure Tree_Relabelling.mirror \\<diamondop>\n    (pure Tree_Relabelling.tree.Leaf \\<diamondop> p x)", "by(applicative_lifting) simp"], ["proof (state)\nthis:\n  local.plabel (Tree_Relabelling.mirror (Tree_Relabelling.tree.Leaf x)) =\n  pure Tree_Relabelling.mirror \\<diamondop>\n  local.plabel (Tree_Relabelling.tree.Leaf x)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>local.plabel (Tree_Relabelling.mirror t1) =\n                pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1;\n        local.plabel (Tree_Relabelling.mirror t2) =\n        pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2\\<rbrakk>\n       \\<Longrightarrow> local.plabel\n                          (Tree_Relabelling.mirror\n                            (Tree_Relabelling.tree.Node t1 t2)) =\n                         pure Tree_Relabelling.mirror \\<diamondop>\n                         local.plabel (Tree_Relabelling.tree.Node t1 t2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>local.plabel (Tree_Relabelling.mirror t1) =\n                pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1;\n        local.plabel (Tree_Relabelling.mirror t2) =\n        pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2\\<rbrakk>\n       \\<Longrightarrow> local.plabel\n                          (Tree_Relabelling.mirror\n                            (Tree_Relabelling.tree.Node t1 t2)) =\n                         pure Tree_Relabelling.mirror \\<diamondop>\n                         local.plabel (Tree_Relabelling.tree.Node t1 t2)", "case (Node t1 t2)"], ["proof (state)\nthis:\n  local.plabel (Tree_Relabelling.mirror t1) =\n  pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1\n  local.plabel (Tree_Relabelling.mirror t2) =\n  pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>local.plabel (Tree_Relabelling.mirror t1) =\n                pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1;\n        local.plabel (Tree_Relabelling.mirror t2) =\n        pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2\\<rbrakk>\n       \\<Longrightarrow> local.plabel\n                          (Tree_Relabelling.mirror\n                            (Tree_Relabelling.tree.Node t1 t2)) =\n                         pure Tree_Relabelling.mirror \\<diamondop>\n                         local.plabel (Tree_Relabelling.tree.Node t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel\n     (Tree_Relabelling.mirror (Tree_Relabelling.tree.Node t1 t2)) =\n    pure Tree_Relabelling.mirror \\<diamondop>\n    local.plabel (Tree_Relabelling.tree.Node t1 t2)", "unfolding plabel.simps mirror.simps Node.IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Tree_Relabelling.tree.Node \\<diamondop>\n    (pure Tree_Relabelling.mirror \\<diamondop> local.plabel t2) \\<diamondop>\n    (pure Tree_Relabelling.mirror \\<diamondop> local.plabel t1) =\n    pure Tree_Relabelling.mirror \\<diamondop>\n    (pure Tree_Relabelling.tree.Node \\<diamondop>\n     local.plabel t1 \\<diamondop>\n     local.plabel t2)", "by(applicative_lifting) simp"], ["proof (state)\nthis:\n  local.plabel\n   (Tree_Relabelling.mirror (Tree_Relabelling.tree.Node t1 t2)) =\n  pure Tree_Relabelling.mirror \\<diamondop>\n  local.plabel (Tree_Relabelling.tree.Node t1 t2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plabel_subtree: \"plabel (subtree path t) = pure (subtree path) \\<diamondop> plabel t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel (subtree path t) =\n    pure (subtree path) \\<diamondop> local.plabel t", "proof(induction path t rule: subtree.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>path l r.\n       local.plabel (subtree path l) =\n       pure (subtree path) \\<diamondop> local.plabel l \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Left # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Left # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 2. \\<And>path l r.\n       local.plabel (subtree path r) =\n       pure (subtree path) \\<diamondop> local.plabel r \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Right # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 3. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 4. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "case Left: (1 path l r)"], ["proof (state)\nthis:\n  local.plabel (subtree path l) =\n  pure (subtree path) \\<diamondop> local.plabel l\n\ngoal (4 subgoals):\n 1. \\<And>path l r.\n       local.plabel (subtree path l) =\n       pure (subtree path) \\<diamondop> local.plabel l \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Left # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Left # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 2. \\<And>path l r.\n       local.plabel (subtree path r) =\n       pure (subtree path) \\<diamondop> local.plabel r \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Right # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 3. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 4. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel\n     (subtree (dir.Left # path) (Tree_Relabelling.tree.Node l r)) =\n    pure (subtree (dir.Left # path)) \\<diamondop>\n    local.plabel (Tree_Relabelling.tree.Node l r)", "unfolding plabel.simps subtree.simps Left.IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (subtree path) \\<diamondop> local.plabel l =\n    pure (subtree (dir.Left # path)) \\<diamondop>\n    (pure Tree_Relabelling.tree.Node \\<diamondop>\n     local.plabel l \\<diamondop>\n     local.plabel r)", "by(applicative_lifting) simp"], ["proof (state)\nthis:\n  local.plabel\n   (subtree (dir.Left # path) (Tree_Relabelling.tree.Node l r)) =\n  pure (subtree (dir.Left # path)) \\<diamondop>\n  local.plabel (Tree_Relabelling.tree.Node l r)\n\ngoal (3 subgoals):\n 1. \\<And>path l r.\n       local.plabel (subtree path r) =\n       pure (subtree path) \\<diamondop> local.plabel r \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Right # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 2. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 3. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>path l r.\n       local.plabel (subtree path r) =\n       pure (subtree path) \\<diamondop> local.plabel r \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Right # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 2. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 3. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "case Right: (2 path l r)"], ["proof (state)\nthis:\n  local.plabel (subtree path r) =\n  pure (subtree path) \\<diamondop> local.plabel r\n\ngoal (3 subgoals):\n 1. \\<And>path l r.\n       local.plabel (subtree path r) =\n       pure (subtree path) \\<diamondop> local.plabel r \\<Longrightarrow>\n       local.plabel\n        (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n       pure (subtree (dir.Right # path)) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node l r)\n 2. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 3. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel\n     (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n    pure (subtree (dir.Right # path)) \\<diamondop>\n    local.plabel (Tree_Relabelling.tree.Node l r)", "unfolding plabel.simps subtree.simps Right.IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (subtree path) \\<diamondop> local.plabel r =\n    pure (subtree (dir.Right # path)) \\<diamondop>\n    (pure Tree_Relabelling.tree.Node \\<diamondop>\n     local.plabel l \\<diamondop>\n     local.plabel r)", "by(applicative_lifting) simp"], ["proof (state)\nthis:\n  local.plabel\n   (subtree (dir.Right # path) (Tree_Relabelling.tree.Node l r)) =\n  pure (subtree (dir.Right # path)) \\<diamondop>\n  local.plabel (Tree_Relabelling.tree.Node l r)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "case (3 uu x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>uu_ x.\n       local.plabel (subtree uu_ (Tree_Relabelling.tree.Leaf x)) =\n       pure (subtree uu_) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Leaf x)\n 2. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel (subtree uu (Tree_Relabelling.tree.Leaf x)) =\n    pure (subtree uu) \\<diamondop>\n    local.plabel (Tree_Relabelling.tree.Leaf x)", "unfolding plabel.simps subtree.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Tree_Relabelling.tree.Leaf \\<diamondop> p x =\n    pure (subtree uu) \\<diamondop>\n    (pure Tree_Relabelling.tree.Leaf \\<diamondop> p x)", "by(applicative_lifting) simp"], ["proof (state)\nthis:\n  local.plabel (subtree uu (Tree_Relabelling.tree.Leaf x)) =\n  pure (subtree uu) \\<diamondop> local.plabel (Tree_Relabelling.tree.Leaf x)\n\ngoal (1 subgoal):\n 1. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "case (4 v va)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>v va.\n       local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n       pure (subtree []) \\<diamondop>\n       local.plabel (Tree_Relabelling.tree.Node v va)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n    pure (subtree []) \\<diamondop>\n    local.plabel (Tree_Relabelling.tree.Node v va)", "unfolding plabel.simps subtree.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure Tree_Relabelling.tree.Node \\<diamondop> local.plabel v \\<diamondop>\n    local.plabel va =\n    pure (subtree []) \\<diamondop>\n    (pure Tree_Relabelling.tree.Node \\<diamondop>\n     local.plabel v \\<diamondop>\n     local.plabel va)", "by(applicative_lifting) simp"], ["proof (state)\nthis:\n  local.plabel (subtree [] (Tree_Relabelling.tree.Node v va)) =\n  pure (subtree []) \\<diamondop>\n  local.plabel (Tree_Relabelling.tree.Node v va)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}