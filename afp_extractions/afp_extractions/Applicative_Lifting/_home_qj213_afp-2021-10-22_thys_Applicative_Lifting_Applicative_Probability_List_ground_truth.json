{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative_Probability_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma sum_list_concat_map: \"sum_list (concat (map f xs)) = sum_list (map (\\<lambda>x. sum_list (f x)) xs)\"", "lemma set_ap_list [simp]: \"set (f \\<diamondop> x) = (\\<lambda>(f, x). f x) ` (set f \\<times> set x)\""], "translations": [["", "lemma sum_list_concat_map: \"sum_list (concat (map f xs)) = sum_list (map (\\<lambda>x. sum_list (f x)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (concat (map f xs)) = (\\<Sum>x\\<leftarrow>xs. sum_list (f x))", "by(induction xs) simp_all"], ["", "context includes applicative_syntax begin"], ["", "lemma set_ap_list [simp]: \"set (f \\<diamondop> x) = (\\<lambda>(f, x). f x) ` (set f \\<times> set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (f \\<diamondop> x) = (\\<lambda>(f, x). f x) ` (set f \\<times> set x)", "by(auto simp add: ap_list_def List.bind_def)"], ["", "text \\<open>We call the implementation type \\<open>pfp\\<close> because it is the basis for the Haskell library\n  Probability by Martin Erwig and Steve Kollmansberger (Probabilistic Functional Programming).\\<close>"], ["", "typedef 'a pfp = \"{xs :: ('a \\<times> real) list. (\\<forall>(_, p) \\<in> set xs. p > 0) \\<and> sum_list (map snd xs) = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {xs.\n                (\\<forall>(uu_, p)\\<in>set xs. 0 < p) \\<and>\n                sum_list (map snd xs) = 1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {xs.\n              (\\<forall>(uu_, p)\\<in>set xs. 0 < p) \\<and>\n              sum_list (map snd xs) = 1}", "show \"[(x, 1)] \\<in> ?pfp\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x, 1)]\n    \\<in> {xs.\n           (\\<forall>(uu_, p)\\<in>set xs. 0 < p) \\<and>\n           sum_list (map snd xs) = 1}", "by simp"], ["proof (state)\nthis:\n  [(?x, 1)]\n  \\<in> {xs.\n         (\\<forall>(uu_, p)\\<in>set xs. 0 < p) \\<and>\n         sum_list (map snd xs) = 1}\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_pfp"], ["", "lift_definition pure_pfp :: \"'a \\<Rightarrow> 'a pfp\" is \"\\<lambda>x. [(x, 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<forall>(uu_, y)\\<in>set [(a, 1)]. 0 < y) \\<and>\n       sum_list (map snd [(a, 1)]) = 1", "by simp"], ["", "lift_definition ap_pfp :: \"('a \\<Rightarrow> 'b) pfp \\<Rightarrow> 'a pfp \\<Rightarrow> 'b pfp\"\nis \"\\<lambda>fs xs. [\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop> fs \\<diamondop> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>(\\<forall>(uu_, y)\\<in>set list1. 0 < y) \\<and>\n                sum_list (map snd list1) = 1;\n        (\\<forall>(uu_, y)\\<in>set list2. 0 < y) \\<and>\n        sum_list (map snd list2) = 1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(uu_, y)\n                                   \\<in>set\n   ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop> list1 \\<diamondop>\n    list2).\n                             0 < y) \\<and>\n                         sum_list\n                          (map snd\n                            ([\\<lambda>(f, p) (x, q).\n                                 (f x, p * q)] \\<diamondop>\n                             list1 \\<diamondop>\n                             list2)) =\n                         1", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>list1 list2 a b.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1;\n        (a, b)\n        \\<in> set ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop>\n                   list1 \\<diamondop>\n                   list2)\\<rbrakk>\n       \\<Longrightarrow> 0 < b\n 2. \\<And>list1 list2.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map snd\n                            ([\\<lambda>(f, p) (x, q).\n                                 (f x, p * q)] \\<diamondop>\n                             list1 \\<diamondop>\n                             list2)) =\n                         1", "fix xs :: \"(('a \\<Rightarrow> 'b) \\<times> real) list\" and ys :: \"('a \\<times> real) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>list1 list2 a b.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1;\n        (a, b)\n        \\<in> set ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop>\n                   list1 \\<diamondop>\n                   list2)\\<rbrakk>\n       \\<Longrightarrow> 0 < b\n 2. \\<And>list1 list2.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map snd\n                            ([\\<lambda>(f, p) (x, q).\n                                 (f x, p * q)] \\<diamondop>\n                             list1 \\<diamondop>\n                             list2)) =\n                         1", "assume xs: \"\\<forall>(x, y) \\<in> set xs. 0 < y\" \"sum_list (map snd xs) = 1\"\n    and ys: \"\\<forall>(x, y) \\<in> set ys. 0 < y\" \"sum_list (map snd ys) = 1\""], ["proof (state)\nthis:\n  \\<forall>(x, y)\\<in>set xs. 0 < y\n  sum_list (map snd xs) = 1\n  \\<forall>(x, y)\\<in>set ys. 0 < y\n  sum_list (map snd ys) = 1\n\ngoal (2 subgoals):\n 1. \\<And>list1 list2 a b.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1;\n        (a, b)\n        \\<in> set ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop>\n                   list1 \\<diamondop>\n                   list2)\\<rbrakk>\n       \\<Longrightarrow> 0 < b\n 2. \\<And>list1 list2.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map snd\n                            ([\\<lambda>(f, p) (x, q).\n                                 (f x, p * q)] \\<diamondop>\n                             list1 \\<diamondop>\n                             list2)) =\n                         1", "let ?ap = \"[\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop> xs \\<diamondop> ys\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>list1 list2 a b.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1;\n        (a, b)\n        \\<in> set ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop>\n                   list1 \\<diamondop>\n                   list2)\\<rbrakk>\n       \\<Longrightarrow> 0 < b\n 2. \\<And>list1 list2.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map snd\n                            ([\\<lambda>(f, p) (x, q).\n                                 (f x, p * q)] \\<diamondop>\n                             list1 \\<diamondop>\n                             list2)) =\n                         1", "show \"0 < b\" if \"(a, b) \\<in> set ?ap\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b", "using that xs ys"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> set ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop>\n             xs \\<diamondop>\n             ys)\n  \\<forall>(x, y)\\<in>set xs. 0 < y\n  sum_list (map snd xs) = 1\n  \\<forall>(x, y)\\<in>set ys. 0 < y\n  sum_list (map snd ys) = 1\n\ngoal (1 subgoal):\n 1. 0 < b", "by(auto intro!: mult_pos_pos)"], ["proof (state)\nthis:\n  (?a, ?b)\n  \\<in> set ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop>\n             xs \\<diamondop>\n             ys) \\<Longrightarrow>\n  0 < ?b\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>\\<forall>(uu_, y)\\<in>set list1. 0 < y;\n        sum_list (map snd list1) = 1;\n        \\<forall>(uu_, y)\\<in>set list2. 0 < y;\n        sum_list (map snd list2) = 1\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map snd\n                            ([\\<lambda>(f, p) (x, q).\n                                 (f x, p * q)] \\<diamondop>\n                             list1 \\<diamondop>\n                             list2)) =\n                         1", "show \"sum_list (map snd ?ap) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map snd\n       ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop> xs \\<diamondop>\n        ys)) =\n    1", "using xs ys"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\\<in>set xs. 0 < y\n  sum_list (map snd xs) = 1\n  \\<forall>(x, y)\\<in>set ys. 0 < y\n  sum_list (map snd ys) = 1\n\ngoal (1 subgoal):\n 1. sum_list\n     (map snd\n       ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop> xs \\<diamondop>\n        ys)) =\n    1", "by(simp add: ap_list_def List.bind_def map_concat o_def split_beta sum_list_concat_map sum_list_const_mult)"], ["proof (state)\nthis:\n  sum_list\n   (map snd\n     ([\\<lambda>(f, p) (x, q). (f x, p * q)] \\<diamondop> xs \\<diamondop>\n      ys)) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "adhoc_overloading Applicative.ap ap_pfp"], ["", "applicative pfp\n for pure: pure_pfp\n     ap: ap_pfp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x. pure_pfp f \\<diamondop> pure_pfp x = pure_pfp (f x)\n 2. \\<And>g f x.\n       pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. pure_pfp (\\<lambda>x. x) \\<diamondop> x = x\n 4. \\<And>f x.\n       f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x. pure_pfp f \\<diamondop> pure_pfp x = pure_pfp (f x)\n 2. \\<And>g f x.\n       pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. pure_pfp (\\<lambda>x. x) \\<diamondop> x = x\n 4. \\<And>f x.\n       f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f", "show \"pure_pfp (\\<lambda>x. x) \\<diamondop> x = x\" for x :: \"'a pfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure_pfp (\\<lambda>x. x) \\<diamondop> x = x", "by transfer(simp add: ap_list_def List.bind_def)"], ["proof (state)\nthis:\n  pure_pfp (\\<lambda>x. x) \\<diamondop> ?x = ?x\n\ngoal (3 subgoals):\n 1. \\<And>f x. pure_pfp f \\<diamondop> pure_pfp x = pure_pfp (f x)\n 2. \\<And>g f x.\n       pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>f x.\n       f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f", "show \"pure_pfp f \\<diamondop> pure_pfp x = pure_pfp (f x)\" for f :: \"'a \\<Rightarrow> 'b\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure_pfp f \\<diamondop> pure_pfp x = pure_pfp (f x)", "by transfer (applicative_lifting; simp)"], ["proof (state)\nthis:\n  pure_pfp ?f \\<diamondop> pure_pfp ?x = pure_pfp (?f ?x)\n\ngoal (2 subgoals):\n 1. \\<And>g f x.\n       pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 2. \\<And>f x.\n       f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f", "show \"pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop> f \\<diamondop> x = g \\<diamondop> (f \\<diamondop> x)\"\n    for g :: \"('b \\<Rightarrow> 'c) pfp\" and f :: \"('a \\<Rightarrow> 'b) pfp\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop>\n    f \\<diamondop>\n    x =\n    g \\<diamondop> (f \\<diamondop> x)", "by transfer(applicative_lifting; clarsimp)"], ["proof (state)\nthis:\n  pure_pfp (\\<lambda>g f x. g (f x)) \\<diamondop> ?g \\<diamondop>\n  ?f \\<diamondop>\n  ?x =\n  ?g \\<diamondop> (?f \\<diamondop> ?x)\n\ngoal (1 subgoal):\n 1. \\<And>f x.\n       f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f", "show \"f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f\" for f :: \"('a \\<Rightarrow> 'b) pfp\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<diamondop> pure_pfp x = pure_pfp (\\<lambda>f. f x) \\<diamondop> f", "by transfer(applicative_lifting; clarsimp)"], ["proof (state)\nthis:\n  ?f \\<diamondop> pure_pfp ?x = pure_pfp (\\<lambda>f. f ?x) \\<diamondop> ?f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}