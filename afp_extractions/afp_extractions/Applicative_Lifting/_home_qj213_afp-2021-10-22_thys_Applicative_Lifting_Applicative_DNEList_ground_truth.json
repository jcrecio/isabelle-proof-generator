{"file_name": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting/Applicative_DNEList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Applicative_Lifting", "problem_names": ["lemma bind_eq_Nil_iff [simp]: \"List.bind xs f = [] \\<longleftrightarrow> (\\<forall>x\\<in>set xs. f x = [])\"", "lemma zip_eq_Nil_iff [simp]: \"zip xs ys = [] \\<longleftrightarrow> xs = [] \\<or> ys = []\"", "lemma remdups_append1: \"remdups (remdups xs @ ys) = remdups (xs @ ys)\"", "lemma remdups_append2: \"remdups (xs @ remdups ys) = remdups (xs @ ys)\"", "lemma remdups_append1_drop: \"set xs \\<subseteq> set ys \\<Longrightarrow> remdups (xs @ ys) = remdups ys\"", "lemma remdups_concat_map: \"remdups (concat (map remdups xss)) = remdups (concat xss)\"", "lemma remdups_concat_remdups: \"remdups (concat (remdups xss)) = remdups (concat xss)\"", "lemma remdups_replicate: \"remdups (replicate n x) = (if n = 0 then [] else [x])\"", "lemma dnelist_subtype_dlist:\n  \"type_definition (\\<lambda>x. Dlist (list_of_dnelist x)) (\\<lambda>x. Abs_dnelist (list_of_dlist x)) {xs. xs \\<noteq> Dlist.empty}\"", "lemma map_def: \"Applicative_DNEList.map = map_fun id (map_fun list_of_dnelist Abs_dnelist) (\\<lambda>f xs. remdups (list.map f xs))\"", "lemma map_transfer [transfer_rule]:\n  \"rel_fun (=) (rel_fun (pcr_dnelist (=)) (pcr_dnelist (=))) (\\<lambda>f xs. remdups (map f xs)) Applicative_DNEList.map\"", "lemma ap_pure_list [simp]: \"ap_list [f] xs = map f xs\"", "lemma ap_pure_dlist: \"pure_dnelist f \\<diamondop> x = Applicative_DNEList.map f x\"", "lemma \"pure_dnelist (\\<lambda>f x y. f y x) \\<diamondop> pure_dnelist ((*)) \\<diamondop> x \\<diamondop> y \\<noteq> pure_dnelist ((*)) \\<diamondop> y \\<diamondop> x\""], "translations": [["", "lemma bind_eq_Nil_iff [simp]: \"List.bind xs f = [] \\<longleftrightarrow> (\\<forall>x\\<in>set xs. f x = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (List.bind xs f = []) = (\\<forall>x\\<in>set xs. f x = [])", "by(simp add: List.bind_def)"], ["", "lemma zip_eq_Nil_iff [simp]: \"zip xs ys = [] \\<longleftrightarrow> xs = [] \\<or> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zip xs ys = []) = (xs = [] \\<or> ys = [])", "by(cases xs ys rule: list.exhaust[case_product list.exhaust]) simp_all"], ["", "lemma remdups_append1: \"remdups (remdups xs @ ys) = remdups (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (remdups xs @ ys) = remdups (xs @ ys)", "by(induction xs) simp_all"], ["", "lemma remdups_append2: \"remdups (xs @ remdups ys) = remdups (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (xs @ remdups ys) = remdups (xs @ ys)", "by(induction xs) simp_all"], ["", "lemma remdups_append1_drop: \"set xs \\<subseteq> set ys \\<Longrightarrow> remdups (xs @ ys) = remdups ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ys \\<Longrightarrow>\n    remdups (xs @ ys) = remdups ys", "by(induction xs) auto"], ["", "lemma remdups_concat_map: \"remdups (concat (map remdups xss)) = remdups (concat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (concat (map remdups xss)) = remdups (concat xss)", "by(induction xss)(simp_all add: remdups_append1, metis remdups_append2)"], ["", "lemma remdups_concat_remdups: \"remdups (concat (remdups xss)) = remdups (concat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (concat (remdups xss)) = remdups (concat xss)", "apply(induction xss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. remdups (concat (remdups [])) = remdups (concat [])\n 2. \\<And>a xss.\n       remdups (concat (remdups xss)) =\n       remdups (concat xss) \\<Longrightarrow>\n       remdups (concat (remdups (a # xss))) = remdups (concat (a # xss))", "apply(auto simp add: remdups_append1_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xss.\n       \\<lbrakk>remdups (concat (remdups xss)) = remdups (concat xss);\n        a \\<in> set xss\\<rbrakk>\n       \\<Longrightarrow> remdups (concat xss) = remdups (a @ concat xss)\n 2. \\<And>a xss.\n       \\<lbrakk>remdups (concat (remdups xss)) = remdups (concat xss);\n        a \\<notin> set xss\\<rbrakk>\n       \\<Longrightarrow> remdups (a @ concat (remdups xss)) =\n                         remdups (a @ concat xss)", "apply(subst remdups_append1_drop; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>remdups (concat (remdups xss)) = remdups (concat xss);\n        a \\<notin> set xss\\<rbrakk>\n       \\<Longrightarrow> remdups (a @ concat (remdups xss)) =\n                         remdups (a @ concat xss)", "apply(metis remdups_append2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma remdups_replicate: \"remdups (replicate n x) = (if n = 0 then [] else [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (replicate n x) = (if n = 0 then [] else [x])", "by(induction n) simp_all"], ["", "typedef 'a dnelist = \"{xs::'a list. distinct xs \\<and> xs \\<noteq> []}\"\n  morphisms list_of_dnelist Abs_dnelist"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {xs. distinct xs \\<and> xs \\<noteq> []}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {xs. distinct xs \\<and> xs \\<noteq> []}", "show \"[x] \\<in> ?dnelist\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. [x] \\<in> {xs. distinct xs \\<and> xs \\<noteq> []}", "by simp"], ["proof (state)\nthis:\n  [?x] \\<in> {xs. distinct xs \\<and> xs \\<noteq> []}\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_dnelist"], ["", "lemma dnelist_subtype_dlist:\n  \"type_definition (\\<lambda>x. Dlist (list_of_dnelist x)) (\\<lambda>x. Abs_dnelist (list_of_dlist x)) {xs. xs \\<noteq> Dlist.empty}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition (\\<lambda>x. Dlist (list_of_dnelist x))\n     (\\<lambda>x. Abs_dnelist (list_of_dlist x))\n     {xs. xs \\<noteq> Dlist.empty}", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. Dlist (list_of_dnelist x) \\<in> {xs. xs \\<noteq> Dlist.empty}\n 2. \\<And>x. Abs_dnelist (list_of_dlist (Dlist (list_of_dnelist x))) = x\n 3. \\<And>y.\n       y \\<in> {xs. xs \\<noteq> Dlist.empty} \\<Longrightarrow>\n       Dlist (list_of_dnelist (Abs_dnelist (list_of_dlist y))) = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Dlist (list_of_dnelist x_) \\<in> {xs. xs \\<noteq> Dlist.empty}", "by(transfer; auto simp add: dlist_eq_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. Abs_dnelist (list_of_dlist (Dlist (list_of_dnelist x))) = x\n 2. \\<And>y.\n       y \\<in> {xs. xs \\<noteq> Dlist.empty} \\<Longrightarrow>\n       Dlist (list_of_dnelist (Abs_dnelist (list_of_dlist y))) = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dnelist (list_of_dlist (Dlist (list_of_dnelist x_))) = x_", "by(simp add: distinct_remdups_id dnelist.list_of_dnelist[simplified] list_of_dnelist_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {xs. xs \\<noteq> Dlist.empty} \\<Longrightarrow>\n       Dlist (list_of_dnelist (Abs_dnelist (list_of_dlist y))) = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<in> {xs. xs \\<noteq> Dlist.empty} \\<Longrightarrow>\n    Dlist (list_of_dnelist (Abs_dnelist (list_of_dlist y_))) = y_", "by(simp add: dlist_eq_iff Abs_dnelist_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_bnf (no_warn_transfer, no_warn_wits) 'a dnelist via dnelist_subtype_dlist for map: map"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       x \\<in> {xs. xs \\<noteq> Dlist.empty} \\<Longrightarrow>\n       map_dlist f x \\<in> {xs. xs \\<noteq> Dlist.empty}\n 2. \\<And>z.\n       \\<lbrakk>map_dlist fst z \\<in> {xs. xs \\<noteq> Dlist.empty};\n        map_dlist snd z \\<in> {xs. xs \\<noteq> Dlist.empty}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z'\\<in>{xs. xs \\<noteq> Dlist.empty}.\n                            set_dlist z' \\<subseteq> set_dlist z \\<and>\n                            map_dlist fst z' = map_dlist fst z \\<and>\n                            map_dlist snd z' = map_dlist snd z", "by(auto simp: dlist_eq_iff)"], ["", "hide_const (open) map"], ["", "context begin"], ["", "qualified"], ["", "lemma map_def: \"Applicative_DNEList.map = map_fun id (map_fun list_of_dnelist Abs_dnelist) (\\<lambda>f xs. remdups (list.map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dnelist.map =\n    map_fun id (map_fun list_of_dnelist Abs_dnelist)\n     (\\<lambda>f xs. remdups (map f xs))", "unfolding map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        (\\<lambda>x. Abs_dnelist (list_of_dlist x)) \\<circ>\n        map_dlist f \\<circ>\n        (\\<lambda>x. Dlist (list_of_dnelist x))) =\n    map_fun id (map_fun list_of_dnelist Abs_dnelist)\n     (\\<lambda>f xs. remdups (map f xs))", "by(simp add: fun_eq_iff distinct_remdups_id list_of_dnelist[simplified])"], ["", "qualified"], ["", "lemma map_transfer [transfer_rule]:\n  \"rel_fun (=) (rel_fun (pcr_dnelist (=)) (pcr_dnelist (=))) (\\<lambda>f xs. remdups (map f xs)) Applicative_DNEList.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) (rel_fun (pcr_dnelist (=)) (pcr_dnelist (=)))\n     (\\<lambda>f xs. remdups (map f xs)) dnelist.map", "by(simp add: map_def rel_fun_def dnelist.pcr_cr_eq cr_dnelist_def list_of_dnelist[simplified] Abs_dnelist_inverse)"], ["", "qualified"], ["", "lift_definition single :: \"'a \\<Rightarrow> 'a dnelist\" is \"\\<lambda>x. [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. distinct [a] \\<and> [a] \\<noteq> []", "by simp"], ["", "qualified"], ["", "lift_definition insert :: \"'a \\<Rightarrow> 'a dnelist \\<Rightarrow> 'a dnelist\" is \"\\<lambda>x xs. if x \\<in> set xs then xs else x # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       distinct list \\<and> list \\<noteq> [] \\<Longrightarrow>\n       distinct (if a \\<in> set list then list else a # list) \\<and>\n       (if a \\<in> set list then list else a # list) \\<noteq> []", "by auto"], ["", "qualified"], ["", "lift_definition append :: \"'a dnelist \\<Rightarrow> 'a dnelist \\<Rightarrow> 'a dnelist\" is \"\\<lambda>xs ys. remdups (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>distinct list1 \\<and> list1 \\<noteq> [];\n        distinct list2 \\<and> list2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> distinct (remdups (list1 @ list2)) \\<and>\n                         remdups (list1 @ list2) \\<noteq> []", "by auto"], ["", "qualified"], ["", "lift_definition bind :: \"'a dnelist \\<Rightarrow> ('a \\<Rightarrow> 'b dnelist) \\<Rightarrow> 'b dnelist\" is \"\\<lambda>xs f. remdups (List.bind xs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list fun.\n       \\<lbrakk>distinct list \\<and> list \\<noteq> [];\n        \\<And>x. distinct (fun x) \\<and> fun x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> distinct (remdups (List.bind list fun)) \\<and>\n                         remdups (List.bind list fun) \\<noteq> []", "by auto"], ["", "abbreviation (input) pure_dnelist :: \"'a \\<Rightarrow> 'a dnelist\"\nwhere \"pure_dnelist \\<equiv> single\""], ["", "end"], ["", "lift_definition ap_dnelist :: \"('a \\<Rightarrow> 'b) dnelist \\<Rightarrow> 'a dnelist \\<Rightarrow> 'b dnelist\"\nis \"\\<lambda>f x. remdups (ap_list f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>distinct list1 \\<and> list1 \\<noteq> [];\n        distinct list2 \\<and> list2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (remdups (Applicative.ap list1 list2)) \\<and>\n                         remdups (Applicative.ap list1 list2) \\<noteq> []", "by(auto simp add: ap_list_def)"], ["", "adhoc_overloading Applicative.ap ap_dnelist"], ["", "lemma ap_pure_list [simp]: \"ap_list [f] xs = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative.ap [f] xs = map f xs", "by(simp add: ap_list_def List.bind_def)"], ["", "context includes applicative_syntax\nbegin"], ["", "lemma ap_pure_dlist: \"pure_dnelist f \\<diamondop> x = Applicative_DNEList.map f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative_DNEList.single f \\<diamondop> x = dnelist.map f x", "by transfer simp"], ["", "applicative dnelist (K)\nfor pure: pure_dnelist\n    ap: ap_dnelist"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f x.\n       Applicative_DNEList.single f \\<diamondop>\n       Applicative_DNEList.single x =\n       Applicative_DNEList.single (f x)\n 2. \\<And>g f x.\n       Applicative_DNEList.single (\\<lambda>g f x. g (f x)) \\<diamondop>\n       g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. Applicative_DNEList.single (\\<lambda>x. x) \\<diamondop> x = x\n 4. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x\n 5. \\<And>f x.\n       f \\<diamondop> Applicative_DNEList.single x =\n       Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f x.\n       Applicative_DNEList.single f \\<diamondop>\n       Applicative_DNEList.single x =\n       Applicative_DNEList.single (f x)\n 2. \\<And>g f x.\n       Applicative_DNEList.single (\\<lambda>g f x. g (f x)) \\<diamondop>\n       g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x. Applicative_DNEList.single (\\<lambda>x. x) \\<diamondop> x = x\n 4. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x\n 5. \\<And>f x.\n       f \\<diamondop> Applicative_DNEList.single x =\n       Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "show \"pure_dnelist (\\<lambda>x. x) \\<diamondop> x = x\" for x :: \"'a dnelist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative_DNEList.single (\\<lambda>x. x) \\<diamondop> x = x", "by transfer simp"], ["proof (state)\nthis:\n  Applicative_DNEList.single (\\<lambda>x. x) \\<diamondop> ?x = ?x\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       Applicative_DNEList.single f \\<diamondop>\n       Applicative_DNEList.single x =\n       Applicative_DNEList.single (f x)\n 2. \\<And>g f x.\n       Applicative_DNEList.single (\\<lambda>g f x. g (f x)) \\<diamondop>\n       g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x\n 4. \\<And>f x.\n       f \\<diamondop> Applicative_DNEList.single x =\n       Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "have *: \"remdups (remdups (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop> f) \\<diamondop> x) = remdups (g \\<diamondop> remdups (f \\<diamondop> x))\"\n    (is \"?lhs = ?rhs\") for g :: \"('b \\<Rightarrow> 'c) list\" and f :: \"('a \\<Rightarrow> 'b) list\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "have \"?lhs = remdups (concat (map (\\<lambda>f. map f x) (remdups (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (remdups\n           (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))))", "unfolding ap_list_def List.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map (\\<lambda>f. concat (map (\\<lambda>x. [f x]) x))\n         (remdups\n           (concat\n             (map (\\<lambda>fa. concat (map (\\<lambda>x. [fa x]) f))\n               (remdups\n                 (concat\n                   (map (\\<lambda>f. concat (map (\\<lambda>x. [f x]) g))\n                     [\\<lambda>g f x. g (f x)])))))))) =\n    remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (remdups\n           (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))))", "by(subst (2) remdups_concat_remdups[symmetric])(simp add: o_def remdups_map_remdups remdups_concat_remdups)"], ["proof (state)\nthis:\n  remdups\n   (remdups\n     (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n      f) \\<diamondop>\n    x) =\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (remdups\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "also"], ["proof (state)\nthis:\n  remdups\n   (remdups\n     (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n      f) \\<diamondop>\n    x) =\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (remdups\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "have \"\\<dots> =  remdups (concat (map (\\<lambda>f. map f x) (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (remdups\n           (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))) =\n    remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))", "by(subst (1) remdups_concat_remdups[symmetric])(simp add: remdups_map_remdups remdups_concat_remdups)"], ["proof (state)\nthis:\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (remdups\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))) =\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "also"], ["proof (state)\nthis:\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (remdups\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))) =\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g))))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "have \"\\<dots> = remdups (concat (map remdups (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f))) g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))) =\n    remdups\n     (concat\n       (map remdups\n         (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f)))\n           g)))", "using list.pure_B_conv[of g f x]"], ["proof (prove)\nusing this:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop> x =\n  g \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))) =\n    remdups\n     (concat\n       (map remdups\n         (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f)))\n           g)))", "unfolding remdups_concat_map"], ["proof (prove)\nusing this:\n  [\\<lambda>g f x. g (f x)] \\<diamondop> g \\<diamondop> f \\<diamondop> x =\n  g \\<diamondop> (f \\<diamondop> x)\n\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map (\\<lambda>f. map f x)\n         (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))) =\n    remdups\n     (concat\n       (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f))) g))", "by(simp add: ap_list_def List.bind_def o_def)"], ["proof (state)\nthis:\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))) =\n  remdups\n   (concat\n     (map remdups\n       (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f))) g)))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "also"], ["proof (state)\nthis:\n  remdups\n   (concat\n     (map (\\<lambda>f. map f x)\n       (concat (map (\\<lambda>x. map (\\<lambda>f y. x (f y)) f) g)))) =\n  remdups\n   (concat\n     (map remdups\n       (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f))) g)))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map remdups\n         (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f)))\n           g))) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "unfolding ap_list_def List.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (concat\n       (map remdups\n         (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f)))\n           g))) =\n    remdups\n     (concat\n       (map (\\<lambda>fa.\n                concat\n                 (map (\\<lambda>x. [fa x])\n                   (remdups\n                     (concat\n                       (map (\\<lambda>f. concat (map (\\<lambda>x. [f x]) x))\n                         f)))))\n         g))", "by(subst (2) remdups_concat_map[symmetric])(simp add: o_def remdups_map_remdups)"], ["proof (state)\nthis:\n  remdups\n   (concat\n     (map remdups\n       (map (\\<lambda>g. map g (concat (map (\\<lambda>f. map f x) f)))\n         g))) =\n  remdups (g \\<diamondop> remdups (f \\<diamondop> x))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "finally"], ["proof (chain)\npicking this:\n  remdups\n   (remdups\n     (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n      f) \\<diamondop>\n    x) =\n  remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "show ?thesis"], ["proof (prove)\nusing this:\n  remdups\n   (remdups\n     (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n      f) \\<diamondop>\n    x) =\n  remdups (g \\<diamondop> remdups (f \\<diamondop> x))\n\ngoal (1 subgoal):\n 1. remdups\n     (remdups\n       (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n        f) \\<diamondop>\n      x) =\n    remdups (g \\<diamondop> remdups (f \\<diamondop> x))", "."], ["proof (state)\nthis:\n  remdups\n   (remdups\n     (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> g) \\<diamondop>\n      f) \\<diamondop>\n    x) =\n  remdups (g \\<diamondop> remdups (f \\<diamondop> x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  remdups\n   (remdups\n     (remdups ([\\<lambda>g f x. g (f x)] \\<diamondop> ?g) \\<diamondop>\n      ?f) \\<diamondop>\n    ?x) =\n  remdups (?g \\<diamondop> remdups (?f \\<diamondop> ?x))\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       Applicative_DNEList.single f \\<diamondop>\n       Applicative_DNEList.single x =\n       Applicative_DNEList.single (f x)\n 2. \\<And>g f x.\n       Applicative_DNEList.single (\\<lambda>g f x. g (f x)) \\<diamondop>\n       g \\<diamondop>\n       f \\<diamondop>\n       x =\n       g \\<diamondop> (f \\<diamondop> x)\n 3. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x\n 4. \\<And>f x.\n       f \\<diamondop> Applicative_DNEList.single x =\n       Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "show \"pure_dnelist (\\<lambda>g f x. g (f x)) \\<diamondop> g \\<diamondop> f \\<diamondop> x = g \\<diamondop> (f \\<diamondop> x)\"\n    for g :: \"('b \\<Rightarrow> 'c) dnelist\" and f :: \"('a \\<Rightarrow> 'b) dnelist\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative_DNEList.single (\\<lambda>g f x. g (f x)) \\<diamondop>\n    g \\<diamondop>\n    f \\<diamondop>\n    x =\n    g \\<diamondop> (f \\<diamondop> x)", "by transfer(rule *)"], ["proof (state)\nthis:\n  Applicative_DNEList.single (\\<lambda>g f x. g (f x)) \\<diamondop>\n  ?g \\<diamondop>\n  ?f \\<diamondop>\n  ?x =\n  ?g \\<diamondop> (?f \\<diamondop> ?x)\n\ngoal (3 subgoals):\n 1. \\<And>f x.\n       Applicative_DNEList.single f \\<diamondop>\n       Applicative_DNEList.single x =\n       Applicative_DNEList.single (f x)\n 2. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x\n 3. \\<And>f x.\n       f \\<diamondop> Applicative_DNEList.single x =\n       Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "show \"pure_dnelist f \\<diamondop> pure_dnelist x = pure_dnelist (f x)\" for f :: \"'a \\<Rightarrow> 'b\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative_DNEList.single f \\<diamondop> Applicative_DNEList.single x =\n    Applicative_DNEList.single (f x)", "by transfer simp"], ["proof (state)\nthis:\n  Applicative_DNEList.single ?f \\<diamondop> Applicative_DNEList.single ?x =\n  Applicative_DNEList.single (?f ?x)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x\n 2. \\<And>f x.\n       f \\<diamondop> Applicative_DNEList.single x =\n       Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "show \"f \\<diamondop> pure_dnelist x = pure_dnelist (\\<lambda>f. f x) \\<diamondop> f\" for f :: \"('a \\<Rightarrow> 'b) dnelist\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<diamondop> Applicative_DNEList.single x =\n    Applicative_DNEList.single (\\<lambda>f. f x) \\<diamondop> f", "by transfer(simp add: list.interchange)"], ["proof (state)\nthis:\n  ?f \\<diamondop> Applicative_DNEList.single ?x =\n  Applicative_DNEList.single (\\<lambda>f. f ?x) \\<diamondop> ?f\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x", "have *: \"remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x\" if x: \"distinct x\" and y: \"distinct y\" \"y \\<noteq> []\"\n    for x :: \"'b list\" and y :: \"'a list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "have \"remdups (map (\\<lambda>(x :: 'b) (y :: 'a). x) x) = map (\\<lambda>(x :: 'b) (y :: 'a). x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (map (\\<lambda>x y. x) x) = map (\\<lambda>x y. x) x", "using that"], ["proof (prove)\nusing this:\n  distinct x\n  distinct y\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. remdups (map (\\<lambda>x y. x) x) = map (\\<lambda>x y. x) x", "by(simp add: distinct_map inj_on_def fun_eq_iff)"], ["proof (state)\nthis:\n  remdups (map (\\<lambda>x y. x) x) = map (\\<lambda>x y. x) x\n\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "hence \"remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x)))\""], ["proof (prove)\nusing this:\n  remdups (map (\\<lambda>x y. x) x) = map (\\<lambda>x y. x) x\n\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) =\n    remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x)))", "by(simp add: ap_list_def List.bind_def del: remdups_id_iff_distinct)"], ["proof (state)\nthis:\n  remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) =\n  remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x)))\n\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "also"], ["proof (state)\nthis:\n  remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) =\n  remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x)))\n\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x))) =\n    x", "using that"], ["proof (prove)\nusing this:\n  distinct x\n  distinct y\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x))) =\n    x", "by(simp add: o_def map_replicate_const)(subst remdups_concat_map[symmetric], simp add: o_def remdups_replicate)"], ["proof (state)\nthis:\n  remdups (concat (map (\\<lambda>f. map f y) (map (\\<lambda>x y. x) x))) = x\n\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "finally"], ["proof (chain)\npicking this:\n  remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x\n\ngoal (1 subgoal):\n 1. remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x", "."], ["proof (state)\nthis:\n  remdups (remdups ([\\<lambda>x y. x] \\<diamondop> x) \\<diamondop> y) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>distinct ?x; distinct ?y; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> remdups\n                     (remdups\n                       ([\\<lambda>x y. x] \\<diamondop> ?x) \\<diamondop>\n                      ?y) =\n                    ?x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop>\n       x \\<diamondop>\n       y =\n       x", "show \"pure_dnelist (\\<lambda>x y. x) \\<diamondop> x \\<diamondop> y = x\"\n    for x :: \"'b dnelist\" and y :: \"'a dnelist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop> x \\<diamondop>\n    y =\n    x", "by transfer(rule *; simp)"], ["proof (state)\nthis:\n  Applicative_DNEList.single (\\<lambda>x y. x) \\<diamondop> ?x \\<diamondop>\n  ?y =\n  ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{typ \"_ dnelist\"} does not have combinator C, so it cannot have W either.\\<close>"], ["", "context begin"], ["", "private"], ["", "lift_definition x :: \"int dnelist\" is \"[2,3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [2, 3] \\<and> [2, 3] \\<noteq> []", "by simp"], ["", "private"], ["", "lift_definition y :: \"int dnelist\" is \"[5,7]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [5, 7] \\<and> [5, 7] \\<noteq> []", "by simp"], ["", "private"], ["", "lemma \"pure_dnelist (\\<lambda>f x y. f y x) \\<diamondop> pure_dnelist ((*)) \\<diamondop> x \\<diamondop> y \\<noteq> pure_dnelist ((*)) \\<diamondop> y \\<diamondop> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Applicative_DNEList.single (\\<lambda>f x y. f y x) \\<diamondop>\n    Applicative_DNEList.single (*) \\<diamondop>\n    x \\<diamondop>\n    y \\<noteq>\n    Applicative_DNEList.single (*) \\<diamondop> y \\<diamondop> x", "by transfer(simp add: ap_list_def fun_eq_iff)"], ["", "end"], ["", "end"], ["", "end"]]}