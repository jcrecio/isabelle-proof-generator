{"file_name": "/home/qj213/afp-2021-10-22/thys/Koenigsberg_Friendship/MoreGraph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Koenigsberg_Friendship", "problem_names": ["lemma del_undirected: \"del_unEdge v e v' g = delete_edge v' e v (delete_edge v e v' g)\"", "lemma delete_edge_sym: \"del_unEdge v e v' g = del_unEdge v' e v g\"", "lemma del_unEdge_valid[simp]: assumes \"valid_unMultigraph g\" \n    shows \"valid_unMultigraph (del_unEdge v e v' g)\"", "lemma set_compre_diff:\"{x \\<in> A - B. P x}={x \\<in> A. P x} - {x \\<in> B . P x}\"", "lemma set_compre_subset: \"B \\<subseteq> A \\<Longrightarrow> {x \\<in> B. P x} \\<subseteq> {x \\<in> A. P x}\"", "lemma del_edge_undirected_degree_plus: \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g  \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1=degree v g\"", "lemma del_edge_undirected_degree_plus': \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g \\<Longrightarrow> degree v' (del_unEdge v e v' g) + 1=degree v' g\"", "lemma del_edge_undirected_degree_minus[simp]: \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g \\<Longrightarrow> degree v (del_unEdge v e v' g) =degree v g- (1::nat)\"", "lemma del_edge_undirected_degree_minus'[simp]: \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g \\<Longrightarrow> degree v' (del_unEdge v e v' g) =degree v' g- (1::nat)\"", "lemma del_unEdge_com: \"del_unEdge v w v' (del_unEdge n e n' g)\n          = del_unEdge n e n' (del_unEdge v w v' g)\"", "lemma rem_unPath_com: \"rem_unPath ps (del_unEdge v w v' g) \n            = del_unEdge v w v' (rem_unPath ps g)\"", "lemma rem_unPath_valid[intro]: \n  \"valid_unMultigraph g \\<Longrightarrow> valid_unMultigraph (rem_unPath ps g)\"", "lemma (in valid_unMultigraph) degree_frame:\n    assumes \"finite (edges G)\"  \"x \\<notin> {v, v'}\" \n    shows \"degree x (del_unEdge v w v' G) = degree x G\" (is \"?L=?R\")", "lemma [simp]: \"rev_path [] = []\"", "lemma rev_path_append[simp]: \"rev_path (xs@ys) = (rev_path ys) @ (rev_path xs)\"", "lemma rev_path_double[simp]: \"rev_path(rev_path xs)=xs\"", "lemma del_UnEdge_node[simp]: \"v\\<in>nodes (del_unEdge u e u' G) \\<longleftrightarrow> v\\<in>nodes G  \"", "lemma [intro!]: \"finite (edges G) \\<Longrightarrow> finite (edges (del_unEdge u e u' G))\"", "lemma [intro!]: \"finite (nodes G) \\<Longrightarrow> finite (nodes (del_unEdge u e u' G))\"", "lemma [intro!]: \"finite (edges G) \\<Longrightarrow> finite (edges (rem_unPath ps G))\"", "lemma del_UnEdge_frame[intro]: \n  \"x\\<in>edges g \\<Longrightarrow> x\\<noteq>(v,e,v') \\<Longrightarrow>x\\<noteq>(v',e,v) \\<Longrightarrow> x\\<in>edges (del_unEdge v e v' g)\"", "lemma [intro!]: \"finite (nodes G) \\<Longrightarrow> finite (odd_nodes_set G)\"", "lemma [simp]: \"nodes (del_unEdge u e u' G)=nodes G\"", "lemma [simp]: \"nodes (rem_unPath ps G) = nodes G\"", "lemma [intro!]: \"finite (nodes G) \\<Longrightarrow> finite (nodes (rem_unPath ps G))\"", "lemma in_set_rev_path[simp]: \"(v',w,v )\\<in>set (rev_path ps) \\<longleftrightarrow> (v,w,v')\\<in>set ps \"", "lemma rem_unPath_edges: \n    \"edges(rem_unPath ps G) = edges G - (set ps \\<union> set (rev_path ps))\"", "lemma rem_unPath_graph [simp]: \n    \"rem_unPath (rev_path ps) G=rem_unPath ps G\"", "lemma distinct_rev_path[simp]: \"distinct (rev_path ps) \\<longleftrightarrow>distinct ps\"", "lemma (in valid_unMultigraph) is_path_rev: \"is_path v' (rev_path ps) v \\<longleftrightarrow> is_path v ps v'\"", "lemma (in valid_unMultigraph) singleton_distinct_path [intro]:\n   \"(v,w,v')\\<in>E \\<Longrightarrow> is_trail v [(v,w,v')] v'\"", "lemma (in valid_unMultigraph) is_trail_path: \n  \"is_trail v ps v' \\<longleftrightarrow> is_path v ps v' \\<and> distinct ps \\<and> (set ps \\<inter> set (rev_path ps) = {})\"", "lemma  (in valid_unMultigraph) is_trail_rev: \n    \"is_trail v' (rev_path ps) v \\<longleftrightarrow> is_trail v ps v' \"", "lemma (in valid_unMultigraph) is_trail_intro[intro]:\n  \"is_trail v' ps v \\<Longrightarrow> is_path v' ps v\"", "lemma (in valid_unMultigraph) is_trail_split:\n      \"is_trail v (p1@p2) v' \\<Longrightarrow> (\\<exists>u. is_trail v p1 u \\<and> is_trail u p2 v')\"", "lemma (in valid_unMultigraph) is_trail_split':\"is_trail v (p1@(u,w,u')#p2) v' \n    \\<Longrightarrow> is_trail v p1 u \\<and> (u,w,u')\\<in>E \\<and> is_trail u' p2 v'\"", "lemma (in valid_unMultigraph) distinct_elim[simp]:\n  assumes \"is_trail v ((v1,w,v2)#ps) v'\" \n  shows \"(v1,w,v2)\\<in>edges(rem_unPath ps G) \\<longleftrightarrow> (v1,w,v2)\\<in>E\"", "lemma distinct_path_subset:\n  assumes \"valid_unMultigraph G1\" \"valid_unMultigraph G2\" \"edges G1 \\<subseteq>edges G2\" \"nodes G1 \\<subseteq>nodes G2\"\n  assumes distinct_G1:\"valid_unMultigraph.is_trail G1 v ps v'\"\n  shows \"valid_unMultigraph.is_trail G2 v ps v'\"", "lemma (in valid_unMultigraph) distinct_path_intro':\n  assumes \"valid_unMultigraph.is_trail (rem_unPath p G) v ps v'\"\n  shows \"is_trail  v ps v'\"", "lemma (in valid_unMultigraph) distinct_path_intro:\n  assumes \"valid_unMultigraph.is_trail (del_unEdge x1 x2 x3 G) v ps v'\"\n  shows \"is_trail  v ps v'\"", "lemma (in valid_unMultigraph) distinct_elim_rev[simp]:\n  assumes \"is_trail v ((v1,w,v2)#ps) v'\" \n  shows \"(v2,w,v1)\\<in>edges(rem_unPath ps G) \\<longleftrightarrow> (v2,w,v1)\\<in>E\"", "lemma (in valid_unMultigraph) del_UnEdge_even:\n  assumes \"(v,w,v') \\<in> E\" \"finite E\"\n  shows \"v\\<in>odd_nodes_set(del_unEdge v w v' G) \\<longleftrightarrow> even (degree v G)\"", "lemma (in valid_unMultigraph) del_UnEdge_even':\n  assumes \"(v,w,v') \\<in> E\" \"finite E\"\n  shows \"v'\\<in>odd_nodes_set(del_unEdge v w v' G) \\<longleftrightarrow> even (degree v' G)\"", "lemma del_UnEdge_even_even:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"even (degree v G)\" \"even (degree v' G)\"\n    shows \"num_of_odd_nodes(del_unEdge v w v' G)=num_of_odd_nodes G + 2\"", "lemma del_UnEdge_even_odd:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"even (degree v G)\" \"odd (degree v' G)\"\n    shows \"num_of_odd_nodes(del_unEdge v w v' G)=num_of_odd_nodes G\"", "lemma del_UnEdge_odd_even:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"odd (degree v G)\" \"even (degree v' G)\"\n    shows \"num_of_odd_nodes(del_unEdge v w v' G)=num_of_odd_nodes G\"", "lemma del_UnEdge_odd_odd:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"odd (degree v G)\" \"odd (degree v' G)\"\n    shows \"num_of_odd_nodes G=num_of_odd_nodes(del_unEdge v w v' G)+2\"", "lemma (in valid_unMultigraph) rem_UnPath_parity_v': \n  assumes \"finite E\"  \"is_trail v ps v'\" \n  shows \"v\\<noteq>v' \\<longleftrightarrow> (odd (degree v' (rem_unPath ps G)) = even(degree v' G))\"", "lemma (in valid_unMultigraph) rem_UnPath_parity_v: \n  assumes \"finite E\"  \"is_trail v ps v'\" \n  shows \"v\\<noteq>v' \\<longleftrightarrow> (odd (degree v (rem_unPath ps G)) = even(degree v G))\"", "lemma (in valid_unMultigraph) rem_UnPath_parity_others:\n  assumes \"finite E\"  \"is_trail v ps v'\" \"n\\<notin>{v,v'}\"\n  shows \" even (degree n (rem_unPath ps G)) = even(degree n G)\"", "lemma (in valid_unMultigraph) rem_UnPath_even:\n  assumes \"finite E\" \"finite V\" \"is_trail v ps v'\" \n  assumes parity_assms:  \"even (degree v' G)\"\n  shows \"num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G \n          + (if even (degree v G)\\<and> v\\<noteq>v' then 2 else 0)\"", "lemma (in valid_unMultigraph) rem_UnPath_odd:\n  assumes \"finite E\" \"finite V\" \"is_trail v ps v'\" \n  assumes parity_assms:  \"odd (degree v' G)\"\n  shows \"num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G \n          + (if odd (degree v G)\\<and> v\\<noteq>v' then -2 else 0)\"", "lemma (in valid_unMultigraph) rem_UnPath_cycle:\n  assumes \"finite E\" \"finite V\" \"is_trail v ps v'\" \"v=v'\"\n  shows \"num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\" (is \"?L=?R\")", "lemma (in valid_unMultigraph) \"connected \\<Longrightarrow> \\<forall>v\\<in>V. \\<forall>v'\\<in>V. v\\<noteq>v'\\<longrightarrow>(\\<exists>ps. is_trail v ps v')\"", "lemma (in valid_unMultigraph) no_rep_length: \"is_trail v ps v'\\<Longrightarrow>length ps=card(set ps)\"", "lemma (in valid_unMultigraph) path_in_edges:\"is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E\"", "lemma (in valid_unMultigraph) trail_bound: \n    assumes \"finite E\" \" is_trail v ps v'\"\n    shows \"length ps \\<le>card E\"", "lemma (in valid_unMultigraph) longest_path:\n  assumes \"finite E\" \"n \\<in> V\"\n  shows \"\\<exists>v. \\<exists>max_path. is_trail v max_path n \\<and> \n        (\\<forall>v'. \\<forall>e\\<in>E. \\<not>is_trail v' (e#max_path) n)\"", "lemma even_card':\n  assumes \"even(card A)\" \"x\\<in>A\"\n  shows \"\\<exists>y\\<in>A. y\\<noteq>x\"", "lemma odd_card: \n  assumes \"finite A\" \"odd(card A)\"\n  shows \"\\<exists>x. x\\<in>A\"", "lemma (in valid_unMultigraph) extend_distinct_path: \n  assumes \"finite E\"  \"is_trail v' ps v\" \n  assumes parity_assms:\"(even (degree v' G)\\<and>v'\\<noteq>v)\\<or>(odd (degree v' G)\\<and>v'=v)\"\n  shows \"\\<exists>e v1. is_trail v1 (e#ps) v\"", "lemma (in valid_unMultigraph) del_unEdge_connectivity:\n  assumes \"connected\" \"\\<exists>ps. valid_graph.is_path (del_unEdge v e v' G) v ps v'\"\n  shows \"valid_unMultigraph.connected (del_unEdge v e v' G)\"", "lemma (in valid_unMultigraph) path_between_odds:\n  assumes \"odd(degree v G)\" \"odd(degree v' G)\" \"finite E\"  \"v\\<noteq>v'\" \"num_of_odd_nodes G=2\"\n  shows \"\\<exists>ps. is_trail v ps v'\"", "lemma (in valid_unMultigraph) del_unEdge_even_connectivity:\n  assumes \"finite E\" \"finite V\" \"connected\" \"\\<forall>n\\<in>V. even(degree n G)\" \"(v,e,v')\\<in>E\"\n  shows \"valid_unMultigraph.connected (del_unEdge v e v' G)\"", "lemma (in valid_graph) path_end:\"ps\\<noteq>[] \\<Longrightarrow> is_path v ps v' \\<Longrightarrow> v'=snd (snd(last ps))\"", "lemma (in valid_unMultigraph) connectivity_split:\n  assumes \"connected\" \"\\<not>valid_unMultigraph.connected (del_unEdge v w v' G)\" \n          \"(v,w,v')\\<in>E\"\n  obtains G1 G2 where\n         \"nodes G1={n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\"\n         and \"edges G1={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n            \\<and> n\\<in>nodes G1 \\<and> n'\\<in>nodes G1}\"\n         and \"nodes G2={n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\"\n         and \"edges G2={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n            \\<and> n\\<in>nodes G2 \\<and> n'\\<in>nodes G2}\" \n         and \"edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\" \n         and \"edges G1 \\<inter> edges G2={}\" \n         and \"nodes G1 \\<union> nodes G2=nodes (del_unEdge v w v' G)\"\n         and \"nodes G1 \\<inter> nodes G2={}\" \n         and \"valid_unMultigraph G1\" \n         and \"valid_unMultigraph G2\"\n         and \"valid_unMultigraph.connected G1\"  \n         and \"valid_unMultigraph.connected G2\"", "lemma sub_graph_degree_frame:\n  assumes \"valid_graph G2\" \"edges G1 \\<union> edges G2 =edges G\" \"nodes G1 \\<inter> nodes G2={}\" \"n\\<in>nodes G1\"\n  shows \"degree n G=degree n G1\"", "lemma odd_nodes_no_edge[simp]: \"finite (nodes g) \\<Longrightarrow> num_of_odd_nodes (g \\<lparr>edges:={} \\<rparr>) = 0\"", "lemma (in valid_unMultigraph) adjacent_sym: \"adjacent v v' \\<longleftrightarrow> adjacent v' v\"", "lemma (in valid_unMultigraph) adjacent_no_loop[simp]: \"adjacent v v' \\<Longrightarrow> v \\<noteq>v'\"", "lemma (in valid_unMultigraph) adjacent_V[simp]: \n    assumes \"adjacent v v'\"\n    shows \"v\\<in>V\" \"v'\\<in>V\"", "lemma (in valid_unMultigraph) adjacent_finite:\n  \"finite E \\<Longrightarrow> finite {n. adjacent v n}\"", "lemma (in valid_unSimpGraph) finV_to_finE[simp]: \n  assumes \"finite V\" \n  shows \"finite E\"", "lemma del_unEdge_valid'[simp]:\"valid_unSimpGraph G\\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)\"", "lemma (in valid_unSimpGraph) del_UnEdge_non_adj: \n    \"(v,w,u)\\<in>E \\<Longrightarrow> \\<not>valid_unMultigraph.adjacent (del_unEdge v w u G) v u\"", "lemma (in valid_unSimpGraph) degree_adjacent: \"finite E \\<Longrightarrow> degree v G=card {n. adjacent v n}\""], "translations": [["", "lemma del_undirected: \"del_unEdge v e v' g = delete_edge v' e v (delete_edge v e v' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_unEdge v e v' g = delete_edge v' e v (delete_edge v e v' g)", "unfolding del_unEdge_def delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes = nodes g,\n       edges = edges g - {(v, e, v'), (v', e, v)}\\<rparr> =\n    \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = nodes g,\n                  edges = edges g - {(v, e, v')}\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = nodes g, edges = edges g - {(v, e, v')}\\<rparr> -\n         {(v', e, v)}\\<rparr>", "by auto"], ["", "lemma delete_edge_sym: \"del_unEdge v e v' g = del_unEdge v' e v g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_unEdge v e v' g = del_unEdge v' e v g", "unfolding del_unEdge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes = nodes g,\n       edges = edges g - {(v, e, v'), (v', e, v)}\\<rparr> =\n    \\<lparr>nodes = nodes g,\n       edges = edges g - {(v', e, v), (v, e, v')}\\<rparr>", "by auto"], ["", "lemma del_unEdge_valid[simp]: assumes \"valid_unMultigraph g\" \n    shows \"valid_unMultigraph (del_unEdge v e v' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' g)", "interpret valid_unMultigraph g"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph g", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' g)", "unfolding del_unEdge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph\n     \\<lparr>nodes = V, edges = E - {(v, e, v'), (v', e, v)}\\<rparr>", "by unfold_locales (auto dest: E_validD)"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v e v' g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_compre_diff:\"{x \\<in> A - B. P x}={x \\<in> A. P x} - {x \\<in> B . P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> A - B. P x} = {x \\<in> A. P x} - {x \\<in> B. P x}", "by blast"], ["", "lemma set_compre_subset: \"B \\<subseteq> A \\<Longrightarrow> {x \\<in> B. P x} \\<subseteq> {x \\<in> A. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<Longrightarrow>\n    {x \\<in> B. P x} \\<subseteq> {x \\<in> A. P x}", "by blast"], ["", "lemma del_edge_undirected_degree_plus: \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g  \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1=degree v g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "assume assms: \"finite (edges g)\" \"(v,e,v') \\<in> edges g\" \"(v',e,v) \\<in> edges g \""], ["proof (state)\nthis:\n  finite (edges g)\n  (v, e, v') \\<in> edges g\n  (v', e, v) \\<in> edges g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "have \"degree v (del_unEdge v e v' g) + 1\n          = card ({ea \\<in>  edges g - {(v, e, v'), (v', e, v)}. fst ea = v}) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v (del_unEdge v e v' g) + 1 =\n    card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1", "unfolding del_unEdge_def degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {ea \\<in> edges\n                \\<lparr>nodes = nodes g,\n                   edges = edges g - {(v, e, v'), (v', e, v)}\\<rparr>.\n      fst ea = v} +\n    1 =\n    card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1", "by simp"], ["proof (state)\nthis:\n  degree v (del_unEdge v e v' g) + 1 =\n  card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "also"], ["proof (state)\nthis:\n  degree v (del_unEdge v e v' g) + 1 =\n  card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "have \"...=card ({ea \\<in>  edges g. fst ea = v} - {ea \\<in> {(v, e, v'), (v', e, v)}. \n      fst ea = v})+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1 =\n    card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1", "by (metis set_compre_diff)"], ["proof (state)\nthis:\n  card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1 =\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n  1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "also"], ["proof (state)\nthis:\n  card {ea \\<in> edges g - {(v, e, v'), (v', e, v)}. fst ea = v} + 1 =\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n  1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "have \"...=card ({ea \\<in>  edges g. fst ea = v}) - card({ea \\<in> {(v, e, v'), (v', e, v)}. \n      fst ea = v})+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "have \"{(v, e, v'), (v', e, v)} \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, e, v'), (v', e, v)} \\<subseteq> edges g", "using \\<open>(v,e,v') \\<in> edges g\\<close> \\<open>(v',e,v) \\<in> edges g\\<close>"], ["proof (prove)\nusing this:\n  (v, e, v') \\<in> edges g\n  (v', e, v) \\<in> edges g\n\ngoal (1 subgoal):\n 1. {(v, e, v'), (v', e, v)} \\<subseteq> edges g", "by auto"], ["proof (state)\nthis:\n  {(v, e, v'), (v', e, v)} \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "hence \"{ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} \\<subseteq> {ea \\<in>  edges g. fst ea = v}\""], ["proof (prove)\nusing this:\n  {(v, e, v'), (v', e, v)} \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n    \\<subseteq> {ea \\<in> edges g. fst ea = v}", "by auto"], ["proof (state)\nthis:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n  \\<subseteq> {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "moreover"], ["proof (state)\nthis:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n  \\<subseteq> {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "have \"finite {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}", "by auto"], ["proof (state)\nthis:\n  finite {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "ultimately"], ["proof (chain)\npicking this:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n  \\<subseteq> {ea \\<in> edges g. fst ea = v}\n  finite {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}", "have \"card ({ea \\<in> edges g. fst ea = v} - {ea \\<in> {(v, e, v'), (v', e, v)}. \n          fst ea = v})=card {ea \\<in> edges g. fst ea = v} - card {ea \\<in> {(v, e, v'), (v', e, v)}.\n          fst ea = v}\""], ["proof (prove)\nusing this:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n  \\<subseteq> {ea \\<in> edges g. fst ea = v}\n  finite {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}", "using card_Diff_subset"], ["proof (prove)\nusing this:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n  \\<subseteq> {ea \\<in> edges g. fst ea = v}\n  finite {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n  \\<lbrakk>finite ?B; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> card (?A - ?B) = card ?A - card ?B\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}", "by blast"], ["proof (state)\nthis:\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) =\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "thus ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) =\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}\n\ngoal (1 subgoal):\n 1. card\n     ({ea \\<in> edges g. fst ea = v} -\n      {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n    1 =\n    card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1", "by auto"], ["proof (state)\nthis:\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n  1 =\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n  1 =\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n  1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "also"], ["proof (state)\nthis:\n  card\n   ({ea \\<in> edges g. fst ea = v} -\n    {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}) +\n  1 =\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n  1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "have \"...=card ({ea \\<in>  edges g. fst ea = v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "have \"{ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v}={(v,e,v')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = {(v, e, v')}", "by auto"], ["proof (state)\nthis:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = {(v, e, v')}\n\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "hence \"card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = 1\""], ["proof (prove)\nusing this:\n  {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = {(v, e, v')}\n\ngoal (1 subgoal):\n 1. card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = 1", "by auto"], ["proof (state)\nthis:\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = 1\n\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "moreover"], ["proof (state)\nthis:\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = 1\n\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "have \"card {ea \\<in> edges g. fst ea = v}\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} \\<noteq> 0", "by (metis (lifting, mono_tags) Collect_empty_eq assms(1) assms(2) \n          card_eq_0_iff fst_conv mem_Collect_eq rev_finite_subset subsetI)"], ["proof (state)\nthis:\n  card {ea \\<in> edges g. fst ea = v} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "ultimately"], ["proof (chain)\npicking this:\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = 1\n  card {ea \\<in> edges g. fst ea = v} \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} = 1\n  card {ea \\<in> edges g. fst ea = v} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card {ea \\<in> edges g. fst ea = v} -\n    card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n    1 =\n    card {ea \\<in> edges g. fst ea = v}", "by arith"], ["proof (state)\nthis:\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n  1 =\n  card {ea \\<in> edges g. fst ea = v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {ea \\<in> edges g. fst ea = v} -\n  card {ea \\<in> {(v, e, v'), (v', e, v)}. fst ea = v} +\n  1 =\n  card {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "finally"], ["proof (chain)\npicking this:\n  degree v (del_unEdge v e v' g) + 1 = card {ea \\<in> edges g. fst ea = v}", "have \"degree v (del_unEdge v e v' g) + 1=card ({ea \\<in>  edges g. fst ea = v})\""], ["proof (prove)\nusing this:\n  degree v (del_unEdge v e v' g) + 1 = card {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. degree v (del_unEdge v e v' g) + 1 = card {ea \\<in> edges g. fst ea = v}", "."], ["proof (state)\nthis:\n  degree v (del_unEdge v e v' g) + 1 = card {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) + 1 = degree v g", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree v (del_unEdge v e v' g) + 1 = card {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. degree v (del_unEdge v e v' g) + 1 = degree v g", "unfolding degree_def"], ["proof (prove)\nusing this:\n  card {ea \\<in> edges (del_unEdge v e v' g). fst ea = v} + 1 =\n  card {ea \\<in> edges g. fst ea = v}\n\ngoal (1 subgoal):\n 1. card {ea \\<in> edges (del_unEdge v e v' g). fst ea = v} + 1 =\n    card {e \\<in> edges g. fst e = v}", "."], ["proof (state)\nthis:\n  degree v (del_unEdge v e v' g) + 1 = degree v g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_edge_undirected_degree_plus': \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g \\<Longrightarrow> degree v' (del_unEdge v e v' g) + 1=degree v' g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v' (del_unEdge v e v' g) + 1 = degree v' g", "by (metis del_edge_undirected_degree_plus delete_edge_sym)"], ["", "lemma del_edge_undirected_degree_minus[simp]: \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g \\<Longrightarrow> degree v (del_unEdge v e v' g) =degree v g- (1::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) = degree v g - 1", "using del_edge_undirected_degree_plus"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (edges ?g); (?v, ?e, ?v') \\<in> edges ?g;\n   (?v', ?e, ?v) \\<in> edges ?g\\<rbrakk>\n  \\<Longrightarrow> degree ?v (del_unEdge ?v ?e ?v' ?g) + 1 = degree ?v ?g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v (del_unEdge v e v' g) = degree v g - 1", "by (metis add_diff_cancel_left' add.commute)"], ["", "lemma del_edge_undirected_degree_minus'[simp]: \"finite (edges g) \\<Longrightarrow> (v,e,v') \\<in> edges g \n    \\<Longrightarrow> (v',e,v) \\<in> edges g \\<Longrightarrow> degree v' (del_unEdge v e v' g) =degree v' g- (1::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (edges g); (v, e, v') \\<in> edges g;\n     (v', e, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> degree v' (del_unEdge v e v' g) = degree v' g - 1", "by (metis del_edge_undirected_degree_minus delete_edge_sym)"], ["", "lemma del_unEdge_com: \"del_unEdge v w v' (del_unEdge n e n' g)\n          = del_unEdge n e n' (del_unEdge v w v' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_unEdge v w v' (del_unEdge n e n' g) =\n    del_unEdge n e n' (del_unEdge v w v' g)", "unfolding del_unEdge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = nodes g,\n                  edges = edges g - {(n, e, n'), (n', e, n)}\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = nodes g,\n             edges = edges g - {(n, e, n'), (n', e, n)}\\<rparr> -\n         {(v, w, v'), (v', w, v)}\\<rparr> =\n    \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = nodes g,\n                  edges = edges g - {(v, w, v'), (v', w, v)}\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = nodes g,\n             edges = edges g - {(v, w, v'), (v', w, v)}\\<rparr> -\n         {(n, e, n'), (n', e, n)}\\<rparr>", "by auto"], ["", "lemma rem_unPath_com: \"rem_unPath ps (del_unEdge v w v' g) \n            = del_unEdge v w v' (rem_unPath ps g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_unPath ps (del_unEdge v w v' g) =\n    del_unEdge v w v' (rem_unPath ps g)", "proof (induct ps arbitrary: g)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g.\n       rem_unPath [] (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath [] g)\n 2. \\<And>a ps g.\n       (\\<And>g.\n           rem_unPath ps (del_unEdge v w v' g) =\n           del_unEdge v w v' (rem_unPath ps g)) \\<Longrightarrow>\n       rem_unPath (a # ps) (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath (a # ps) g)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>g.\n       rem_unPath [] (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath [] g)\n 2. \\<And>a ps g.\n       (\\<And>g.\n           rem_unPath ps (del_unEdge v w v' g) =\n           del_unEdge v w v' (rem_unPath ps g)) \\<Longrightarrow>\n       rem_unPath (a # ps) (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath (a # ps) g)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_unPath [] (del_unEdge v w v' g) =\n    del_unEdge v w v' (rem_unPath [] g)", "by (metis rem_unPath.simps(1))"], ["proof (state)\nthis:\n  rem_unPath [] (del_unEdge v w v' g) = del_unEdge v w v' (rem_unPath [] g)\n\ngoal (1 subgoal):\n 1. \\<And>a ps g.\n       (\\<And>g.\n           rem_unPath ps (del_unEdge v w v' g) =\n           del_unEdge v w v' (rem_unPath ps g)) \\<Longrightarrow>\n       rem_unPath (a # ps) (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath (a # ps) g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps g.\n       (\\<And>g.\n           rem_unPath ps (del_unEdge v w v' g) =\n           del_unEdge v w v' (rem_unPath ps g)) \\<Longrightarrow>\n       rem_unPath (a # ps) (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath (a # ps) g)", "case (Cons a ps')"], ["proof (state)\nthis:\n  rem_unPath ps' (del_unEdge v w v' ?g) =\n  del_unEdge v w v' (rem_unPath ps' ?g)\n\ngoal (1 subgoal):\n 1. \\<And>a ps g.\n       (\\<And>g.\n           rem_unPath ps (del_unEdge v w v' g) =\n           del_unEdge v w v' (rem_unPath ps g)) \\<Longrightarrow>\n       rem_unPath (a # ps) (del_unEdge v w v' g) =\n       del_unEdge v w v' (rem_unPath (a # ps) g)", "thus ?case"], ["proof (prove)\nusing this:\n  rem_unPath ps' (del_unEdge v w v' ?g) =\n  del_unEdge v w v' (rem_unPath ps' ?g)\n\ngoal (1 subgoal):\n 1. rem_unPath (a # ps') (del_unEdge v w v' g) =\n    del_unEdge v w v' (rem_unPath (a # ps') g)", "using del_unEdge_com"], ["proof (prove)\nusing this:\n  rem_unPath ps' (del_unEdge v w v' ?g) =\n  del_unEdge v w v' (rem_unPath ps' ?g)\n  del_unEdge ?v ?w ?v' (del_unEdge ?n ?e ?n' ?g) =\n  del_unEdge ?n ?e ?n' (del_unEdge ?v ?w ?v' ?g)\n\ngoal (1 subgoal):\n 1. rem_unPath (a # ps') (del_unEdge v w v' g) =\n    del_unEdge v w v' (rem_unPath (a # ps') g)", "by (metis prod_cases3 rem_unPath.simps(1) rem_unPath.simps(2))"], ["proof (state)\nthis:\n  rem_unPath (a # ps') (del_unEdge v w v' g) =\n  del_unEdge v w v' (rem_unPath (a # ps') g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rem_unPath_valid[intro]: \n  \"valid_unMultigraph g \\<Longrightarrow> valid_unMultigraph (rem_unPath ps g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph g \\<Longrightarrow>\n    valid_unMultigraph (rem_unPath ps g)", "proof (induct ps )"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_unMultigraph g \\<Longrightarrow>\n    valid_unMultigraph (rem_unPath [] g)\n 2. \\<And>a ps.\n       \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n                valid_unMultigraph (rem_unPath ps g);\n        valid_unMultigraph g\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph (rem_unPath (a # ps) g)", "case Nil"], ["proof (state)\nthis:\n  valid_unMultigraph g\n\ngoal (2 subgoals):\n 1. valid_unMultigraph g \\<Longrightarrow>\n    valid_unMultigraph (rem_unPath [] g)\n 2. \\<And>a ps.\n       \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n                valid_unMultigraph (rem_unPath ps g);\n        valid_unMultigraph g\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph (rem_unPath (a # ps) g)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_unMultigraph g\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath [] g)", "by simp"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath [] g)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n                valid_unMultigraph (rem_unPath ps g);\n        valid_unMultigraph g\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph (rem_unPath (a # ps) g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n                valid_unMultigraph (rem_unPath ps g);\n        valid_unMultigraph g\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph (rem_unPath (a # ps) g)", "case (Cons x xs)"], ["proof (state)\nthis:\n  valid_unMultigraph g \\<Longrightarrow>\n  valid_unMultigraph (rem_unPath xs g)\n  valid_unMultigraph g\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n                valid_unMultigraph (rem_unPath ps g);\n        valid_unMultigraph g\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph (rem_unPath (a # ps) g)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_unMultigraph g \\<Longrightarrow>\n  valid_unMultigraph (rem_unPath xs g)\n  valid_unMultigraph g\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath (x # xs) g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "have \"valid_unMultigraph (rem_unPath (x # xs) g) = valid_unMultigraph \n         (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath (x # xs) g) =\n    valid_unMultigraph\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g))", "using rem_unPath_com"], ["proof (prove)\nusing this:\n  rem_unPath ?ps (del_unEdge ?v ?w ?v' ?g) =\n  del_unEdge ?v ?w ?v' (rem_unPath ?ps ?g)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath (x # xs) g) =\n    valid_unMultigraph\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g))", "by (metis prod.collapse rem_unPath.simps(2))"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath (x # xs) g) =\n  valid_unMultigraph\n   (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "also"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath (x # xs) g) =\n  valid_unMultigraph\n   (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "have \"...=valid_unMultigraph (rem_unPath xs g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g)) =\n    valid_unMultigraph (rem_unPath xs g)", "by (metis Cons.hyps Cons.prems del_unEdge_valid)"], ["proof (state)\nthis:\n  valid_unMultigraph\n   (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g)) =\n  valid_unMultigraph (rem_unPath xs g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "also"], ["proof (state)\nthis:\n  valid_unMultigraph\n   (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs g)) =\n  valid_unMultigraph (rem_unPath xs g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "have \"...=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs g) = True", "using Cons"], ["proof (prove)\nusing this:\n  valid_unMultigraph g \\<Longrightarrow>\n  valid_unMultigraph (rem_unPath xs g)\n  valid_unMultigraph g\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs g) = True", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs g) = True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "finally"], ["proof (chain)\npicking this:\n  valid_unMultigraph (rem_unPath (x # xs) g) = True", "have \"?case=True\""], ["proof (prove)\nusing this:\n  valid_unMultigraph (rem_unPath (x # xs) g) = True\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath (x # xs) g) = True", "."], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath (x # xs) g) = True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_unMultigraph g \\<Longrightarrow>\n             valid_unMultigraph (rem_unPath xs g);\n     valid_unMultigraph g\\<rbrakk>\n    \\<Longrightarrow> valid_unMultigraph (rem_unPath (x # xs) g)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_unMultigraph (rem_unPath (x # xs) g) = True\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath (x # xs) g)", "by simp"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath (x # xs) g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath (x # xs) g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) degree_frame:\n    assumes \"finite (edges G)\"  \"x \\<notin> {v, v'}\" \n    shows \"degree x (del_unEdge v w v' G) = degree x G\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x (del_unEdge v w v' G) = degree x G", "proof (cases \"(v,w,v') \\<in> edges G\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "case True"], ["proof (state)\nthis:\n  (v, w, v') \\<in> E\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "have \"?L=card({e. e\\<in>edges G - {(v,w,v'),(v',w,v)} \\<and> fst e=x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x (del_unEdge v w v' G) =\n    card {e \\<in> E - {(v, w, v'), (v', w, v)}. fst e = x}", "by (simp add:del_unEdge_def degree_def)"], ["proof (state)\nthis:\n  degree x (del_unEdge v w v' G) =\n  card {e \\<in> E - {(v, w, v'), (v', w, v)}. fst e = x}\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "also"], ["proof (state)\nthis:\n  degree x (del_unEdge v w v' G) =\n  card {e \\<in> E - {(v, w, v'), (v', w, v)}. fst e = x}\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "have \"...=card({e. e\\<in>edges G \\<and> fst e=x}-{e. e\\<in>{(v,w,v'),(v',w,v)} \\<and> fst e=x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {e \\<in> E - {(v, w, v'), (v', w, v)}. fst e = x} =\n    card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x})", "by (metis  set_compre_diff)"], ["proof (state)\nthis:\n  card {e \\<in> E - {(v, w, v'), (v', w, v)}. fst e = x} =\n  card\n   ({e \\<in> E. fst e = x} - {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x})\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "also"], ["proof (state)\nthis:\n  card {e \\<in> E - {(v, w, v'), (v', w, v)}. fst e = x} =\n  card\n   ({e \\<in> E. fst e = x} - {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x})\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "have \"...=card({e. e\\<in>edges G \\<and> fst e=x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n    card {e \\<in> E. fst e = x}", "using \\<open>x \\<notin> {v, v'}\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'}\n\ngoal (1 subgoal):\n 1. card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n    card {e \\<in> E. fst e = x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n    card {e \\<in> E. fst e = x}", "have \"x\\<noteq>v \\<and> x\\<noteq> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<and> x \\<noteq> v'", "using \\<open>x\\<notin>{v,v'}\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'}\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<and> x \\<noteq> v'", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> v \\<and> x \\<noteq> v'\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n    card {e \\<in> E. fst e = x}", "hence \"{e. e\\<in>{(v,w,v'),(v',w,v)} \\<and> fst e=x}={}\""], ["proof (prove)\nusing this:\n  x \\<noteq> v \\<and> x \\<noteq> v'\n\ngoal (1 subgoal):\n 1. {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x} = {}", "by auto"], ["proof (state)\nthis:\n  {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x} = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n    card {e \\<in> E. fst e = x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x} = {}\n\ngoal (1 subgoal):\n 1. card\n     ({e \\<in> E. fst e = x} -\n      {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n    card {e \\<in> E. fst e = x}", "by (metis Diff_empty)"], ["proof (state)\nthis:\n  card\n   ({e \\<in> E. fst e = x} -\n    {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n  card {e \\<in> E. fst e = x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   ({e \\<in> E. fst e = x} -\n    {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n  card {e \\<in> E. fst e = x}\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "also"], ["proof (state)\nthis:\n  card\n   ({e \\<in> E. fst e = x} -\n    {e \\<in> {(v, w, v'), (v', w, v)}. fst e = x}) =\n  card {e \\<in> E. fst e = x}\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "have \"...=?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {e \\<in> E. fst e = x} = degree x G", "by (simp add:degree_def)"], ["proof (state)\nthis:\n  card {e \\<in> E. fst e = x} = degree x G\n\ngoal (2 subgoals):\n 1. (v, w, v') \\<in> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G\n 2. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "finally"], ["proof (chain)\npicking this:\n  degree x (del_unEdge v w v' G) = degree x G", "show ?thesis"], ["proof (prove)\nusing this:\n  degree x (del_unEdge v w v' G) = degree x G\n\ngoal (1 subgoal):\n 1. degree x (del_unEdge v w v' G) = degree x G", "."], ["proof (state)\nthis:\n  degree x (del_unEdge v w v' G) = degree x G\n\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "case False"], ["proof (state)\nthis:\n  (v, w, v') \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "moreover"], ["proof (state)\nthis:\n  (v, w, v') \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "hence \"(v',w,v)\\<notin>E\""], ["proof (prove)\nusing this:\n  (v, w, v') \\<notin> E\n\ngoal (1 subgoal):\n 1. (v', w, v) \\<notin> E", "using corres"], ["proof (prove)\nusing this:\n  (v, w, v') \\<notin> E\n  ((?v, ?w, ?u') \\<in> E) = ((?u', ?w, ?v) \\<in> E)\n\ngoal (1 subgoal):\n 1. (v', w, v) \\<notin> E", "by auto"], ["proof (state)\nthis:\n  (v', w, v) \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "ultimately"], ["proof (chain)\npicking this:\n  (v, w, v') \\<notin> E\n  (v', w, v) \\<notin> E", "have \"E- {(v,w,v'),(v',w,v)}=E\""], ["proof (prove)\nusing this:\n  (v, w, v') \\<notin> E\n  (v', w, v) \\<notin> E\n\ngoal (1 subgoal):\n 1. E - {(v, w, v'), (v', w, v)} = E", "by blast"], ["proof (state)\nthis:\n  E - {(v, w, v'), (v', w, v)} = E\n\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "hence \"del_unEdge v w v' G=G\""], ["proof (prove)\nusing this:\n  E - {(v, w, v'), (v', w, v)} = E\n\ngoal (1 subgoal):\n 1. del_unEdge v w v' G = G", "by (auto simp add:del_unEdge_def)"], ["proof (state)\nthis:\n  del_unEdge v w v' G = G\n\ngoal (1 subgoal):\n 1. (v, w, v') \\<notin> E \\<Longrightarrow>\n    degree x (del_unEdge v w v' G) = degree x G", "thus ?thesis"], ["proof (prove)\nusing this:\n  del_unEdge v w v' G = G\n\ngoal (1 subgoal):\n 1. degree x (del_unEdge v w v' G) = degree x G", "by auto"], ["proof (state)\nthis:\n  degree x (del_unEdge v w v' G) = degree x G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"rev_path [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_path [] = []", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b, c). (c, b, a)) (rev []) = []", "by simp"], ["", "lemma rev_path_append[simp]: \"rev_path (xs@ys) = (rev_path ys) @ (rev_path xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_path (xs @ ys) = rev_path ys @ rev_path xs", "unfolding rev_path_def rev_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b, c). (c, b, a)) (rev ys @ rev xs) =\n    map (\\<lambda>(a, b, c). (c, b, a)) (rev ys) @\n    map (\\<lambda>(a, b, c). (c, b, a)) (rev xs)", "by auto"], ["", "lemma rev_path_double[simp]: \"rev_path(rev_path xs)=xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_path (rev_path xs) = xs", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b, c). (c, b, a))\n     (rev (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs))) =\n    xs", "by (induct xs,auto)"], ["", "lemma del_UnEdge_node[simp]: \"v\\<in>nodes (del_unEdge u e u' G) \\<longleftrightarrow> v\\<in>nodes G  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> nodes (del_unEdge u e u' G)) = (v \\<in> nodes G)", "by (metis del_unEdge_def select_convs(1))"], ["", "lemma [intro!]: \"finite (edges G) \\<Longrightarrow> finite (edges (del_unEdge u e u' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges G) \\<Longrightarrow> finite (edges (del_unEdge u e u' G))", "by (metis del_unEdge_def finite_Diff select_convs(2))"], ["", "lemma [intro!]: \"finite (nodes G) \\<Longrightarrow> finite (nodes (del_unEdge u e u' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes G) \\<Longrightarrow> finite (nodes (del_unEdge u e u' G))", "by (metis del_unEdge_def select_convs(1))"], ["", "lemma [intro!]: \"finite (edges G) \\<Longrightarrow> finite (edges (rem_unPath ps G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges G) \\<Longrightarrow> finite (edges (rem_unPath ps G))", "proof (induct ps arbitrary:G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       finite (edges G) \\<Longrightarrow> finite (edges (rem_unPath [] G))\n 2. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "case Nil"], ["proof (state)\nthis:\n  finite (edges G)\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       finite (edges G) \\<Longrightarrow> finite (edges (rem_unPath [] G))\n 2. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "thus ?case"], ["proof (prove)\nusing this:\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath [] G))", "by simp"], ["proof (state)\nthis:\n  finite (edges (rem_unPath [] G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite (edges ?G) \\<Longrightarrow> finite (edges (rem_unPath xs ?G))\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "hence \"finite (edges (rem_unPath (x # xs) G)) = finite (edges (del_unEdge \n          (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)))\""], ["proof (prove)\nusing this:\n  finite (edges ?G) \\<Longrightarrow> finite (edges (rem_unPath xs ?G))\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath (x # xs) G)) =\n    finite\n     (edges\n       (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)))", "by (metis rem_unPath.simps(2) rem_unPath_com surjective_pairing)"], ["proof (state)\nthis:\n  finite (edges (rem_unPath (x # xs) G)) =\n  finite\n   (edges\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "also"], ["proof (state)\nthis:\n  finite (edges (rem_unPath (x # xs) G)) =\n  finite\n   (edges\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "have \"...=finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (edges\n       (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))) =\n    finite (edges (rem_unPath xs G))", "using del_unEdge_def"], ["proof (prove)\nusing this:\n  del_unEdge ?v ?e ?v' ?g \\<equiv>\n  \\<lparr>nodes = nodes ?g,\n     edges = edges ?g - {(?v, ?e, ?v'), (?v', ?e, ?v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. finite\n     (edges\n       (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))) =\n    finite (edges (rem_unPath xs G))", "by (metis  finite.emptyI finite_Diff2 finite_Diff_insert select_convs(2))"], ["proof (state)\nthis:\n  finite\n   (edges\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))) =\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "also"], ["proof (state)\nthis:\n  finite\n   (edges\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))) =\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "have \"...=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G)) = True", "using Cons"], ["proof (prove)\nusing this:\n  finite (edges ?G) \\<Longrightarrow> finite (edges (rem_unPath xs ?G))\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G)) = True", "by auto"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G)) = True\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "finally"], ["proof (chain)\npicking this:\n  finite (edges (rem_unPath (x # xs) G)) = True", "have \"?case = True\""], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath (x # xs) G)) = True\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath (x # xs) G)) = True", "."], ["proof (state)\nthis:\n  finite (edges (rem_unPath (x # xs) G)) = True\n\ngoal (1 subgoal):\n 1. \\<And>a ps G.\n       \\<lbrakk>\\<And>G.\n                   finite (edges G) \\<Longrightarrow>\n                   finite (edges (rem_unPath ps G));\n        finite (edges G)\\<rbrakk>\n       \\<Longrightarrow> finite (edges (rem_unPath (a # ps) G))", "thus ?case"], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath (x # xs) G)) = True\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath (x # xs) G))", "by simp"], ["proof (state)\nthis:\n  finite (edges (rem_unPath (x # xs) G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_UnEdge_frame[intro]: \n  \"x\\<in>edges g \\<Longrightarrow> x\\<noteq>(v,e,v') \\<Longrightarrow>x\\<noteq>(v',e,v) \\<Longrightarrow> x\\<in>edges (del_unEdge v e v' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> edges g; x \\<noteq> (v, e, v');\n     x \\<noteq> (v', e, v)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> edges (del_unEdge v e v' g)", "unfolding del_unEdge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> edges g; x \\<noteq> (v, e, v');\n     x \\<noteq> (v', e, v)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> edges\n                               \\<lparr>nodes = nodes g,\n                                  edges =\n                                    edges g -\n                                    {(v, e, v'), (v', e, v)}\\<rparr>", "by auto"], ["", "lemma [intro!]: \"finite (nodes G) \\<Longrightarrow> finite (odd_nodes_set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes G) \\<Longrightarrow> finite (odd_nodes_set G)", "by (metis (lifting) mem_Collect_eq odd_nodes_set_def rev_finite_subset subsetI)"], ["", "lemma [simp]: \"nodes (del_unEdge u e u' G)=nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (del_unEdge u e u' G) = nodes G", "by (metis del_unEdge_def select_convs(1))"], ["", "lemma [simp]: \"nodes (rem_unPath ps G) = nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (rem_unPath ps G) = nodes G", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. nodes (rem_unPath [] G) = nodes G\n 2. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. nodes (rem_unPath [] G) = nodes G\n 2. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (rem_unPath [] G) = nodes G", "by simp"], ["proof (state)\nthis:\n  nodes (rem_unPath [] G) = nodes G\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "case (Cons x xs)"], ["proof (state)\nthis:\n  nodes (rem_unPath xs G) = nodes G\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "have \"nodes (rem_unPath (x # xs) G)=nodes (del_unEdge \n        (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (rem_unPath (x # xs) G) =\n    nodes (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com surjective_pairing)"], ["proof (state)\nthis:\n  nodes (rem_unPath (x # xs) G) =\n  nodes (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "also"], ["proof (state)\nthis:\n  nodes (rem_unPath (x # xs) G) =\n  nodes (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "have \"...=nodes (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes\n     (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)) =\n    nodes (rem_unPath xs G)", "by auto"], ["proof (state)\nthis:\n  nodes (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)) =\n  nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "also"], ["proof (state)\nthis:\n  nodes (del_unEdge (fst x) (fst (snd x)) (snd (snd x)) (rem_unPath xs G)) =\n  nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "have \"...=nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (rem_unPath xs G) = nodes G", "using Cons"], ["proof (prove)\nusing this:\n  nodes (rem_unPath xs G) = nodes G\n\ngoal (1 subgoal):\n 1. nodes (rem_unPath xs G) = nodes G", "by auto"], ["proof (state)\nthis:\n  nodes (rem_unPath xs G) = nodes G\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       nodes (rem_unPath ps G) = nodes G \\<Longrightarrow>\n       nodes (rem_unPath (a # ps) G) = nodes G", "finally"], ["proof (chain)\npicking this:\n  nodes (rem_unPath (x # xs) G) = nodes G", "show ?case"], ["proof (prove)\nusing this:\n  nodes (rem_unPath (x # xs) G) = nodes G\n\ngoal (1 subgoal):\n 1. nodes (rem_unPath (x # xs) G) = nodes G", "."], ["proof (state)\nthis:\n  nodes (rem_unPath (x # xs) G) = nodes G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [intro!]: \"finite (nodes G) \\<Longrightarrow> finite (nodes (rem_unPath ps G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes G) \\<Longrightarrow> finite (nodes (rem_unPath ps G))", "by auto"], ["", "lemma in_set_rev_path[simp]: \"(v',w,v )\\<in>set (rev_path ps) \\<longleftrightarrow> (v,w,v')\\<in>set ps \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', w, v) \\<in> set (rev_path ps)) = ((v, w, v') \\<in> set ps)", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((v', w, v) \\<in> set (rev_path [])) = ((v, w, v') \\<in> set [])\n 2. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ((v', w, v) \\<in> set (rev_path [])) = ((v, w, v') \\<in> set [])\n 2. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', w, v) \\<in> set (rev_path [])) = ((v, w, v') \\<in> set [])", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', w, v) \\<in> set (map (\\<lambda>(a, b, c). (c, b, a)) (rev []))) =\n    ((v, w, v') \\<in> set [])", "by auto"], ["proof (state)\nthis:\n  ((v', w, v) \\<in> set (rev_path [])) = ((v, w, v') \\<in> set [])\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "case (Cons x xs)"], ["proof (state)\nthis:\n  ((v', w, v) \\<in> set (rev_path xs)) = ((v, w, v') \\<in> set xs)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "have \"set (rev_path (x # xs))=set ((rev_path xs)@[(x3,x2,x1)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs))) =\n    set (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs) @ [(x3, x2, x1)])", "using x"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs))) =\n    set (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs) @ [(x3, x2, x1)])", "by auto"], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "also"], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "have \"...=set (rev_path xs) \\<union> {(x3,x2,x1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path xs @ [(x3, x2, x1)]) =\n    set (rev_path xs) \\<union> {(x3, x2, x1)}", "by auto"], ["proof (state)\nthis:\n  set (rev_path xs @ [(x3, x2, x1)]) =\n  set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "finally"], ["proof (chain)\npicking this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}", "have \"set (rev_path (x # xs)) =set (rev_path xs) \\<union> {(x3,x2,x1)}\""], ["proof (prove)\nusing this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}", "."], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "moreover"], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "have \"set (x#xs)= set xs \\<union> {(x1,x2,x3)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (x # xs) = set xs \\<union> {(x1, x2, x3)}", "by (metis List.set_simps(2) insert_is_Un sup_commute x)"], ["proof (state)\nthis:\n  set (x # xs) = set xs \\<union> {(x1, x2, x3)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       ((v', w, v) \\<in> set (rev_path ps)) =\n       ((v, w, v') \\<in> set ps) \\<Longrightarrow>\n       ((v', w, v) \\<in> set (rev_path (a # ps))) =\n       ((v, w, v') \\<in> set (a # ps))", "ultimately"], ["proof (chain)\npicking this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n  set (x # xs) = set xs \\<union> {(x1, x2, x3)}", "show ?case"], ["proof (prove)\nusing this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n  set (x # xs) = set xs \\<union> {(x1, x2, x3)}\n\ngoal (1 subgoal):\n 1. ((v', w, v) \\<in> set (rev_path (x # xs))) =\n    ((v, w, v') \\<in> set (x # xs))", "using Cons"], ["proof (prove)\nusing this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n  set (x # xs) = set xs \\<union> {(x1, x2, x3)}\n  ((v', w, v) \\<in> set (rev_path xs)) = ((v, w, v') \\<in> set xs)\n\ngoal (1 subgoal):\n 1. ((v', w, v) \\<in> set (rev_path (x # xs))) =\n    ((v, w, v') \\<in> set (x # xs))", "by auto"], ["proof (state)\nthis:\n  ((v', w, v) \\<in> set (rev_path (x # xs))) =\n  ((v, w, v') \\<in> set (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rem_unPath_edges: \n    \"edges(rem_unPath ps G) = edges G - (set ps \\<union> set (rev_path ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (rem_unPath ps G) = edges G - (set ps \\<union> set (rev_path ps))", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. edges (rem_unPath [] G) = edges G - (set [] \\<union> set (rev_path []))\n 2. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. edges (rem_unPath [] G) = edges G - (set [] \\<union> set (rev_path []))\n 2. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (rem_unPath [] G) = edges G - (set [] \\<union> set (rev_path []))", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (rem_unPath [] G) =\n    edges G -\n    (set [] \\<union> set (map (\\<lambda>(a, b, c). (c, b, a)) (rev [])))", "by auto"], ["proof (state)\nthis:\n  edges (rem_unPath [] G) = edges G - (set [] \\<union> set (rev_path []))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  edges (rem_unPath xs G) = edges G - (set xs \\<union> set (rev_path xs))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "obtain x1 x2 x3 where x: \"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "hence \"edges(rem_unPath (x#xs) G)= edges(del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. edges (rem_unPath (x # xs) G) =\n    edges (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com)"], ["proof (state)\nthis:\n  edges (rem_unPath (x # xs) G) =\n  edges (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "also"], ["proof (state)\nthis:\n  edges (rem_unPath (x # xs) G) =\n  edges (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "have \"...=edges(rem_unPath xs G)-{(x1,x2,x3),(x3,x2,x1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    edges (rem_unPath xs G) - {(x1, x2, x3), (x3, x2, x1)}", "by (metis del_unEdge_def select_convs(2))"], ["proof (state)\nthis:\n  edges (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  edges (rem_unPath xs G) - {(x1, x2, x3), (x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "also"], ["proof (state)\nthis:\n  edges (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  edges (rem_unPath xs G) - {(x1, x2, x3), (x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "have \"...= edges G - (set xs \\<union> set (rev_path xs))-{(x1,x2,x3),(x3,x2,x1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (rem_unPath xs G) - {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)}", "by (metis Cons.hyps)"], ["proof (state)\nthis:\n  edges (rem_unPath xs G) - {(x1, x2, x3), (x3, x2, x1)} =\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "also"], ["proof (state)\nthis:\n  edges (rem_unPath xs G) - {(x1, x2, x3), (x3, x2, x1)} =\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "have \"...=edges G - (set (x#xs) \\<union> set (rev_path (x#xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "have \"set (rev_path xs) \\<union> {(x3,x2,x1)}=set ((rev_path xs)@[(x3,x2,x1)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path xs) \\<union> {(x3, x2, x1)} =\n    set (rev_path xs @ [(x3, x2, x1)])", "by (metis List.set_simps(2) empty_set set_append)"], ["proof (state)\nthis:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} =\n  set (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "also"], ["proof (state)\nthis:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} =\n  set (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "have \"...=set (rev_path (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path xs @ [(x3, x2, x1)]) = set (rev_path (x # xs))", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs) @ [(x3, x2, x1)]) =\n    set (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs)))", "using  x"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs) @ [(x3, x2, x1)]) =\n    set (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs)))", "by auto"], ["proof (state)\nthis:\n  set (rev_path xs @ [(x3, x2, x1)]) = set (rev_path (x # xs))\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "finally"], ["proof (chain)\npicking this:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))", "have \"set (rev_path xs) \\<union> {(x3,x2,x1)}=set (rev_path (x#xs))\""], ["proof (prove)\nusing this:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))\n\ngoal (1 subgoal):\n 1. set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))", "."], ["proof (state)\nthis:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "moreover"], ["proof (state)\nthis:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "have \"set xs \\<union> {(x1,x2,x3)}=set (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<union> {(x1, x2, x3)} = set (x # xs)", "by (metis List.set_simps(2) insert_is_Un sup_commute x)"], ["proof (state)\nthis:\n  set xs \\<union> {(x1, x2, x3)} = set (x # xs)\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "moreover"], ["proof (state)\nthis:\n  set xs \\<union> {(x1, x2, x3)} = set (x # xs)\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "have \"edges G - (set xs \\<union> set (rev_path xs))-{(x1,x2,x3),(x3,x2,x1)} =\n                      edges G - ((set xs \\<union> {(x1,x2,x3)}) \\<union> (set (rev_path xs) \\<union> {(x3,x2,x1)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G -\n    (set xs \\<union> {(x1, x2, x3)} \\<union>\n     (set (rev_path xs) \\<union> {(x3, x2, x1)}))", "by auto"], ["proof (state)\nthis:\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)} =\n  edges G -\n  (set xs \\<union> {(x1, x2, x3)} \\<union>\n   (set (rev_path xs) \\<union> {(x3, x2, x1)}))\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))\n  set xs \\<union> {(x1, x2, x3)} = set (x # xs)\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)} =\n  edges G -\n  (set xs \\<union> {(x1, x2, x3)} \\<union>\n   (set (rev_path xs) \\<union> {(x3, x2, x1)}))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (rev_path xs) \\<union> {(x3, x2, x1)} = set (rev_path (x # xs))\n  set xs \\<union> {(x1, x2, x3)} = set (x # xs)\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)} =\n  edges G -\n  (set xs \\<union> {(x1, x2, x3)} \\<union>\n   (set (rev_path xs) \\<union> {(x3, x2, x1)}))\n\ngoal (1 subgoal):\n 1. edges G - (set xs \\<union> set (rev_path xs)) -\n    {(x1, x2, x3), (x3, x2, x1)} =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "by auto"], ["proof (state)\nthis:\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)} =\n  edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges G - (set xs \\<union> set (rev_path xs)) -\n  {(x1, x2, x3), (x3, x2, x1)} =\n  edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       edges (rem_unPath ps G) =\n       edges G - (set ps \\<union> set (rev_path ps)) \\<Longrightarrow>\n       edges (rem_unPath (a # ps) G) =\n       edges G - (set (a # ps) \\<union> set (rev_path (a # ps)))", "finally"], ["proof (chain)\npicking this:\n  edges (rem_unPath (x # xs) G) =\n  edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "show ?case"], ["proof (prove)\nusing this:\n  edges (rem_unPath (x # xs) G) =\n  edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))\n\ngoal (1 subgoal):\n 1. edges (rem_unPath (x # xs) G) =\n    edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))", "."], ["proof (state)\nthis:\n  edges (rem_unPath (x # xs) G) =\n  edges G - (set (x # xs) \\<union> set (rev_path (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rem_unPath_graph [simp]: \n    \"rem_unPath (rev_path ps) G=rem_unPath ps G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_unPath (rev_path ps) G = rem_unPath ps G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rem_unPath (rev_path ps) G = rem_unPath ps G", "have \"nodes(rem_unPath (rev_path ps) G)=nodes(rem_unPath ps G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (rem_unPath (rev_path ps) G) = nodes (rem_unPath ps G)", "by auto"], ["proof (state)\nthis:\n  nodes (rem_unPath (rev_path ps) G) = nodes (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. rem_unPath (rev_path ps) G = rem_unPath ps G", "moreover"], ["proof (state)\nthis:\n  nodes (rem_unPath (rev_path ps) G) = nodes (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. rem_unPath (rev_path ps) G = rem_unPath ps G", "have \"edges(rem_unPath (rev_path ps) G)=edges(rem_unPath ps G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)", "have \"set (rev_path ps) \\<union> set (rev_path (rev_path ps)) = set ps \\<union>  set (rev_path ps) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path ps) \\<union> set (rev_path (rev_path ps)) =\n    set ps \\<union> set (rev_path ps)", "by auto"], ["proof (state)\nthis:\n  set (rev_path ps) \\<union> set (rev_path (rev_path ps)) =\n  set ps \\<union> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (rev_path ps) \\<union> set (rev_path (rev_path ps)) =\n  set ps \\<union> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)", "by (metis rem_unPath_edges)"], ["proof (state)\nthis:\n  edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. rem_unPath (rev_path ps) G = rem_unPath ps G", "ultimately"], ["proof (chain)\npicking this:\n  nodes (rem_unPath (rev_path ps) G) = nodes (rem_unPath ps G)\n  edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)", "show ?thesis"], ["proof (prove)\nusing this:\n  nodes (rem_unPath (rev_path ps) G) = nodes (rem_unPath ps G)\n  edges (rem_unPath (rev_path ps) G) = edges (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. rem_unPath (rev_path ps) G = rem_unPath ps G", "by auto"], ["proof (state)\nthis:\n  rem_unPath (rev_path ps) G = rem_unPath ps G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_rev_path[simp]: \"distinct (rev_path ps) \\<longleftrightarrow>distinct ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rev_path ps) = distinct ps", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (rev_path []) = distinct []\n 2. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. distinct (rev_path []) = distinct []\n 2. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rev_path []) = distinct []", "by auto"], ["proof (state)\nthis:\n  distinct (rev_path []) = distinct []\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (rev_path xs) = distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "obtain x1 x2 x3 where x: \"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "hence \"distinct (rev_path (x # xs))=distinct ((rev_path xs)@[(x3,x2,x1)])\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. distinct (rev_path (x # xs)) = distinct (rev_path xs @ [(x3, x2, x1)])", "unfolding rev_path_def"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs))) =\n    distinct (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs) @ [(x3, x2, x1)])", "by auto"], ["proof (state)\nthis:\n  distinct (rev_path (x # xs)) = distinct (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "also"], ["proof (state)\nthis:\n  distinct (rev_path (x # xs)) = distinct (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "have \"...= (distinct (rev_path xs) \\<and> (x3,x2,x1)\\<notin>set (rev_path xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rev_path xs @ [(x3, x2, x1)]) =\n    (distinct (rev_path xs) \\<and> (x3, x2, x1) \\<notin> set (rev_path xs))", "by (metis distinct.simps(2) distinct1_rotate rotate1.simps(2))"], ["proof (state)\nthis:\n  distinct (rev_path xs @ [(x3, x2, x1)]) =\n  (distinct (rev_path xs) \\<and> (x3, x2, x1) \\<notin> set (rev_path xs))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "also"], ["proof (state)\nthis:\n  distinct (rev_path xs @ [(x3, x2, x1)]) =\n  (distinct (rev_path xs) \\<and> (x3, x2, x1) \\<notin> set (rev_path xs))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "have \"...=distinct (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct (rev_path xs) \\<and>\n     (x3, x2, x1) \\<notin> set (rev_path xs)) =\n    distinct (x # xs)", "by (metis Cons.hyps distinct.simps(2) in_set_rev_path x)"], ["proof (state)\nthis:\n  (distinct (rev_path xs) \\<and> (x3, x2, x1) \\<notin> set (rev_path xs)) =\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "finally"], ["proof (chain)\npicking this:\n  distinct (rev_path (x # xs)) = distinct (x # xs)", "have \"distinct (rev_path (x # xs))=distinct (x#xs)\""], ["proof (prove)\nusing this:\n  distinct (rev_path (x # xs)) = distinct (x # xs)\n\ngoal (1 subgoal):\n 1. distinct (rev_path (x # xs)) = distinct (x # xs)", "."], ["proof (state)\nthis:\n  distinct (rev_path (x # xs)) = distinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       distinct (rev_path ps) = distinct ps \\<Longrightarrow>\n       distinct (rev_path (a # ps)) = distinct (a # ps)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (rev_path (x # xs)) = distinct (x # xs)\n\ngoal (1 subgoal):\n 1. distinct (rev_path (x # xs)) = distinct (x # xs)", "."], ["proof (state)\nthis:\n  distinct (rev_path (x # xs)) = distinct (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) is_path_rev: \"is_path v' (rev_path ps) v \\<longleftrightarrow> is_path v ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path v' (rev_path ps) v = is_path v ps v'", "proof (induct ps arbitrary: v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v. is_path v' (rev_path []) v = is_path v [] v'\n 2. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v. is_path v' (rev_path []) v = is_path v [] v'\n 2. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path v' (rev_path []) v = is_path v [] v'", "by auto"], ["proof (state)\nthis:\n  is_path v' (rev_path []) v = is_path v [] v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "case (Cons x xs)"], ["proof (state)\nthis:\n  is_path v' (rev_path xs) ?v = is_path ?v xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "obtain x1 x2 x3 where x: \"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "hence \"is_path v' (rev_path (x # xs)) v=is_path v' ((rev_path xs) @[(x3,x2,x1)]) v\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_path v' (rev_path (x # xs)) v =\n    is_path v' (rev_path xs @ [(x3, x2, x1)]) v", "unfolding rev_path_def"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_path v' (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs))) v =\n    is_path v'\n     (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs) @ [(x3, x2, x1)]) v", "by auto"], ["proof (state)\nthis:\n  is_path v' (rev_path (x # xs)) v =\n  is_path v' (rev_path xs @ [(x3, x2, x1)]) v\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "also"], ["proof (state)\nthis:\n  is_path v' (rev_path (x # xs)) v =\n  is_path v' (rev_path xs @ [(x3, x2, x1)]) v\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "have \"...=(is_path v' (rev_path xs) x3 \\<and> (x3,x2,x1)\\<in>E \\<and> is_path x1 [] v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path v' (rev_path xs @ [(x3, x2, x1)]) v =\n    (is_path v' (rev_path xs) x3 \\<and>\n     (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)", "by auto"], ["proof (state)\nthis:\n  is_path v' (rev_path xs @ [(x3, x2, x1)]) v =\n  (is_path v' (rev_path xs) x3 \\<and>\n   (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "also"], ["proof (state)\nthis:\n  is_path v' (rev_path xs @ [(x3, x2, x1)]) v =\n  (is_path v' (rev_path xs) x3 \\<and>\n   (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "have \"...=(is_path x3 xs v' \\<and> (x3,x2,x1)\\<in>E \\<and> is_path x1 [] v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_path v' (rev_path xs) x3 \\<and>\n     (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v) =\n    (is_path x3 xs v' \\<and> (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)", "using Cons.hyps"], ["proof (prove)\nusing this:\n  is_path v' (rev_path xs) ?v = is_path ?v xs v'\n\ngoal (1 subgoal):\n 1. (is_path v' (rev_path xs) x3 \\<and>\n     (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v) =\n    (is_path x3 xs v' \\<and> (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)", "by auto"], ["proof (state)\nthis:\n  (is_path v' (rev_path xs) x3 \\<and>\n   (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v) =\n  (is_path x3 xs v' \\<and> (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "also"], ["proof (state)\nthis:\n  (is_path v' (rev_path xs) x3 \\<and>\n   (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v) =\n  (is_path x3 xs v' \\<and> (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "have \"...=is_path v (x#xs) v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_path x3 xs v' \\<and> (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v) =\n    is_path v (x # xs) v'", "by (metis corres is_path.simps(1) is_path.simps(2) is_path_memb x)"], ["proof (state)\nthis:\n  (is_path x3 xs v' \\<and> (x3, x2, x1) \\<in> E \\<and> is_path x1 [] v) =\n  is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "finally"], ["proof (chain)\npicking this:\n  is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'", "have \"is_path v' (rev_path (x # xs)) v=is_path v (x#xs) v'\""], ["proof (prove)\nusing this:\n  is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'", "."], ["proof (state)\nthis:\n  is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_path v' (rev_path ps) v = is_path v ps v') \\<Longrightarrow>\n       is_path v' (rev_path (a # ps)) v = is_path v (a # ps) v'", "thus ?case"], ["proof (prove)\nusing this:\n  is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'", "."], ["proof (state)\nthis:\n  is_path v' (rev_path (x # xs)) v = is_path v (x # xs) v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) singleton_distinct_path [intro]:\n   \"(v,w,v')\\<in>E \\<Longrightarrow> is_trail v [(v,w,v')] v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w, v') \\<in> E \\<Longrightarrow> is_trail v [(v, w, v')] v'", "by (metis E_validD(2) all_not_in_conv is_trail.simps set_empty)"], ["", "lemma (in valid_unMultigraph) is_trail_path: \n  \"is_trail v ps v' \\<longleftrightarrow> is_path v ps v' \\<and> distinct ps \\<and> (set ps \\<inter> set (rev_path ps) = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v ps v' =\n    (is_path v ps v' \\<and>\n     distinct ps \\<and> set ps \\<inter> set (rev_path ps) = {})", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       is_trail v [] v' =\n       (is_path v [] v' \\<and>\n        distinct [] \\<and> set [] \\<inter> set (rev_path []) = {})\n 2. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v.\n       is_trail v [] v' =\n       (is_path v [] v' \\<and>\n        distinct [] \\<and> set [] \\<inter> set (rev_path []) = {})\n 2. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v [] v' =\n    (is_path v [] v' \\<and>\n     distinct [] \\<and> set [] \\<inter> set (rev_path []) = {})", "by auto"], ["proof (state)\nthis:\n  is_trail v [] v' =\n  (is_path v [] v' \\<and>\n   distinct [] \\<and> set [] \\<inter> set (rev_path []) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "case (Cons x xs)"], ["proof (state)\nthis:\n  is_trail ?v xs v' =\n  (is_path ?v xs v' \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "obtain x1 x2 x3 where x: \"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "hence \"is_trail v (x#xs) v'= (v=x1 \\<and> (x1,x2,x3)\\<in>E \\<and> \n                (x1,x2,x3)\\<notin>set xs \\<and>(x3,x2,x1)\\<notin>set xs \\<and> is_trail x3 xs v')\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_trail v (x # xs) v' =\n    (v = x1 \\<and>\n     (x1, x2, x3) \\<in> E \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v')", "by (metis is_trail.simps(2))"], ["proof (state)\nthis:\n  is_trail v (x # xs) v' =\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v')\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "also"], ["proof (state)\nthis:\n  is_trail v (x # xs) v' =\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v')\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "have \"...=(v=x1 \\<and> (x1,x2,x3)\\<in>E \\<and>  (x1,x2,x3)\\<notin>set xs \\<and>(x3,x2,x1)\\<notin>set xs \\<and> is_path x3 xs v' \n                  \\<and> distinct xs \\<and> (set xs \\<inter> set (rev_path xs)={}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v = x1 \\<and>\n     (x1, x2, x3) \\<in> E \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v') =\n    (v = x1 \\<and>\n     (x1, x2, x3) \\<in> E \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     is_path x3 xs v' \\<and>\n     distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})", "using Cons.hyps"], ["proof (prove)\nusing this:\n  is_trail ?v xs v' =\n  (is_path ?v xs v' \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. (v = x1 \\<and>\n     (x1, x2, x3) \\<in> E \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v') =\n    (v = x1 \\<and>\n     (x1, x2, x3) \\<in> E \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     is_path x3 xs v' \\<and>\n     distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})", "by auto"], ["proof (state)\nthis:\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v') =\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   is_path x3 xs v' \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "also"], ["proof (state)\nthis:\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and> is_trail x3 xs v') =\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   is_path x3 xs v' \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "have \"...=(is_path v (x#xs) v' \\<and> (x1,x2,x3) \\<noteq> (x3,x2,x1) \\<and> (x1,x2,x3)\\<notin>set xs \n                  \\<and>(x3,x2,x1)\\<notin>set xs \\<and> distinct xs \\<and> (set xs \\<inter> set (rev_path xs)={}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v = x1 \\<and>\n     (x1, x2, x3) \\<in> E \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     is_path x3 xs v' \\<and>\n     distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})", "by (metis append_Nil is_path.simps(1) is_path_simps(2) is_path_split' no_id x)"], ["proof (state)\nthis:\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   is_path x3 xs v' \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "also"], ["proof (state)\nthis:\n  (v = x1 \\<and>\n   (x1, x2, x3) \\<in> E \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   is_path x3 xs v' \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "have \"...=(is_path v (x#xs) v' \\<and> (x1,x2,x3) \\<noteq> (x3,x2,x1) \\<and>(x3,x2,x1)\\<notin>set xs \n                  \\<and> distinct (x#xs) \\<and> (set xs \\<inter> set (rev_path xs)={}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x1, x2, x3) \\<notin> set xs \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {})", "by (metis (full_types) distinct.simps(2) x)"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "also"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x1, x2, x3) \\<notin> set xs \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct xs \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "have \"...=(is_path v (x#xs) v' \\<and> (x1,x2,x3) \\<noteq> (x3,x2,x1) \\<and> distinct (x#xs) \n                  \\<and> (x3,x2,x1)\\<notin>set xs \\<and> set xs \\<inter> set (rev_path (x#xs))={})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "have \"set (rev_path (x#xs)) = set ((rev_path xs)@[(x3,x2,x1)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])", "using x"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])", "by auto"], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "also"], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs @ [(x3, x2, x1)])\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "have \"... = set (rev_path xs) \\<union> {(x3,x2,x1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path xs @ [(x3, x2, x1)]) =\n    set (rev_path xs) \\<union> {(x3, x2, x1)}", "by auto"], ["proof (state)\nthis:\n  set (rev_path xs @ [(x3, x2, x1)]) =\n  set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "finally"], ["proof (chain)\npicking this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}", "have \"set (rev_path (x#xs))=set (rev_path xs) \\<union> {(x3,x2,x1)}\""], ["proof (prove)\nusing this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}", "."], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {})", "by blast"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   distinct (x # xs) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   set xs \\<inter> set (rev_path (x # xs)) = {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   distinct (x # xs) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   set xs \\<inter> set (rev_path (x # xs)) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "also"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   distinct (x # xs) \\<and> set xs \\<inter> set (rev_path xs) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   distinct (x # xs) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   set xs \\<inter> set (rev_path (x # xs)) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "have \"...=(is_path v (x#xs) v'\\<and> distinct (x#xs) \\<and> (set (x#xs) \\<inter> set (rev_path (x#xs))={}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "have \"(x3,x2,x1)\\<notin>set xs \\<longleftrightarrow> (x1,x2,x3)\\<notin> set (rev_path xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x3, x2, x1) \\<notin> set xs) =\n    ((x1, x2, x3) \\<notin> set (rev_path xs))", "using in_set_rev_path"], ["proof (prove)\nusing this:\n  ((?v', ?w, ?v) \\<in> set (rev_path ?ps)) = ((?v, ?w, ?v') \\<in> set ?ps)\n\ngoal (1 subgoal):\n 1. ((x3, x2, x1) \\<notin> set xs) =\n    ((x1, x2, x3) \\<notin> set (rev_path xs))", "by auto"], ["proof (state)\nthis:\n  ((x3, x2, x1) \\<notin> set xs) = ((x1, x2, x3) \\<notin> set (rev_path xs))\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "moreover"], ["proof (state)\nthis:\n  ((x3, x2, x1) \\<notin> set xs) = ((x1, x2, x3) \\<notin> set (rev_path xs))\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "have  \"set (rev_path (x#xs))=set (rev_path xs) \\<union> {(x3,x2,x1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}", "unfolding rev_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs))) =\n    set (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs)) \\<union>\n    {(x3, x2, x1)}", "using x"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(a, b, c). (c, b, a)) (rev (x # xs))) =\n    set (map (\\<lambda>(a, b, c). (c, b, a)) (rev xs)) \\<union>\n    {(x3, x2, x1)}", "by auto"], ["proof (state)\nthis:\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "ultimately"], ["proof (chain)\npicking this:\n  ((x3, x2, x1) \\<notin> set xs) = ((x1, x2, x3) \\<notin> set (rev_path xs))\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}", "have \" (x1,x2,x3) \\<noteq> (x3,x2,x1)\\<and> (x3,x2,x1)\\<notin>set xs \n                        \\<longleftrightarrow> (x1,x2,x3)\\<notin> set (rev_path (x#xs))\""], ["proof (prove)\nusing this:\n  ((x3, x2, x1) \\<notin> set xs) = ((x1, x2, x3) \\<notin> set (rev_path xs))\n  set (rev_path (x # xs)) = set (rev_path xs) \\<union> {(x3, x2, x1)}\n\ngoal (1 subgoal):\n 1. ((x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     (x3, x2, x1) \\<notin> set xs) =\n    ((x1, x2, x3) \\<notin> set (rev_path (x # xs)))", "by blast"], ["proof (state)\nthis:\n  ((x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and> (x3, x2, x1) \\<notin> set xs) =\n  ((x1, x2, x3) \\<notin> set (rev_path (x # xs)))\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and> (x3, x2, x1) \\<notin> set xs) =\n  ((x1, x2, x3) \\<notin> set (rev_path (x # xs)))\n\ngoal (1 subgoal):\n 1. (is_path v (x # xs) v' \\<and>\n     (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n     distinct (x # xs) \\<and>\n     (x3, x2, x1) \\<notin> set xs \\<and>\n     set xs \\<inter> set (rev_path (x # xs)) = {}) =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "by (metis (mono_tags) Int_iff Int_insert_left_if0 List.set_simps(2) empty_iff insertI1 x)"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   distinct (x # xs) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   set xs \\<inter> set (rev_path (x # xs)) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (is_path v (x # xs) v' \\<and>\n   (x1, x2, x3) \\<noteq> (x3, x2, x1) \\<and>\n   distinct (x # xs) \\<and>\n   (x3, x2, x1) \\<notin> set xs \\<and>\n   set xs \\<inter> set (rev_path (x # xs)) = {}) =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "finally"], ["proof (chain)\npicking this:\n  is_trail v (x # xs) v' =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "have \"is_trail v (x#xs) v'\\<longleftrightarrow>(is_path v (x#xs) v'\\<and> distinct (x#xs) \n                  \\<and> (set (x#xs) \\<inter> set (rev_path (x#xs))={}))\""], ["proof (prove)\nusing this:\n  is_trail v (x # xs) v' =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})\n\ngoal (1 subgoal):\n 1. is_trail v (x # xs) v' =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "."], ["proof (state)\nthis:\n  is_trail v (x # xs) v' =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       (\\<And>v.\n           is_trail v ps v' =\n           (is_path v ps v' \\<and>\n            distinct ps \\<and>\n            set ps \\<inter> set (rev_path ps) = {})) \\<Longrightarrow>\n       is_trail v (a # ps) v' =\n       (is_path v (a # ps) v' \\<and>\n        distinct (a # ps) \\<and>\n        set (a # ps) \\<inter> set (rev_path (a # ps)) = {})", "thus ?case"], ["proof (prove)\nusing this:\n  is_trail v (x # xs) v' =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})\n\ngoal (1 subgoal):\n 1. is_trail v (x # xs) v' =\n    (is_path v (x # xs) v' \\<and>\n     distinct (x # xs) \\<and>\n     set (x # xs) \\<inter> set (rev_path (x # xs)) = {})", "."], ["proof (state)\nthis:\n  is_trail v (x # xs) v' =\n  (is_path v (x # xs) v' \\<and>\n   distinct (x # xs) \\<and>\n   set (x # xs) \\<inter> set (rev_path (x # xs)) = {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  (in valid_unMultigraph) is_trail_rev: \n    \"is_trail v' (rev_path ps) v \\<longleftrightarrow> is_trail v ps v' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v' (rev_path ps) v = is_trail v ps v'", "using rev_path_append is_trail_path  is_path_rev distinct_rev_path"], ["proof (prove)\nusing this:\n  rev_path (?xs @ ?ys) = rev_path ?ys @ rev_path ?xs\n  is_trail ?v ?ps ?v' =\n  (is_path ?v ?ps ?v' \\<and>\n   distinct ?ps \\<and> set ?ps \\<inter> set (rev_path ?ps) = {})\n  is_path ?v' (rev_path ?ps) ?v = is_path ?v ?ps ?v'\n  distinct (rev_path ?ps) = distinct ?ps\n\ngoal (1 subgoal):\n 1. is_trail v' (rev_path ps) v = is_trail v ps v'", "by (metis Int_commute distinct_append)"], ["", "lemma (in valid_unMultigraph) is_trail_intro[intro]:\n  \"is_trail v' ps v \\<Longrightarrow> is_path v' ps v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v' ps v \\<Longrightarrow> is_path v' ps v", "by (induct ps arbitrary:v',auto)"], ["", "lemma (in valid_unMultigraph) is_trail_split:\n      \"is_trail v (p1@p2) v' \\<Longrightarrow> (\\<exists>u. is_trail v p1 u \\<and> is_trail u p2 v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v (p1 @ p2) v' \\<Longrightarrow>\n    \\<exists>u. is_trail v p1 u \\<and> is_trail u p2 v'", "apply (induct p1 arbitrary: v,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. is_trail v p2 v' \\<Longrightarrow> v \\<in> V", "apply (metis is_trail_intro is_path_memb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in valid_unMultigraph) is_trail_split':\"is_trail v (p1@(u,w,u')#p2) v' \n    \\<Longrightarrow> is_trail v p1 u \\<and> (u,w,u')\\<in>E \\<and> is_trail u' p2 v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v (p1 @ (u, w, u') # p2) v' \\<Longrightarrow>\n    is_trail v p1 u \\<and> (u, w, u') \\<in> E \\<and> is_trail u' p2 v'", "by (metis is_trail.simps(2) is_trail_split)"], ["", "lemma (in valid_unMultigraph) distinct_elim[simp]:\n  assumes \"is_trail v ((v1,w,v2)#ps) v'\" \n  shows \"(v1,w,v2)\\<in>edges(rem_unPath ps G) \\<longleftrightarrow> (v1,w,v2)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v1, w, v2) \\<in> edges (rem_unPath ps G)) = ((v1, w, v2) \\<in> E)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (v1, w, v2) \\<in> edges (rem_unPath ps G) \\<Longrightarrow>\n    (v1, w, v2) \\<in> E\n 2. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "assume \"(v1, w, v2) \\<in> edges (rem_unPath ps G)\""], ["proof (state)\nthis:\n  (v1, w, v2) \\<in> edges (rem_unPath ps G)\n\ngoal (2 subgoals):\n 1. (v1, w, v2) \\<in> edges (rem_unPath ps G) \\<Longrightarrow>\n    (v1, w, v2) \\<in> E\n 2. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "thus \"(v1, w, v2) \\<in> E\""], ["proof (prove)\nusing this:\n  (v1, w, v2) \\<in> edges (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E", "by (metis assms is_trail.simps(2))"], ["proof (state)\nthis:\n  (v1, w, v2) \\<in> E\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "assume \"(v1, w, v2) \\<in> E\""], ["proof (state)\nthis:\n  (v1, w, v2) \\<in> E\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "have \"(v1,w,v2)\\<notin>set ps \\<and> (v2,w,v1)\\<notin>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<notin> set ps \\<and> (v2, w, v1) \\<notin> set ps", "by (metis assms is_trail.simps(2))"], ["proof (state)\nthis:\n  (v1, w, v2) \\<notin> set ps \\<and> (v2, w, v1) \\<notin> set ps\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "hence \"(v1,w,v2)\\<notin>set ps \\<and> (v1,w,v2)\\<notin>set (rev_path ps)\""], ["proof (prove)\nusing this:\n  (v1, w, v2) \\<notin> set ps \\<and> (v2, w, v1) \\<notin> set ps\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<notin> set ps \\<and>\n    (v1, w, v2) \\<notin> set (rev_path ps)", "by simp"], ["proof (state)\nthis:\n  (v1, w, v2) \\<notin> set ps \\<and> (v1, w, v2) \\<notin> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "hence \"(v1,w,v2)\\<notin>set ps \\<union> set (rev_path ps)\""], ["proof (prove)\nusing this:\n  (v1, w, v2) \\<notin> set ps \\<and> (v1, w, v2) \\<notin> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<notin> set ps \\<union> set (rev_path ps)", "by simp"], ["proof (state)\nthis:\n  (v1, w, v2) \\<notin> set ps \\<union> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "hence \"(v1,w,v2)\\<in>edges G - (set ps \\<union> set (rev_path ps))\""], ["proof (prove)\nusing this:\n  (v1, w, v2) \\<notin> set ps \\<union> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E - (set ps \\<union> set (rev_path ps))", "using \\<open>(v1, w, v2) \\<in> E\\<close>"], ["proof (prove)\nusing this:\n  (v1, w, v2) \\<notin> set ps \\<union> set (rev_path ps)\n  (v1, w, v2) \\<in> E\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E - (set ps \\<union> set (rev_path ps))", "by auto"], ["proof (state)\nthis:\n  (v1, w, v2) \\<in> E - (set ps \\<union> set (rev_path ps))\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> E \\<Longrightarrow>\n    (v1, w, v2) \\<in> edges (rem_unPath ps G)", "thus \"(v1,w,v2)\\<in>edges(rem_unPath ps G)\""], ["proof (prove)\nusing this:\n  (v1, w, v2) \\<in> E - (set ps \\<union> set (rev_path ps))\n\ngoal (1 subgoal):\n 1. (v1, w, v2) \\<in> edges (rem_unPath ps G)", "by (metis rem_unPath_edges)"], ["proof (state)\nthis:\n  (v1, w, v2) \\<in> edges (rem_unPath ps G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_path_subset:\n  assumes \"valid_unMultigraph G1\" \"valid_unMultigraph G2\" \"edges G1 \\<subseteq>edges G2\" \"nodes G1 \\<subseteq>nodes G2\"\n  assumes distinct_G1:\"valid_unMultigraph.is_trail G1 v ps v'\"\n  shows \"valid_unMultigraph.is_trail G2 v ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G2 v ps v'", "using distinct_G1"], ["proof (prove)\nusing this:\n  valid_unMultigraph.is_trail G1 v ps v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G2 v ps v'", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       valid_unMultigraph.is_trail G1 v [] v' \\<Longrightarrow>\n       valid_unMultigraph.is_trail G2 v [] v'\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "case Nil"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G1 v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       valid_unMultigraph.is_trail G1 v [] v' \\<Longrightarrow>\n       valid_unMultigraph.is_trail G2 v [] v'\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "hence \"v=v'\\<and>v'\\<in>nodes G1\""], ["proof (prove)\nusing this:\n  valid_unMultigraph.is_trail G1 v [] v'\n\ngoal (1 subgoal):\n 1. v = v' \\<and> v' \\<in> nodes G1", "by (metis (full_types) assms(1) valid_unMultigraph.is_trail.simps(1))"], ["proof (state)\nthis:\n  v = v' \\<and> v' \\<in> nodes G1\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       valid_unMultigraph.is_trail G1 v [] v' \\<Longrightarrow>\n       valid_unMultigraph.is_trail G2 v [] v'\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "hence \"v=v'\\<and>v'\\<in>nodes G2\""], ["proof (prove)\nusing this:\n  v = v' \\<and> v' \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. v = v' \\<and> v' \\<in> nodes G2", "using \\<open>nodes G1 \\<subseteq> nodes G2\\<close>"], ["proof (prove)\nusing this:\n  v = v' \\<and> v' \\<in> nodes G1\n  nodes G1 \\<subseteq> nodes G2\n\ngoal (1 subgoal):\n 1. v = v' \\<and> v' \\<in> nodes G2", "by auto"], ["proof (state)\nthis:\n  v = v' \\<and> v' \\<in> nodes G2\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       valid_unMultigraph.is_trail G1 v [] v' \\<Longrightarrow>\n       valid_unMultigraph.is_trail G2 v [] v'\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "thus ?case"], ["proof (prove)\nusing this:\n  v = v' \\<and> v' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G2 v [] v'", "by (metis assms(2) valid_unMultigraph.is_trail.simps(1))"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G2 v [] v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "case (Cons x xs)"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G1 ?v xs v' \\<Longrightarrow>\n  valid_unMultigraph.is_trail G2 ?v xs v'\n  valid_unMultigraph.is_trail G1 v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "hence \"valid_unMultigraph.is_trail G1 x3 xs v'\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G1 x3 xs v'", "by (metis Cons.prems assms(1) valid_unMultigraph.is_trail.simps(2))"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G1 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "hence \"valid_unMultigraph.is_trail G2 x3 xs v'\""], ["proof (prove)\nusing this:\n  valid_unMultigraph.is_trail G1 x3 xs v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G2 x3 xs v'", "using Cons"], ["proof (prove)\nusing this:\n  valid_unMultigraph.is_trail G1 x3 xs v'\n  valid_unMultigraph.is_trail G1 ?v xs v' \\<Longrightarrow>\n  valid_unMultigraph.is_trail G2 ?v xs v'\n  valid_unMultigraph.is_trail G1 v (x # xs) v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G2 x3 xs v'", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G2 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "moreover"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G2 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "have \"x\\<in>edges G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> edges G1", "by (metis Cons.prems assms(1) valid_unMultigraph.is_trail.simps(2) x)"], ["proof (state)\nthis:\n  x \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "hence \"x\\<in>edges G2\""], ["proof (prove)\nusing this:\n  x \\<in> edges G1\n\ngoal (1 subgoal):\n 1. x \\<in> edges G2", "using \\<open>edges G1 \\<subseteq> edges G2\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> edges G1\n  edges G1 \\<subseteq> edges G2\n\ngoal (1 subgoal):\n 1. x \\<in> edges G2", "by auto"], ["proof (state)\nthis:\n  x \\<in> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "moreover"], ["proof (state)\nthis:\n  x \\<in> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "have \"v=x1\\<and>(x1,x2,x3)\\<notin>set xs\\<and>(x3,x2,x1)\\<notin>set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = x1 \\<and>\n    (x1, x2, x3) \\<notin> set xs \\<and> (x3, x2, x1) \\<notin> set xs", "by (metis Cons.prems assms(1) valid_unMultigraph.is_trail.simps(2) x)"], ["proof (state)\nthis:\n  v = x1 \\<and>\n  (x1, x2, x3) \\<notin> set xs \\<and> (x3, x2, x1) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "hence \"v=x1\" \"(x1,x2,x3)\\<notin>set xs\" \"(x3,x2,x1)\\<notin>set xs\""], ["proof (prove)\nusing this:\n  v = x1 \\<and>\n  (x1, x2, x3) \\<notin> set xs \\<and> (x3, x2, x1) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. v = x1 &&& (x1, x2, x3) \\<notin> set xs &&& (x3, x2, x1) \\<notin> set xs", "by auto"], ["proof (state)\nthis:\n  v = x1\n  (x1, x2, x3) \\<notin> set xs\n  (x3, x2, x1) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   valid_unMultigraph.is_trail G1 v ps v' \\<Longrightarrow>\n                   valid_unMultigraph.is_trail G2 v ps v';\n        valid_unMultigraph.is_trail G1 v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_unMultigraph.is_trail G2 v (a # ps) v'", "ultimately"], ["proof (chain)\npicking this:\n  valid_unMultigraph.is_trail G2 x3 xs v'\n  x \\<in> edges G2\n  v = x1\n  (x1, x2, x3) \\<notin> set xs\n  (x3, x2, x1) \\<notin> set xs", "show ?case"], ["proof (prove)\nusing this:\n  valid_unMultigraph.is_trail G2 x3 xs v'\n  x \\<in> edges G2\n  v = x1\n  (x1, x2, x3) \\<notin> set xs\n  (x3, x2, x1) \\<notin> set xs\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.is_trail G2 v (x # xs) v'", "by (metis assms(2) valid_unMultigraph.is_trail.simps(2) x)"], ["proof (state)\nthis:\n  valid_unMultigraph.is_trail G2 v (x # xs) v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) distinct_path_intro':\n  assumes \"valid_unMultigraph.is_trail (rem_unPath p G) v ps v'\"\n  shows \"is_trail  v ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v ps v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_trail v ps v'", "have valid:\"valid_unMultigraph (rem_unPath p G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath p G)", "using rem_unPath_valid[OF valid_unMultigraph_axioms,of p]"], ["proof (prove)\nusing this:\n  valid_unMultigraph (rem_unPath p G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath p G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath p G)\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "moreover"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath p G)\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "have \"nodes (rem_unPath p G) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (rem_unPath p G) \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  nodes (rem_unPath p G) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "moreover"], ["proof (state)\nthis:\n  nodes (rem_unPath p G) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "have \"edges (rem_unPath p G) \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (rem_unPath p G) \\<subseteq> E", "using rem_unPath_edges"], ["proof (prove)\nusing this:\n  edges (rem_unPath ?ps ?G) =\n  edges ?G - (set ?ps \\<union> set (rev_path ?ps))\n\ngoal (1 subgoal):\n 1. edges (rem_unPath p G) \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  edges (rem_unPath p G) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "ultimately"], ["proof (chain)\npicking this:\n  valid_unMultigraph (rem_unPath p G)\n  nodes (rem_unPath p G) \\<subseteq> V\n  edges (rem_unPath p G) \\<subseteq> E", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_unMultigraph (rem_unPath p G)\n  nodes (rem_unPath p G) \\<subseteq> V\n  edges (rem_unPath p G) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "using distinct_path_subset[of \"rem_unPath p G\" G] valid_unMultigraph_axioms assms"], ["proof (prove)\nusing this:\n  valid_unMultigraph (rem_unPath p G)\n  nodes (rem_unPath p G) \\<subseteq> V\n  edges (rem_unPath p G) \\<subseteq> E\n  \\<lbrakk>valid_unMultigraph (rem_unPath p G); valid_unMultigraph G;\n   edges (rem_unPath p G) \\<subseteq> E;\n   nodes (rem_unPath p G) \\<subseteq> V;\n   valid_unMultigraph.is_trail (rem_unPath p G) ?v ?ps ?v'\\<rbrakk>\n  \\<Longrightarrow> is_trail ?v ?ps ?v'\n  valid_unMultigraph G\n  valid_unMultigraph.is_trail (rem_unPath p G) v ps v'\n\ngoal (1 subgoal):\n 1. is_trail v ps v'", "by auto"], ["proof (state)\nthis:\n  is_trail v ps v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) distinct_path_intro:\n  assumes \"valid_unMultigraph.is_trail (del_unEdge x1 x2 x3 G) v ps v'\"\n  shows \"is_trail  v ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v ps v'", "by (metis (full_types) assms distinct_path_intro' rem_unPath.simps(1) \n    rem_unPath.simps(2))"], ["", "lemma (in valid_unMultigraph) distinct_elim_rev[simp]:\n  assumes \"is_trail v ((v1,w,v2)#ps) v'\" \n  shows \"(v2,w,v1)\\<in>edges(rem_unPath ps G) \\<longleftrightarrow> (v2,w,v1)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "have  \"valid_unMultigraph (rem_unPath ps G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath ps G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath ps G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "hence \"(v2,w,v1)\\<in>edges(rem_unPath ps G)\\<longleftrightarrow>(v1,w,v2)\\<in>edges(rem_unPath ps G)\""], ["proof (prove)\nusing this:\n  valid_unMultigraph (rem_unPath ps G)\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) =\n    ((v1, w, v2) \\<in> edges (rem_unPath ps G))", "by (metis valid_unMultigraph.corres)"], ["proof (state)\nthis:\n  ((v2, w, v1) \\<in> edges (rem_unPath ps G)) =\n  ((v1, w, v2) \\<in> edges (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "moreover"], ["proof (state)\nthis:\n  ((v2, w, v1) \\<in> edges (rem_unPath ps G)) =\n  ((v1, w, v2) \\<in> edges (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "have \"(v2,w,v1)\\<in>E\\<longleftrightarrow>(v1,w,v2)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> E) = ((v1, w, v2) \\<in> E)", "using corres"], ["proof (prove)\nusing this:\n  ((?v, ?w, ?u') \\<in> E) = ((?u', ?w, ?v) \\<in> E)\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> E) = ((v1, w, v2) \\<in> E)", "by simp"], ["proof (state)\nthis:\n  ((v2, w, v1) \\<in> E) = ((v1, w, v2) \\<in> E)\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "ultimately"], ["proof (chain)\npicking this:\n  ((v2, w, v1) \\<in> edges (rem_unPath ps G)) =\n  ((v1, w, v2) \\<in> edges (rem_unPath ps G))\n  ((v2, w, v1) \\<in> E) = ((v1, w, v2) \\<in> E)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((v2, w, v1) \\<in> edges (rem_unPath ps G)) =\n  ((v1, w, v2) \\<in> edges (rem_unPath ps G))\n  ((v2, w, v1) \\<in> E) = ((v1, w, v2) \\<in> E)\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "using distinct_elim"], ["proof (prove)\nusing this:\n  ((v2, w, v1) \\<in> edges (rem_unPath ps G)) =\n  ((v1, w, v2) \\<in> edges (rem_unPath ps G))\n  ((v2, w, v1) \\<in> E) = ((v1, w, v2) \\<in> E)\n  is_trail ?v ((?v1.0, ?w, ?v2.0) # ?ps) ?v' \\<Longrightarrow>\n  ((?v1.0, ?w, ?v2.0) \\<in> edges (rem_unPath ?ps G)) =\n  ((?v1.0, ?w, ?v2.0) \\<in> E)\n\ngoal (1 subgoal):\n 1. ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)", "by (metis assms)"], ["proof (state)\nthis:\n  ((v2, w, v1) \\<in> edges (rem_unPath ps G)) = ((v2, w, v1) \\<in> E)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) del_UnEdge_even:\n  assumes \"(v,w,v') \\<in> E\" \"finite E\"\n  shows \"v\\<in>odd_nodes_set(del_unEdge v w v' G) \\<longleftrightarrow> even (degree v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "have \"degree v (del_unEdge v w v' G) + 1=degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v (del_unEdge v w v' G) + 1 = degree v G", "using del_edge_undirected_degree_plus corres"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (edges ?g); (?v, ?e, ?v') \\<in> edges ?g;\n   (?v', ?e, ?v) \\<in> edges ?g\\<rbrakk>\n  \\<Longrightarrow> degree ?v (del_unEdge ?v ?e ?v' ?g) + 1 = degree ?v ?g\n  ((?v, ?w, ?u') \\<in> E) = ((?u', ?w, ?v) \\<in> E)\n\ngoal (1 subgoal):\n 1. degree v (del_unEdge v w v' G) + 1 = degree v G", "by (metis assms)"], ["proof (state)\nthis:\n  degree v (del_unEdge v w v' G) + 1 = degree v G\n\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "from this [symmetric]"], ["proof (chain)\npicking this:\n  degree v G = degree v (del_unEdge v w v' G) + 1", "have \"odd (degree v (del_unEdge v w v' G)) = even (degree v G)\""], ["proof (prove)\nusing this:\n  degree v G = degree v (del_unEdge v w v' G) + 1\n\ngoal (1 subgoal):\n 1. odd (degree v (del_unEdge v w v' G)) = even (degree v G)", "by simp"], ["proof (state)\nthis:\n  odd (degree v (del_unEdge v w v' G)) = even (degree v G)\n\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "moreover"], ["proof (state)\nthis:\n  odd (degree v (del_unEdge v w v' G)) = even (degree v G)\n\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "have \"v\\<in>nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> nodes (del_unEdge v w v' G)", "by (metis E_validD(1) assms(1) del_UnEdge_node)"], ["proof (state)\nthis:\n  v \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "ultimately"], ["proof (chain)\npicking this:\n  odd (degree v (del_unEdge v w v' G)) = even (degree v G)\n  v \\<in> nodes (del_unEdge v w v' G)", "show ?thesis"], ["proof (prove)\nusing this:\n  odd (degree v (del_unEdge v w v' G)) = even (degree v G)\n  v \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  odd (degree v (del_unEdge v w v' G)) = even (degree v G)\n  v \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (v \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n              odd (degree va (del_unEdge v w v' G))}) =\n    even (degree v G)", "by auto"], ["proof (state)\nthis:\n  (v \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) del_UnEdge_even':\n  assumes \"(v,w,v') \\<in> E\" \"finite E\"\n  shows \"v'\\<in>odd_nodes_set(del_unEdge v w v' G) \\<longleftrightarrow> even (degree v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v' \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v' G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v' \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v' G)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v' \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v' G)", "by (metis (full_types) assms corres del_UnEdge_even delete_edge_sym)"], ["proof (state)\nthis:\n  (v' \\<in> odd_nodes_set (del_unEdge v w v' G)) = even (degree v' G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_UnEdge_even_even:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"even (degree v G)\" \"even (degree v' G)\"\n    shows \"num_of_odd_nodes(del_unEdge v w v' G)=num_of_odd_nodes G + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "interpret G:valid_unMultigraph"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have  \"v\\<in>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> odd_nodes_set (del_unEdge v w v' G)", "by (metis G.del_UnEdge_even assms(2) assms(4) parity_assms(1))"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have  \"v'\\<in>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> odd_nodes_set (del_unEdge v w v' G)", "by (metis G.del_UnEdge_even' assms(2) assms(4) parity_assms(2))"], ["proof (state)\nthis:\n  v' \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> odd_nodes_set (del_unEdge v w v' G)\n  v' \\<in> odd_nodes_set (del_unEdge v w v' G)", "have extra_odd_nodes:\"{v,v'} \\<subseteq> odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  v \\<in> odd_nodes_set (del_unEdge v w v' G)\n  v' \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  v \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))}\n  v' \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n            odd (degree va (del_unEdge v w v' G))}\n\ngoal (1 subgoal):\n 1. {v, v'}\n    \\<subseteq> {va \\<in> nodes (del_unEdge v w v' G).\n                 odd (degree va (del_unEdge v w v' G))}", "by auto"], ["proof (state)\nthis:\n  {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \"v \\<notin>odd_nodes_set G\" and \"v'\\<notin>odd_nodes_set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> odd_nodes_set G &&& v' \\<notin> odd_nodes_set G", "using parity_assms"], ["proof (prove)\nusing this:\n  even (degree v G)\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. v \\<notin> odd_nodes_set G &&& v' \\<notin> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  even (degree v G)\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. v \\<notin> {v \\<in> G.V. odd (degree v G)} &&&\n    v' \\<notin> {v \\<in> G.V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  v \\<notin> odd_nodes_set G\n  v' \\<notin> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "hence vv'_odd_disjoint: \"{v,v'} \\<inter> odd_nodes_set G = {}\""], ["proof (prove)\nusing this:\n  v \\<notin> odd_nodes_set G\n  v' \\<notin> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. {v, v'} \\<inter> odd_nodes_set G = {}", "by auto"], ["proof (state)\nthis:\n  {v, v'} \\<inter> odd_nodes_set G = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  {v, v'} \\<inter> odd_nodes_set G = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \"odd_nodes_set(del_unEdge v w v' G) -{v,v'}\\<subseteq>odd_nodes_set G \""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) - {v, v'}\n    \\<subseteq> odd_nodes_set G", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "assume x_odd_set: \"x \\<in> odd_nodes_set (del_unEdge v w v' G) - {v, v'}\""], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) - {v, v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "hence \"degree x (del_unEdge v w v' G) = degree x G\""], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) - {v, v'}\n\ngoal (1 subgoal):\n 1. degree x (del_unEdge v w v' G) = degree x G", "by (metis Diff_iff G.degree_frame assms(2))"], ["proof (state)\nthis:\n  degree x (del_unEdge v w v' G) = degree x G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "hence \"odd(degree x G)\""], ["proof (prove)\nusing this:\n  degree x (del_unEdge v w v' G) = degree x G\n\ngoal (1 subgoal):\n 1. odd (degree x G)", "using x_odd_set"], ["proof (prove)\nusing this:\n  degree x (del_unEdge v w v' G) = degree x G\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) - {v, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  degree x (del_unEdge v w v' G) = degree x G\n  x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))} -\n          {v, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x G)", "by auto"], ["proof (state)\nthis:\n  odd (degree x G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "moreover"], ["proof (state)\nthis:\n  odd (degree x G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "have \"x \\<in> nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> G.V", "using x_odd_set"], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) - {v, v'}\n\ngoal (1 subgoal):\n 1. x \\<in> G.V", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))} -\n          {v, v'}\n\ngoal (1 subgoal):\n 1. x \\<in> G.V", "by auto"], ["proof (state)\nthis:\n  x \\<in> G.V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) -\n               {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "ultimately"], ["proof (chain)\npicking this:\n  odd (degree x G)\n  x \\<in> G.V", "show \"x \\<in> odd_nodes_set G\""], ["proof (prove)\nusing this:\n  odd (degree x G)\n  x \\<in> G.V\n\ngoal (1 subgoal):\n 1. x \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  odd (degree x G)\n  x \\<in> G.V\n\ngoal (1 subgoal):\n 1. x \\<in> {v \\<in> G.V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) - {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) - {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \"odd_nodes_set G \\<subseteq> odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set G \\<subseteq> odd_nodes_set (del_unEdge v w v' G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "assume x_odd_set:  \"x \\<in> odd_nodes_set G\""], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> odd(degree x (del_unEdge v w v' G))\""], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    odd (degree x (del_unEdge v w v' G))", "by (metis (lifting) G.degree_frame assms(2) mem_Collect_eq odd_nodes_set_def)"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> x\\<in>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "using x_odd_set del_UnEdge_node"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x (del_unEdge v w v' G))\n  x \\<in> odd_nodes_set G\n  (?v \\<in> nodes (del_unEdge ?u ?e ?u' ?G)) = (?v \\<in> nodes ?G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x (del_unEdge v w v' G))\n  x \\<in> {v \\<in> G.V. odd (degree v G)}\n  (?v \\<in> nodes (del_unEdge ?u ?e ?u' ?G)) = (?v \\<in> nodes ?G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n             odd (degree va (del_unEdge v w v' G))}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "moreover"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "have \"x\\<in>{v,v'} \\<Longrightarrow> x\\<in>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "using extra_odd_nodes"], ["proof (prove)\nusing this:\n  {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<in> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  x \\<in> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n  x \\<in> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)", "show \"x \\<in> odd_nodes_set (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n  x \\<in> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<in> odd_nodes_set (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_nodes_set G \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "ultimately"], ["proof (chain)\npicking this:\n  {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n  {v, v'} \\<inter> odd_nodes_set G = {}\n  odd_nodes_set (del_unEdge v w v' G) - {v, v'} \\<subseteq> odd_nodes_set G\n  odd_nodes_set G \\<subseteq> odd_nodes_set (del_unEdge v w v' G)", "have \"odd_nodes_set(del_unEdge v w v' G)=odd_nodes_set G \\<union> {v,v'}\""], ["proof (prove)\nusing this:\n  {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n  {v, v'} \\<inter> odd_nodes_set G = {}\n  odd_nodes_set (del_unEdge v w v' G) - {v, v'} \\<subseteq> odd_nodes_set G\n  odd_nodes_set G \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}", "by auto"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "thus \"num_of_odd_nodes(del_unEdge v w v' G) = num_of_odd_nodes G + 2\""], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "assume \"odd_nodes_set(del_unEdge v w v' G)=odd_nodes_set G \\<union> {v,v'}\""], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \"v\\<noteq>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "using G.no_id \\<open>(v,w,v')\\<in>edges G\\<close>"], ["proof (prove)\nusing this:\n  (?v, ?w, ?v) \\<notin> G.E\n  (v, w, v') \\<in> G.E\n\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "hence \"card{v,v'}=2\""], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. card {v, v'} = 2", "by simp"], ["proof (state)\nthis:\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \" odd_nodes_set G \\<inter> {v,v'} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set G \\<inter> {v, v'} = {}", "using vv'_odd_disjoint"], ["proof (prove)\nusing this:\n  {v, v'} \\<inter> odd_nodes_set G = {}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G \\<inter> {v, v'} = {}", "by auto"], ["proof (state)\nthis:\n  odd_nodes_set G \\<inter> {v, v'} = {}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set G \\<inter> {v, v'} = {}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \"finite(odd_nodes_set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "by (metis (lifting) assms(3) mem_Collect_eq odd_nodes_set_def rev_finite_subset subsetI)"], ["proof (state)\nthis:\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "moreover"], ["proof (state)\nthis:\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "have \"finite {v,v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v, v'}", "by auto"], ["proof (state)\nthis:\n  finite {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) =\n    odd_nodes_set G \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "ultimately"], ["proof (chain)\npicking this:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n  card {v, v'} = 2\n  odd_nodes_set G \\<inter> {v, v'} = {}\n  finite (odd_nodes_set G)\n  finite {v, v'}", "show ?thesis"], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n  card {v, v'} = 2\n  odd_nodes_set G \\<inter> {v, v'} = {}\n  finite (odd_nodes_set G)\n  finite {v, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2", "unfolding num_of_odd_nodes_def"], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n  card {v, v'} = 2\n  odd_nodes_set G \\<inter> {v, v'} = {}\n  finite (odd_nodes_set G)\n  finite {v, v'}\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set (del_unEdge v w v' G)) = card (odd_nodes_set G) + 2", "using card_Un_disjoint"], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) = odd_nodes_set G \\<union> {v, v'}\n  card {v, v'} = 2\n  odd_nodes_set G \\<inter> {v, v'} = {}\n  finite (odd_nodes_set G)\n  finite {v, v'}\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> card (?A \\<union> ?B) = card ?A + card ?B\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set (del_unEdge v w v' G)) = card (odd_nodes_set G) + 2", "by metis"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_UnEdge_even_odd:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"even (degree v G)\" \"odd (degree v' G)\"\n    shows \"num_of_odd_nodes(del_unEdge v w v' G)=num_of_odd_nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "interpret G : valid_unMultigraph"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have odd_v:\"v\\<in>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> odd_nodes_set (del_unEdge v w v' G)", "by (metis G.del_UnEdge_even assms(2) assms(4) parity_assms(1))"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have  not_odd_v':\"v'\\<notin>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<notin> odd_nodes_set (del_unEdge v w v' G)", "by (metis G.del_UnEdge_even' assms(2) assms(4) parity_assms(2))"], ["proof (state)\nthis:\n  v' \\<notin> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have \"odd_nodes_set(del_unEdge v w v' G) \\<union> {v'} \\<subseteq>odd_nodes_set G \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n    \\<subseteq> odd_nodes_set G \\<union> {v}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "assume x_prems:\" x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\""], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "have \"x=v' \\<Longrightarrow>x\\<in>odd_nodes_set G \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = v' \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}", "using parity_assms"], ["proof (prove)\nusing this:\n  even (degree v G)\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. x = v' \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}", "by (metis (lifting) G.E_validD(2) Un_def assms(4) mem_Collect_eq odd_nodes_set_def )"], ["proof (state)\nthis:\n  x = v' \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "moreover"], ["proof (state)\nthis:\n  x = v' \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "have \"x=v \\<Longrightarrow> x\\<in>odd_nodes_set G \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}", "by (metis insertI1 insert_is_Un sup_commute)"], ["proof (state)\nthis:\n  x = v \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "moreover"], ["proof (state)\nthis:\n  x = v \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "have \"x\\<notin>{v,v'} \\<Longrightarrow> x \\<in> odd_nodes_set (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "using x_prems"], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))}\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> {v \\<in> G.V. odd (degree v G)}", "using G.degree_frame \\<open>finite (edges G)\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))}\n  \\<lbrakk>finite G.E; ?x \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> degree ?x (del_unEdge ?v ?w ?v' G) = degree ?x G\n  finite G.E\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> {v \\<in> G.V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> x\\<in>odd_nodes_set G \\<union> {v}\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set G \\<union> {v}", "by simp"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union>\n               {v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set G \\<union> {v}", "ultimately"], ["proof (chain)\npicking this:\n  x = v' \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n  x = v \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}", "show \"x \\<in> odd_nodes_set G \\<union> {v}\""], ["proof (prove)\nusing this:\n  x = v' \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n  x = v \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. x \\<in> odd_nodes_set G \\<union> {v}", "by auto"], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  \\<subseteq> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  \\<subseteq> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have \"odd_nodes_set G \\<union> {v} \\<subseteq> odd_nodes_set(del_unEdge v w v' G) \\<union> {v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set G \\<union> {v}\n    \\<subseteq> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "assume x_prems: \"x \\<in> odd_nodes_set G \\<union> {v}\""], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "have \"x=v \\<Longrightarrow> x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "by (metis UnI1 odd_v)"], ["proof (state)\nthis:\n  x = v \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "moreover"], ["proof (state)\nthis:\n  x = v \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "have \"x=v' \\<Longrightarrow> x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = v' \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "by auto"], ["proof (state)\nthis:\n  x = v' \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "moreover"], ["proof (state)\nthis:\n  x = v' \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "have \"x\\<notin>{v,v'} \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set G \\<union> {v}", "using x_prems"], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set G \\<union> {v}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "hence \"x\\<notin>{v,v'} \\<Longrightarrow>  x\\<in>odd_nodes_set (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> {v \\<in> G.V. odd (degree v G)} \\<union> {v}\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n             odd (degree va (del_unEdge v w v' G))}", "using G.degree_frame \\<open>finite (edges G)\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> {v \\<in> G.V. odd (degree v G)} \\<union> {v}\n  \\<lbrakk>finite G.E; ?x \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> degree ?x (del_unEdge ?v ?w ?v' G) = degree ?x G\n  finite G.E\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n             odd (degree va (del_unEdge v w v' G))}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "by simp"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G \\<union> {v} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "ultimately"], ["proof (chain)\npicking this:\n  x = v \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  x = v' \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "show \"x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\""], ["proof (prove)\nusing this:\n  x = v \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  x = v' \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  x \\<notin> {v, v'} \\<Longrightarrow>\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "by auto"], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_nodes_set G \\<union> {v}\n  \\<subseteq> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "ultimately"], ["proof (chain)\npicking this:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  \\<subseteq> odd_nodes_set G \\<union> {v}\n  odd_nodes_set G \\<union> {v}\n  \\<subseteq> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}", "have \"odd_nodes_set(del_unEdge v w v' G) \\<union> {v'} = odd_nodes_set G \\<union> {v}\""], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n  \\<subseteq> odd_nodes_set G \\<union> {v}\n  odd_nodes_set G \\<union> {v}\n  \\<subseteq> odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) \\<union> {v'} =\n    odd_nodes_set G \\<union> {v}", "by auto"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'} =\n  odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'} =\n  odd_nodes_set G \\<union> {v}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have \" odd_nodes_set G \\<inter> {v} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set G \\<inter> {v} = {}", "using parity_assms"], ["proof (prove)\nusing this:\n  even (degree v G)\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. odd_nodes_set G \\<inter> {v} = {}", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  even (degree v G)\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. {v \\<in> G.V. odd (degree v G)} \\<inter> {v} = {}", "by auto"], ["proof (state)\nthis:\n  odd_nodes_set G \\<inter> {v} = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set G \\<inter> {v} = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have \" odd_nodes_set(del_unEdge v w v' G) \\<inter> {v'}={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}", "by (metis Int_insert_left_if0 inf_bot_left inf_commute not_odd_v')"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have \"finite (odd_nodes_set(del_unEdge v w v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (odd_nodes_set (del_unEdge v w v' G))", "using \\<open>finite (nodes G)\\<close>"], ["proof (prove)\nusing this:\n  finite G.V\n\ngoal (1 subgoal):\n 1. finite (odd_nodes_set (del_unEdge v w v' G))", "by auto"], ["proof (state)\nthis:\n  finite (odd_nodes_set (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "moreover"], ["proof (state)\nthis:\n  finite (odd_nodes_set (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "have \"finite (odd_nodes_set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "using \\<open>finite (nodes G)\\<close>"], ["proof (prove)\nusing this:\n  finite G.V\n\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "by auto"], ["proof (state)\nthis:\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "ultimately"], ["proof (chain)\npicking this:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'} =\n  odd_nodes_set G \\<union> {v}\n  odd_nodes_set G \\<inter> {v} = {}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite (odd_nodes_set G)", "have \"card(odd_nodes_set G) + card {v} = \n                   card(odd_nodes_set(del_unEdge v w v' G)) + card {v'}\""], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'} =\n  odd_nodes_set G \\<union> {v}\n  odd_nodes_set G \\<inter> {v} = {}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set G) + card {v} =\n    card (odd_nodes_set (del_unEdge v w v' G)) + card {v'}", "using card_Un_disjoint[of \"odd_nodes_set (del_unEdge v w v' G)\" \"{v'}\"] \n      card_Un_disjoint[of \"odd_nodes_set G\" \"{v}\"]"], ["proof (prove)\nusing this:\n  odd_nodes_set (del_unEdge v w v' G) \\<union> {v'} =\n  odd_nodes_set G \\<union> {v}\n  odd_nodes_set G \\<inter> {v} = {}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite (odd_nodes_set G)\n  \\<lbrakk>finite (odd_nodes_set (del_unEdge v w v' G)); finite {v'};\n   odd_nodes_set (del_unEdge v w v' G) \\<inter> {v'} = {}\\<rbrakk>\n  \\<Longrightarrow> card\n                     (odd_nodes_set (del_unEdge v w v' G) \\<union> {v'}) =\n                    card (odd_nodes_set (del_unEdge v w v' G)) + card {v'}\n  \\<lbrakk>finite (odd_nodes_set G); finite {v};\n   odd_nodes_set G \\<inter> {v} = {}\\<rbrakk>\n  \\<Longrightarrow> card (odd_nodes_set G \\<union> {v}) =\n                    card (odd_nodes_set G) + card {v}\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set G) + card {v} =\n    card (odd_nodes_set (del_unEdge v w v' G)) + card {v'}", "by auto"], ["proof (state)\nthis:\n  card (odd_nodes_set G) + card {v} =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "thus ?thesis"], ["proof (prove)\nusing this:\n  card (odd_nodes_set G) + card {v} =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "unfolding num_of_odd_nodes_def"], ["proof (prove)\nusing this:\n  card (odd_nodes_set G) + card {v} =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v'}\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set (del_unEdge v w v' G)) = card (odd_nodes_set G)", "by simp"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_UnEdge_odd_even:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"odd (degree v G)\" \"even (degree v' G)\"\n    shows \"num_of_odd_nodes(del_unEdge v w v' G)=num_of_odd_nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v w v' G) = num_of_odd_nodes G", "by (metis assms del_UnEdge_even_odd delete_edge_sym parity_assms valid_unMultigraph.corres)"], ["", "lemma del_UnEdge_odd_odd:\n    assumes \"valid_unMultigraph G\" \"finite(edges G)\" \"finite(nodes G)\" \"(v, w, v')\\<in>edges G\"\n    assumes parity_assms: \"odd (degree v G)\" \"odd (degree v' G)\"\n    shows \"num_of_odd_nodes G=num_of_odd_nodes(del_unEdge v w v' G)+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "interpret G:valid_unMultigraph"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have  \"v\\<notin>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> odd_nodes_set (del_unEdge v w v' G)", "by (metis G.del_UnEdge_even assms(2) assms(4) parity_assms(1))"], ["proof (state)\nthis:\n  v \\<notin> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  v \\<notin> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have  \"v'\\<notin>odd_nodes_set(del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<notin> odd_nodes_set (del_unEdge v w v' G)", "by (metis G.del_UnEdge_even' assms(2) assms(4) parity_assms(2))"], ["proof (state)\nthis:\n  v' \\<notin> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "ultimately"], ["proof (chain)\npicking this:\n  v \\<notin> odd_nodes_set (del_unEdge v w v' G)\n  v' \\<notin> odd_nodes_set (del_unEdge v w v' G)", "have vv'_disjoint: \"{v,v'} \\<inter> odd_nodes_set(del_unEdge v w v' G) = {}\""], ["proof (prove)\nusing this:\n  v \\<notin> odd_nodes_set (del_unEdge v w v' G)\n  v' \\<notin> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. {v, v'} \\<inter> odd_nodes_set (del_unEdge v w v' G) = {}", "by (metis (full_types) Int_insert_left_if0 inf_bot_left)"], ["proof (state)\nthis:\n  {v, v'} \\<inter> odd_nodes_set (del_unEdge v w v' G) = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  {v, v'} \\<inter> odd_nodes_set (del_unEdge v w v' G) = {}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have extra_odd_nodes:\"{v,v'} \\<subseteq> odd_nodes_set( G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v, v'} \\<subseteq> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v, v'} \\<subseteq> {v \\<in> G.V. odd (degree v G)}", "using \\<open>(v,w,v')\\<in>edges G\\<close>"], ["proof (prove)\nusing this:\n  (v, w, v') \\<in> G.E\n\ngoal (1 subgoal):\n 1. {v, v'} \\<subseteq> {v \\<in> G.V. odd (degree v G)}", "by (metis (lifting) G.E_validD empty_subsetI insert_subset mem_Collect_eq parity_assms)"], ["proof (state)\nthis:\n  {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have \"odd_nodes_set G -{v,v'}\\<subseteq>odd_nodes_set (del_unEdge v w v' G) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set G - {v, v'}\n    \\<subseteq> odd_nodes_set (del_unEdge v w v' G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "assume x_odd_set: \"x \\<in> odd_nodes_set G - {v, v'}\""], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set G - {v, v'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "hence \"degree x G = degree x (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set G - {v, v'}\n\ngoal (1 subgoal):\n 1. degree x G = degree x (del_unEdge v w v' G)", "by (metis Diff_iff G.degree_frame assms(2))"], ["proof (state)\nthis:\n  degree x G = degree x (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "hence \"odd(degree x (del_unEdge v w v' G))\""], ["proof (prove)\nusing this:\n  degree x G = degree x (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. odd (degree x (del_unEdge v w v' G))", "using x_odd_set"], ["proof (prove)\nusing this:\n  degree x G = degree x (del_unEdge v w v' G)\n  x \\<in> odd_nodes_set G - {v, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x (del_unEdge v w v' G))", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  degree x G = degree x (del_unEdge v w v' G)\n  x \\<in> {v \\<in> G.V. odd (degree v G)} - {v, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x (del_unEdge v w v' G))", "by auto"], ["proof (state)\nthis:\n  odd (degree x (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "moreover"], ["proof (state)\nthis:\n  odd (degree x (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "have \"x \\<in> nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> nodes (del_unEdge v w v' G)", "using x_odd_set"], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set G - {v, v'}\n\ngoal (1 subgoal):\n 1. x \\<in> nodes (del_unEdge v w v' G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<in> {v \\<in> G.V. odd (degree v G)} - {v, v'}\n\ngoal (1 subgoal):\n 1. x \\<in> nodes (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  x \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set G - {v, v'} \\<Longrightarrow>\n       x \\<in> odd_nodes_set (del_unEdge v w v' G)", "ultimately"], ["proof (chain)\npicking this:\n  odd (degree x (del_unEdge v w v' G))\n  x \\<in> nodes (del_unEdge v w v' G)", "show \"x \\<in> odd_nodes_set (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  odd (degree x (del_unEdge v w v' G))\n  x \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<in> odd_nodes_set (del_unEdge v w v' G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  odd (degree x (del_unEdge v w v' G))\n  x \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n             odd (degree va (del_unEdge v w v' G))}", "by auto"], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_nodes_set G - {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set G - {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have \"odd_nodes_set (del_unEdge v w v' G) \\<subseteq> odd_nodes_set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) \\<subseteq> odd_nodes_set G", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "assume x_odd_set:  \"x \\<in> odd_nodes_set (del_unEdge v w v' G)\""], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> odd(degree x G)\""], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)", "using assms G.degree_frame"], ["proof (prove)\nusing this:\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n  valid_unMultigraph G\n  finite G.E\n  finite G.V\n  (v, w, v') \\<in> G.E\n  odd (degree v G)\n  odd (degree v' G)\n  \\<lbrakk>finite G.E; ?x \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> degree ?x (del_unEdge ?v ?w ?v' G) = degree ?x G\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))}\n  valid_unMultigraph G\n  finite G.E\n  finite G.V\n  (v, w, v') \\<in> G.E\n  odd (degree v G)\n  odd (degree v' G)\n  \\<lbrakk>finite G.E; ?x \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> degree ?x (del_unEdge ?v ?w ?v' G) = degree ?x G\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "hence \"x\\<notin>{v,v'} \\<Longrightarrow> x\\<in>odd_nodes_set G\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G", "using x_odd_set del_UnEdge_node"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)\n  x \\<in> odd_nodes_set (del_unEdge v w v' G)\n  (?v \\<in> nodes (del_unEdge ?u ?e ?u' ?G)) = (?v \\<in> nodes ?G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> odd (degree x G)\n  x \\<in> {va \\<in> nodes (del_unEdge v w v' G).\n           odd (degree va (del_unEdge v w v' G))}\n  (?v \\<in> nodes (del_unEdge ?u ?e ?u' ?G)) = (?v \\<in> nodes ?G)\n\ngoal (1 subgoal):\n 1. x \\<notin> {v, v'} \\<Longrightarrow>\n    x \\<in> {v \\<in> G.V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "moreover"], ["proof (state)\nthis:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "have \"x\\<in>{v,v'} \\<Longrightarrow> x\\<in>odd_nodes_set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G", "using extra_odd_nodes"], ["proof (prove)\nusing this:\n  {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. x \\<in> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G", "by auto"], ["proof (state)\nthis:\n  x \\<in> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> odd_nodes_set (del_unEdge v w v' G) \\<Longrightarrow>\n       x \\<in> odd_nodes_set G", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n  x \\<in> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G", "show \"x \\<in> odd_nodes_set G\""], ["proof (prove)\nusing this:\n  x \\<notin> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n  x \\<in> {v, v'} \\<Longrightarrow> x \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. x \\<in> odd_nodes_set G", "by auto"], ["proof (state)\nthis:\n  x \\<in> odd_nodes_set G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "ultimately"], ["proof (chain)\npicking this:\n  {v, v'} \\<inter> odd_nodes_set (del_unEdge v w v' G) = {}\n  {v, v'} \\<subseteq> odd_nodes_set G\n  odd_nodes_set G - {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n  odd_nodes_set (del_unEdge v w v' G) \\<subseteq> odd_nodes_set G", "have \"odd_nodes_set G=odd_nodes_set (del_unEdge v w v' G) \\<union> {v,v'}\""], ["proof (prove)\nusing this:\n  {v, v'} \\<inter> odd_nodes_set (del_unEdge v w v' G) = {}\n  {v, v'} \\<subseteq> odd_nodes_set G\n  odd_nodes_set G - {v, v'} \\<subseteq> odd_nodes_set (del_unEdge v w v' G)\n  odd_nodes_set (del_unEdge v w v' G) \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}", "by auto"], ["proof (state)\nthis:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "assume \"odd_nodes_set G=odd_nodes_set (del_unEdge v w v' G) \\<union> {v,v'}\""], ["proof (state)\nthis:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have \" odd_nodes_set (del_unEdge v w v' G) \\<inter> {v,v'} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}", "using vv'_disjoint"], ["proof (prove)\nusing this:\n  {v, v'} \\<inter> odd_nodes_set (del_unEdge v w v' G) = {}\n\ngoal (1 subgoal):\n 1. odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}", "by auto"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have \"finite(odd_nodes_set (del_unEdge v w v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (odd_nodes_set (del_unEdge v w v' G))", "using assms del_UnEdge_node finite_subset"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n  finite G.E\n  finite G.V\n  (v, w, v') \\<in> G.E\n  odd (degree v G)\n  odd (degree v' G)\n  (?v \\<in> nodes (del_unEdge ?u ?e ?u' ?G)) = (?v \\<in> nodes ?G)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (odd_nodes_set (del_unEdge v w v' G))", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n  finite G.E\n  finite G.V\n  (v, w, v') \\<in> G.E\n  odd (degree v G)\n  odd (degree v' G)\n  (?v \\<in> nodes (del_unEdge ?u ?e ?u' ?G)) = (?v \\<in> nodes ?G)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite\n     {va \\<in> nodes (del_unEdge v w v' G).\n      odd (degree va (del_unEdge v w v' G))}", "by auto"], ["proof (state)\nthis:\n  finite (odd_nodes_set (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  finite (odd_nodes_set (del_unEdge v w v' G))\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have \"finite {v,v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v, v'}", "by auto"], ["proof (state)\nthis:\n  finite {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "ultimately"], ["proof (chain)\npicking this:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite {v, v'}", "have \"card(odd_nodes_set G)\n                       = card(odd_nodes_set  (del_unEdge v w v' G)) + card{v,v'}\""], ["proof (prove)\nusing this:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite {v, v'}\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set G) =\n    card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}", "unfolding num_of_odd_nodes_def"], ["proof (prove)\nusing this:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite {v, v'}\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set G) =\n    card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}", "using card_Un_disjoint"], ["proof (prove)\nusing this:\n  odd_nodes_set G = odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'}\n  odd_nodes_set (del_unEdge v w v' G) \\<inter> {v, v'} = {}\n  finite (odd_nodes_set (del_unEdge v w v' G))\n  finite {v, v'}\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> card (?A \\<union> ?B) = card ?A + card ?B\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set G) =\n    card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}", "by metis"], ["proof (state)\nthis:\n  card (odd_nodes_set G) =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "moreover"], ["proof (state)\nthis:\n  card (odd_nodes_set G) =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "have \"v\\<noteq>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "using G.no_id \\<open>(v,w,v')\\<in>edges G\\<close>"], ["proof (prove)\nusing this:\n  (?v, ?w, ?v) \\<notin> G.E\n  (v, w, v') \\<in> G.E\n\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "hence \"card{v,v'}=2\""], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. card {v, v'} = 2", "by simp"], ["proof (state)\nthis:\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. odd_nodes_set G =\n    odd_nodes_set (del_unEdge v w v' G) \\<union> {v, v'} \\<Longrightarrow>\n    num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "ultimately"], ["proof (chain)\npicking this:\n  card (odd_nodes_set G) =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}\n  card {v, v'} = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  card (odd_nodes_set G) =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2", "unfolding num_of_odd_nodes_def"], ["proof (prove)\nusing this:\n  card (odd_nodes_set G) =\n  card (odd_nodes_set (del_unEdge v w v' G)) + card {v, v'}\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. card (odd_nodes_set G) = card (odd_nodes_set (del_unEdge v w v' G)) + 2", "by simp"], ["proof (state)\nthis:\n  num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G = num_of_odd_nodes (del_unEdge v w v' G) + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) rem_UnPath_parity_v': \n  assumes \"finite E\"  \"is_trail v ps v'\" \n  shows \"v\\<noteq>v' \\<longleftrightarrow> (odd (degree v' (rem_unPath ps G)) = even(degree v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath ps G)) = even (degree v' G))", "using assms"], ["proof (prove)\nusing this:\n  finite E\n  is_trail v ps v'\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath ps G)) = even (degree v' G))", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; is_trail v [] v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath [] G)) =\n                          even (degree v' G))\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "case Nil"], ["proof (state)\nthis:\n  finite E\n  is_trail v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; is_trail v [] v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath [] G)) =\n                          even (degree v' G))\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "thus ?case"], ["proof (prove)\nusing this:\n  finite E\n  is_trail v [] v'\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath [] G)) = even (degree v' G))", "by (metis is_trail.simps(1) rem_unPath.simps(1))"], ["proof (state)\nthis:\n  (v \\<noteq> v') = (odd (degree v' (rem_unPath [] G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>finite E; is_trail ?v xs v'\\<rbrakk>\n  \\<Longrightarrow> (?v \\<noteq> v') =\n                    (odd (degree v' (rem_unPath xs G)) = even (degree v' G))\n  finite E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "print_cases"], ["proof (state)\nthis:\n  \\<lbrakk>finite E; is_trail ?v xs v'\\<rbrakk>\n  \\<Longrightarrow> (?v \\<noteq> v') =\n                    (odd (degree v' (rem_unPath xs G)) = even (degree v' G))\n  finite E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "obtain x1 x2 x3 where x: \"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "hence rem_x:\"odd (degree v' (rem_unPath (x#xs) G)) = odd(degree v' (del_unEdge\n            x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "by (metis  rem_unPath.simps(2) rem_unPath_com)"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "have \"x3=v' \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x3 = v' \\<Longrightarrow>\n    (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "proof (cases \"v=v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 = v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "case True"], ["proof (state)\nthis:\n  v = v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 = v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "assume \"x3=v'\""], ["proof (state)\nthis:\n  x3 = v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 = v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"x1=v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = v'", "using x"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. x1 = v'", "by (metis Cons.prems(2) True is_trail.simps(2))"], ["proof (state)\nthis:\n  x1 = v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 = v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x1 = v'\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "using \\<open>x3=v'\\<close>"], ["proof (prove)\nusing this:\n  x1 = v'\n  x3 = v'\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "by (metis Cons.prems(2) is_trail.simps(2) no_id x)"], ["proof (state)\nthis:\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "case False"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "assume \"x3=v'\""], ["proof (state)\nthis:\n  x3 = v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"odd (degree v' (rem_unPath (x # xs) G)) =odd(degree v' (\n            del_unEdge x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "using rem_x"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "."], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=odd(degree v' (rem_unPath xs G) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "have \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by (metis (full_types) assms(1) finite_Diff rem_unPath_edges)"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "moreover"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "have \"(x1,x2,x3) \\<in>edges( rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) distinct_elim is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "have \"(x3,x2,x1) \\<in>edges( rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) corres distinct_elim_rev is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "ultimately"], ["proof (chain)\npicking this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "by (metis \\<open>x3 = v'\\<close> del_edge_undirected_degree_minus delete_edge_sym  x)"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G) - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G) - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=even(degree v' (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "have \"(x1,x2,x3)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> E", "by (metis Cons.prems(2) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "hence \"(x3,x2,x1)\\<in>edges (rem_unPath xs G)\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) corres distinct_elim_rev x)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "hence \"(x3,x2,x1)\\<in>{e \\<in> edges (rem_unPath xs G). fst e = v'}\""], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}", "using \\<open>x3=v'\\<close>"], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n  x3 = v'\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}", "by (metis (mono_tags) fst_conv mem_Collect_eq)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "have \"finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {e \\<in> edges (rem_unPath xs G). fst e = v'}", "using \\<open>finite E\\<close>"], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite {e \\<in> edges (rem_unPath xs G). fst e = v'}", "by auto"], ["proof (state)\nthis:\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "ultimately"], ["proof (chain)\npicking this:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}", "have \"degree v' (rem_unPath xs G)\\<noteq>0\""], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. degree v' (rem_unPath xs G) \\<noteq> 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. card {e \\<in> edges (rem_unPath xs G). fst e = v'} \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree v' (rem_unPath xs G) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree v' (rem_unPath xs G) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G) - 1) = even (degree v' (rem_unPath xs G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G) - 1) = even (degree v' (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G) - 1) = even (degree v' (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=even (degree v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree v' (rem_unPath xs G)) = even (degree v' G)", "using \\<open>x3 = v'\\<close> assms"], ["proof (prove)\nusing this:\n  x3 = v'\n  finite E\n  is_trail v ps v'\n\ngoal (1 subgoal):\n 1. even (degree v' (rem_unPath xs G)) = even (degree v' G)", "by (metis (mono_tags) Cons.hyps Cons.prems(2) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  even (degree v' (rem_unPath xs G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "finally"], ["proof (chain)\npicking this:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)", "have \"odd (degree v' (rem_unPath (x # xs) G))=even (degree v' G)\""], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)", "."], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 = v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "by (metis False)"], ["proof (state)\nthis:\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x3 = v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "moreover"], ["proof (state)\nthis:\n  x3 = v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "have \"x3\\<noteq>v'\\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x3 \\<noteq> v' \\<Longrightarrow>\n    (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "proof (cases \"v=v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "case True"], ["proof (state)\nthis:\n  v = v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "assume \"x3\\<noteq>v'\""], ["proof (state)\nthis:\n  x3 \\<noteq> v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"odd (degree v' (rem_unPath (x # xs) G)) =odd(degree v' (\n            del_unEdge x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "using rem_x"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "."], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=odd(degree v' (rem_unPath xs G) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "have \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by (metis (full_types) assms(1) finite_Diff rem_unPath_edges)"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "moreover"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "have \"(x1,x2,x3) \\<in>edges( rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) distinct_elim is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "have \"(x3,x2,x1) \\<in>edges( rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) corres distinct_elim_rev is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "ultimately"], ["proof (chain)\npicking this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "using True x"], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n  v = v'\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G) - 1)", "by (metis Cons.prems(2) del_edge_undirected_degree_minus is_trail.simps(2))"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G) - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G) - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=even(degree v' (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "have \"(x1,x2,x3)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> E", "by (metis Cons.prems(2) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "hence \"(x1,x2,x3)\\<in>edges (rem_unPath xs G)\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) distinct_elim x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "hence \"(x1,x2,x3)\\<in>{e \\<in> edges (rem_unPath xs G). fst e = v'}\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}", "using \\<open>v=v'\\<close> x  Cons"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  v = v'\n  x = (x1, x2, x3)\n  \\<lbrakk>finite E; is_trail ?v xs v'\\<rbrakk>\n  \\<Longrightarrow> (?v \\<noteq> v') =\n                    (odd (degree v' (rem_unPath xs G)) = even (degree v' G))\n  finite E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}", "by (metis (lifting, mono_tags) fst_conv is_trail.simps(2) mem_Collect_eq)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "have \"finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {e \\<in> edges (rem_unPath xs G). fst e = v'}", "using \\<open>finite E\\<close>"], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite {e \\<in> edges (rem_unPath xs G). fst e = v'}", "by auto"], ["proof (state)\nthis:\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "ultimately"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}", "have \"degree v' (rem_unPath xs G)\\<noteq>0\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. degree v' (rem_unPath xs G) \\<noteq> 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = v'}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = v'}\n\ngoal (1 subgoal):\n 1. card {e \\<in> edges (rem_unPath xs G). fst e = v'} \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree v' (rem_unPath xs G) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree v' (rem_unPath xs G) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G) - 1) =\n    even (degree v' (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G) - 1) = even (degree v' (rem_unPath xs G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G) - 1) = even (degree v' (rem_unPath xs G))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G) - 1) = even (degree v' (rem_unPath xs G))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...\\<noteq>even (degree v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree v' (rem_unPath xs G)) \\<noteq> even (degree v' G)", "using \\<open>x3 \\<noteq> v'\\<close> assms"], ["proof (prove)\nusing this:\n  x3 \\<noteq> v'\n  finite E\n  is_trail v ps v'\n\ngoal (1 subgoal):\n 1. even (degree v' (rem_unPath xs G)) \\<noteq> even (degree v' G)", "by (metis Cons.hyps Cons.prems(2)is_trail.simps(2) x)"], ["proof (state)\nthis:\n  even (degree v' (rem_unPath xs G)) \\<noteq> even (degree v' G)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "finally"], ["proof (chain)\npicking this:\n  odd (degree v' (rem_unPath (x # xs) G)) \\<noteq> even (degree v' G)", "have \"odd (degree v' (rem_unPath (x # xs) G))\\<noteq>even (degree v' G)\""], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) \\<noteq> even (degree v' G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) \\<noteq> even (degree v' G)", "."], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) \\<noteq> even (degree v' G)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x3 \\<noteq> v'; v = v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))\n 2. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) \\<noteq> even (degree v' G)\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "by (metis True)"], ["proof (state)\nthis:\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "case False"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "assume \"x3\\<noteq>v'\""], ["proof (state)\nthis:\n  x3 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"odd (degree v' (rem_unPath (x # xs) G)) =odd(degree v' (\n            del_unEdge x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "using rem_x"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) =\n    odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "."], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) =\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=odd(degree v' (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "have \"v=x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = x1", "by (metis Cons.prems(2) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  v = x1\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "hence \"v'\\<notin>{x1,x3}\""], ["proof (prove)\nusing this:\n  v = x1\n\ngoal (1 subgoal):\n 1. v' \\<notin> {x1, x3}", "by (metis (mono_tags) False \\<open>x3 \\<noteq> v'\\<close> empty_iff insert_iff)"], ["proof (state)\nthis:\n  v' \\<notin> {x1, x3}\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  v' \\<notin> {x1, x3}\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "have \"valid_unMultigraph (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "have \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by (metis (full_types) assms(1) finite_Diff rem_unPath_edges)"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "ultimately"], ["proof (chain)\npicking this:\n  v' \\<notin> {x1, x3}\n  valid_unMultigraph (rem_unPath xs G)\n  finite (edges (rem_unPath xs G))", "have \"degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))\n                            =degree v' (rem_unPath xs G)\""], ["proof (prove)\nusing this:\n  v' \\<notin> {x1, x3}\n  valid_unMultigraph (rem_unPath xs G)\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    degree v' (rem_unPath xs G)", "using degree_frame"], ["proof (prove)\nusing this:\n  v' \\<notin> {x1, x3}\n  valid_unMultigraph (rem_unPath xs G)\n  finite (edges (rem_unPath xs G))\n  \\<lbrakk>finite E; ?x \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> degree ?x (del_unEdge ?v ?w ?v' G) = degree ?x G\n\ngoal (1 subgoal):\n 1. degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    degree v' (rem_unPath xs G)", "by (metis valid_unMultigraph.degree_frame)"], ["proof (state)\nthis:\n  degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  degree v' (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  degree v' (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    odd (degree v' (rem_unPath xs G))", "by simp"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "also"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  odd (degree v' (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "have \"...=even (degree v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G)) = even (degree v' G)", "using assms x \\<open>x3 \\<noteq> v'\\<close>"], ["proof (prove)\nusing this:\n  finite E\n  is_trail v ps v'\n  x = (x1, x2, x3)\n  x3 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath xs G)) = even (degree v' G)", "by (metis Cons.hyps Cons.prems(2)  is_trail.simps(2))"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath xs G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "finally"], ["proof (chain)\npicking this:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)", "have \"odd (degree v' (rem_unPath (x # xs) G))=even (degree v' G)\""], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)", "."], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x3 \\<noteq> v'; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> v') =\n                      (odd (degree v' (rem_unPath (x # xs) G)) =\n                       even (degree v' G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "by (metis False)"], ["proof (state)\nthis:\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x3 \\<noteq> v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v'\\<rbrakk>\n                   \\<Longrightarrow> (v \\<noteq> v') =\n                                     (odd (degree v' (rem_unPath ps G)) =\neven (degree v' G));\n        finite E; is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> (v \\<noteq> v') =\n                         (odd (degree v' (rem_unPath (a # ps) G)) =\n                          even (degree v' G))", "ultimately"], ["proof (chain)\npicking this:\n  x3 = v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n  x3 \\<noteq> v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "show ?case"], ["proof (prove)\nusing this:\n  x3 = v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n  x3 \\<noteq> v' \\<Longrightarrow>\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal (1 subgoal):\n 1. (v \\<noteq> v') =\n    (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))", "by auto"], ["proof (state)\nthis:\n  (v \\<noteq> v') =\n  (odd (degree v' (rem_unPath (x # xs) G)) = even (degree v' G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) rem_UnPath_parity_v: \n  assumes \"finite E\"  \"is_trail v ps v'\" \n  shows \"v\\<noteq>v' \\<longleftrightarrow> (odd (degree v (rem_unPath ps G)) = even(degree v G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<noteq> v') = (odd (degree v (rem_unPath ps G)) = even (degree v G))", "by (metis assms is_trail_rev rem_UnPath_parity_v' rem_unPath_graph)"], ["", "lemma (in valid_unMultigraph) rem_UnPath_parity_others:\n  assumes \"finite E\"  \"is_trail v ps v'\" \"n\\<notin>{v,v'}\"\n  shows \" even (degree n (rem_unPath ps G)) = even(degree n G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath ps G)) = even (degree n G)", "using assms"], ["proof (prove)\nusing this:\n  finite E\n  is_trail v ps v'\n  n \\<notin> {v, v'}\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath ps G)) = even (degree n G)", "proof (induct ps arbitrary: v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; is_trail v [] v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath [] G)) =\n                         even (degree n G)\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "case Nil"], ["proof (state)\nthis:\n  finite E\n  is_trail v [] v'\n  n \\<notin> {v, v'}\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; is_trail v [] v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath [] G)) =\n                         even (degree n G)\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "thus ?case"], ["proof (prove)\nusing this:\n  finite E\n  is_trail v [] v'\n  n \\<notin> {v, v'}\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath [] G)) = even (degree n G)", "by auto"], ["proof (state)\nthis:\n  even (degree n (rem_unPath [] G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>finite E; is_trail ?v xs v'; n \\<notin> {?v, v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree n (rem_unPath xs G)) = even (degree n G)\n  finite E\n  is_trail v (x # xs) v'\n  n \\<notin> {v, v'}\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "hence \"even (degree n (rem_unPath (x#xs) G))= even (degree n (\n          del_unEdge x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) =\n    even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "by (metis rem_unPath.simps(2) rem_unPath_com)"], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) =\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "have \"n=x3 \\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "assume \"n=x3\""], ["proof (state)\nthis:\n  n = x3\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"even (degree n (rem_unPath (x#xs) G))= even (degree n (\n          del_unEdge x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) =\n    even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) =\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "also"], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) =\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"...=even(degree n (rem_unPath xs G) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "have \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by (metis (full_types) assms(1) finite_Diff rem_unPath_edges)"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "moreover"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "have \"(x1,x2,x3) \\<in>edges( rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) distinct_elim is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "have \"(x3,x2,x1) \\<in>edges( rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) corres distinct_elim_rev is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "ultimately"], ["proof (chain)\npicking this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "using \\<open>n = x3\\<close> del_edge_undirected_degree_minus'"], ["proof (prove)\nusing this:\n  finite (edges (rem_unPath xs G))\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n  n = x3\n  \\<lbrakk>finite (edges ?g); (?v, ?e, ?v') \\<in> edges ?g;\n   (?v', ?e, ?v) \\<in> edges ?g\\<rbrakk>\n  \\<Longrightarrow> degree ?v' (del_unEdge ?v ?e ?v' ?g) = degree ?v' ?g - 1\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G) - 1)", "by auto"], ["proof (state)\nthis:\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  even (degree n (rem_unPath xs G) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  even (degree n (rem_unPath xs G) - 1)\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "also"], ["proof (state)\nthis:\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  even (degree n (rem_unPath xs G) - 1)\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"...=odd(degree n (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "have \"(x1,x2,x3)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> E", "by (metis Cons.prems(2) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "hence \"(x3,x2,x1)\\<in>edges (rem_unPath xs G)\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> edges (rem_unPath xs G)", "by (metis Cons.prems(2) corres distinct_elim_rev x)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "hence \"(x3,x2,x1)\\<in>{e \\<in> edges (rem_unPath xs G). fst e = n}\""], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}", "using \\<open>n=x3\\<close>"], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> edges (rem_unPath xs G)\n  n = x3\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}", "by (metis (mono_tags) fst_conv mem_Collect_eq)"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "have \"finite {e \\<in> edges (rem_unPath xs G). fst e = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {e \\<in> edges (rem_unPath xs G). fst e = n}", "using \\<open>finite E\\<close>"], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite {e \\<in> edges (rem_unPath xs G). fst e = n}", "by auto"], ["proof (state)\nthis:\n  finite {e \\<in> edges (rem_unPath xs G). fst e = n}\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "ultimately"], ["proof (chain)\npicking this:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = n}", "have \"degree n (rem_unPath xs G)\\<noteq>0\""], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = n}\n\ngoal (1 subgoal):\n 1. degree n (rem_unPath xs G) \\<noteq> 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> {e \\<in> edges (rem_unPath xs G). fst e = n}\n  finite {e \\<in> edges (rem_unPath xs G). fst e = n}\n\ngoal (1 subgoal):\n 1. card {e \\<in> edges (rem_unPath xs G). fst e = n} \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree n (rem_unPath xs G) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree n (rem_unPath xs G) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "also"], ["proof (state)\nthis:\n  even (degree n (rem_unPath xs G) - 1) = odd (degree n (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"...=even(degree n G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree n (rem_unPath xs G)) = even (degree n G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree n (rem_unPath xs G)) = even (degree n G)", "have \"x3\\<noteq>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x3 \\<noteq> v'", "by (metis \\<open>n = x3\\<close> assms(3) insert_iff)"], ["proof (state)\nthis:\n  x3 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree n (rem_unPath xs G)) = even (degree n G)", "hence \"odd (degree x3 (rem_unPath xs G)) = even(degree x3 G)\""], ["proof (prove)\nusing this:\n  x3 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree x3 (rem_unPath xs G)) = even (degree x3 G)", "using Cons assms"], ["proof (prove)\nusing this:\n  x3 \\<noteq> v'\n  \\<lbrakk>finite E; is_trail ?v xs v'; n \\<notin> {?v, v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree n (rem_unPath xs G)) = even (degree n G)\n  finite E\n  is_trail v (x # xs) v'\n  n \\<notin> {v, v'}\n  finite E\n  is_trail v ps v'\n  n \\<notin> {v, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x3 (rem_unPath xs G)) = even (degree x3 G)", "by (metis is_trail.simps(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  odd (degree x3 (rem_unPath xs G)) = even (degree x3 G)\n\ngoal (1 subgoal):\n 1. odd (degree n (rem_unPath xs G)) = even (degree n G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree x3 (rem_unPath xs G)) = even (degree x3 G)\n\ngoal (1 subgoal):\n 1. odd (degree n (rem_unPath xs G)) = even (degree n G)", "using \\<open>n=x3\\<close>"], ["proof (prove)\nusing this:\n  odd (degree x3 (rem_unPath xs G)) = even (degree x3 G)\n  n = x3\n\ngoal (1 subgoal):\n 1. odd (degree n (rem_unPath xs G)) = even (degree n G)", "by auto"], ["proof (state)\nthis:\n  odd (degree n (rem_unPath xs G)) = even (degree n G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (degree n (rem_unPath xs G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "finally"], ["proof (chain)\npicking this:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"even (degree n (rem_unPath (x#xs) G))=even(degree n G)\""], ["proof (prove)\nusing this:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "."], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. n = x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "."], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "moreover"], ["proof (state)\nthis:\n  n = x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "have \"n\\<noteq>x3 \\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "assume \"n\\<noteq>x3\""], ["proof (state)\nthis:\n  n \\<noteq> x3\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"even (degree n (rem_unPath (x#xs) G))= even (degree n (\n          del_unEdge x1 x2 x3 (rem_unPath xs G)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) =\n    even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) =\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "also"], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) =\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"...=even(degree n (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "have \"v=x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = x1", "by (metis Cons.prems(2) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  v = x1\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "hence \"n\\<notin>{x1,x3}\""], ["proof (prove)\nusing this:\n  v = x1\n\ngoal (1 subgoal):\n 1. n \\<notin> {x1, x3}", "by (metis Cons.prems(3) \\<open>n \\<noteq> x3\\<close> insertE insertI1 singletonE)"], ["proof (state)\nthis:\n  n \\<notin> {x1, x3}\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  n \\<notin> {x1, x3}\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "have \"valid_unMultigraph (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "moreover"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "have \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by (metis (full_types) assms(1) finite_Diff rem_unPath_edges)"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "ultimately"], ["proof (chain)\npicking this:\n  n \\<notin> {x1, x3}\n  valid_unMultigraph (rem_unPath xs G)\n  finite (edges (rem_unPath xs G))", "have \"degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))\n                            =degree n (rem_unPath xs G)\""], ["proof (prove)\nusing this:\n  n \\<notin> {x1, x3}\n  valid_unMultigraph (rem_unPath xs G)\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    degree n (rem_unPath xs G)", "using degree_frame"], ["proof (prove)\nusing this:\n  n \\<notin> {x1, x3}\n  valid_unMultigraph (rem_unPath xs G)\n  finite (edges (rem_unPath xs G))\n  \\<lbrakk>finite E; ?x \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> degree ?x (del_unEdge ?v ?w ?v' G) = degree ?x G\n\ngoal (1 subgoal):\n 1. degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    degree n (rem_unPath xs G)", "by (metis valid_unMultigraph.degree_frame)"], ["proof (state)\nthis:\n  degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  degree n (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree n (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  degree n (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n    even (degree n (rem_unPath xs G))", "by simp"], ["proof (state)\nthis:\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  even (degree n (rem_unPath xs G))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  even (degree n (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "also"], ["proof (state)\nthis:\n  even (degree n (del_unEdge x1 x2 x3 (rem_unPath xs G))) =\n  even (degree n (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"...=even(degree n G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G)) = even (degree n G)", "using Cons assms \\<open>n \\<noteq> x3\\<close> x"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; is_trail ?v xs v'; n \\<notin> {?v, v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree n (rem_unPath xs G)) = even (degree n G)\n  finite E\n  is_trail v (x # xs) v'\n  n \\<notin> {v, v'}\n  finite E\n  is_trail v ps v'\n  n \\<notin> {v, v'}\n  n \\<noteq> x3\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath xs G)) = even (degree n G)", "by auto"], ["proof (state)\nthis:\n  even (degree n (rem_unPath xs G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "finally"], ["proof (chain)\npicking this:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "have \"even (degree n (rem_unPath (x#xs) G))=even(degree n G)\""], ["proof (prove)\nusing this:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "."], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. n \\<noteq> x3 \\<Longrightarrow>\n    even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "."], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<noteq> x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; is_trail v ps v';\n                    n \\<notin> {v, v'}\\<rbrakk>\n                   \\<Longrightarrow> even (degree n (rem_unPath ps G)) =\n                                     even (degree n G);\n        finite E; is_trail v (a # ps) v'; n \\<notin> {v, v'}\\<rbrakk>\n       \\<Longrightarrow> even (degree n (rem_unPath (a # ps) G)) =\n                         even (degree n G)", "ultimately"], ["proof (chain)\npicking this:\n  n = x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n  n \\<noteq> x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "show ?case"], ["proof (prove)\nusing this:\n  n = x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n  n \\<noteq> x3 \\<Longrightarrow>\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal (1 subgoal):\n 1. even (degree n (rem_unPath (x # xs) G)) = even (degree n G)", "by auto"], ["proof (state)\nthis:\n  even (degree n (rem_unPath (x # xs) G)) = even (degree n G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) rem_UnPath_even:\n  assumes \"finite E\" \"finite V\" \"is_trail v ps v'\" \n  assumes parity_assms:  \"even (degree v' G)\"\n  shows \"num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G \n          + (if even (degree v G)\\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "using assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; finite V; is_trail v [] v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath [] G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "case Nil"], ["proof (state)\nthis:\n  finite E\n  finite V\n  is_trail v [] v'\n  even (degree v' G)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; finite V; is_trail v [] v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath [] G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "thus ?case"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v [] v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath [] G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath [] G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have fin_nodes: \"finite (nodes (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes (rem_unPath xs G))", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. finite (nodes (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  finite (nodes (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have fin_edges: \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have valid_rem_xs: \"valid_unMultigraph (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have x_in:\"(x1,x2,x3)\\<in>edges (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (rem_unPath xs G)", "by (metis (full_types) Cons.prems(3) distinct_elim is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have \"even (degree x1 (rem_unPath xs G)) \n        \\<Longrightarrow> even(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "assume parity_x1_x3: \"even (degree x1 (rem_unPath xs G))\" \n                           \"even(degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  even (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) + 2", "using  parity_x1_x3  fin_nodes fin_edges valid_rem_xs x_in del_UnEdge_even_even"], ["proof (prove)\nusing this:\n  even (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n  finite (nodes (rem_unPath xs G))\n  finite (edges (rem_unPath xs G))\n  valid_unMultigraph (rem_unPath xs G)\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  \\<lbrakk>valid_unMultigraph ?G; finite (edges ?G); finite (nodes ?G);\n   (?v, ?w, ?v') \\<in> edges ?G; even (degree ?v ?G);\n   even (degree ?v' ?G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (del_unEdge ?v ?w ?v' ?G) =\n                    num_of_odd_nodes ?G + 2\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) + 2", "by metis"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree x3 G) \\<and> x3\\<noteq>v' then 2 else 0 )+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) + 2 =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2", "using Cons.hyps[OF \\<open>finite E\\<close> \\<open>finite V\\<close>, of x3] \\<open>is_trail v (x # xs) v'\\<close>\n          \\<open>even (degree v' G)\\<close> x"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_trail x3 xs v'; even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2\n                     else 0)\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) + 2 =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) + 2 =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n  2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) + 2 =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n  2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2 =\n    num_of_odd_nodes G + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2 =\n    num_of_odd_nodes G + 2", "have \"even(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> odd (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2 =\n    num_of_odd_nodes G + 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2 =\n    num_of_odd_nodes G + 2", "using parity_x1_x3(2)"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n    2 =\n    num_of_odd_nodes G + 2", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n  2 =\n  num_of_odd_nodes G + 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n  2 =\n  num_of_odd_nodes G + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) +\n  2 =\n  num_of_odd_nodes G + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "using Cons assms"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "by (metis is_trail.simps(2)  parity_x1_x3(1) rem_UnPath_parity_v' x)"], ["proof (state)\nthis:\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'", "have \"x1\\<notin>{x3,v'}\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. x1 \\<notin> {x3, v'}", "by auto"], ["proof (state)\nthis:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence  \"even(degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. even (degree x1 G)", "using Cons.prems(3) assms(1) assms(2) parity_x1_x3(1)"], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  even (degree x1 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. even (degree x1 G)", "by (metis (full_types)  is_trail.simps(2) rem_UnPath_parity_others x)"], ["proof (state)\nthis:\n  even (degree x1 G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"even(degree x1 G) \\<and> x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  even (degree x1 G)\n\ngoal (1 subgoal):\n 1. even (degree x1 G) \\<and> x1 \\<noteq> v'", "using \\<open>x1 \\<noteq> v'\\<close>"], ["proof (prove)\nusing this:\n  even (degree x1 G)\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. even (degree x1 G) \\<and> x1 \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  even (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"even(degree v G) \\<and> v\\<noteq>v'\""], ["proof (prove)\nusing this:\n  even (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. even (degree v G) \\<and> v \\<noteq> v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  even (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  even (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G + 2 =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G + 2 =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have \"even (degree x1 (rem_unPath xs G)) \\<Longrightarrow> \n                    odd(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "assume parity_x1_x3: \"even (degree x1 (rem_unPath xs G))\" \n                           \"odd (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  even (degree x1 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "using  parity_x1_x3  fin_nodes fin_edges valid_rem_xs x_in"], ["proof (prove)\nusing this:\n  even (degree x1 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n  finite (nodes (rem_unPath xs G))\n  finite (edges (rem_unPath xs G))\n  valid_unMultigraph (rem_unPath xs G)\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "by (metis del_UnEdge_even_odd)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree x3 G) \\<and> x3\\<noteq>v' then 2 else 0 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)", "using  Cons.hyps Cons.prems(3) assms(1) assms(2)  parity_assms x"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  even (degree v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G + 2", "have \"even(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> odd (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G + 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G + 2", "using parity_x1_x3(2)"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G + 2", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n  num_of_odd_nodes G + 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n  num_of_odd_nodes G + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n  num_of_odd_nodes G + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "using Cons assms"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "by (metis is_trail.simps(2)  parity_x1_x3(1) rem_UnPath_parity_v' x)"], ["proof (state)\nthis:\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'", "have \"x1\\<notin>{x3,v'}\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. x1 \\<notin> {x3, v'}", "by auto"], ["proof (state)\nthis:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence  \"even(degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. even (degree x1 G)", "using Cons.prems(3) assms(1) assms(2) parity_x1_x3(1)"], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  even (degree x1 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. even (degree x1 G)", "by (metis (full_types)  is_trail.simps(2) rem_UnPath_parity_others x)"], ["proof (state)\nthis:\n  even (degree x1 G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"even(degree x1 G) \\<and> x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  even (degree x1 G)\n\ngoal (1 subgoal):\n 1. even (degree x1 G) \\<and> x1 \\<noteq> v'", "using \\<open>x1 \\<noteq> v'\\<close>"], ["proof (prove)\nusing this:\n  even (degree x1 G)\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. even (degree x1 G) \\<and> x1 \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  even (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"even(degree v G) \\<and> v\\<noteq>v'\""], ["proof (prove)\nusing this:\n  even (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. even (degree v G) \\<and> v \\<noteq> v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  even (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  even (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G + 2 =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G + 2 =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G + 2 =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have \"odd (degree x1 (rem_unPath xs G)) \\<Longrightarrow> \n                    even(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "assume parity_x1_x3: \"odd (degree x1 (rem_unPath xs G))\" \n                           \"even (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  odd (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "using  parity_x1_x3  fin_nodes fin_edges valid_rem_xs x_in"], ["proof (prove)\nusing this:\n  odd (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n  finite (nodes (rem_unPath xs G))\n  finite (edges (rem_unPath xs G))\n  valid_unMultigraph (rem_unPath xs G)\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "by (metis del_UnEdge_odd_even)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree x3 G) \\<and> x3\\<noteq>v' then 2 else 0 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)", "using  Cons.hyps Cons.prems(3) assms(1) assms(2) parity_assms x"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  even (degree v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G", "have \"even(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> odd (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G", "thus ?thesis"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G", "using parity_x1_x3(2)"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n    num_of_odd_nodes G", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n  num_of_odd_nodes G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n  num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) =\n  num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "proof (cases \"v\\<noteq>v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "case True"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"is_trail x3 xs v' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail x3 xs v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  is_trail x3 xs v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'", "have  \"odd (degree x1 (rem_unPath xs G)) \n                          \\<longleftrightarrow> odd(degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n\ngoal (1 subgoal):\n 1. odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)", "using True parity_x1_x3(1) rem_UnPath_parity_others x Cons.prems(3) assms(1) assms(2)"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n  v \\<noteq> v'\n  odd (degree x1 (rem_unPath xs G))\n  \\<lbrakk>finite E; is_trail ?v ?ps ?v'; ?n \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree ?n (rem_unPath ?ps G)) = even (degree ?n G)\n  x = (x1, x2, x3)\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n\ngoal (1 subgoal):\n 1. odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)", "by auto"], ["proof (state)\nthis:\n  odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"odd(degree x1 G)\""], ["proof (prove)\nusing this:\n  odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. odd (degree x1 G)", "by (metis parity_x1_x3(1))"], ["proof (state)\nthis:\n  odd (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by (metis (mono_tags) Cons.prems(3) Nat.add_0_right is_trail.simps(2) x)"], ["proof (state)\nthis:\n  num_of_odd_nodes G =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> v \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "have \"odd (degree x1 (rem_unPath xs G)) \\<Longrightarrow> \n                    odd(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "assume parity_x1_x3: \"odd (degree x1 (rem_unPath xs G))\" \n                           \"odd (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  odd (degree x1 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)-(2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) - 2", "using del_UnEdge_odd_odd"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_unMultigraph ?G; finite (edges ?G); finite (nodes ?G);\n   (?v, ?w, ?v') \\<in> edges ?G; odd (degree ?v ?G);\n   odd (degree ?v' ?G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes ?G =\n                    num_of_odd_nodes (del_unEdge ?v ?w ?v' ?G) + 2\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) - 2", "by (metis add_implies_diff  fin_edges fin_nodes parity_x1_x3 valid_rem_xs x_in)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree x3 G) \\<and> x3\\<noteq>v' then 2 else 0 )-(2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2", "using Cons assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v';\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath xs G) =\n                    num_of_odd_nodes G +\n                    (if even (degree ?v G) \\<and> ?v \\<noteq> v' then 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 =\n    num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2", "by (metis is_trail.simps(2) x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) - 2 =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n  2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) - 2 =\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n  2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2 =\n    num_of_odd_nodes G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2 =\n    num_of_odd_nodes G", "have \"even(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> odd (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  even (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n    odd (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2 =\n    num_of_odd_nodes G", "thus ?thesis"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2 =\n    num_of_odd_nodes G", "using parity_x1_x3(2)"], ["proof (prove)\nusing this:\n  (even (degree x3 G) \\<and> x3 \\<noteq> v') =\n  odd (degree x3 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G +\n    (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n    2 =\n    num_of_odd_nodes G", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n  2 =\n  num_of_odd_nodes G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n  2 =\n  num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes G +\n  (if even (degree x3 G) \\<and> x3 \\<noteq> v' then 2 else 0) -\n  2 =\n  num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "proof (cases \"v\\<noteq>v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "case True"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"is_trail x3 xs v' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail x3 xs v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  is_trail x3 xs v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'", "have  \"odd (degree x1 (rem_unPath xs G)) \n                          \\<longleftrightarrow> odd(degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n\ngoal (1 subgoal):\n 1. odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)", "using True Cons.prems(3) assms(1) assms(2) parity_x1_x3(1) rem_UnPath_parity_others x"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n  v \\<noteq> v'\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  odd (degree x1 (rem_unPath xs G))\n  \\<lbrakk>finite E; is_trail ?v ?ps ?v'; ?n \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree ?n (rem_unPath ?ps G)) = even (degree ?n G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)", "by auto"], ["proof (state)\nthis:\n  odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "hence \"odd(degree x1 G)\""], ["proof (prove)\nusing this:\n  odd (degree x1 (rem_unPath xs G)) = odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. odd (degree x1 G)", "by (metis parity_x1_x3(1))"], ["proof (state)\nthis:\n  odd (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by (metis (mono_tags) Cons.prems(3) Nat.add_0_right is_trail.simps(2) x)"], ["proof (state)\nthis:\n  num_of_odd_nodes G =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by (metis (mono_tags) add_0_iff)"], ["proof (state)\nthis:\n  num_of_odd_nodes G =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes G =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if even(degree v G) \\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                      num_of_odd_nodes G +\n                      (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "."], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    even (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> num_of_odd_nodes (rem_unPath ps G) =\n                                     num_of_odd_nodes G +\n                                     (if even (degree v G) \\<and>\n   v \\<noteq> v'\nthen 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        even (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> num_of_odd_nodes (rem_unPath (a # ps) G) =\n                         num_of_odd_nodes G +\n                         (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (rem_unPath (x # xs) G) =\n                    num_of_odd_nodes G +\n                    (if even (degree v G) \\<and> v \\<noteq> v' then 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by metis"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) rem_UnPath_odd:\n  assumes \"finite E\" \"finite V\" \"is_trail v ps v'\" \n  assumes parity_assms:  \"odd (degree v' G)\"\n  shows \"num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G \n          + (if odd (degree v G)\\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath ps G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "using assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath ps G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; finite V; is_trail v [] v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath [] G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "case Nil"], ["proof (state)\nthis:\n  finite E\n  finite V\n  is_trail v [] v'\n  odd (degree v' G)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>finite E; finite V; is_trail v [] v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath [] G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "thus ?case"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v [] v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath [] G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath [] G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree ?v G) \\<and> ?v \\<noteq> v' then - 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have fin_nodes: \"finite (nodes (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes (rem_unPath xs G))", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree ?v G) \\<and> ?v \\<noteq> v' then - 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. finite (nodes (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  finite (nodes (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have fin_edges: \"finite (edges (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree ?v G) \\<and> ?v \\<noteq> v' then - 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. finite (edges (rem_unPath xs G))", "by auto"], ["proof (state)\nthis:\n  finite (edges (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have valid_rem_xs: \"valid_unMultigraph (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (rem_unPath xs G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have x_in:\"(x1,x2,x3)\\<in>edges (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (rem_unPath xs G)", "by (metis (full_types) Cons.prems(3) distinct_elim is_trail.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have \"even (degree x1 (rem_unPath xs G)) \n        \\<Longrightarrow> even(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "assume parity_x1_x3: \"even (degree x1 (rem_unPath xs G))\" \n                           \"even (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  even (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) + 2", "using  parity_x1_x3  fin_nodes fin_edges valid_rem_xs x_in del_UnEdge_even_even"], ["proof (prove)\nusing this:\n  even (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n  finite (nodes (rem_unPath xs G))\n  finite (edges (rem_unPath xs G))\n  valid_unMultigraph (rem_unPath xs G)\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n  \\<lbrakk>valid_unMultigraph ?G; finite (edges ?G); finite (nodes ?G);\n   (?v, ?w, ?v') \\<in> edges ?G; even (degree ?v ?G);\n   even (degree ?v' ?G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (del_unEdge ?v ?w ?v' ?G) =\n                    num_of_odd_nodes ?G + 2\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) + 2", "by metis"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) + 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if odd(degree x3 G) \\<and> x3\\<noteq>v' then - 2 else 0 )+2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G) + 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2", "using Cons.hyps[OF \\<open>finite E\\<close> \\<open>finite V\\<close>,of x3] \\<open>is_trail v (x # xs) v'\\<close>\n          \\<open>odd (degree v' G)\\<close> x"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_trail x3 xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2\n                     else 0)\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G) + 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G) + 2) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n  2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G) + 2) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n  2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2 =\n    int (num_of_odd_nodes G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2 =\n    int (num_of_odd_nodes G)", "have \"odd (degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> even (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2 =\n    int (num_of_odd_nodes G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2 =\n    int (num_of_odd_nodes G)", "using parity_x1_x3(2)"], ["proof (prove)\nusing this:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n    2 =\n    int (num_of_odd_nodes G)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n  2 =\n  int (num_of_odd_nodes G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n  2 =\n  int (num_of_odd_nodes G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) +\n  2 =\n  int (num_of_odd_nodes G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "proof (cases \"v\\<noteq>v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "case True"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"is_trail x3 xs v' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail x3 xs v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  is_trail x3 xs v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'", "have  \"even (degree x1 (rem_unPath xs G)) \n                          \\<longleftrightarrow> even (degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n\ngoal (1 subgoal):\n 1. even (degree x1 (rem_unPath xs G)) = even (degree x1 G)", "using True Cons.prems(3) assms(1) assms(2) parity_x1_x3(1) \n                rem_UnPath_parity_others x"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n  v \\<noteq> v'\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  even (degree x1 (rem_unPath xs G))\n  \\<lbrakk>finite E; is_trail ?v ?ps ?v'; ?n \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree ?n (rem_unPath ?ps G)) = even (degree ?n G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. even (degree x1 (rem_unPath xs G)) = even (degree x1 G)", "by auto"], ["proof (state)\nthis:\n  even (degree x1 (rem_unPath xs G)) = even (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"even (degree x1 G)\""], ["proof (prove)\nusing this:\n  even (degree x1 (rem_unPath xs G)) = even (degree x1 G)\n\ngoal (1 subgoal):\n 1. even (degree x1 G)", "by (metis parity_x1_x3(1))"], ["proof (state)\nthis:\n  even (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  even (degree x1 G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by (metis (hide_lams, mono_tags) Cons.prems(3)  is_trail.simps(2)  \n                monoid_add_class.add.right_neutral x)"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> v \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have \"even (degree x1 (rem_unPath xs G)) \\<Longrightarrow> \n                    odd(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "assume parity_x1_x3: \"even (degree x1 (rem_unPath xs G))\" \n                           \"odd (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  even (degree x1 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "using  parity_x1_x3  fin_nodes fin_edges valid_rem_xs x_in"], ["proof (prove)\nusing this:\n  even (degree x1 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n  finite (nodes (rem_unPath xs G))\n  finite (edges (rem_unPath xs G))\n  valid_unMultigraph (rem_unPath xs G)\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "by (metis del_UnEdge_even_odd)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if odd(degree x3 G) \\<and> x3\\<noteq>v' then - 2 else 0 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)", "using  Cons.hyps[OF \\<open>finite E\\<close> \\<open>finite V\\<close>, of x3] Cons.prems(3) assms(1) assms(2) \n          parity_assms x"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_trail x3 xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2\n                     else 0)\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  odd (degree v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G)", "have \"odd(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> even (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G)", "using parity_x1_x3(2)"], ["proof (prove)\nusing this:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n  int (num_of_odd_nodes G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n  int (num_of_odd_nodes G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n  int (num_of_odd_nodes G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...= num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "proof (cases \"v\\<noteq>v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "case True"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"is_trail x3 xs v' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail x3 xs v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  is_trail x3 xs v'\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'", "have  \"even (degree x1 (rem_unPath xs G)) \n                          \\<longleftrightarrow> even (degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n\ngoal (1 subgoal):\n 1. even (degree x1 (rem_unPath xs G)) = even (degree x1 G)", "using True Cons.prems(3) assms(1) assms(2) parity_x1_x3(1) \n                rem_UnPath_parity_others x"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  is_trail x3 xs v'\n  v \\<noteq> v'\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  even (degree x1 (rem_unPath xs G))\n  \\<lbrakk>finite E; is_trail ?v ?ps ?v'; ?n \\<notin> {?v, ?v'}\\<rbrakk>\n  \\<Longrightarrow> even (degree ?n (rem_unPath ?ps G)) = even (degree ?n G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. even (degree x1 (rem_unPath xs G)) = even (degree x1 G)", "by auto"], ["proof (state)\nthis:\n  even (degree x1 (rem_unPath xs G)) = even (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"even (degree x1 G)\""], ["proof (prove)\nusing this:\n  even (degree x1 (rem_unPath xs G)) = even (degree x1 G)\n\ngoal (1 subgoal):\n 1. even (degree x1 G)", "by (metis parity_x1_x3(1))"], ["proof (state)\nthis:\n  even (degree x1 G)\n\ngoal (2 subgoals):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n 2. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "with Cons.prems(3) x"], ["proof (chain)\npicking this:\n  is_trail v (x # xs) v'\n  x = (x1, x2, x3)\n  even (degree x1 G)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_trail v (x # xs) v'\n  x = (x1, x2, x3)\n  even (degree x1 G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> v' \\<Longrightarrow>\n    int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> v \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have \"odd (degree x1 (rem_unPath xs G)) \\<Longrightarrow> \n                    even(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "assume parity_x1_x3: \"odd (degree x1 (rem_unPath xs G))\" \n                           \"even (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  odd (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "using  parity_x1_x3  fin_nodes fin_edges valid_rem_xs x_in"], ["proof (prove)\nusing this:\n  odd (degree x1 (rem_unPath xs G))\n  even (degree x3 (rem_unPath xs G))\n  finite (nodes (rem_unPath xs G))\n  finite (edges (rem_unPath xs G))\n  valid_unMultigraph (rem_unPath xs G)\n  (x1, x2, x3) \\<in> edges (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G)", "by (metis del_UnEdge_odd_even)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if odd(degree x3 G) \\<and> x3\\<noteq>v' then -2 else 0 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)", "using  Cons.hyps Cons.prems(3) assms(1) assms(2) parity_assms x"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree ?v G) \\<and> ?v \\<noteq> v' then - 2\n                     else 0)\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  odd (degree v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G + (- 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G) + - 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G) + - 2", "have \"odd(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> even (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G) + - 2", "hence \"odd(degree x3 G) \\<and> x3\\<noteq>v'\""], ["proof (prove)\nusing this:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree x3 G) \\<and> x3 \\<noteq> v'", "by (metis parity_x1_x3(2))"], ["proof (state)\nthis:\n  odd (degree x3 G) \\<and> x3 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G) + - 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree x3 G) \\<and> x3 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n    int (num_of_odd_nodes G) + - 2", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n  int (num_of_odd_nodes G) + - 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n  int (num_of_odd_nodes G) + - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0) =\n  int (num_of_odd_nodes G) + - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "using Cons assms"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree ?v G) \\<and> ?v \\<noteq> v' then - 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "by (metis is_trail.simps(2)  parity_x1_x3(1) rem_UnPath_parity_v' x)"], ["proof (state)\nthis:\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'", "have \"x1\\<notin>{x3,v'}\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. x1 \\<notin> {x3, v'}", "by auto"], ["proof (state)\nthis:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence  \"odd(degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x1 G)", "using Cons.prems(3) assms(1) assms(2) parity_x1_x3(1)"], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  odd (degree x1 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree x1 G)", "by (metis (full_types)  is_trail.simps(2) rem_UnPath_parity_others x)"], ["proof (state)\nthis:\n  odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"odd(degree x1 G) \\<and> x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. odd (degree x1 G) \\<and> x1 \\<noteq> v'", "using \\<open>x1 \\<noteq> v'\\<close>"], ["proof (prove)\nusing this:\n  odd (degree x1 G)\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree x1 G) \\<and> x1 \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  odd (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"odd(degree v G) \\<and> v\\<noteq>v'\""], ["proof (prove)\nusing this:\n  odd (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree v G) \\<and> v \\<noteq> v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  odd (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G) + - 2 =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) + - 2 =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G) + - 2 =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     even (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "have \"odd (degree x1 (rem_unPath xs G)) \\<Longrightarrow> \n                    odd(degree x3 (rem_unPath xs G)) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "assume parity_x1_x3: \"odd (degree x1 (rem_unPath xs G))\" \n                           \"odd (degree x3 (rem_unPath xs G))\""], ["proof (state)\nthis:\n  odd (degree x1 (rem_unPath xs G))\n  odd (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)= num_of_odd_nodes \n         (del_unEdge x1 x2 x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath (x # xs) G) =\n    num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))", "by (metis rem_unPath.simps(2) rem_unPath_com x)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath (x # xs) G) =\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"... =num_of_odd_nodes (rem_unPath xs G)-(2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) - 2", "using del_UnEdge_odd_odd"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_unMultigraph ?G; finite (edges ?G); finite (nodes ?G);\n   (?v, ?w, ?v') \\<in> edges ?G; odd (degree ?v ?G);\n   odd (degree ?v' ?G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes ?G =\n                    num_of_odd_nodes (del_unEdge ?v ?w ?v' ?G) + 2\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n    num_of_odd_nodes (rem_unPath xs G) - 2", "by (metis add_implies_diff  fin_edges fin_nodes parity_x1_x3 valid_rem_xs x_in)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge x1 x2 x3 (rem_unPath xs G)) =\n  num_of_odd_nodes (rem_unPath xs G) - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G -(2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "have \"odd(degree x3 G) \\<and> x3\\<noteq>v' \\<longleftrightarrow> even (degree x3 (rem_unPath xs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n    even (degree x3 (rem_unPath xs G))", "by (metis  is_trail.simps(2) parity_x1_x3(2) rem_UnPath_parity_v x)"], ["proof (state)\nthis:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "hence \"\\<not>(odd(degree x3 G) \\<and> x3\\<noteq>v')\""], ["proof (prove)\nusing this:\n  (odd (degree x3 G) \\<and> x3 \\<noteq> v') =\n  even (degree x3 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. \\<not> (odd (degree x3 G) \\<and> x3 \\<noteq> v')", "by (metis parity_x1_x3(2))"], ["proof (state)\nthis:\n  \\<not> (odd (degree x3 G) \\<and> x3 \\<noteq> v')\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "have \"num_of_odd_nodes (rem_unPath xs G)= \n                  num_of_odd_nodes G+(if odd(degree x3 G) \\<and> x3\\<noteq>v' then -2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath xs G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)", "by (metis Cons.hyps Cons.prems(3) assms(1) assms(2) \n                is_trail.simps(2) parity_assms x)"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "using \\<open>\\<not> (odd (degree x3 G) \\<and> x3 \\<noteq> v')\\<close>"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath xs G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree x3 G) \\<and> x3 \\<noteq> v' then - 2 else 0)\n  \\<not> (odd (degree x3 G) \\<and> x3 \\<noteq> v')\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "also"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath xs G) - 2 = num_of_odd_nodes G - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "have \"...=num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"x1\\<noteq>x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> x3", "by (metis valid_rem_xs valid_unMultigraph.no_id x_in)"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "using Cons assms"], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  \\<lbrakk>finite E; finite V; is_trail ?v xs v'; odd (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath xs G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree ?v G) \\<and> ?v \\<noteq> v' then - 2\n                     else 0)\n  finite E\n  finite V\n  is_trail v (x # xs) v'\n  odd (degree v' G)\n  finite E\n  finite V\n  is_trail v ps v'\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v'", "by (metis is_trail.simps(2)  parity_x1_x3(1) rem_UnPath_parity_v' x)"], ["proof (state)\nthis:\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'", "have \"x1\\<notin>{x3,v'}\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x3\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. x1 \\<notin> {x3, v'}", "by auto"], ["proof (state)\nthis:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence  \"odd(degree x1 G)\""], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n\ngoal (1 subgoal):\n 1. odd (degree x1 G)", "using Cons.prems(3) assms(1) assms(2) parity_x1_x3(1)"], ["proof (prove)\nusing this:\n  x1 \\<notin> {x3, v'}\n  is_trail v (x # xs) v'\n  finite E\n  finite V\n  odd (degree x1 (rem_unPath xs G))\n\ngoal (1 subgoal):\n 1. odd (degree x1 G)", "by (metis (full_types)  is_trail.simps(2) rem_UnPath_parity_others x)"], ["proof (state)\nthis:\n  odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"odd(degree x1 G) \\<and> x1\\<noteq>v'\""], ["proof (prove)\nusing this:\n  odd (degree x1 G)\n\ngoal (1 subgoal):\n 1. odd (degree x1 G) \\<and> x1 \\<noteq> v'", "using \\<open>x1 \\<noteq> v'\\<close>"], ["proof (prove)\nusing this:\n  odd (degree x1 G)\n  x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree x1 G) \\<and> x1 \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  odd (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"odd(degree v G) \\<and> v\\<noteq>v'\""], ["proof (prove)\nusing this:\n  odd (degree x1 G) \\<and> x1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. odd (degree v G) \\<and> v \\<noteq> v'", "by (metis Cons.prems(3) is_trail.simps(2) x)"], ["proof (state)\nthis:\n  odd (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"v\\<in>odd_nodes_set G\""], ["proof (prove)\nusing this:\n  odd (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. v \\<in> odd_nodes_set G", "using Cons.prems(3) E_validD(1)  x"], ["proof (prove)\nusing this:\n  odd (degree v G) \\<and> v \\<noteq> v'\n  is_trail v (x # xs) v'\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. v \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  odd (degree v G) \\<and> v \\<noteq> v'\n  is_trail v (x # xs) v'\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"v'\\<in>odd_nodes_set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> odd_nodes_set G", "using  is_path_memb[OF is_trail_intro[OF assms(3)]]  parity_assms"], ["proof (prove)\nusing this:\n  v \\<in> V \\<and> v' \\<in> V\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. v' \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  v \\<in> V \\<and> v' \\<in> V\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. v' \\<in> {v \\<in> V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  v' \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> odd_nodes_set G\n  v' \\<in> odd_nodes_set G", "have \"{v,v'}\\<subseteq>odd_nodes_set G\""], ["proof (prove)\nusing this:\n  v \\<in> odd_nodes_set G\n  v' \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. {v, v'} \\<subseteq> odd_nodes_set G", "by auto"], ["proof (state)\nthis:\n  {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  {v, v'} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"v\\<noteq>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "by (metis \\<open>odd (degree v G) \\<and> v \\<noteq> v'\\<close>)"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "hence \"card{v,v'}=2\""], ["proof (prove)\nusing this:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. card {v, v'} = 2", "by auto"], ["proof (state)\nthis:\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "moreover"], ["proof (state)\nthis:\n  card {v, v'} = 2\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"finite(odd_nodes_set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "using \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite {v \\<in> V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  {v, v'} \\<subseteq> odd_nodes_set G\n  card {v, v'} = 2\n  finite (odd_nodes_set G)", "have \"num_of_odd_nodes G\\<ge>2\""], ["proof (prove)\nusing this:\n  {v, v'} \\<subseteq> odd_nodes_set G\n  card {v, v'} = 2\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. 2 \\<le> num_of_odd_nodes G", "by (metis card_mono num_of_odd_nodes_def)"], ["proof (state)\nthis:\n  2 \\<le> num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "using \\<open>odd (degree v G) \\<and> v \\<noteq> v'\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> num_of_odd_nodes G\n  odd (degree v G) \\<and> v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes G - 2) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by auto"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G - 2) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (num_of_odd_nodes G - 2) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "finally"], ["proof (chain)\npicking this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "have \"num_of_odd_nodes (rem_unPath (x#xs) G)=\n                        num_of_odd_nodes G+(if odd(degree v G) \\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n     odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n    \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                      int (num_of_odd_nodes G) +\n                      (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                       else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "."], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>finite E; finite V; is_trail v ps v';\n                    odd (degree v' G)\\<rbrakk>\n                   \\<Longrightarrow> int\n(num_of_odd_nodes (rem_unPath ps G)) =\n                                     int (num_of_odd_nodes G) +\n                                     (if odd (degree v G) \\<and>\n   v \\<noteq> v'\nthen - 2 else 0);\n        finite E; finite V; is_trail v (a # ps) v';\n        odd (degree v' G)\\<rbrakk>\n       \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (a # ps) G)) =\n                         int (num_of_odd_nodes G) +\n                         (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n  \\<lbrakk>even (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   even (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n  \\<lbrakk>odd (degree x1 (rem_unPath xs G));\n   odd (degree x3 (rem_unPath xs G))\\<rbrakk>\n  \\<Longrightarrow> int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n                    int (num_of_odd_nodes G) +\n                    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by metis"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath (x # xs) G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) rem_UnPath_cycle:\n  assumes \"finite E\" \"finite V\" \"is_trail v ps v'\" \"v=v'\"\n  shows \"num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "proof  (cases \"even(degree v' G)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\n 2. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "case True"], ["proof (state)\nthis:\n  even (degree v' G)\n\ngoal (2 subgoals):\n 1. even (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\n 2. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "hence \"?L = num_of_odd_nodes G + (if even (degree v G)\\<and> v\\<noteq>v' then 2 else 0)\""], ["proof (prove)\nusing this:\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) =\n    num_of_odd_nodes G +\n    (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "by (metis assms(1) assms(2) assms(3) rem_UnPath_even)"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath ps G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (2 subgoals):\n 1. even (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\n 2. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "with assms"], ["proof (chain)\npicking this:\n  finite E\n  finite V\n  is_trail v ps v'\n  v = v'\n  num_of_odd_nodes (rem_unPath ps G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite E\n  finite V\n  is_trail v ps v'\n  v = v'\n  num_of_odd_nodes (rem_unPath ps G) =\n  num_of_odd_nodes G +\n  (if even (degree v G) \\<and> v \\<noteq> v' then 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\n\ngoal (1 subgoal):\n 1. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "case False"], ["proof (state)\nthis:\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "hence \"?L = num_of_odd_nodes G + (if odd (degree v G)\\<and> v\\<noteq>v' then -2 else 0)\""], ["proof (prove)\nusing this:\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. int (num_of_odd_nodes (rem_unPath ps G)) =\n    int (num_of_odd_nodes G) +\n    (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)", "by (metis assms(1) assms(2) assms(3) rem_UnPath_odd)"], ["proof (state)\nthis:\n  int (num_of_odd_nodes (rem_unPath ps G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. odd (degree v' G) \\<Longrightarrow>\n    num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath ps G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "using \\<open>v = v'\\<close>"], ["proof (prove)\nusing this:\n  int (num_of_odd_nodes (rem_unPath ps G)) =\n  int (num_of_odd_nodes G) +\n  (if odd (degree v G) \\<and> v \\<noteq> v' then - 2 else 0)\n  v = v'\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes (rem_unPath ps G) = num_of_odd_nodes G\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Connectivity\\<close>"], ["", "definition (in valid_unMultigraph) connected::bool where\n  \"connected \\<equiv> \\<forall> v\\<in>V. \\<forall>v'\\<in>V. v\\<noteq>v' \\<longrightarrow> (\\<exists>ps. is_path v ps v')\""], ["", "lemma (in valid_unMultigraph) \"connected \\<Longrightarrow> \\<forall>v\\<in>V. \\<forall>v'\\<in>V. v\\<noteq>v'\\<longrightarrow>(\\<exists>ps. is_trail v ps v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.connected \\<Longrightarrow>\n    \\<forall>v\\<in>V.\n       \\<forall>v'\\<in>V.\n          v \\<noteq> v' \\<longrightarrow> (\\<exists>ps. is_trail v ps v')", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>local.connected; v \\<in> V; v' \\<in> V;\n        v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. is_trail v ps v'", "fix v v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>local.connected; v \\<in> V; v' \\<in> V;\n        v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. is_trail v ps v'", "assume \"v\\<in>V\" \"v'\\<in>V\" \"v\\<noteq>v'\""], ["proof (state)\nthis:\n  v \\<in> V\n  v' \\<in> V\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>local.connected; v \\<in> V; v' \\<in> V;\n        v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. is_trail v ps v'", "assume connected"], ["proof (state)\nthis:\n  local.connected\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>local.connected; v \\<in> V; v' \\<in> V;\n        v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. is_trail v ps v'", "obtain ps where \"is_path v ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps. is_path v ps v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>connected\\<close> \\<open>v \\<in> V\\<close> \\<open>v' \\<in> V\\<close> \\<open>v\\<noteq>v'\\<close>  connected_def)"], ["proof (state)\nthis:\n  is_path v ps v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>local.connected; v \\<in> V; v' \\<in> V;\n        v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. is_trail v ps v'", "then"], ["proof (chain)\npicking this:\n  is_path v ps v'", "obtain ps' where \"is_trail v ps' v'\""], ["proof (prove)\nusing this:\n  is_path v ps v'\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        is_trail v ps' v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct ps arbitrary:v )"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v [] v'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  is_trail v ?ps' v' \\<Longrightarrow> thesis\n  is_path v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v [] v'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  is_trail v ?ps' v' \\<Longrightarrow> thesis\n  is_path v [] v'\n\ngoal (1 subgoal):\n 1. thesis", "by (metis is_trail.simps(1) is_path.simps(1))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ps'. is_trail ?v ps' v' \\<Longrightarrow> thesis;\n   is_path ?v xs v'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  is_trail v ?ps' v' \\<Longrightarrow> thesis\n  is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"is_path x3 xs v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path x3 xs v'", "by (metis Cons.prems(2) is_path.simps(2) x)"], ["proof (state)\nthis:\n  is_path x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  is_path x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "fix ps'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "assume \"is_trail x3 ps' v'\""], ["proof (state)\nthis:\n  is_trail x3 ps' v'\n\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "hence \"(x1,x2,x3)\\<notin>set ps' \\<and> (x3,x2,x1)\\<notin>set ps' \\<Longrightarrow>is_trail v (x#ps') v'\""], ["proof (prove)\nusing this:\n  is_trail x3 ps' v'\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<notin> set ps' \\<and>\n    (x3, x2, x1) \\<notin> set ps' \\<Longrightarrow>\n    is_trail v (x # ps') v'", "by (metis Cons.prems(2) is_trail.simps(2) is_path.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<notin> set ps' \\<and>\n  (x3, x2, x1) \\<notin> set ps' \\<Longrightarrow>\n  is_trail v (x # ps') v'\n\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<notin> set ps' \\<and>\n  (x3, x2, x1) \\<notin> set ps' \\<Longrightarrow>\n  is_trail v (x # ps') v'\n\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "have \"(x1,x2,x3)\\<in>set ps' \\<Longrightarrow> \\<exists>ps1. is_trail v ps1 v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "assume \"(x1,x2,x3)\\<in>set ps'\""], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> set ps'\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "then"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<in> set ps'", "obtain ps1 ps2 where \"ps'=ps1@(x1,x2,x3)#ps2\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> set ps'\n\ngoal (1 subgoal):\n 1. (\\<And>ps1 ps2.\n        ps' = ps1 @ (x1, x2, x3) # ps2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis split_list)"], ["proof (state)\nthis:\n  ps' = ps1 @ (x1, x2, x3) # ps2\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "hence \"is_trail v (x#ps2) v'\""], ["proof (prove)\nusing this:\n  ps' = ps1 @ (x1, x2, x3) # ps2\n\ngoal (1 subgoal):\n 1. is_trail v (x # ps2) v'", "using \\<open>is_trail x3 ps' v'\\<close> x"], ["proof (prove)\nusing this:\n  ps' = ps1 @ (x1, x2, x3) # ps2\n  is_trail x3 ps' v'\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_trail v (x # ps2) v'", "by (metis Cons.prems(2) is_trail.simps(2) \n                    is_trail_split is_path.simps(2))"], ["proof (state)\nthis:\n  is_trail v (x # ps2) v'\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_trail v (x # ps2) v'\n\ngoal (1 subgoal):\n 1. \\<exists>ps1. is_trail v ps1 v'", "by rule"], ["proof (state)\nthis:\n  \\<exists>ps1. is_trail v ps1 v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "have \"(x3,x2,x1)\\<in>set ps' \\<Longrightarrow>  \\<exists>ps1. is_trail v ps1 v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "assume \"(x3,x2,x1)\\<in>set ps'\""], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> set ps'\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "then"], ["proof (chain)\npicking this:\n  (x3, x2, x1) \\<in> set ps'", "obtain ps1 ps2 where \"ps'=ps1@(x3,x2,x1)#ps2\""], ["proof (prove)\nusing this:\n  (x3, x2, x1) \\<in> set ps'\n\ngoal (1 subgoal):\n 1. (\\<And>ps1 ps2.\n        ps' = ps1 @ (x3, x2, x1) # ps2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis split_list)"], ["proof (state)\nthis:\n  ps' = ps1 @ (x3, x2, x1) # ps2\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "hence \"is_trail v ps2 v'\""], ["proof (prove)\nusing this:\n  ps' = ps1 @ (x3, x2, x1) # ps2\n\ngoal (1 subgoal):\n 1. is_trail v ps2 v'", "using \\<open>is_trail x3 ps' v'\\<close> x"], ["proof (prove)\nusing this:\n  ps' = ps1 @ (x3, x2, x1) # ps2\n  is_trail x3 ps' v'\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_trail v ps2 v'", "by (metis Cons.prems(2) is_trail.simps(2) \n                    is_trail_split is_path.simps(2))"], ["proof (state)\nthis:\n  is_trail v ps2 v'\n\ngoal (1 subgoal):\n 1. (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n    \\<exists>ps1. is_trail v ps1 v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_trail v ps2 v'\n\ngoal (1 subgoal):\n 1. \\<exists>ps1. is_trail v ps1 v'", "by rule"], ["proof (state)\nthis:\n  \\<exists>ps1. is_trail v ps1 v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n\ngoal (1 subgoal):\n 1. \\<And>ps'. is_trail x3 ps' v' \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<notin> set ps' \\<and>\n  (x3, x2, x1) \\<notin> set ps' \\<Longrightarrow>\n  is_trail v (x # ps') v'\n  (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n  (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'", "show thesis"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<notin> set ps' \\<and>\n  (x3, x2, x1) \\<notin> set ps' \\<Longrightarrow>\n  is_trail v (x # ps') v'\n  (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n  (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n\ngoal (1 subgoal):\n 1. thesis", "using Cons"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<notin> set ps' \\<and>\n  (x3, x2, x1) \\<notin> set ps' \\<Longrightarrow>\n  is_trail v (x # ps') v'\n  (x1, x2, x3) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n  (x3, x2, x1) \\<in> set ps' \\<Longrightarrow>\n  \\<exists>ps1. is_trail v ps1 v'\n  \\<lbrakk>\\<And>ps'. is_trail ?v ps' v' \\<Longrightarrow> thesis;\n   is_path ?v xs v'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  is_trail v ?ps' v' \\<Longrightarrow> thesis\n  is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_trail x3 ?ps' v' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<And>ps'.\n                               is_trail v ps' v' \\<Longrightarrow> thesis;\n                    is_path v ps v'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ps'. is_trail v ps' v' \\<Longrightarrow> thesis;\n        is_path v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_path x3 xs v'\n  is_trail x3 ?ps' v' \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\nusing this:\n  is_path x3 xs v'\n  is_trail x3 ?ps' v' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "using Cons"], ["proof (prove)\nusing this:\n  is_path x3 xs v'\n  is_trail x3 ?ps' v' \\<Longrightarrow> thesis\n  \\<lbrakk>\\<And>ps'. is_trail ?v ps' v' \\<Longrightarrow> thesis;\n   is_path ?v xs v'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  is_trail v ?ps' v' \\<Longrightarrow> thesis\n  is_path v (x # xs) v'\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_trail v ps' v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>local.connected; v \\<in> V; v' \\<in> V;\n        v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. is_trail v ps v'", "thus \"\\<exists>ps. is_trail v ps v'\""], ["proof (prove)\nusing this:\n  is_trail v ps' v'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "by rule"], ["proof (state)\nthis:\n  \\<exists>ps. is_trail v ps v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) no_rep_length: \"is_trail v ps v'\\<Longrightarrow>length ps=card(set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v ps v' \\<Longrightarrow> length ps = card (set ps)", "by (induct ps arbitrary:v, auto)"], ["", "lemma (in valid_unMultigraph) path_in_edges:\"is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v. is_trail v [] v' \\<Longrightarrow> set [] \\<subseteq> E\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "case Nil"], ["proof (state)\nthis:\n  is_trail v [] v'\n\ngoal (2 subgoals):\n 1. \\<And>v. is_trail v [] v' \\<Longrightarrow> set [] \\<subseteq> E\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  set [] \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "case (Cons x xs)"], ["proof (state)\nthis:\n  is_trail ?v xs v' \\<Longrightarrow> set xs \\<subseteq> E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "hence \"is_trail x3 xs v'\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_trail x3 xs v'", "using Cons"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n  is_trail ?v xs v' \\<Longrightarrow> set xs \\<subseteq> E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. is_trail x3 xs v'", "by auto"], ["proof (state)\nthis:\n  is_trail x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "hence \" set xs \\<subseteq> E\""], ["proof (prove)\nusing this:\n  is_trail x3 xs v'\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> E", "using Cons"], ["proof (prove)\nusing this:\n  is_trail x3 xs v'\n  is_trail ?v xs v' \\<Longrightarrow> set xs \\<subseteq> E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> E\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "have \"x\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> E", "using Cons"], ["proof (prove)\nusing this:\n  is_trail ?v xs v' \\<Longrightarrow> set xs \\<subseteq> E\n  is_trail v (x # xs) v'\n\ngoal (1 subgoal):\n 1. x \\<in> E", "by (metis is_trail_intro is_path.simps(2) x)"], ["proof (state)\nthis:\n  x \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   is_trail v ps v' \\<Longrightarrow> set ps \\<subseteq> E;\n        is_trail v (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> set (a # ps) \\<subseteq> E", "ultimately"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> E\n  x \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> E\n  x \\<in> E\n\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> E", "by auto"], ["proof (state)\nthis:\n  set (x # xs) \\<subseteq> E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) trail_bound: \n    assumes \"finite E\" \" is_trail v ps v'\"\n    shows \"length ps \\<le>card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps \\<le> card E", "by (metis (hide_lams, no_types) assms(1) assms(2) card_mono no_rep_length path_in_edges)"], ["", "definition (in valid_unMultigraph) exist_path_length:: \"'v \\<Rightarrow> nat \\<Rightarrow>bool\" where\n  \"exist_path_length v l\\<equiv>\\<exists>v' ps. is_trail v' ps v \\<and> length ps=l\""], ["", "lemma (in valid_unMultigraph) longest_path:\n  assumes \"finite E\" \"n \\<in> V\"\n  shows \"\\<exists>v. \\<exists>max_path. is_trail v max_path n \\<and> \n        (\\<forall>v'. \\<forall>e\\<in>E. \\<not>is_trail v' (e#max_path) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'. \\<forall>e\\<in>E. \\<not> is_trail v' (e # max_path) n)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "assume  contro:\"\\<not> (\\<exists>v max_path. is_trail v max_path n \n           \\<and> (\\<forall>v'. \\<forall>e\\<in>E. \\<not>is_trail v' (e#max_path) n))\""], ["proof (state)\nthis:\n  \\<nexists>v max_path.\n     is_trail v max_path n \\<and>\n     (\\<forall>v'. \\<forall>e\\<in>E. \\<not> is_trail v' (e # max_path) n)\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence  induct:\"(\\<forall>v max_path.  is_trail v max_path n \n           \\<longrightarrow> (\\<exists>v'. \\<exists>e\\<in>E. is_trail v' (e#max_path) n))\""], ["proof (prove)\nusing this:\n  \\<nexists>v max_path.\n     is_trail v max_path n \\<and>\n     (\\<forall>v'. \\<forall>e\\<in>E. \\<not> is_trail v' (e # max_path) n)\n\ngoal (1 subgoal):\n 1. \\<forall>v max_path.\n       is_trail v max_path n \\<longrightarrow>\n       (\\<exists>v'. \\<exists>e\\<in>E. is_trail v' (e # max_path) n)", "by auto"], ["proof (state)\nthis:\n  \\<forall>v max_path.\n     is_trail v max_path n \\<longrightarrow>\n     (\\<exists>v'. \\<exists>e\\<in>E. is_trail v' (e # max_path) n)\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "have \"is_trail n [] n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_trail n [] n", "using \\<open>n \\<in> V\\<close>"], ["proof (prove)\nusing this:\n  n \\<in> V\n\ngoal (1 subgoal):\n 1. is_trail n [] n", "by auto"], ["proof (state)\nthis:\n  is_trail n [] n\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence \"exist_path_length n 0\""], ["proof (prove)\nusing this:\n  is_trail n [] n\n\ngoal (1 subgoal):\n 1. exist_path_length n 0", "unfolding exist_path_length_def"], ["proof (prove)\nusing this:\n  is_trail n [] n\n\ngoal (1 subgoal):\n 1. \\<exists>v' ps. is_trail v' ps n \\<and> length ps = 0", "by auto"], ["proof (state)\nthis:\n  exist_path_length n 0\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  exist_path_length n 0\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "have \"\\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E", "using trail_bound[OF \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  is_trail ?v ?ps ?v' \\<Longrightarrow> length ?ps \\<le> card E\n\ngoal (1 subgoal):\n 1. \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E", "unfolding exist_path_length_def"], ["proof (prove)\nusing this:\n  is_trail ?v ?ps ?v' \\<Longrightarrow> length ?ps \\<le> card E\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (\\<exists>v' ps.\n           is_trail v' ps n \\<and> length ps = y) \\<longrightarrow>\n       y \\<le> card E", "by auto"], ["proof (state)\nthis:\n  \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence bound:\"\\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\""], ["proof (prove)\nusing this:\n  \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\n\ngoal (1 subgoal):\n 1. \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E", "by auto"], ["proof (state)\nthis:\n  \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  exist_path_length n 0\n  \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E", "have \"exist_path_length n (GREATEST x. exist_path_length n x)\""], ["proof (prove)\nusing this:\n  exist_path_length n 0\n  \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\n\ngoal (1 subgoal):\n 1. exist_path_length n (GREATEST x. exist_path_length n x)", "using GreatestI_nat"], ["proof (prove)\nusing this:\n  exist_path_length n 0\n  \\<forall>y. exist_path_length n y \\<longrightarrow> y \\<le> card E\n  \\<lbrakk>?P ?k; \\<And>y. ?P y \\<Longrightarrow> y \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?P (Greatest ?P)\n\ngoal (1 subgoal):\n 1. exist_path_length n (GREATEST x. exist_path_length n x)", "by auto"], ["proof (state)\nthis:\n  exist_path_length n (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  exist_path_length n (GREATEST x. exist_path_length n x)", "obtain v max_path where \n    max_path:\"is_trail v max_path n\" \"length max_path=(GREATEST x. exist_path_length n x)\""], ["proof (prove)\nusing this:\n  exist_path_length n (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. (\\<And>v max_path.\n        \\<lbrakk>is_trail v max_path n;\n         length max_path = (GREATEST x. exist_path_length n x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis exist_path_length_def)"], ["proof (state)\nthis:\n  is_trail v max_path n\n  length max_path = (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence \"\\<exists> v' e. is_trail v' (e#max_path) n\""], ["proof (prove)\nusing this:\n  is_trail v max_path n\n  length max_path = (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. \\<exists>v' e. is_trail v' (e # max_path) n", "using induct"], ["proof (prove)\nusing this:\n  is_trail v max_path n\n  length max_path = (GREATEST x. exist_path_length n x)\n  \\<forall>v max_path.\n     is_trail v max_path n \\<longrightarrow>\n     (\\<exists>v'. \\<exists>e\\<in>E. is_trail v' (e # max_path) n)\n\ngoal (1 subgoal):\n 1. \\<exists>v' e. is_trail v' (e # max_path) n", "by metis"], ["proof (state)\nthis:\n  \\<exists>v' e. is_trail v' (e # max_path) n\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence \"exist_path_length n (length max_path +1)\""], ["proof (prove)\nusing this:\n  \\<exists>v' e. is_trail v' (e # max_path) n\n\ngoal (1 subgoal):\n 1. exist_path_length n (length max_path + 1)", "by (metis One_nat_def exist_path_length_def list.size(4))"], ["proof (state)\nthis:\n  exist_path_length n (length max_path + 1)\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence \"length max_path + 1 \\<le> (GREATEST x. exist_path_length n x)\""], ["proof (prove)\nusing this:\n  exist_path_length n (length max_path + 1)\n\ngoal (1 subgoal):\n 1. length max_path + 1 \\<le> (GREATEST x. exist_path_length n x)", "by (metis Greatest_le_nat bound)"], ["proof (state)\nthis:\n  length max_path + 1 \\<le> (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "hence \"length max_path + 1 \\<le> length max_path\""], ["proof (prove)\nusing this:\n  length max_path + 1 \\<le> (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. length max_path + 1 \\<le> length max_path", "using max_path"], ["proof (prove)\nusing this:\n  length max_path + 1 \\<le> (GREATEST x. exist_path_length n x)\n  is_trail v max_path n\n  length max_path = (GREATEST x. exist_path_length n x)\n\ngoal (1 subgoal):\n 1. length max_path + 1 \\<le> length max_path", "by auto"], ["proof (state)\nthis:\n  length max_path + 1 \\<le> length max_path\n\ngoal (1 subgoal):\n 1. \\<nexists>v max_path.\n       is_trail v max_path n \\<and>\n       (\\<forall>v'.\n           \\<forall>e\\<in>E.\n              \\<not> is_trail v' (e # max_path) n) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  length max_path + 1 \\<le> length max_path\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma even_card':\n  assumes \"even(card A)\" \"x\\<in>A\"\n  shows \"\\<exists>y\\<in>A. y\\<noteq>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. y \\<noteq> x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>A. y \\<noteq> x) \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>y\\<in>A. y \\<noteq> x)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>y\\<in>A. y \\<noteq> x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>A. y \\<noteq> x) \\<Longrightarrow> False", "hence \"\\<forall>y\\<in>A. y=x\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>A. y \\<noteq> x)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. y = x", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A. y = x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>A. y \\<noteq> x) \\<Longrightarrow> False", "hence \"A={x}\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A. y = x\n\ngoal (1 subgoal):\n 1. A = {x}", "by (metis all_not_in_conv assms(2) insertI2 mk_disjoint_insert)"], ["proof (state)\nthis:\n  A = {x}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>A. y \\<noteq> x) \\<Longrightarrow> False", "hence \"card(A)=1\""], ["proof (prove)\nusing this:\n  A = {x}\n\ngoal (1 subgoal):\n 1. card A = 1", "by auto"], ["proof (state)\nthis:\n  card A = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>A. y \\<noteq> x) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  card A = 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>even(card A)\\<close>"], ["proof (prove)\nusing this:\n  card A = 1\n  even (card A)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_card: \n  assumes \"finite A\" \"odd(card A)\"\n  shows \"\\<exists>x. x\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> A", "by (metis all_not_in_conv assms(2) card.empty even_zero)"], ["", "lemma (in valid_unMultigraph) extend_distinct_path: \n  assumes \"finite E\"  \"is_trail v' ps v\" \n  assumes parity_assms:\"(even (degree v' G)\\<and>v'\\<noteq>v)\\<or>(odd (degree v' G)\\<and>v'=v)\"\n  shows \"\\<exists>e v1. is_trail v1 (e#ps) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "have \"(even (degree v' G)\\<and>v'\\<noteq>v) \\<Longrightarrow> odd(degree v' (rem_unPath  ps G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree v' G) \\<and> v' \\<noteq> v \\<Longrightarrow>\n    odd (degree v' (rem_unPath ps G))", "by (metis assms(1) assms(2) rem_UnPath_parity_v)"], ["proof (state)\nthis:\n  even (degree v' G) \\<and> v' \\<noteq> v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "moreover"], ["proof (state)\nthis:\n  even (degree v' G) \\<and> v' \\<noteq> v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "have \"(odd (degree v' G)\\<and>v'=v) \\<Longrightarrow> odd(degree v' (rem_unPath  ps G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' G) \\<and> v' = v \\<Longrightarrow>\n    odd (degree v' (rem_unPath ps G))", "by (metis assms(1) assms(2) rem_UnPath_parity_v')"], ["proof (state)\nthis:\n  odd (degree v' G) \\<and> v' = v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "ultimately"], ["proof (chain)\npicking this:\n  even (degree v' G) \\<and> v' \\<noteq> v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n  odd (degree v' G) \\<and> v' = v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))", "have \"odd(degree v' (rem_unPath  ps G))\""], ["proof (prove)\nusing this:\n  even (degree v' G) \\<and> v' \\<noteq> v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n  odd (degree v' G) \\<and> v' = v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath ps G))", "using parity_assms"], ["proof (prove)\nusing this:\n  even (degree v' G) \\<and> v' \\<noteq> v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n  odd (degree v' G) \\<and> v' = v \\<Longrightarrow>\n  odd (degree v' (rem_unPath ps G))\n  even (degree v' G) \\<and> v' \\<noteq> v \\<or>\n  odd (degree v' G) \\<and> v' = v\n\ngoal (1 subgoal):\n 1. odd (degree v' (rem_unPath ps G))", "by auto"], ["proof (state)\nthis:\n  odd (degree v' (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "hence \"odd (card {e. fst e=v' \\<and> e\\<in>edges G - (set ps \\<union> set (rev_path ps))})\""], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath ps G))\n\ngoal (1 subgoal):\n 1. odd (card\n          {e. fst e = v' \\<and>\n              e \\<in> E - (set ps \\<union> set (rev_path ps))})", "using  rem_unPath_edges"], ["proof (prove)\nusing this:\n  odd (degree v' (rem_unPath ps G))\n  edges (rem_unPath ?ps ?G) =\n  edges ?G - (set ?ps \\<union> set (rev_path ?ps))\n\ngoal (1 subgoal):\n 1. odd (card\n          {e. fst e = v' \\<and>\n              e \\<in> E - (set ps \\<union> set (rev_path ps))})", "unfolding degree_def"], ["proof (prove)\nusing this:\n  odd (card {e \\<in> edges (rem_unPath ps G). fst e = v'})\n  edges (rem_unPath ?ps ?G) =\n  edges ?G - (set ?ps \\<union> set (rev_path ?ps))\n\ngoal (1 subgoal):\n 1. odd (card\n          {e. fst e = v' \\<and>\n              e \\<in> E - (set ps \\<union> set (rev_path ps))})", "by (metis (lifting, no_types) Collect_cong)"], ["proof (state)\nthis:\n  odd (card\n        {e. fst e = v' \\<and>\n            e \\<in> E - (set ps \\<union> set (rev_path ps))})\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "hence \"{e. fst e=v' \\<and> e\\<in>E - (set ps \\<union> set (rev_path ps))}\\<noteq>{}\""], ["proof (prove)\nusing this:\n  odd (card\n        {e. fst e = v' \\<and>\n            e \\<in> E - (set ps \\<union> set (rev_path ps))})\n\ngoal (1 subgoal):\n 1. {e. fst e = v' \\<and>\n        e \\<in> E - (set ps \\<union> set (rev_path ps))} \\<noteq>\n    {}", "by (metis empty_iff finite.emptyI odd_card)"], ["proof (state)\nthis:\n  {e. fst e = v' \\<and>\n      e \\<in> E - (set ps \\<union> set (rev_path ps))} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "then"], ["proof (chain)\npicking this:\n  {e. fst e = v' \\<and>\n      e \\<in> E - (set ps \\<union> set (rev_path ps))} \\<noteq>\n  {}", "obtain v0 w where v0w:  \"(v',w,v0)\\<in>E\" \"(v',w,v0)\\<notin>set ps \\<union> set (rev_path ps)\""], ["proof (prove)\nusing this:\n  {e. fst e = v' \\<and>\n      e \\<in> E - (set ps \\<union> set (rev_path ps))} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>w v0.\n        \\<lbrakk>(v', w, v0) \\<in> E;\n         (v', w, v0) \\<notin> set ps \\<union> set (rev_path ps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v', w, v0) \\<in> E\n  (v', w, v0) \\<notin> set ps \\<union> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "hence \"is_trail v0 ((v0,w,v')#ps) v\""], ["proof (prove)\nusing this:\n  (v', w, v0) \\<in> E\n  (v', w, v0) \\<notin> set ps \\<union> set (rev_path ps)\n\ngoal (1 subgoal):\n 1. is_trail v0 ((v0, w, v') # ps) v", "by (metis (hide_lams, mono_tags) Un_iff assms(2) corres in_set_rev_path is_trail.simps(2))"], ["proof (state)\nthis:\n  is_trail v0 ((v0, w, v') # ps) v\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_trail v0 ((v0, w, v') # ps) v\n\ngoal (1 subgoal):\n 1. \\<exists>e v1. is_trail v1 (e # ps) v", "by metis"], ["proof (state)\nthis:\n  \\<exists>e v1. is_trail v1 (e # ps) v\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>replace an edge (or its reverse in a path) by another path (in an undirected graph)\\<close>"], ["", "fun replace_by_UnPath:: \"('v,'w) path \\<Rightarrow> 'v \\<times>'w \\<times>'v \\<Rightarrow> ('v,'w) path \\<Rightarrow>  ('v,'w) path\" where\n  \"replace_by_UnPath [] _ _ = []\" |\n  \"replace_by_UnPath (x#xs) (v,e,v') ps = \n    (if x=(v,e,v') then ps@replace_by_UnPath xs (v,e,v') ps\n     else if x=(v',e,v) then (rev_path ps)@replace_by_UnPath xs (v,e,v') ps\n     else x#replace_by_UnPath xs (v,e,v') ps)\""], ["", "lemma (in valid_unMultigraph) del_unEdge_connectivity:\n  assumes \"connected\" \"\\<exists>ps. valid_graph.is_path (del_unEdge v e v' G) v ps v'\"\n  shows \"valid_unMultigraph.connected (del_unEdge v e v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have valid_unMulti:\"valid_unMultigraph (del_unEdge v e v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' G)", "by simp"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v e v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have valid_graph: \"valid_graph (del_unEdge v e v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph (del_unEdge v e v' G)", "using valid_graph_axioms del_undirected"], ["proof (prove)\nusing this:\n  valid_graph G\n  del_unEdge ?v ?e ?v' ?g = delete_edge ?v' ?e ?v (delete_edge ?v ?e ?v' ?g)\n\ngoal (1 subgoal):\n 1. valid_graph (del_unEdge v e v' G)", "by (metis delete_edge_valid)"], ["proof (state)\nthis:\n  valid_graph (del_unEdge v e v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "obtain ex_path where ex_path:\"valid_graph.is_path (del_unEdge v e v' G) v ex_path v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ex_path.\n        valid_graph.is_path (del_unEdge v e v' G) v ex_path\n         v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(2))"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) v ex_path v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "unfolding valid_unMultigraph.connected_def[OF valid_unMulti]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>va\\<in>nodes (del_unEdge v e v' G).\n       \\<forall>v'a\\<in>nodes (del_unEdge v e v' G).\n          va \\<noteq> v'a \\<longrightarrow>\n          (\\<exists>ps. valid_graph.is_path (del_unEdge v e v' G) va ps v'a)", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "assume  n : \"n \\<in>nodes (del_unEdge v e v' G)\""], ["proof (state)\nthis:\n  n \\<in> nodes (del_unEdge v e v' G)\n\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "assume  n': \"n'\\<in>nodes (del_unEdge v e v' G)\""], ["proof (state)\nthis:\n  n' \\<in> nodes (del_unEdge v e v' G)\n\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "assume \"n\\<noteq>n'\""], ["proof (state)\nthis:\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "obtain ps where ps:\"is_path n ps n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps. is_path n ps n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>n\\<noteq>n'\\<close> n n' \\<open>connected\\<close> connected_def del_UnEdge_node)"], ["proof (state)\nthis:\n  is_path n ps n'\n\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "hence \"valid_graph.is_path (del_unEdge v e v' G) \n           n (replace_by_UnPath ps (v,e,v') ex_path) n'\""], ["proof (prove)\nusing this:\n  is_path n ps n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath ps (v, e, v') ex_path) n'", "proof (induct ps arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       is_path n [] n' \\<Longrightarrow>\n       valid_graph.is_path (del_unEdge v e v' G) n\n        (replace_by_UnPath [] (v, e, v') ex_path) n'\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "case Nil"], ["proof (state)\nthis:\n  is_path n [] n'\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       is_path n [] n' \\<Longrightarrow>\n       valid_graph.is_path (del_unEdge v e v' G) n\n        (replace_by_UnPath [] (v, e, v') ex_path) n'\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "thus ?case"], ["proof (prove)\nusing this:\n  is_path n [] n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath [] (v, e, v') ex_path) n'", "by (metis is_path.simps(1) n' replace_by_UnPath.simps(1) valid_graph \n          valid_graph.is_path_simps(1))"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath [] (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "case (Cons x xs)"], ["proof (state)\nthis:\n  is_path ?n xs n' \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) ?n\n   (replace_by_UnPath xs (v, e, v') ex_path) n'\n  is_path n (x # xs) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "have \"x=(v,e,v') \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (v, e, v') \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = (v, e, v') \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "assume \"x=(v,e,v')\""], ["proof (state)\nthis:\n  x = (v, e, v')\n\ngoal (1 subgoal):\n 1. x = (v, e, v') \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "hence \"valid_graph.is_path (del_unEdge v e v' G) \n                n (replace_by_UnPath (x#xs) (v,e,v') ex_path) n'\n                = valid_graph.is_path (del_unEdge v e v' G) \n                n (ex_path@(replace_by_UnPath xs (v,e,v') ex_path)) n'\""], ["proof (prove)\nusing this:\n  x = (v, e, v')\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n'", "by (metis replace_by_UnPath.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. x = (v, e, v') \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "also"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. x = (v, e, v') \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "have \"...=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n' =\n    True", "by (metis Cons.hyps Cons.prems \\<open>x = (v, e, v')\\<close> ex_path is_path.simps(2) valid_graph \n                  valid_graph.is_path_split)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n' =\n  True\n\ngoal (1 subgoal):\n 1. x = (v, e, v') \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "finally"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  True", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  True\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "by simp"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (v, e, v') \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "moreover"], ["proof (state)\nthis:\n  x = (v, e, v') \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "have \"x=(v',e,v) \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "assume \"x=(v',e,v)\""], ["proof (state)\nthis:\n  x = (v', e, v)\n\ngoal (1 subgoal):\n 1. x = (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "hence \"valid_graph.is_path (del_unEdge v e v' G) \n                n (replace_by_UnPath (x#xs) (v,e,v') ex_path) n'\n                = valid_graph.is_path (del_unEdge v e v' G) \n                n ((rev_path ex_path)@(replace_by_UnPath xs (v,e,v') ex_path)) n'\""], ["proof (prove)\nusing this:\n  x = (v', e, v)\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (rev_path ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n'", "by (metis Cons.prems is_path.simps(2) no_id replace_by_UnPath.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (rev_path ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. x = (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "also"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (rev_path ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. x = (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "have \"...=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (rev_path ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n' =\n    True", "by (metis Cons.hyps Cons.prems \\<open>x = (v', e, v)\\<close> is_path.simps(2) ex_path valid_graph \n                  valid_graph.is_path_split valid_unMulti valid_unMultigraph.is_path_rev)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (rev_path ex_path @ replace_by_UnPath xs (v, e, v') ex_path) n' =\n  True\n\ngoal (1 subgoal):\n 1. x = (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "finally"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  True", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n' =\n  True\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "by simp"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "moreover"], ["proof (state)\nthis:\n  x = (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "have \"x\\<noteq>(v,e,v')\\<and>x\\<noteq>(v',e,v)\\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (v, e, v') \\<and> x \\<noteq> (v', e, v) \\<Longrightarrow>\n    valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "by (metis Cons.hyps Cons.prems del_UnEdge_frame is_path.simps(2) replace_by_UnPath.simps(2) \n              valid_graph valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  x \\<noteq> (v, e, v') \\<and> x \\<noteq> (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   is_path n ps n' \\<Longrightarrow>\n                   valid_graph.is_path (del_unEdge v e v' G) n\n                    (replace_by_UnPath ps (v, e, v') ex_path) n';\n        is_path n (a # ps) n'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v e v' G) n\n                          (replace_by_UnPath (a # ps) (v, e, v') ex_path) n'", "ultimately"], ["proof (chain)\npicking this:\n  x = (v, e, v') \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n  x = (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n  x \\<noteq> (v, e, v') \\<and> x \\<noteq> (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "show ?case"], ["proof (prove)\nusing this:\n  x = (v, e, v') \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n  x = (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n  x \\<noteq> (v, e, v') \\<and> x \\<noteq> (v', e, v) \\<Longrightarrow>\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v e v' G) n\n     (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath (x # xs) (v, e, v') ex_path) n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath ps (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<And>va v'a.\n       \\<lbrakk>va \\<in> nodes (del_unEdge v e v' G);\n        v'a \\<in> nodes (del_unEdge v e v' G); va \\<noteq> v'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps.\n                            valid_graph.is_path (del_unEdge v e v' G) va ps\n                             v'a", "thus \"\\<exists>ps. valid_graph.is_path (del_unEdge v e v' G) n ps n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v e v' G) n\n   (replace_by_UnPath ps (v, e, v') ex_path) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. valid_graph.is_path (del_unEdge v e v' G) n ps n'", "by auto"], ["proof (state)\nthis:\n  \\<exists>ps. valid_graph.is_path (del_unEdge v e v' G) n ps n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_unMultigraph.connected (del_unEdge v e v' G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) path_between_odds:\n  assumes \"odd(degree v G)\" \"odd(degree v' G)\" \"finite E\"  \"v\\<noteq>v'\" \"num_of_odd_nodes G=2\"\n  shows \"\\<exists>ps. is_trail v ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "have \"v\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> False", "assume \"v\\<notin>V\""], ["proof (state)\nthis:\n  v \\<notin> V\n\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> False", "hence \"\\<forall>e \\<in> E. fst e \\<noteq> v\""], ["proof (prove)\nusing this:\n  v \\<notin> V\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>E. fst e \\<noteq> v", "by (metis E_valid(1) imageI subsetD)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>E. fst e \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> False", "hence \"degree v G=0\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>E. fst e \\<noteq> v\n\ngoal (1 subgoal):\n 1. degree v G = 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>E. fst e \\<noteq> v\n\ngoal (1 subgoal):\n 1. card {e \\<in> E. fst e = v} = 0", "using \\<open>finite E\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>E. fst e \\<noteq> v\n  finite E\n\ngoal (1 subgoal):\n 1. card {e \\<in> E. fst e = v} = 0", "by force"], ["proof (state)\nthis:\n  degree v G = 0\n\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  degree v G = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>odd(degree v G)\\<close>"], ["proof (prove)\nusing this:\n  degree v G = 0\n  odd (degree v G)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "have \"v'\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> V", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<notin> V \\<Longrightarrow> False", "assume \"v'\\<notin>V\""], ["proof (state)\nthis:\n  v' \\<notin> V\n\ngoal (1 subgoal):\n 1. v' \\<notin> V \\<Longrightarrow> False", "hence \"\\<forall>e \\<in> E. fst e \\<noteq> v'\""], ["proof (prove)\nusing this:\n  v' \\<notin> V\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>E. fst e \\<noteq> v'", "by (metis E_valid(1) imageI subsetD)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>E. fst e \\<noteq> v'\n\ngoal (1 subgoal):\n 1. v' \\<notin> V \\<Longrightarrow> False", "hence \"degree v' G=0\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>E. fst e \\<noteq> v'\n\ngoal (1 subgoal):\n 1. degree v' G = 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>E. fst e \\<noteq> v'\n\ngoal (1 subgoal):\n 1. card {e \\<in> E. fst e = v'} = 0", "using \\<open>finite E\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>E. fst e \\<noteq> v'\n  finite E\n\ngoal (1 subgoal):\n 1. card {e \\<in> E. fst e = v'} = 0", "by force"], ["proof (state)\nthis:\n  degree v' G = 0\n\ngoal (1 subgoal):\n 1. v' \\<notin> V \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  degree v' G = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>odd(degree v' G)\\<close>"], ["proof (prove)\nusing this:\n  degree v' G = 0\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "then"], ["proof (chain)\npicking this:\n  v' \\<in> V", "obtain max_path v0 where max_path:\n      \"is_trail  v0 max_path v'\" \n      \"(\\<forall>n. \\<forall>w\\<in>E. \\<not>is_trail n (w#max_path) v')\""], ["proof (prove)\nusing this:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v0 max_path.\n        \\<lbrakk>is_trail v0 max_path v';\n         \\<forall>n.\n            \\<forall>w\\<in>E. \\<not> is_trail n (w # max_path) v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using longest_path[of v']"], ["proof (prove)\nusing this:\n  v' \\<in> V\n  \\<lbrakk>finite E; v' \\<in> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v max_path.\n                       is_trail v max_path v' \\<and>\n                       (\\<forall>v'a.\n                           \\<forall>e\\<in>E.\n                              \\<not> is_trail v'a (e # max_path) v')\n\ngoal (1 subgoal):\n 1. (\\<And>v0 max_path.\n        \\<lbrakk>is_trail v0 max_path v';\n         \\<forall>n.\n            \\<forall>w\\<in>E. \\<not> is_trail n (w # max_path) v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(3))"], ["proof (state)\nthis:\n  is_trail v0 max_path v'\n  \\<forall>n. \\<forall>w\\<in>E. \\<not> is_trail n (w # max_path) v'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "have \"even(degree v0 G)\\<Longrightarrow>v0=v' \\<Longrightarrow> v0=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v", "by (metis assms(2))"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "have \"even(degree v0 G)\\<Longrightarrow>v0\\<noteq>v' \\<Longrightarrow> v0=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> v0 = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> v0 = v", "assume\"even(degree v0 G)\" \"v0\\<noteq>v'\""], ["proof (state)\nthis:\n  even (degree v0 G)\n  v0 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> v0 = v", "hence \"\\<exists>w v1. is_trail \n            v1 (w#max_path) v'\""], ["proof (prove)\nusing this:\n  even (degree v0 G)\n  v0 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<exists>w v1. is_trail v1 (w # max_path) v'", "by (metis assms(3) extend_distinct_path max_path(1))"], ["proof (state)\nthis:\n  \\<exists>w v1. is_trail v1 (w # max_path) v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> v0 = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w v1. is_trail v1 (w # max_path) v'\n\ngoal (1 subgoal):\n 1. v0 = v", "by (metis (full_types) is_trail.simps(2) max_path(2) prod.exhaust)"], ["proof (state)\nthis:\n  v0 = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "have \"odd(degree v0 G)\\<Longrightarrow>v0=v'\\<Longrightarrow>v0=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v", "assume\"odd(degree v0 G)\" \"v0=v'\""], ["proof (state)\nthis:\n  odd (degree v0 G)\n  v0 = v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v", "hence \"\\<exists>w v1. is_trail v1 (w#max_path) v'\""], ["proof (prove)\nusing this:\n  odd (degree v0 G)\n  v0 = v'\n\ngoal (1 subgoal):\n 1. \\<exists>w v1. is_trail v1 (w # max_path) v'", "by (metis assms(3) extend_distinct_path max_path(1))"], ["proof (state)\nthis:\n  \\<exists>w v1. is_trail v1 (w # max_path) v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w v1. is_trail v1 (w # max_path) v'\n\ngoal (1 subgoal):\n 1. v0 = v", "by (metis (full_types) List.set_simps(2) insert_subset max_path(2) path_in_edges)"], ["proof (state)\nthis:\n  v0 = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "have \"odd(degree v0 G)\\<Longrightarrow>v0\\<noteq>v'\\<Longrightarrow>v0=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> v0 = v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"v0 \\<noteq> v\" \"odd(degree v0 G)\" \"v0\\<noteq>v'\""], ["proof (state)\nthis:\n  v0 \\<noteq> v\n  odd (degree v0 G)\n  v0 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v0 \\<noteq> v\n  odd (degree v0 G)\n  v0 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "have \"v\\<in>odd_nodes_set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> odd_nodes_set G", "using \\<open>v \\<in> V\\<close> \\<open> odd (degree v G)\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> V\n  odd (degree v G)\n\ngoal (1 subgoal):\n 1. v \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  v \\<in> V\n  odd (degree v G)\n\ngoal (1 subgoal):\n 1. v \\<in> {v \\<in> V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "have \"v'\\<in>odd_nodes_set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> odd_nodes_set G", "using \\<open>v' \\<in> V\\<close> \\<open>odd (degree v' G)\\<close>"], ["proof (prove)\nusing this:\n  v' \\<in> V\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. v' \\<in> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  v' \\<in> V\n  odd (degree v' G)\n\ngoal (1 subgoal):\n 1. v' \\<in> {v \\<in> V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  v' \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<noteq> v\n  odd (degree v0 G)\n  v0 \\<noteq> v'\n  v \\<in> odd_nodes_set G\n  v' \\<in> odd_nodes_set G", "have \"{v,v',v0} \\<subseteq> odd_nodes_set G\""], ["proof (prove)\nusing this:\n  v0 \\<noteq> v\n  odd (degree v0 G)\n  v0 \\<noteq> v'\n  v \\<in> odd_nodes_set G\n  v' \\<in> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. {v, v', v0} \\<subseteq> odd_nodes_set G", "using   is_path_memb[OF is_trail_intro[OF \\<open>is_trail v0 max_path v'\\<close>]] max_path(1)"], ["proof (prove)\nusing this:\n  v0 \\<noteq> v\n  odd (degree v0 G)\n  v0 \\<noteq> v'\n  v \\<in> odd_nodes_set G\n  v' \\<in> odd_nodes_set G\n  v0 \\<in> V \\<and> v' \\<in> V\n  is_trail v0 max_path v'\n\ngoal (1 subgoal):\n 1. {v, v', v0} \\<subseteq> odd_nodes_set G", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  v0 \\<noteq> v\n  odd (degree v0 G)\n  v0 \\<noteq> v'\n  v \\<in> {v \\<in> V. odd (degree v G)}\n  v' \\<in> {v \\<in> V. odd (degree v G)}\n  v0 \\<in> V \\<and> v' \\<in> V\n  is_trail v0 max_path v'\n\ngoal (1 subgoal):\n 1. {v, v', v0} \\<subseteq> {v \\<in> V. odd (degree v G)}", "by auto"], ["proof (state)\nthis:\n  {v, v', v0} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {v, v', v0} \\<subseteq> odd_nodes_set G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "have \"card {v,v',v0}=3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {v, v', v0} = 3", "using \\<open>v0\\<noteq>v\\<close> \\<open>v\\<noteq>v'\\<close> \\<open>v0\\<noteq>v'\\<close>"], ["proof (prove)\nusing this:\n  v0 \\<noteq> v\n  v \\<noteq> v'\n  v0 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. card {v, v', v0} = 3", "by auto"], ["proof (state)\nthis:\n  card {v, v', v0} = 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card {v, v', v0} = 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "have \"finite (odd_nodes_set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "using assms(5) card_eq_0_iff[of \"odd_nodes_set G\"]"], ["proof (prove)\nusing this:\n  num_of_odd_nodes G = 2\n  (card (odd_nodes_set G) = 0) =\n  (odd_nodes_set G = {} \\<or> infinite (odd_nodes_set G))\n\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "unfolding num_of_odd_nodes_def"], ["proof (prove)\nusing this:\n  card (odd_nodes_set G) = 2\n  (card (odd_nodes_set G) = 0) =\n  (odd_nodes_set G = {} \\<or> infinite (odd_nodes_set G))\n\ngoal (1 subgoal):\n 1. finite (odd_nodes_set G)", "by auto"], ["proof (state)\nthis:\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {v, v', v0} \\<subseteq> odd_nodes_set G\n  card {v, v', v0} = 3\n  finite (odd_nodes_set G)", "have \"3\\<le>card(odd_nodes_set G)\""], ["proof (prove)\nusing this:\n  {v, v', v0} \\<subseteq> odd_nodes_set G\n  card {v, v', v0} = 3\n  finite (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. 3 \\<le> card (odd_nodes_set G)", "by (metis card_mono)"], ["proof (state)\nthis:\n  3 \\<le> card (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'; v0 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  3 \\<le> card (odd_nodes_set G)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>num_of_odd_nodes G=2\\<close>"], ["proof (prove)\nusing this:\n  3 \\<le> card (odd_nodes_set G)\n  num_of_odd_nodes G = 2\n\ngoal (1 subgoal):\n 1. False", "unfolding num_of_odd_nodes_def"], ["proof (prove)\nusing this:\n  3 \\<le> card (odd_nodes_set G)\n  card (odd_nodes_set G) = 2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>even (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n  \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v\n  \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n  \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v", "have \"v0=v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>even (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n  \\<lbrakk>even (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v\n  \\<lbrakk>odd (degree v0 G); v0 = v'\\<rbrakk> \\<Longrightarrow> v0 = v\n  \\<lbrakk>odd (degree v0 G); v0 \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> v0 = v\n\ngoal (1 subgoal):\n 1. v0 = v", "by auto"], ["proof (state)\nthis:\n  v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  v0 = v\n\ngoal (1 subgoal):\n 1. \\<exists>ps. is_trail v ps v'", "by (metis max_path(1))"], ["proof (state)\nthis:\n  \\<exists>ps. is_trail v ps v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unMultigraph) del_unEdge_even_connectivity:\n  assumes \"finite E\" \"finite V\" \"connected\" \"\\<forall>n\\<in>V. even(degree n G)\" \"(v,e,v')\\<in>E\"\n  shows \"valid_unMultigraph.connected (del_unEdge v e v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have valid_unMulti:\"valid_unMultigraph (del_unEdge v e v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v e v' G)", "by simp"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v e v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have valid_graph: \"valid_graph (del_unEdge v e v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph (del_unEdge v e v' G)", "using valid_graph_axioms del_undirected"], ["proof (prove)\nusing this:\n  valid_graph G\n  del_unEdge ?v ?e ?v' ?g = delete_edge ?v' ?e ?v (delete_edge ?v ?e ?v' ?g)\n\ngoal (1 subgoal):\n 1. valid_graph (del_unEdge v e v' G)", "by (metis delete_edge_valid)"], ["proof (state)\nthis:\n  valid_graph (del_unEdge v e v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have fin_E': \"finite(edges (del_unEdge v e v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (del_unEdge v e v' G))", "by (metis (hide_lams, no_types) assms(1) del_undirected delete_edge_def \n        finite_Diff select_convs(2))"], ["proof (state)\nthis:\n  finite (edges (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have fin_V': \"finite(nodes (del_unEdge v e v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes (del_unEdge v e v' G))", "by (metis (mono_tags) assms(2) del_undirected delete_edge_def select_convs(1))"], ["proof (state)\nthis:\n  finite (nodes (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have all_even: \"\\<forall>n\\<in>nodes (del_unEdge v e v' G). n\\<notin>{v,v'}\n                  \\<longrightarrow>even(degree n (del_unEdge v e v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>nodes (del_unEdge v e v' G).\n       n \\<notin> {v, v'} \\<longrightarrow>\n       even (degree n (del_unEdge v e v' G))", "by (metis (full_types) assms(1) assms(4) degree_frame del_UnEdge_node)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>nodes (del_unEdge v e v' G).\n     n \\<notin> {v, v'} \\<longrightarrow>\n     even (degree n (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \"even (degree v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree v G)", "by (metis (full_types) E_validD(1) assms(4) assms(5))"], ["proof (state)\nthis:\n  even (degree v G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "moreover"], ["proof (state)\nthis:\n  even (degree v G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \"even (degree v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree v' G)", "by (metis (full_types) E_validD(2) assms(4) assms(5))"], ["proof (state)\nthis:\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "moreover"], ["proof (state)\nthis:\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \"num_of_odd_nodes G = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = 0", "using \\<open>\\<forall>n\\<in>V. even(degree n G)\\<close> \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>V. even (degree n G)\n  finite V\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes G = 0", "unfolding num_of_odd_nodes_def odd_nodes_set_def"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>V. even (degree n G)\n  finite V\n\ngoal (1 subgoal):\n 1. card {v \\<in> V. odd (degree v G)} = 0", "by auto"], ["proof (state)\nthis:\n  num_of_odd_nodes G = 0\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "ultimately"], ["proof (chain)\npicking this:\n  even (degree v G)\n  even (degree v' G)\n  num_of_odd_nodes G = 0", "have \"num_of_odd_nodes (del_unEdge v e v' G) = 2\""], ["proof (prove)\nusing this:\n  even (degree v G)\n  even (degree v' G)\n  num_of_odd_nodes G = 0\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v e v' G) = 2", "using del_UnEdge_even_even[of G v e v',OF valid_unMultigraph_axioms]"], ["proof (prove)\nusing this:\n  even (degree v G)\n  even (degree v' G)\n  num_of_odd_nodes G = 0\n  \\<lbrakk>finite E; finite V; (v, e, v') \\<in> E; even (degree v G);\n   even (degree v' G)\\<rbrakk>\n  \\<Longrightarrow> num_of_odd_nodes (del_unEdge v e v' G) =\n                    num_of_odd_nodes G + 2\n\ngoal (1 subgoal):\n 1. num_of_odd_nodes (del_unEdge v e v' G) = 2", "by (metis assms(1) assms(2) assms(5) monoid_add_class.add.left_neutral)"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge v e v' G) = 2\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "moreover"], ["proof (state)\nthis:\n  num_of_odd_nodes (del_unEdge v e v' G) = 2\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \" odd (degree v (del_unEdge v e v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v (del_unEdge v e v' G))", "using \\<open>even (degree v G)\\<close> del_UnEdge_even[OF \\<open>(v,e,v')\\<in>E\\<close> \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  even (degree v G)\n  (v \\<in> odd_nodes_set (del_unEdge v e v' G)) = even (degree v G)\n\ngoal (1 subgoal):\n 1. odd (degree v (del_unEdge v e v' G))", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  even (degree v G)\n  (v \\<in> {va \\<in> nodes (del_unEdge v e v' G).\n            odd (degree va (del_unEdge v e v' G))}) =\n  even (degree v G)\n\ngoal (1 subgoal):\n 1. odd (degree v (del_unEdge v e v' G))", "by auto"], ["proof (state)\nthis:\n  odd (degree v (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "moreover"], ["proof (state)\nthis:\n  odd (degree v (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \"odd (degree v' (del_unEdge v e v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge v e v' G))", "using \\<open>even (degree v' G)\\<close> del_UnEdge_even'[OF \\<open>(v,e,v')\\<in>E\\<close> \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  even (degree v' G)\n  (v' \\<in> odd_nodes_set (del_unEdge v e v' G)) = even (degree v' G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge v e v' G))", "unfolding odd_nodes_set_def"], ["proof (prove)\nusing this:\n  even (degree v' G)\n  (v' \\<in> {va \\<in> nodes (del_unEdge v e v' G).\n             odd (degree va (del_unEdge v e v' G))}) =\n  even (degree v' G)\n\ngoal (1 subgoal):\n 1. odd (degree v' (del_unEdge v e v' G))", "by auto"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "moreover"], ["proof (state)\nthis:\n  odd (degree v' (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \"finite (edges (del_unEdge v e v' G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (del_unEdge v e v' G))", "using \\<open>finite E\\<close>"], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite (edges (del_unEdge v e v' G))", "by auto"], ["proof (state)\nthis:\n  finite (edges (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "moreover"], ["proof (state)\nthis:\n  finite (edges (del_unEdge v e v' G))\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "have \"v\\<noteq>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "using no_id \\<open>(v,e,v')\\<in>E\\<close>"], ["proof (prove)\nusing this:\n  (?v, ?w, ?v) \\<notin> E\n  (v, e, v') \\<in> E\n\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "ultimately"], ["proof (chain)\npicking this:\n  num_of_odd_nodes (del_unEdge v e v' G) = 2\n  odd (degree v (del_unEdge v e v' G))\n  odd (degree v' (del_unEdge v e v' G))\n  finite (edges (del_unEdge v e v' G))\n  v \\<noteq> v'", "have \"\\<exists>ps. valid_unMultigraph.is_trail (del_unEdge v e v' G) v ps v'\""], ["proof (prove)\nusing this:\n  num_of_odd_nodes (del_unEdge v e v' G) = 2\n  odd (degree v (del_unEdge v e v' G))\n  odd (degree v' (del_unEdge v e v' G))\n  finite (edges (del_unEdge v e v' G))\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. valid_unMultigraph.is_trail (del_unEdge v e v' G) v ps v'", "using valid_unMultigraph.path_between_odds[OF valid_unMulti,of v v']"], ["proof (prove)\nusing this:\n  num_of_odd_nodes (del_unEdge v e v' G) = 2\n  odd (degree v (del_unEdge v e v' G))\n  odd (degree v' (del_unEdge v e v' G))\n  finite (edges (del_unEdge v e v' G))\n  v \\<noteq> v'\n  \\<lbrakk>odd (degree v (del_unEdge v e v' G));\n   odd (degree v' (del_unEdge v e v' G));\n   finite (edges (del_unEdge v e v' G)); v \\<noteq> v';\n   num_of_odd_nodes (del_unEdge v e v' G) = 2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ps.\n                       valid_unMultigraph.is_trail (del_unEdge v e v' G) v\n                        ps v'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. valid_unMultigraph.is_trail (del_unEdge v e v' G) v ps v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>ps. valid_unMultigraph.is_trail (del_unEdge v e v' G) v ps v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ps. valid_unMultigraph.is_trail (del_unEdge v e v' G) v ps v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v e v' G)", "by (metis (full_types) assms(3) del_unEdge_connectivity valid_unMulti \n      valid_unMultigraph.is_trail_intro)"], ["proof (state)\nthis:\n  valid_unMultigraph.connected (del_unEdge v e v' G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_graph) path_end:\"ps\\<noteq>[] \\<Longrightarrow> is_path v ps v' \\<Longrightarrow> v'=snd (snd(last ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<noteq> []; is_path v ps v'\\<rbrakk>\n    \\<Longrightarrow> v' = snd (snd (last ps))", "by (induct ps arbitrary:v,auto)"], ["", "lemma (in valid_unMultigraph) connectivity_split:\n  assumes \"connected\" \"\\<not>valid_unMultigraph.connected (del_unEdge v w v' G)\" \n          \"(v,w,v')\\<in>E\"\n  obtains G1 G2 where\n         \"nodes G1={n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\"\n         and \"edges G1={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n            \\<and> n\\<in>nodes G1 \\<and> n'\\<in>nodes G1}\"\n         and \"nodes G2={n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\"\n         and \"edges G2={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n            \\<and> n\\<in>nodes G2 \\<and> n'\\<in>nodes G2}\" \n         and \"edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\" \n         and \"edges G1 \\<inter> edges G2={}\" \n         and \"nodes G1 \\<union> nodes G2=nodes (del_unEdge v w v' G)\"\n         and \"nodes G1 \\<inter> nodes G2={}\" \n         and \"valid_unMultigraph G1\" \n         and \"valid_unMultigraph G2\"\n         and \"valid_unMultigraph.connected G1\"  \n         and \"valid_unMultigraph.connected G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have valid0:\"valid_graph (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph (del_unEdge v w v' G)", "using valid_graph_axioms"], ["proof (prove)\nusing this:\n  valid_graph G\n\ngoal (1 subgoal):\n 1. valid_graph (del_unEdge v w v' G)", "by (metis del_undirected delete_edge_valid)"], ["proof (state)\nthis:\n  valid_graph (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have valid0':\"valid_unMultigraph (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w v' G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w v' G)", "by (metis del_unEdge_valid)"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain G1_nodes where G1_nodes:\"G1_nodes= \n      {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G1_nodes.\n        G1_nodes =\n        {n. \\<exists>ps.\n               valid_graph.is_path (del_unEdge v w v' G) n ps\n                v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}", "obtain G1 where G1:\"G1=\n      \\<lparr>nodes=G1_nodes, edges={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n      \\<and> n\\<in>G1_nodes \\<and> n'\\<in>G1_nodes}\\<rparr>\""], ["proof (prove)\nusing this:\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n\ngoal (1 subgoal):\n 1. (\\<And>G1.\n        G1 =\n        \\<lparr>nodes = G1_nodes,\n           edges =\n             {(n, e, n').\n              (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n              n \\<in> G1_nodes \\<and>\n              n' \\<in> G1_nodes}\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain G2_nodes where G2_nodes:\"G2_nodes= \n      {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G2_nodes.\n        G2_nodes =\n        {n. \\<exists>ps.\n               valid_graph.is_path (del_unEdge v w v' G) n ps\n                v'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}", "obtain G2 where G2:\"G2=\n      \\<lparr>nodes=G2_nodes, edges={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n      \\<and> n\\<in>G2_nodes \\<and> n'\\<in>G2_nodes}\\<rparr>\""], ["proof (prove)\nusing this:\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>G2.\n        G2 =\n        \\<lparr>nodes = G2_nodes,\n           edges =\n             {(n, e, n').\n              (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n              n \\<in> G2_nodes \\<and>\n              n' \\<in> G2_nodes}\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have valid_G1:\"valid_unMultigraph G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph G1", "using G1 valid_unMultigraph.corres[OF valid0'] valid_unMultigraph.no_id[OF valid0']"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  ((?v, ?w, ?u') \\<in> edges (del_unEdge v w v' G)) =\n  ((?u', ?w, ?v) \\<in> edges (del_unEdge v w v' G))\n  (?v, ?w, ?v) \\<notin> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph G1", "by (unfold_locales,auto)"], ["proof (state)\nthis:\n  valid_unMultigraph G1\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence valid_G1':\"valid_graph G1\""], ["proof (prove)\nusing this:\n  valid_unMultigraph G1\n\ngoal (1 subgoal):\n 1. valid_graph G1", "using valid_unMultigraph_def"], ["proof (prove)\nusing this:\n  valid_unMultigraph G1\n  valid_unMultigraph ?G \\<equiv>\n  valid_graph ?G \\<and> valid_unMultigraph_axioms ?G\n\ngoal (1 subgoal):\n 1. valid_graph G1", "by auto"], ["proof (state)\nthis:\n  valid_graph G1\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have valid_G2:\"valid_unMultigraph G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph G2", "using G2 valid_unMultigraph.corres[OF valid0'] valid_unMultigraph.no_id[OF valid0']"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  ((?v, ?w, ?u') \\<in> edges (del_unEdge v w v' G)) =\n  ((?u', ?w, ?v) \\<in> edges (del_unEdge v w v' G))\n  (?v, ?w, ?v) \\<notin> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph G2", "by (unfold_locales,auto)"], ["proof (state)\nthis:\n  valid_unMultigraph G2\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence valid_G2': \"valid_graph G2\""], ["proof (prove)\nusing this:\n  valid_unMultigraph G2\n\ngoal (1 subgoal):\n 1. valid_graph G2", "using valid_unMultigraph_def"], ["proof (prove)\nusing this:\n  valid_unMultigraph G2\n  valid_unMultigraph ?G \\<equiv>\n  valid_graph ?G \\<and> valid_unMultigraph_axioms ?G\n\ngoal (1 subgoal):\n 1. valid_graph G2", "by auto"], ["proof (state)\nthis:\n  valid_graph G2\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"nodes G1={n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes G1 =\n    {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}", "using G1_nodes G1"], ["proof (prove)\nusing this:\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. nodes G1 =\n    {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}", "by auto"], ["proof (state)\nthis:\n  nodes G1 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  nodes G1 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"edges G1={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n                 \\<and> n\\<in>nodes G1 \\<and> n'\\<in>nodes G1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G1 =\n    {(n, e, n').\n     (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n     n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}", "using G1_nodes G1"], ["proof (prove)\nusing this:\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. edges G1 =\n    {(n, e, n').\n     (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n     n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}", "by auto"], ["proof (state)\nthis:\n  edges G1 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  edges G1 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"nodes G2={n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes G2 =\n    {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}", "using G2_nodes G2"], ["proof (prove)\nusing this:\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. nodes G2 =\n    {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}", "by auto"], ["proof (state)\nthis:\n  nodes G2 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  nodes G2 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"edges G2={(n,e,n'). (n,e,n')\\<in>edges (del_unEdge v w v' G) \n                 \\<and> n\\<in>nodes G2 \\<and> n'\\<in>nodes G2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G2 =\n    {(n, e, n').\n     (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n     n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}", "using G2_nodes G2"], ["proof (prove)\nusing this:\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. edges G2 =\n    {(n, e, n').\n     (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n     n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}", "by auto"], ["proof (state)\nthis:\n  edges G2 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  edges G2 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"nodes G1 \\<union> nodes G2=nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "assume \"nodes G1 \\<union> nodes G2 \\<noteq> nodes (del_unEdge v w v' G)\""], ["proof (state)\nthis:\n  nodes G1 \\<union> nodes G2 \\<noteq> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  nodes G1 \\<union> nodes G2 \\<noteq> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)", "using valid_graph.is_path_memb[OF valid0] G1 G1_nodes"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) ?v ?p ?v' \\<Longrightarrow>\n  ?v \\<in> nodes (del_unEdge v w v' G) \\<and>\n  ?v' \\<in> nodes (del_unEdge v w v' G)\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n\ngoal (1 subgoal):\n 1. nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"nodes G2 \\<subseteq> nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes G2 \\<subseteq> nodes (del_unEdge v w v' G)", "using valid_graph.is_path_memb[OF valid0] G2 G2_nodes"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) ?v ?p ?v' \\<Longrightarrow>\n  ?v \\<in> nodes (del_unEdge v w v' G) \\<and>\n  ?v' \\<in> nodes (del_unEdge v w v' G)\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. nodes G2 \\<subseteq> nodes (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  nodes G2 \\<subseteq> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  nodes G1 \\<union> nodes G2 \\<noteq> nodes (del_unEdge v w v' G)\n  nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)\n  nodes G2 \\<subseteq> nodes (del_unEdge v w v' G)", "obtain n where n:\n          \"n\\<in>nodes (del_unEdge v w v' G)\" \"n\\<notin>nodes G1\" \"n\\<notin>nodes G2\""], ["proof (prove)\nusing this:\n  nodes G1 \\<union> nodes G2 \\<noteq> nodes (del_unEdge v w v' G)\n  nodes G1 \\<subseteq> nodes (del_unEdge v w v' G)\n  nodes G2 \\<subseteq> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<in> nodes (del_unEdge v w v' G); n \\<notin> nodes G1;\n         n \\<notin> nodes G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<in> nodes (del_unEdge v w v' G)\n  n \\<notin> nodes G1\n  n \\<notin> nodes G2\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "hence n_neg_v : \"\\<not>(\\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v)\" and\n            n_neg_v': \"\\<not>(\\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v')\""], ["proof (prove)\nusing this:\n  n \\<in> nodes (del_unEdge v w v' G)\n  n \\<notin> nodes G1\n  n \\<notin> nodes G2\n\ngoal (1 subgoal):\n 1. \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v &&&\n    \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'", "using G1 G1_nodes G2 G2_nodes"], ["proof (prove)\nusing this:\n  n \\<in> nodes (del_unEdge v w v' G)\n  n \\<notin> nodes G1\n  n \\<notin> nodes G2\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v &&&\n    \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'", "by auto"], ["proof (state)\nthis:\n  \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v\n  \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "hence \"n\\<noteq>v\""], ["proof (prove)\nusing this:\n  \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v\n  \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'\n\ngoal (1 subgoal):\n 1. n \\<noteq> v", "by (metis n(1) valid0 valid_graph.is_path_simps(1))"], ["proof (state)\nthis:\n  n \\<noteq> v\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> v", "obtain nvs where nvs: \"is_path n nvs v\""], ["proof (prove)\nusing this:\n  n \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>nvs. is_path n nvs v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>connected\\<close>"], ["proof (prove)\nusing this:\n  n \\<noteq> v\n  local.connected\n\ngoal (1 subgoal):\n 1. (\\<And>nvs. is_path n nvs v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis E_validD(1) assms(3) connected_def del_UnEdge_node n(1))"], ["proof (state)\nthis:\n  is_path n nvs v\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  is_path n nvs v", "obtain nvs' where nvs': \"nvs'=takeWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs\""], ["proof (prove)\nusing this:\n  is_path n nvs v\n\ngoal (1 subgoal):\n 1. (\\<And>nvs'.\n        nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have nvs_nvs':\"nvs=nvs'@dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nvs =\n    nvs' @\n    dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs", "using nvs' takeWhile_dropWhile_id"], ["proof (prove)\nusing this:\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n  takeWhile ?P ?xs @ dropWhile ?P ?xs = ?xs\n\ngoal (1 subgoal):\n 1. nvs =\n    nvs' @\n    dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs", "by auto"], ["proof (state)\nthis:\n  nvs =\n  nvs' @\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n  nvs =\n  nvs' @\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs", "obtain n' where is_path_nvs': \"is_path n nvs' n'\"\n          and \"is_path n' (dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs) v\""], ["proof (prove)\nusing this:\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n  nvs =\n  nvs' @\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>is_path n nvs' n';\n         is_path n'\n          (dropWhile\n            (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n            nvs)\n          v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nvs is_path_split[of n nvs' \"dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs\"]"], ["proof (prove)\nusing this:\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n  nvs =\n  nvs' @\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n  is_path n nvs v\n  is_path n\n   (nvs' @\n    dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs)\n   ?v' =\n  (\\<exists>u.\n      is_path n nvs' u \\<and>\n      is_path u\n       (dropWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs)\n       ?v')\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>is_path n nvs' n';\n         is_path n'\n          (dropWhile\n            (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n            nvs)\n          v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_path n nvs' n'\n  is_path n'\n   (dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs)\n   v\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"n'=v \\<or> n'=v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' = v \\<or> n' = v'", "proof (cases \"dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs =\n    [] \\<Longrightarrow>\n    n' = v \\<or> n' = v'\n 2. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "case Nil"], ["proof (state)\nthis:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs =\n  []\n\ngoal (2 subgoals):\n 1. dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs =\n    [] \\<Longrightarrow>\n    n' = v \\<or> n' = v'\n 2. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "hence \"nvs=nvs'\""], ["proof (prove)\nusing this:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs =\n  []\n\ngoal (1 subgoal):\n 1. nvs = nvs'", "using nvs_nvs'"], ["proof (prove)\nusing this:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs =\n  []\n  nvs =\n  nvs' @\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. nvs = nvs'", "by (metis append_Nil2)"], ["proof (state)\nthis:\n  nvs = nvs'\n\ngoal (2 subgoals):\n 1. dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs =\n    [] \\<Longrightarrow>\n    n' = v \\<or> n' = v'\n 2. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "hence \"n'=v\""], ["proof (prove)\nusing this:\n  nvs = nvs'\n\ngoal (1 subgoal):\n 1. n' = v", "using  nvs is_path_nvs' path_end"], ["proof (prove)\nusing this:\n  nvs = nvs'\n  is_path n nvs v\n  is_path n nvs' n'\n  \\<lbrakk>?ps \\<noteq> []; is_path ?v ?ps ?v'\\<rbrakk>\n  \\<Longrightarrow> ?v' = snd (snd (last ?ps))\n\ngoal (1 subgoal):\n 1. n' = v", "by (metis (mono_tags) is_path.simps(1))"], ["proof (state)\nthis:\n  n' = v\n\ngoal (2 subgoals):\n 1. dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs =\n    [] \\<Longrightarrow>\n    n' = v \\<or> n' = v'\n 2. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n' = v\n\ngoal (1 subgoal):\n 1. n' = v \\<or> n' = v'", "by auto"], ["proof (state)\nthis:\n  n' = v \\<or> n' = v'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "case (Cons x xs)"], ["proof (state)\nthis:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs =\n  x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "hence \"dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs\\<noteq>[]\""], ["proof (prove)\nusing this:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs =\n  x # xs\n\ngoal (1 subgoal):\n 1. dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n     nvs \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "hence \"hd (dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs)=(v,w,v')\n                 \\<or> hd (dropWhile (\\<lambda>x. x\\<noteq>(v,w,v')\\<and>x\\<noteq>(v',w,v)) nvs)=(v',w,v)\""], ["proof (prove)\nusing this:\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. hd (dropWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs) =\n    (v, w, v') \\<or>\n    hd (dropWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs) =\n    (v', w, v)", "by (metis (lifting, full_types) hd_dropWhile)"], ["proof (state)\nthis:\n  hd (dropWhile\n       (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n       nvs) =\n  (v, w, v') \\<or>\n  hd (dropWhile\n       (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n       nvs) =\n  (v', w, v)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "hence \"x=(v,w,v')\\<or>x=(v',w,v)\""], ["proof (prove)\nusing this:\n  hd (dropWhile\n       (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n       nvs) =\n  (v, w, v') \\<or>\n  hd (dropWhile\n       (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n       nvs) =\n  (v', w, v)\n\ngoal (1 subgoal):\n 1. x = (v, w, v') \\<or> x = (v', w, v)", "using Cons"], ["proof (prove)\nusing this:\n  hd (dropWhile\n       (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n       nvs) =\n  (v, w, v') \\<or>\n  hd (dropWhile\n       (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n       nvs) =\n  (v', w, v)\n  dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs =\n  x # xs\n\ngoal (1 subgoal):\n 1. x = (v, w, v') \\<or> x = (v', w, v)", "by auto"], ["proof (state)\nthis:\n  x = (v, w, v') \\<or> x = (v', w, v)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       dropWhile\n        (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n        nvs =\n       a # list \\<Longrightarrow>\n       n' = v \\<or> n' = v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = (v, w, v') \\<or> x = (v', w, v)\n\ngoal (1 subgoal):\n 1. n' = v \\<or> n' = v'", "using \\<open>is_path n' (dropWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs) v\\<close>"], ["proof (prove)\nusing this:\n  x = (v, w, v') \\<or> x = (v', w, v)\n  is_path n'\n   (dropWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs)\n   v\n\ngoal (1 subgoal):\n 1. n' = v \\<or> n' = v'", "by (metis Cons  is_path.simps(2))"], ["proof (state)\nthis:\n  n' = v \\<or> n' = v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' = v \\<or> n' = v'\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  n' = v \\<or> n' = v'\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"valid_graph.is_path (del_unEdge v w v' G) n nvs' n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) n nvs' n'", "using is_path_nvs' nvs'"], ["proof (prove)\nusing this:\n  is_path n nvs' n'\n  nvs' =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) n nvs' n'", "proof (induct nvs' arbitrary:n nvs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n nvs.\n       \\<lbrakk>is_path n [] n';\n        [] =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n [] n'\n 2. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "case Nil"], ["proof (state)\nthis:\n  is_path n [] n'\n  [] =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (2 subgoals):\n 1. \\<And>n nvs.\n       \\<lbrakk>is_path n [] n';\n        [] =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n [] n'\n 2. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "thus ?case"], ["proof (prove)\nusing this:\n  is_path n [] n'\n  [] =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) n [] n'", "by (metis del_UnEdge_node is_path.simps(1) valid0 valid_graph.is_path_simps(1))"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n [] n'\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>is_path ?n xs n';\n   xs =\n   takeWhile\n    (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n    ?nvs\\<rbrakk>\n  \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) ?n xs n'\n  is_path n (x # xs) n'\n  x # xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "hence \"is_path x3 xs n'\""], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. is_path x3 xs n'", "using Cons"], ["proof (prove)\nusing this:\n  x = (x1, x2, x3)\n  \\<lbrakk>is_path ?n xs n';\n   xs =\n   takeWhile\n    (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n    ?nvs\\<rbrakk>\n  \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) ?n xs n'\n  is_path n (x # xs) n'\n  x # xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. is_path x3 xs n'", "by auto"], ["proof (state)\nthis:\n  is_path x3 xs n'\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "moreover"], ["proof (state)\nthis:\n  is_path x3 xs n'\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "have \"xs = takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) (tl nvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    takeWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n     (tl nvs)", "using \\<open>x # xs = takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)) nvs\\<close>"], ["proof (prove)\nusing this:\n  x # xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. xs =\n    takeWhile\n     (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n     (tl nvs)", "by (metis (lifting, no_types) append_Cons list.distinct(1) takeWhile.simps(2) \n                takeWhile_dropWhile_id list.sel(3))"], ["proof (state)\nthis:\n  xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   (tl nvs)\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "ultimately"], ["proof (chain)\npicking this:\n  is_path x3 xs n'\n  xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   (tl nvs)", "have \"valid_graph.is_path (del_unEdge v w v' G) x3 xs n'\""], ["proof (prove)\nusing this:\n  is_path x3 xs n'\n  xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   (tl nvs)\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) x3 xs n'", "using Cons"], ["proof (prove)\nusing this:\n  is_path x3 xs n'\n  xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   (tl nvs)\n  \\<lbrakk>is_path ?n xs n';\n   xs =\n   takeWhile\n    (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n    ?nvs\\<rbrakk>\n  \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) ?n xs n'\n  is_path n (x # xs) n'\n  x # xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) x3 xs n'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs n'\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs n'\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "have \"x\\<noteq>(v,w,v') \\<and> x\\<noteq>(v',w,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)", "using Cons(3) set_takeWhileD[of x \"(\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\" nvs]"], ["proof (prove)\nusing this:\n  x # xs =\n  takeWhile (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n   nvs\n  x \\<in> set (takeWhile\n                (\\<lambda>x.\n                    x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                nvs) \\<Longrightarrow>\n  x \\<in> set nvs \\<and> x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)", "by (metis List.set_simps(2) insertI1)"], ["proof (state)\nthis:\n  x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "hence \"x\\<in>edges (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v)\n\ngoal (1 subgoal):\n 1. x \\<in> edges (del_unEdge v w v' G)", "by (metis Cons.prems(1) del_UnEdge_frame is_path.simps(2) x)"], ["proof (state)\nthis:\n  x \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a nvs' n nvs.\n       \\<lbrakk>\\<And>n nvs.\n                   \\<lbrakk>is_path n nvs' n';\n                    nvs' =\n                    takeWhile\n                     (\\<lambda>x.\n                         x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n                     nvs\\<rbrakk>\n                   \\<Longrightarrow> valid_graph.is_path\n(del_unEdge v w v' G) n nvs' n';\n        is_path n (a # nvs') n';\n        a # nvs' =\n        takeWhile\n         (\\<lambda>x. x \\<noteq> (v, w, v') \\<and> x \\<noteq> (v', w, v))\n         nvs\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path (del_unEdge v w v' G) n\n                          (a # nvs') n'", "ultimately"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs n'\n  x \\<in> edges (del_unEdge v w v' G)", "show ?case"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs n'\n  x \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) n (x # xs) n'", "using x"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs n'\n  x \\<in> edges (del_unEdge v w v' G)\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) n (x # xs) n'", "by (metis Cons.prems(1) is_path.simps(2) valid0 valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n (x # xs) n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs' n'\n\ngoal (1 subgoal):\n 1. nodes G1 \\<union> nodes G2 \\<noteq>\n    nodes (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  n' = v \\<or> n' = v'\n  valid_graph.is_path (del_unEdge v w v' G) n nvs' n'", "show False"], ["proof (prove)\nusing this:\n  n' = v \\<or> n' = v'\n  valid_graph.is_path (del_unEdge v w v' G) n nvs' n'\n\ngoal (1 subgoal):\n 1. False", "using n_neg_v n_neg_v'"], ["proof (prove)\nusing this:\n  n' = v \\<or> n' = v'\n  valid_graph.is_path (del_unEdge v w v' G) n nvs' n'\n  \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v\n  \\<nexists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"nodes G1 \\<inter> nodes G2={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 \\<noteq> {} \\<Longrightarrow> False", "assume \"nodes G1 \\<inter> nodes G2 \\<noteq> {}\""], ["proof (state)\nthis:\n  nodes G1 \\<inter> nodes G2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  nodes G1 \\<inter> nodes G2 \\<noteq> {}", "obtain n where n:\"n\\<in>nodes G1\" \"n\\<in>nodes G2\""], ["proof (prove)\nusing this:\n  nodes G1 \\<inter> nodes G2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<in> nodes G1; n \\<in> nodes G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<in> nodes G1\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  n \\<in> nodes G1\n  n \\<in> nodes G2", "obtain nvs nv's where \n          nvs  : \"valid_graph.is_path (del_unEdge v w v' G) n nvs v\" and\n          nv's : \"valid_graph.is_path (del_unEdge v w v' G) n nv's v'\""], ["proof (prove)\nusing this:\n  n \\<in> nodes G1\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. (\\<And>nvs nv's.\n        \\<lbrakk>valid_graph.is_path (del_unEdge v w v' G) n nvs v;\n         valid_graph.is_path (del_unEdge v w v' G) n nv's v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using G1 G2 G1_nodes G2_nodes"], ["proof (prove)\nusing this:\n  n \\<in> nodes G1\n  n \\<in> nodes G2\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>nvs nv's.\n        \\<lbrakk>valid_graph.is_path (del_unEdge v w v' G) n nvs v;\n         valid_graph.is_path (del_unEdge v w v' G) n nv's v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v\n  valid_graph.is_path (del_unEdge v w v' G) n nv's v'\n\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 \\<noteq> {} \\<Longrightarrow> False", "hence \"valid_graph.is_path (del_unEdge v w v' G) v ((rev_path nvs)@nv's) v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v\n  valid_graph.is_path (del_unEdge v w v' G) n nv's v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) v (rev_path nvs @ nv's) v'", "using valid_unMultigraph.is_path_rev[OF valid0'] valid_graph.is_path_split[OF valid0]"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v\n  valid_graph.is_path (del_unEdge v w v' G) n nv's v'\n  valid_graph.is_path (del_unEdge v w v' G) ?v' (rev_path ?ps) ?v =\n  valid_graph.is_path (del_unEdge v w v' G) ?v ?ps ?v'\n  valid_graph.is_path (del_unEdge v w v' G) ?v (?p1.0 @ ?p2.0) ?v' =\n  (\\<exists>u.\n      valid_graph.is_path (del_unEdge v w v' G) ?v ?p1.0 u \\<and>\n      valid_graph.is_path (del_unEdge v w v' G) u ?p2.0 ?v')\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) v (rev_path nvs @ nv's) v'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) v (rev_path nvs @ nv's) v'\n\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 \\<noteq> {} \\<Longrightarrow> False", "hence \"valid_unMultigraph.connected (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) v (rev_path nvs @ nv's) v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v w v' G)", "by (metis assms(1) del_unEdge_connectivity)"], ["proof (state)\nthis:\n  valid_unMultigraph.connected (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. nodes G1 \\<inter> nodes G2 \\<noteq> {} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  valid_unMultigraph.connected (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(2))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodes G1 \\<inter> nodes G2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  nodes G1 \\<inter> nodes G2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "assume \"edges G1 \\<union> edges G2 \\<noteq> edges (del_unEdge v w v' G)\""], ["proof (state)\nthis:\n  edges G1 \\<union> edges G2 \\<noteq> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  edges G1 \\<union> edges G2 \\<noteq> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"edges G1 \\<subseteq> edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G1 \\<subseteq> edges (del_unEdge v w v' G)", "using G1"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. edges G1 \\<subseteq> edges (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  edges G1 \\<subseteq> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  edges G1 \\<subseteq> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"edges G2 \\<subseteq> edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G2 \\<subseteq> edges (del_unEdge v w v' G)", "using G2"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. edges G2 \\<subseteq> edges (del_unEdge v w v' G)", "by auto"], ["proof (state)\nthis:\n  edges G2 \\<subseteq> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  edges G1 \\<union> edges G2 \\<noteq> edges (del_unEdge v w v' G)\n  edges G1 \\<subseteq> edges (del_unEdge v w v' G)\n  edges G2 \\<subseteq> edges (del_unEdge v w v' G)", "obtain n e n' where \n          nen':\n          \"(n,e,n')\\<in>edges (del_unEdge v w v' G)\" \n          \"(n,e,n')\\<notin>edges G1\" \"(n,e,n')\\<notin>edges G2\""], ["proof (prove)\nusing this:\n  edges G1 \\<union> edges G2 \\<noteq> edges (del_unEdge v w v' G)\n  edges G1 \\<subseteq> edges (del_unEdge v w v' G)\n  edges G2 \\<subseteq> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>n e n'.\n        \\<lbrakk>(n, e, n') \\<in> edges (del_unEdge v w v' G);\n         (n, e, n') \\<notin> edges G1; (n, e, n') \\<notin> edges G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (n, e, n') \\<in> edges (del_unEdge v w v' G)\n  (n, e, n') \\<notin> edges G1\n  (n, e, n') \\<notin> edges G2\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (n, e, n') \\<in> edges (del_unEdge v w v' G)\n  (n, e, n') \\<notin> edges G1\n  (n, e, n') \\<notin> edges G2\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"n\\<in>nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> nodes (del_unEdge v w v' G)", "by (metis nen'(1) valid0 valid_graph.E_validD(1))"], ["proof (state)\nthis:\n  n \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  n \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"n'\\<in>nodes (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<in> nodes (del_unEdge v w v' G)", "by (metis nen'(1) valid0 valid_graph.E_validD(2))"], ["proof (state)\nthis:\n  n' \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (n, e, n') \\<in> edges (del_unEdge v w v' G)\n  (n, e, n') \\<notin> edges G1\n  (n, e, n') \\<notin> edges G2\n  n \\<in> nodes (del_unEdge v w v' G)\n  n' \\<in> nodes (del_unEdge v w v' G)", "have \"(n\\<in>nodes G1 \\<and> n'\\<in>nodes G2)\\<or>(n\\<in>nodes G2\\<and>n'\\<in>nodes G1)\""], ["proof (prove)\nusing this:\n  (n, e, n') \\<in> edges (del_unEdge v w v' G)\n  (n, e, n') \\<notin> edges G1\n  (n, e, n') \\<notin> edges G2\n  n \\<in> nodes (del_unEdge v w v' G)\n  n' \\<in> nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. n \\<in> nodes G1 \\<and> n' \\<in> nodes G2 \\<or>\n    n \\<in> nodes G2 \\<and> n' \\<in> nodes G1", "using G1 G2 \\<open>nodes G1 \\<union> nodes G2=nodes (del_unEdge v w v' G)\\<close>"], ["proof (prove)\nusing this:\n  (n, e, n') \\<in> edges (del_unEdge v w v' G)\n  (n, e, n') \\<notin> edges G1\n  (n, e, n') \\<notin> edges G2\n  n \\<in> nodes (del_unEdge v w v' G)\n  n' \\<in> nodes (del_unEdge v w v' G)\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. n \\<in> nodes G1 \\<and> n' \\<in> nodes G2 \\<or>\n    n \\<in> nodes G2 \\<and> n' \\<in> nodes G1", "by auto"], ["proof (state)\nthis:\n  n \\<in> nodes G1 \\<and> n' \\<in> nodes G2 \\<or>\n  n \\<in> nodes G2 \\<and> n' \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  n \\<in> nodes G1 \\<and> n' \\<in> nodes G2 \\<or>\n  n \\<in> nodes G2 \\<and> n' \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"n\\<in>nodes G1 \\<Longrightarrow> n'\\<in>nodes G2 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"n\\<in>nodes G1\" \"n'\\<in>nodes G2\""], ["proof (state)\nthis:\n  n \\<in> nodes G1\n  n' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  n \\<in> nodes G1\n  n' \\<in> nodes G2", "obtain nvs nv's where \n              nvs  : \"valid_graph.is_path (del_unEdge v w v' G) n nvs v\" and\n              nv's : \"valid_graph.is_path (del_unEdge v w v' G) n' nv's v'\""], ["proof (prove)\nusing this:\n  n \\<in> nodes G1\n  n' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. (\\<And>nvs nv's.\n        \\<lbrakk>valid_graph.is_path (del_unEdge v w v' G) n nvs v;\n         valid_graph.is_path (del_unEdge v w v' G) n' nv's v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using G1 G2 G1_nodes G2_nodes"], ["proof (prove)\nusing this:\n  n \\<in> nodes G1\n  n' \\<in> nodes G2\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>nvs nv's.\n        \\<lbrakk>valid_graph.is_path (del_unEdge v w v' G) n nvs v;\n         valid_graph.is_path (del_unEdge v w v' G) n' nv's v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v\n  valid_graph.is_path (del_unEdge v w v' G) n' nv's v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"valid_graph.is_path (del_unEdge v w v' G) v \n                  ((rev_path nvs)@(n,e,n')#nv's) v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v\n  valid_graph.is_path (del_unEdge v w v' G) n' nv's v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) v\n     (rev_path nvs @ (n, e, n') # nv's) v'", "using valid_unMultigraph.is_path_rev[OF valid0'] valid_graph.is_path_split'[OF valid0]\n                  \\<open>(n,e,n')\\<in>edges (del_unEdge v w v' G)\\<close>"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v\n  valid_graph.is_path (del_unEdge v w v' G) n' nv's v'\n  valid_graph.is_path (del_unEdge v w v' G) ?v' (rev_path ?ps) ?v =\n  valid_graph.is_path (del_unEdge v w v' G) ?v ?ps ?v'\n  valid_graph.is_path (del_unEdge v w v' G) ?v\n   (?p1.0 @ (?u, ?w, ?u') # ?p2.0) ?v' =\n  (valid_graph.is_path (del_unEdge v w v' G) ?v ?p1.0 ?u \\<and>\n   (?u, ?w, ?u') \\<in> edges (del_unEdge v w v' G) \\<and>\n   valid_graph.is_path (del_unEdge v w v' G) ?u' ?p2.0 ?v')\n  (n, e, n') \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) v\n     (rev_path nvs @ (n, e, n') # nv's) v'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) v\n   (rev_path nvs @ (n, e, n') # nv's) v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"valid_unMultigraph.connected (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) v\n   (rev_path nvs @ (n, e, n') # nv's) v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v w v' G)", "by (metis assms(1) del_unEdge_connectivity)"], ["proof (state)\nthis:\n  valid_unMultigraph.connected (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  valid_unMultigraph.connected (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(2))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "have \"n\\<in>nodes G2 \\<Longrightarrow> n'\\<in>nodes G1 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"n'\\<in>nodes G1\" \"n\\<in>nodes G2\""], ["proof (state)\nthis:\n  n' \\<in> nodes G1\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  n' \\<in> nodes G1\n  n \\<in> nodes G2", "obtain n'vs nvs where \n              n'vs  : \"valid_graph.is_path (del_unEdge v w v' G) n' n'vs v\" and\n              nvs : \"valid_graph.is_path (del_unEdge v w v' G) n nvs v'\""], ["proof (prove)\nusing this:\n  n' \\<in> nodes G1\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. (\\<And>n'vs nvs.\n        \\<lbrakk>valid_graph.is_path (del_unEdge v w v' G) n' n'vs v;\n         valid_graph.is_path (del_unEdge v w v' G) n nvs v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using G1 G2 G1_nodes G2_nodes"], ["proof (prove)\nusing this:\n  n' \\<in> nodes G1\n  n \\<in> nodes G2\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n\ngoal (1 subgoal):\n 1. (\\<And>n'vs nvs.\n        \\<lbrakk>valid_graph.is_path (del_unEdge v w v' G) n' n'vs v;\n         valid_graph.is_path (del_unEdge v w v' G) n nvs v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' n'vs v\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' n'vs v\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(n',e,n)\\<in>edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n', e, n) \\<in> edges (del_unEdge v w v' G)", "by (metis nen'(1) valid0' valid_unMultigraph.corres)"], ["proof (state)\nthis:\n  (n', e, n) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v w v' G) n' n'vs v\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v'\n  (n', e, n) \\<in> edges (del_unEdge v w v' G)", "have \"valid_graph.is_path (del_unEdge v w v' G) v \n                  ((rev_path n'vs)@(n',e,n)#nvs) v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n' n'vs v\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v'\n  (n', e, n) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) v\n     (rev_path n'vs @ (n', e, n) # nvs) v'", "using valid_unMultigraph.is_path_rev[OF valid0'] valid_graph.is_path_split'[OF valid0]"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n' n'vs v\n  valid_graph.is_path (del_unEdge v w v' G) n nvs v'\n  (n', e, n) \\<in> edges (del_unEdge v w v' G)\n  valid_graph.is_path (del_unEdge v w v' G) ?v' (rev_path ?ps) ?v =\n  valid_graph.is_path (del_unEdge v w v' G) ?v ?ps ?v'\n  valid_graph.is_path (del_unEdge v w v' G) ?v\n   (?p1.0 @ (?u, ?w, ?u') # ?p2.0) ?v' =\n  (valid_graph.is_path (del_unEdge v w v' G) ?v ?p1.0 ?u \\<and>\n   (?u, ?w, ?u') \\<in> edges (del_unEdge v w v' G) \\<and>\n   valid_graph.is_path (del_unEdge v w v' G) ?u' ?p2.0 ?v')\n\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) v\n     (rev_path n'vs @ (n', e, n) # nvs) v'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) v\n   (rev_path n'vs @ (n', e, n) # nvs) v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"valid_unMultigraph.connected (del_unEdge v w v' G)\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) v\n   (rev_path n'vs @ (n', e, n) # nvs) v'\n\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected (del_unEdge v w v' G)", "by (metis assms(1) del_unEdge_connectivity)"], ["proof (state)\nthis:\n  valid_unMultigraph.connected (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  valid_unMultigraph.connected (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(2))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. edges G1 \\<union> edges G2 \\<noteq>\n    edges (del_unEdge v w v' G) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> nodes G1 \\<and> n' \\<in> nodes G2 \\<or>\n  n \\<in> nodes G2 \\<and> n' \\<in> nodes G1\n  \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n  \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  n \\<in> nodes G1 \\<and> n' \\<in> nodes G2 \\<or>\n  n \\<in> nodes G2 \\<and> n' \\<in> nodes G1\n  \\<lbrakk>n \\<in> nodes G1; n' \\<in> nodes G2\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>n \\<in> nodes G2; n' \\<in> nodes G1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"edges G1 \\<inter> edges G2={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges G1 \\<inter> edges G2 = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. edges G1 \\<inter> edges G2 \\<noteq> {} \\<Longrightarrow> False", "assume \"edges G1 \\<inter> edges G2 \\<noteq> {}\""], ["proof (state)\nthis:\n  edges G1 \\<inter> edges G2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. edges G1 \\<inter> edges G2 \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  edges G1 \\<inter> edges G2 \\<noteq> {}", "obtain n e n' where \"(n,e,n')\\<in>edges G1\" \"(n,e,n')\\<in>edges G2\""], ["proof (prove)\nusing this:\n  edges G1 \\<inter> edges G2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>n e n'.\n        \\<lbrakk>(n, e, n') \\<in> edges G1;\n         (n, e, n') \\<in> edges G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (n, e, n') \\<in> edges G1\n  (n, e, n') \\<in> edges G2\n\ngoal (1 subgoal):\n 1. edges G1 \\<inter> edges G2 \\<noteq> {} \\<Longrightarrow> False", "hence \"n\\<in>nodes G1\" \"n\\<in>nodes G2\""], ["proof (prove)\nusing this:\n  (n, e, n') \\<in> edges G1\n  (n, e, n') \\<in> edges G2\n\ngoal (1 subgoal):\n 1. n \\<in> nodes G1 &&& n \\<in> nodes G2", "using G1 G2"], ["proof (prove)\nusing this:\n  (n, e, n') \\<in> edges G1\n  (n, e, n') \\<in> edges G2\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n\ngoal (1 subgoal):\n 1. n \\<in> nodes G1 &&& n \\<in> nodes G2", "by auto"], ["proof (state)\nthis:\n  n \\<in> nodes G1\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. edges G1 \\<inter> edges G2 \\<noteq> {} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  n \\<in> nodes G1\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>nodes G1 \\<inter> nodes G2={}\\<close>"], ["proof (prove)\nusing this:\n  n \\<in> nodes G1\n  n \\<in> nodes G2\n  nodes G1 \\<inter> nodes G2 = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges G1 \\<inter> edges G2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  edges G1 \\<inter> edges G2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"valid_unMultigraph.connected G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected G1", "unfolding valid_unMultigraph.connected_def[OF valid_G1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>nodes G1.\n       \\<forall>v'\\<in>nodes G1.\n          v \\<noteq> v' \\<longrightarrow>\n          (\\<exists>ps. valid_graph.is_path G1 v ps v')", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "assume  n : \"n \\<in>nodes G1\""], ["proof (state)\nthis:\n  n \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "assume  n': \"n'\\<in>nodes G1\""], ["proof (state)\nthis:\n  n' \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "assume \"n\\<noteq>n'\""], ["proof (state)\nthis:\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "obtain ps where \"valid_graph.is_path (del_unEdge v w v' G) n ps v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        valid_graph.is_path (del_unEdge v w v' G) n ps v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using G1 G1_nodes n"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  n \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        valid_graph.is_path (del_unEdge v w v' G) n ps v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n ps v\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "hence ps:\"valid_graph.is_path G1 n ps v\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n ps v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n ps v", "proof (induct ps arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n [] v\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "case Nil"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n [] v\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n [] v\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "have \"v\\<in>nodes G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> nodes G1", "using G1 G1_nodes valid0"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  valid_graph (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. v \\<in> nodes G1", "by (metis (lifting, no_types) calculation mem_Collect_eq select_convs(1) \n                valid_graph.is_path.simps(1))"], ["proof (state)\nthis:\n  v \\<in> nodes G1\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n [] v\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "ultimately"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v\n  v \\<in> nodes G1", "show ?case"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v\n  v \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n [] v", "by (metis valid0 valid_G1 valid_unMultigraph.is_trail.simps(1)\n                 valid_graph.is_path.simps(1)  valid_unMultigraph.is_trail_intro)"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n [] v\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "case (Cons x xs)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) ?n xs v \\<Longrightarrow>\n  valid_graph.is_path G1 ?n xs v\n  valid_graph.is_path (del_unEdge v w v' G) n (x # xs) v\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "have \"x1\\<in>nodes G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G1", "using G1 G1_nodes Cons.prems x"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  valid_graph.is_path (del_unEdge v w v' G) n (x # xs) v\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G1", "by (metis (lifting) mem_Collect_eq select_convs(1) valid0 valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  x1 \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "moreover"], ["proof (state)\nthis:\n  x1 \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "have \"(x1,x2,x3)\\<in>edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<in> nodes G1\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "have \"(x1,x2,x3)\\<in>edges G1\""], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G1\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G1", "using G1 G2 \\<open>nodes G1 \\<inter> nodes G2={}\\<close> \\<open>edges G1 \\<union> edges G2=edges (del_unEdge v w v' G)\\<close>"], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G1\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G1", "by (metis (full_types) IntI Un_iff  bex_empty   valid_G2' valid_graph.E_validD(1) )"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "have \"valid_graph.is_path (del_unEdge v w v' G) x3 xs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) x3 xs v", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "hence \"valid_graph.is_path G1 x3 xs v\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 x3 xs v", "using Cons.hyps"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v\n  valid_graph.is_path (del_unEdge v w v' G) ?n xs v \\<Longrightarrow>\n  valid_graph.is_path G1 ?n xs v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 x3 xs v", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G1 x3 xs v\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path G1 x3 xs v\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "have \"x1=n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = n", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  x1 = n\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n ps v;\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n (a # ps) v", "ultimately"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<in> edges G1\n  valid_graph.is_path G1 x3 xs v\n  x1 = n", "show ?case"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G1\n  valid_graph.is_path G1 x3 xs v\n  x1 = n\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n (x # xs) v", "using x valid_G1'"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G1\n  valid_graph.is_path G1 x3 xs v\n  x1 = n\n  x = (x1, x2, x3)\n  valid_graph G1\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n (x # xs) v", "by (metis valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n (x # xs) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n ps v\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "obtain ps' where \"valid_graph.is_path (del_unEdge v w v' G) n' ps' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        valid_graph.is_path (del_unEdge v w v' G) n' ps' v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using G1 G1_nodes n'"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  n' \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        valid_graph.is_path (del_unEdge v w v' G) n' ps' v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' ps' v\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "hence ps':\"valid_graph.is_path G1 n' ps' v\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n' ps' v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n' ps' v", "proof (induct ps' arbitrary:n')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n' [] v\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "case Nil"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n' [] v\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n' [] v\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "have \"v\\<in>nodes G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> nodes G1", "using G1 G1_nodes valid0"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  valid_graph (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. v \\<in> nodes G1", "by (metis (lifting, no_types) calculation mem_Collect_eq select_convs(1) \n                valid_graph.is_path.simps(1))"], ["proof (state)\nthis:\n  v \\<in> nodes G1\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v \\<Longrightarrow>\n       valid_graph.is_path G1 n' [] v\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "ultimately"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v\n  v \\<in> nodes G1", "show ?case"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v\n  v \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n' [] v", "by (metis valid0 valid_G1 valid_unMultigraph.is_trail.simps(1)\n                 valid_graph.is_path.simps(1)  valid_unMultigraph.is_trail_intro)"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n' [] v\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "case (Cons x xs)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) ?n' xs v \\<Longrightarrow>\n  valid_graph.is_path G1 ?n' xs v\n  valid_graph.is_path (del_unEdge v w v' G) n' (x # xs) v\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "have \"x1\\<in>nodes G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G1", "using G1 G1_nodes Cons.prems x"], ["proof (prove)\nusing this:\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G1_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  valid_graph.is_path (del_unEdge v w v' G) n' (x # xs) v\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G1", "by (metis (lifting) mem_Collect_eq select_convs(1) valid0 valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  x1 \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "moreover"], ["proof (state)\nthis:\n  x1 \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "have \"(x1,x2,x3)\\<in>edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<in> nodes G1\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "have \"(x1,x2,x3)\\<in>edges G1\""], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G1\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G1", "using G1 G2 \\<open>nodes G1 \\<inter> nodes G2={}\\<close> \n              \\<open>edges G1 \\<union> edges G2=edges (del_unEdge v w v' G)\\<close>"], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G1\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n  G1 =\n  \\<lparr>nodes = G1_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G1_nodes \\<and> n' \\<in> G1_nodes}\\<rparr>\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G1", "by (metis (full_types) IntI Un_iff  bex_empty  valid_G2' valid_graph.E_validD(1))"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "have \"valid_graph.is_path (del_unEdge v w v' G) x3 xs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) x3 xs v", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "hence \"valid_graph.is_path G1 x3 xs v\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 x3 xs v", "using Cons.hyps"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v\n  valid_graph.is_path (del_unEdge v w v' G) ?n' xs v \\<Longrightarrow>\n  valid_graph.is_path G1 ?n' xs v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 x3 xs v", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G1 x3 xs v\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path G1 x3 xs v\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "have \"x1=n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = n'", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  x1 = n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v \\<Longrightarrow>\n                   valid_graph.is_path G1 n' ps' v;\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G1 n' (a # ps') v", "ultimately"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<in> edges G1\n  valid_graph.is_path G1 x3 xs v\n  x1 = n'", "show ?case"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G1\n  valid_graph.is_path G1 x3 xs v\n  x1 = n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n' (x # xs) v", "using x valid_G1'"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G1\n  valid_graph.is_path G1 x3 xs v\n  x1 = n'\n  x = (x1, x2, x3)\n  valid_graph G1\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n' (x # xs) v", "by (metis valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n' (x # xs) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n' ps' v\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "hence \"valid_graph.is_path G1 v (rev_path ps') n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path G1 n' ps' v\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 v (rev_path ps') n'", "using valid_unMultigraph.is_path_rev[OF valid_G1]"], ["proof (prove)\nusing this:\n  valid_graph.is_path G1 n' ps' v\n  valid_graph.is_path G1 ?v' (rev_path ?ps) ?v =\n  valid_graph.is_path G1 ?v ?ps ?v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 v (rev_path ps') n'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G1 v (rev_path ps') n'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "hence \"valid_graph.is_path G1 n (ps@(rev_path ps')) n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path G1 v (rev_path ps') n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n (ps @ rev_path ps') n'", "using ps valid_graph.is_path_split[OF valid_G1',of n ps \"rev_path ps'\" n']"], ["proof (prove)\nusing this:\n  valid_graph.is_path G1 v (rev_path ps') n'\n  valid_graph.is_path G1 n ps v\n  valid_graph.is_path G1 n (ps @ rev_path ps') n' =\n  (\\<exists>u.\n      valid_graph.is_path G1 n ps u \\<and>\n      valid_graph.is_path G1 u (rev_path ps') n')\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G1 n (ps @ rev_path ps') n'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G1 n (ps @ rev_path ps') n'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G1; v' \\<in> nodes G1; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G1 v ps v'", "thus \"\\<exists>ps. valid_graph.is_path G1 n ps n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path G1 n (ps @ rev_path ps') n'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. valid_graph.is_path G1 n ps n'", "by auto"], ["proof (state)\nthis:\n  \\<exists>ps. valid_graph.is_path G1 n ps n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_unMultigraph.connected G1\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  valid_unMultigraph.connected G1\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"valid_unMultigraph.connected G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph.connected G2", "unfolding valid_unMultigraph.connected_def[OF valid_G2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>nodes G2.\n       \\<forall>v'\\<in>nodes G2.\n          v \\<noteq> v' \\<longrightarrow>\n          (\\<exists>ps. valid_graph.is_path G2 v ps v')", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "assume  n : \"n \\<in>nodes G2\""], ["proof (state)\nthis:\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "assume  n': \"n'\\<in>nodes G2\""], ["proof (state)\nthis:\n  n' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "assume \"n\\<noteq>n'\""], ["proof (state)\nthis:\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "obtain ps where \"valid_graph.is_path (del_unEdge v w v' G) n ps v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        valid_graph.is_path (del_unEdge v w v' G) n ps v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using G2 G2_nodes n"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  n \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        valid_graph.is_path (del_unEdge v w v' G) n ps v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n ps v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "hence ps:\"valid_graph.is_path G2 n ps v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n ps v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n ps v'", "proof (induct ps arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n [] v'\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "case Nil"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v'\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n [] v'\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v'\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n [] v'\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "have \"v'\\<in>nodes G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> nodes G2", "using G2 G2_nodes valid0"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  valid_graph (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. v' \\<in> nodes G2", "by (metis (lifting, no_types) calculation mem_Collect_eq select_convs(1) \n                valid_graph.is_path.simps(1))"], ["proof (state)\nthis:\n  v' \\<in> nodes G2\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_graph.is_path (del_unEdge v w v' G) n [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n [] v'\n 2. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "ultimately"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v'\n  v' \\<in> nodes G2", "show ?case"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n [] v'\n  v' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n [] v'", "by (metis valid0 valid_G2 valid_unMultigraph.is_trail.simps(1)\n                 valid_graph.is_path.simps(1)  valid_unMultigraph.is_trail_intro)"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n [] v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "case (Cons x xs)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) ?n xs v' \\<Longrightarrow>\n  valid_graph.is_path G2 ?n xs v'\n  valid_graph.is_path (del_unEdge v w v' G) n (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "have \"x1\\<in>nodes G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G2", "using G2 G2_nodes Cons.prems x"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  valid_graph.is_path (del_unEdge v w v' G) n (x # xs) v'\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G2", "by (metis (lifting) mem_Collect_eq select_convs(1) valid0 valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  x1 \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "moreover"], ["proof (state)\nthis:\n  x1 \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "have \"(x1,x2,x3)\\<in>edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<in> nodes G2\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "have \"(x1,x2,x3)\\<in>edges G2\""], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G2\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G2", "using \\<open>nodes G1 \\<inter> nodes G2={}\\<close> \\<open>edges G1 \\<union> edges G2=edges (del_unEdge v w v' G)\\<close>"], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G2\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G2", "by (metis IntI Un_iff assms(1) bex_empty connected_def del_UnEdge_node valid0 valid0'\n              valid_G1' valid_graph.E_validD(1) valid_graph.E_validD(2) valid_unMultigraph.no_id)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "have \"valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) x3 xs v'", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "hence \"valid_graph.is_path G2 x3 xs v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 x3 xs v'", "using Cons.hyps"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\n  valid_graph.is_path (del_unEdge v w v' G) ?n xs v' \\<Longrightarrow>\n  valid_graph.is_path G2 ?n xs v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 x3 xs v'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G2 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path G2 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "have \"x1=n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = n", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  x1 = n\n\ngoal (1 subgoal):\n 1. \\<And>a ps n.\n       \\<lbrakk>\\<And>n.\n                   valid_graph.is_path (del_unEdge v w v' G) n ps\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n ps v';\n        valid_graph.is_path (del_unEdge v w v' G) n (a # ps) v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n (a # ps) v'", "ultimately"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<in> edges G2\n  valid_graph.is_path G2 x3 xs v'\n  x1 = n", "show ?case"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G2\n  valid_graph.is_path G2 x3 xs v'\n  x1 = n\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n (x # xs) v'", "using x valid_G2'"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G2\n  valid_graph.is_path G2 x3 xs v'\n  x1 = n\n  x = (x1, x2, x3)\n  valid_graph G2\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n (x # xs) v'", "by (metis valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n (x # xs) v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n ps v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "obtain ps' where \"valid_graph.is_path (del_unEdge v w v' G) n' ps' v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        valid_graph.is_path (del_unEdge v w v' G) n' ps'\n         v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using G2 G2_nodes n'"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  n' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        valid_graph.is_path (del_unEdge v w v' G) n' ps'\n         v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' ps' v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "hence ps':\"valid_graph.is_path G2 n' ps' v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n' ps' v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n' ps' v'", "proof (induct ps' arbitrary:n')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n' [] v'\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "case Nil"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v'\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n' [] v'\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v'\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n' [] v'\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "have \"v'\\<in>nodes G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> nodes G2", "using G2 G2_nodes valid0"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  valid_graph (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. v' \\<in> nodes G2", "by (metis (lifting, no_types) calculation mem_Collect_eq select_convs(1) \n                valid_graph.is_path.simps(1))"], ["proof (state)\nthis:\n  v' \\<in> nodes G2\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       valid_graph.is_path (del_unEdge v w v' G) n' [] v' \\<Longrightarrow>\n       valid_graph.is_path G2 n' [] v'\n 2. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "ultimately"], ["proof (chain)\npicking this:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v'\n  v' \\<in> nodes G2", "show ?case"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) n' [] v'\n  v' \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n' [] v'", "by (metis valid0 valid_G2 valid_unMultigraph.is_trail.simps(1)\n                 valid_graph.is_path.simps(1)  valid_unMultigraph.is_trail_intro)"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n' [] v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "case (Cons x xs)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) ?n' xs v' \\<Longrightarrow>\n  valid_graph.is_path G2 ?n' xs v'\n  valid_graph.is_path (del_unEdge v w v' G) n' (x # xs) v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "obtain x1 x2 x3 where x:\"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "have \"x1\\<in>nodes G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G2", "using G2 G2_nodes Cons.prems x"], ["proof (prove)\nusing this:\n  G2 =\n  \\<lparr>nodes = G2_nodes,\n     edges =\n       {(n, e, n').\n        (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n        n \\<in> G2_nodes \\<and> n' \\<in> G2_nodes}\\<rparr>\n  G2_nodes =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  valid_graph.is_path (del_unEdge v w v' G) n' (x # xs) v'\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. x1 \\<in> nodes G2", "by (metis (lifting) mem_Collect_eq select_convs(1) valid0 valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  x1 \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "moreover"], ["proof (state)\nthis:\n  x1 \\<in> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "have \"(x1,x2,x3)\\<in>edges (del_unEdge v w v' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "ultimately"], ["proof (chain)\npicking this:\n  x1 \\<in> nodes G2\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)", "have \"(x1,x2,x3)\\<in>edges G2\""], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G2\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G2", "using  \\<open>nodes G1 \\<inter> nodes G2={}\\<close> \\<open>edges G1 \\<union> edges G2=edges (del_unEdge v w v' G)\\<close>"], ["proof (prove)\nusing this:\n  x1 \\<in> nodes G2\n  (x1, x2, x3) \\<in> edges (del_unEdge v w v' G)\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n\ngoal (1 subgoal):\n 1. (x1, x2, x3) \\<in> edges G2", "by (metis IntI Un_iff assms(1) bex_empty connected_def del_UnEdge_node valid0 valid0' \n              valid_G1' valid_graph.E_validD(1) valid_graph.E_validD(2) valid_unMultigraph.no_id)"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "moreover"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "have \"valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph.is_path (del_unEdge v w v' G) x3 xs v'", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "hence \"valid_graph.is_path G2 x3 xs v'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 x3 xs v'", "using Cons.hyps"], ["proof (prove)\nusing this:\n  valid_graph.is_path (del_unEdge v w v' G) x3 xs v'\n  valid_graph.is_path (del_unEdge v w v' G) ?n' xs v' \\<Longrightarrow>\n  valid_graph.is_path G2 ?n' xs v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 x3 xs v'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G2 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "moreover"], ["proof (state)\nthis:\n  valid_graph.is_path G2 x3 xs v'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "have \"x1=n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = n'", "by (metis Cons.prems valid0 valid_graph.is_path.simps(2) x)"], ["proof (state)\nthis:\n  x1 = n'\n\ngoal (1 subgoal):\n 1. \\<And>a ps' n'.\n       \\<lbrakk>\\<And>n'.\n                   valid_graph.is_path (del_unEdge v w v' G) n' ps'\n                    v' \\<Longrightarrow>\n                   valid_graph.is_path G2 n' ps' v';\n        valid_graph.is_path (del_unEdge v w v' G) n' (a # ps') v'\\<rbrakk>\n       \\<Longrightarrow> valid_graph.is_path G2 n' (a # ps') v'", "ultimately"], ["proof (chain)\npicking this:\n  (x1, x2, x3) \\<in> edges G2\n  valid_graph.is_path G2 x3 xs v'\n  x1 = n'", "show ?case"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G2\n  valid_graph.is_path G2 x3 xs v'\n  x1 = n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n' (x # xs) v'", "using x valid_G2'"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> edges G2\n  valid_graph.is_path G2 x3 xs v'\n  x1 = n'\n  x = (x1, x2, x3)\n  valid_graph G2\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n' (x # xs) v'", "by (metis valid_graph.is_path.simps(2))"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n' (x # xs) v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n' ps' v'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "hence \"valid_graph.is_path G2 v' (rev_path ps') n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path G2 n' ps' v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 v' (rev_path ps') n'", "using valid_unMultigraph.is_path_rev[OF valid_G2]"], ["proof (prove)\nusing this:\n  valid_graph.is_path G2 n' ps' v'\n  valid_graph.is_path G2 ?v' (rev_path ?ps) ?v =\n  valid_graph.is_path G2 ?v ?ps ?v'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 v' (rev_path ps') n'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G2 v' (rev_path ps') n'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "hence \"valid_graph.is_path G2 n (ps@(rev_path ps')) n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path G2 v' (rev_path ps') n'\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n (ps @ rev_path ps') n'", "using ps valid_graph.is_path_split[OF valid_G2',of n ps \"rev_path ps'\" n']"], ["proof (prove)\nusing this:\n  valid_graph.is_path G2 v' (rev_path ps') n'\n  valid_graph.is_path G2 n ps v'\n  valid_graph.is_path G2 n (ps @ rev_path ps') n' =\n  (\\<exists>u.\n      valid_graph.is_path G2 n ps u \\<and>\n      valid_graph.is_path G2 u (rev_path ps') n')\n\ngoal (1 subgoal):\n 1. valid_graph.is_path G2 n (ps @ rev_path ps') n'", "by auto"], ["proof (state)\nthis:\n  valid_graph.is_path G2 n (ps @ rev_path ps') n'\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> nodes G2; v' \\<in> nodes G2; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps. valid_graph.is_path G2 v ps v'", "thus \"\\<exists>ps. valid_graph.is_path G2 n ps n'\""], ["proof (prove)\nusing this:\n  valid_graph.is_path G2 n (ps @ rev_path ps') n'\n\ngoal (1 subgoal):\n 1. \\<exists>ps. valid_graph.is_path G2 n ps n'", "by auto"], ["proof (state)\nthis:\n  \\<exists>ps. valid_graph.is_path G2 n ps n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_unMultigraph.connected G2\n\ngoal (1 subgoal):\n 1. (\\<And>G1 G2.\n        \\<lbrakk>nodes G1 =\n                 {n. \\<exists>ps.\n                        valid_graph.is_path (del_unEdge v w v' G) n ps v};\n         edges G1 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G1 \\<and> n' \\<in> nodes G1};\n         nodes G2 =\n         {n. \\<exists>ps.\n                valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n         edges G2 =\n         {(n, e, n').\n          (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n          n \\<in> nodes G2 \\<and> n' \\<in> nodes G2};\n         edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G);\n         edges G1 \\<inter> edges G2 = {};\n         nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G);\n         nodes G1 \\<inter> nodes G2 = {}; valid_unMultigraph G1;\n         valid_unMultigraph G2; valid_unMultigraph.connected G1;\n         valid_unMultigraph.connected G2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  nodes G1 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  edges G1 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}\n  nodes G2 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  edges G2 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}\n  nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n  edges G1 \\<inter> edges G2 = {}\n  valid_unMultigraph.connected G1\n  valid_unMultigraph.connected G2", "show ?thesis"], ["proof (prove)\nusing this:\n  nodes G1 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  edges G1 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}\n  nodes G2 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  edges G2 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}\n  nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n  edges G1 \\<inter> edges G2 = {}\n  valid_unMultigraph.connected G1\n  valid_unMultigraph.connected G2\n\ngoal (1 subgoal):\n 1. thesis", "using valid_G1 valid_G2 that"], ["proof (prove)\nusing this:\n  nodes G1 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v}\n  edges G1 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G1 \\<and> n' \\<in> nodes G1}\n  nodes G2 =\n  {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'}\n  edges G2 =\n  {(n, e, n').\n   (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n   n \\<in> nodes G2 \\<and> n' \\<in> nodes G2}\n  nodes G1 \\<union> nodes G2 = nodes (del_unEdge v w v' G)\n  nodes G1 \\<inter> nodes G2 = {}\n  edges G1 \\<union> edges G2 = edges (del_unEdge v w v' G)\n  edges G1 \\<inter> edges G2 = {}\n  valid_unMultigraph.connected G1\n  valid_unMultigraph.connected G2\n  valid_unMultigraph G1\n  valid_unMultigraph G2\n  \\<lbrakk>nodes ?G1.0 =\n           {n. \\<exists>ps.\n                  valid_graph.is_path (del_unEdge v w v' G) n ps v};\n   edges ?G1.0 =\n   {(n, e, n').\n    (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n    n \\<in> nodes ?G1.0 \\<and> n' \\<in> nodes ?G1.0};\n   nodes ?G2.0 =\n   {n. \\<exists>ps. valid_graph.is_path (del_unEdge v w v' G) n ps v'};\n   edges ?G2.0 =\n   {(n, e, n').\n    (n, e, n') \\<in> edges (del_unEdge v w v' G) \\<and>\n    n \\<in> nodes ?G2.0 \\<and> n' \\<in> nodes ?G2.0};\n   edges ?G1.0 \\<union> edges ?G2.0 = edges (del_unEdge v w v' G);\n   edges ?G1.0 \\<inter> edges ?G2.0 = {};\n   nodes ?G1.0 \\<union> nodes ?G2.0 = nodes (del_unEdge v w v' G);\n   nodes ?G1.0 \\<inter> nodes ?G2.0 = {}; valid_unMultigraph ?G1.0;\n   valid_unMultigraph ?G2.0; valid_unMultigraph.connected ?G1.0;\n   valid_unMultigraph.connected ?G2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_graph_degree_frame:\n  assumes \"valid_graph G2\" \"edges G1 \\<union> edges G2 =edges G\" \"nodes G1 \\<inter> nodes G2={}\" \"n\\<in>nodes G1\"\n  shows \"degree n G=degree n G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree n G = degree n G1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree n G = degree n G1", "have \"{e \\<in> edges G. fst e = n}\\<subseteq>{e \\<in> edges G1. fst e = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> edges G. fst e = n} \\<subseteq> {e \\<in> edges G1. fst e = n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "assume  \"e \\<in> {e \\<in> edges G. fst e = n}\""], ["proof (state)\nthis:\n  e \\<in> {e \\<in> edges G. fst e = n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "hence \"e\\<in>edges G\" \"fst e=n\""], ["proof (prove)\nusing this:\n  e \\<in> {e \\<in> edges G. fst e = n}\n\ngoal (1 subgoal):\n 1. e \\<in> edges G &&& fst e = n", "by auto"], ["proof (state)\nthis:\n  e \\<in> edges G\n  fst e = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "moreover"], ["proof (state)\nthis:\n  e \\<in> edges G\n  fst e = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "have \"n\\<notin>nodes G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> nodes G2", "using \\<open>nodes G1 \\<inter> nodes G2={}\\<close> \\<open>n\\<in>nodes G1\\<close>"], ["proof (prove)\nusing this:\n  nodes G1 \\<inter> nodes G2 = {}\n  n \\<in> nodes G1\n\ngoal (1 subgoal):\n 1. n \\<notin> nodes G2", "by auto"], ["proof (state)\nthis:\n  n \\<notin> nodes G2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "hence \"e\\<notin>edges G2\""], ["proof (prove)\nusing this:\n  n \\<notin> nodes G2\n\ngoal (1 subgoal):\n 1. e \\<notin> edges G2", "using valid_graph.E_validD[OF \\<open>valid_graph G2\\<close>] \\<open>fst e=n\\<close>"], ["proof (prove)\nusing this:\n  n \\<notin> nodes G2\n  (?v, ?e, ?v') \\<in> edges G2 \\<Longrightarrow> ?v \\<in> nodes G2\n  (?v, ?e, ?v') \\<in> edges G2 \\<Longrightarrow> ?v' \\<in> nodes G2\n  fst e = n\n\ngoal (1 subgoal):\n 1. e \\<notin> edges G2", "by (metis prod.exhaust fst_conv)"], ["proof (state)\nthis:\n  e \\<notin> edges G2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "ultimately"], ["proof (chain)\npicking this:\n  e \\<in> edges G\n  fst e = n\n  e \\<notin> edges G2", "have \"e\\<in>edges G1\""], ["proof (prove)\nusing this:\n  e \\<in> edges G\n  fst e = n\n  e \\<notin> edges G2\n\ngoal (1 subgoal):\n 1. e \\<in> edges G1", "using \\<open>edges G1 \\<union> edges G2 =edges G\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> edges G\n  fst e = n\n  e \\<notin> edges G2\n  edges G1 \\<union> edges G2 = edges G\n\ngoal (1 subgoal):\n 1. e \\<in> edges G1", "by auto"], ["proof (state)\nthis:\n  e \\<in> edges G1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> edges G. fst e = n} \\<Longrightarrow>\n       x \\<in> {e \\<in> edges G1. fst e = n}", "thus \"e \\<in> {e \\<in> edges G1. fst e = n}\""], ["proof (prove)\nusing this:\n  e \\<in> edges G1\n\ngoal (1 subgoal):\n 1. e \\<in> {e \\<in> edges G1. fst e = n}", "using \\<open>fst e=n\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> edges G1\n  fst e = n\n\ngoal (1 subgoal):\n 1. e \\<in> {e \\<in> edges G1. fst e = n}", "by auto"], ["proof (state)\nthis:\n  e \\<in> {e \\<in> edges G1. fst e = n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {e \\<in> edges G. fst e = n} \\<subseteq> {e \\<in> edges G1. fst e = n}\n\ngoal (1 subgoal):\n 1. degree n G = degree n G1", "moreover"], ["proof (state)\nthis:\n  {e \\<in> edges G. fst e = n} \\<subseteq> {e \\<in> edges G1. fst e = n}\n\ngoal (1 subgoal):\n 1. degree n G = degree n G1", "have \"{e \\<in> edges G1. fst e = n}\\<subseteq>{e \\<in> edges G. fst e = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> edges G1. fst e = n} \\<subseteq> {e \\<in> edges G. fst e = n}", "by (metis (lifting) Collect_mono Un_iff assms(2))"], ["proof (state)\nthis:\n  {e \\<in> edges G1. fst e = n} \\<subseteq> {e \\<in> edges G. fst e = n}\n\ngoal (1 subgoal):\n 1. degree n G = degree n G1", "ultimately"], ["proof (chain)\npicking this:\n  {e \\<in> edges G. fst e = n} \\<subseteq> {e \\<in> edges G1. fst e = n}\n  {e \\<in> edges G1. fst e = n} \\<subseteq> {e \\<in> edges G. fst e = n}", "show ?thesis"], ["proof (prove)\nusing this:\n  {e \\<in> edges G. fst e = n} \\<subseteq> {e \\<in> edges G1. fst e = n}\n  {e \\<in> edges G1. fst e = n} \\<subseteq> {e \\<in> edges G. fst e = n}\n\ngoal (1 subgoal):\n 1. degree n G = degree n G1", "unfolding degree_def"], ["proof (prove)\nusing this:\n  {e \\<in> edges G. fst e = n} \\<subseteq> {e \\<in> edges G1. fst e = n}\n  {e \\<in> edges G1. fst e = n} \\<subseteq> {e \\<in> edges G. fst e = n}\n\ngoal (1 subgoal):\n 1. card {e \\<in> edges G. fst e = n} = card {e \\<in> edges G1. fst e = n}", "by auto"], ["proof (state)\nthis:\n  degree n G = degree n G1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_nodes_no_edge[simp]: \"finite (nodes g) \\<Longrightarrow> num_of_odd_nodes (g \\<lparr>edges:={} \\<rparr>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes g) \\<Longrightarrow>\n    num_of_odd_nodes (g\\<lparr>edges := {}\\<rparr>) = 0", "unfolding  num_of_odd_nodes_def odd_nodes_set_def degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes g) \\<Longrightarrow>\n    card\n     {v \\<in> nodes (g\\<lparr>edges := {}\\<rparr>).\n      odd (card\n            {e \\<in> edges (g\\<lparr>edges := {}\\<rparr>). fst e = v})} =\n    0", "by simp"], ["", "section \\<open>Adjacent nodes\\<close>"], ["", "definition (in valid_unMultigraph) adjacent:: \"'v \\<Rightarrow> 'v \\<Rightarrow> bool\" where\n    \"adjacent v v' \\<equiv> \\<exists>w. (v,w,v')\\<in>E\""], ["", "lemma (in valid_unMultigraph) adjacent_sym: \"adjacent v v' \\<longleftrightarrow> adjacent v' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v v' = adjacent v' v", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>w. (v, w, v') \\<in> E) = (\\<exists>w. (v', w, v) \\<in> E)", "by auto"], ["", "lemma (in valid_unMultigraph) adjacent_no_loop[simp]: \"adjacent v v' \\<Longrightarrow> v \\<noteq>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v v' \\<Longrightarrow> v \\<noteq> v'", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. (v, w, v') \\<in> E \\<Longrightarrow> v \\<noteq> v'", "by auto"], ["", "lemma (in valid_unMultigraph) adjacent_V[simp]: \n    assumes \"adjacent v v'\"\n    shows \"v\\<in>V\" \"v'\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V &&& v' \\<in> V", "using assms E_validD"], ["proof (prove)\nusing this:\n  adjacent v v'\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& v' \\<in> V", "unfolding adjacent_def"], ["proof (prove)\nusing this:\n  \\<exists>w. (v, w, v') \\<in> E\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& v' \\<in> V", "by auto"], ["", "lemma (in valid_unMultigraph) adjacent_finite:\n  \"finite E \\<Longrightarrow> finite {n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "assume \"finite E\""], ["proof (state)\nthis:\n  finite E\n\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "{"], ["proof (state)\nthis:\n  finite E\n\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "fix S v"], ["proof (state)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "have \"finite S \\<Longrightarrow> finite {n. \\<exists>w. (v,w,n)\\<in>S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> S}", "proof (induct S rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> {}}", "by auto"], ["proof (state)\nthis:\n  finite {n. \\<exists>w. (v, w, n) \\<in> {}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  finite {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "obtain x1 x2 x3 where x: \"x=(x1,x2,x3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        x = (x1, x2, x3) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "have \"x1=v \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 = v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "assume \"x1=v\""], ["proof (state)\nthis:\n  x1 = v\n\ngoal (1 subgoal):\n 1. x1 = v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "hence \"{n. \\<exists>w. (v, w, n) \\<in> insert x F}=insert x3 {n. \\<exists>w. (v, w, n) \\<in> F}\""], ["proof (prove)\nusing this:\n  x1 = v\n\ngoal (1 subgoal):\n 1. {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n    insert x3 {n. \\<exists>w. (v, w, n) \\<in> F}", "using x"], ["proof (prove)\nusing this:\n  x1 = v\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n    insert x3 {n. \\<exists>w. (v, w, n) \\<in> F}", "by auto"], ["proof (state)\nthis:\n  {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n  insert x3 {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. x1 = v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n  insert x3 {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "using insert"], ["proof (prove)\nusing this:\n  {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n  insert x3 {n. \\<exists>w. (v, w, n) \\<in> F}\n  finite F\n  x \\<notin> F\n  finite {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "by auto"], ["proof (state)\nthis:\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 = v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "moreover"], ["proof (state)\nthis:\n  x1 = v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "have \"x1\\<noteq>v \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq> v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 \\<noteq> v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "assume \"x1\\<noteq>v\""], ["proof (state)\nthis:\n  x1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "hence \"{n. \\<exists>w. (v, w, n) \\<in> insert x F}={n. \\<exists>w. (v, w, n) \\<in> F}\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n    {n. \\<exists>w. (v, w, n) \\<in> F}", "using x"], ["proof (prove)\nusing this:\n  x1 \\<noteq> v\n  x = (x1, x2, x3)\n\ngoal (1 subgoal):\n 1. {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n    {n. \\<exists>w. (v, w, n) \\<in> F}", "by auto"], ["proof (state)\nthis:\n  {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n  {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. x1 \\<noteq> v \\<Longrightarrow>\n    finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n  {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "using insert"], ["proof (prove)\nusing this:\n  {n. \\<exists>w. (v, w, n) \\<in> insert x F} =\n  {n. \\<exists>w. (v, w, n) \\<in> F}\n  finite F\n  x \\<notin> F\n  finite {n. \\<exists>w. (v, w, n) \\<in> F}\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "by auto"], ["proof (state)\nthis:\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 \\<noteq> v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        finite {n. \\<exists>w. (v, w, n) \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "ultimately"], ["proof (chain)\npicking this:\n  x1 = v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n  x1 \\<noteq> v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "show ?case"], ["proof (prove)\nusing this:\n  x1 = v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n  x1 \\<noteq> v \\<Longrightarrow>\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}", "by auto"], ["proof (state)\nthis:\n  finite {n. \\<exists>w. (v, w, n) \\<in> insert x F}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite S \\<Longrightarrow> finite {n. \\<exists>w. (v, w, n) \\<in> S}\n\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "}"], ["proof (state)\nthis:\n  finite ?S2 \\<Longrightarrow>\n  finite {n. \\<exists>w. (?va2, w, n) \\<in> ?S2}\n\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "note aux=this"], ["proof (state)\nthis:\n  finite ?S2 \\<Longrightarrow>\n  finite {n. \\<exists>w. (?va2, w, n) \\<in> ?S2}\n\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite {n. adjacent v n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {n. adjacent v n}", "using aux[OF \\<open>finite E\\<close>, of v]"], ["proof (prove)\nusing this:\n  finite {n. \\<exists>w. (v, w, n) \\<in> E}\n\ngoal (1 subgoal):\n 1. finite {n. adjacent v n}", "unfolding adjacent_def"], ["proof (prove)\nusing this:\n  finite {n. \\<exists>w. (v, w, n) \\<in> E}\n\ngoal (1 subgoal):\n 1. finite {n. \\<exists>w. (v, w, n) \\<in> E}", "by auto"], ["proof (state)\nthis:\n  finite {n. adjacent v n}\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Undirected simple graph\\<close>"], ["", "locale valid_unSimpGraph=valid_unMultigraph G for G::\"('v,'w) graph\"+\n              assumes no_multi[simp]: \"(v,w,u) \\<in> edges G \\<Longrightarrow> (v,w',u) \\<in>edges G \\<Longrightarrow> w = w'\""], ["", "lemma (in valid_unSimpGraph) finV_to_finE[simp]: \n  assumes \"finite V\" \n  shows \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "proof (cases \"{(v1,v2). adjacent v1 v2}={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. {(x, y). adjacent x y} = {} \\<Longrightarrow> finite E\n 2. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "case True"], ["proof (state)\nthis:\n  {(x, y). adjacent x y} = {}\n\ngoal (2 subgoals):\n 1. {(x, y). adjacent x y} = {} \\<Longrightarrow> finite E\n 2. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "hence \"E={}\""], ["proof (prove)\nusing this:\n  {(x, y). adjacent x y} = {}\n\ngoal (1 subgoal):\n 1. E = {}", "unfolding adjacent_def"], ["proof (prove)\nusing this:\n  {(v1, v2). \\<exists>w. (v1, w, v2) \\<in> E} = {}\n\ngoal (1 subgoal):\n 1. E = {}", "by auto"], ["proof (state)\nthis:\n  E = {}\n\ngoal (2 subgoals):\n 1. {(x, y). adjacent x y} = {} \\<Longrightarrow> finite E\n 2. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "thus \"finite E\""], ["proof (prove)\nusing this:\n  E = {}\n\ngoal (1 subgoal):\n 1. finite E", "by auto"], ["proof (state)\nthis:\n  finite E\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "case False"], ["proof (state)\nthis:\n  {(x, y). adjacent x y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "have \"{(v1,v2). adjacent v1 v2} \\<subseteq> V \\<times> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<subseteq> V \\<times> V", "using adjacent_V"], ["proof (prove)\nusing this:\n  adjacent ?v ?v' \\<Longrightarrow> ?v \\<in> V\n  adjacent ?v ?v' \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<subseteq> V \\<times> V", "by auto"], ["proof (state)\nthis:\n  {(x, y). adjacent x y} \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "moreover"], ["proof (state)\nthis:\n  {(x, y). adjacent x y} \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "have \"finite (V \\<times> V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (V \\<times> V)", "using \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite (V \\<times> V)", "by auto"], ["proof (state)\nthis:\n  finite (V \\<times> V)\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "ultimately"], ["proof (chain)\npicking this:\n  {(x, y). adjacent x y} \\<subseteq> V \\<times> V\n  finite (V \\<times> V)", "have \"finite {(v1,v2). adjacent v1 v2}\""], ["proof (prove)\nusing this:\n  {(x, y). adjacent x y} \\<subseteq> V \\<times> V\n  finite (V \\<times> V)\n\ngoal (1 subgoal):\n 1. finite {(x, y). adjacent x y}", "using finite_subset"], ["proof (prove)\nusing this:\n  {(x, y). adjacent x y} \\<subseteq> V \\<times> V\n  finite (V \\<times> V)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {(x, y). adjacent x y}", "by auto"], ["proof (state)\nthis:\n  finite {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "hence \"card {(v1,v2). adjacent v1 v2}\\<noteq>0\""], ["proof (prove)\nusing this:\n  finite {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. card {(x, y). adjacent x y} \\<noteq> 0", "using False card_eq_0_iff"], ["proof (prove)\nusing this:\n  finite {(x, y). adjacent x y}\n  {(x, y). adjacent x y} \\<noteq> {}\n  (card ?A = 0) = (?A = {} \\<or> infinite ?A)\n\ngoal (1 subgoal):\n 1. card {(x, y). adjacent x y} \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card {(x, y). adjacent x y} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "moreover"], ["proof (state)\nthis:\n  card {(x, y). adjacent x y} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "have \"card E=card {(v1,v2). adjacent v1 v2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card E = card {(x, y). adjacent x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card E = card {(x, y). adjacent x y}", "have \"(\\<lambda>(v1,w,v2). (v1,v2))`E = {(v1,v2). adjacent v1 v2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}", "have \"\\<And>x. x\\<in>(\\<lambda>(v1,w,v2). (v1,v2))`E \\<Longrightarrow> x\\<in> {(v1,v2). adjacent v1 v2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E \\<Longrightarrow>\n       x \\<in> {(x, y). adjacent x y}", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E \\<Longrightarrow>\n       x \\<in> {(v1, v2). \\<exists>w. (v1, w, v2) \\<in> E}", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E \\<Longrightarrow>\n  ?x \\<in> {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E \\<Longrightarrow>\n  ?x \\<in> {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}", "have \"\\<And>x. x\\<in>{(v1,v2). adjacent v1 v2} \\<Longrightarrow> x\\<in>(\\<lambda>(v1,w,v2). (v1,v2))`E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(x, y). adjacent x y} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(v1, v2). \\<exists>w. (v1, w, v2) \\<in> E} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E", "by force"], ["proof (state)\nthis:\n  ?x \\<in> {(x, y). adjacent x y} \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E\n\ngoal (1 subgoal):\n 1. (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E \\<Longrightarrow>\n  ?x \\<in> {(x, y). adjacent x y}\n  ?x \\<in> {(x, y). adjacent x y} \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E \\<Longrightarrow>\n  ?x \\<in> {(x, y). adjacent x y}\n  ?x \\<in> {(x, y). adjacent x y} \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>(v1, w, v2). (v1, v2)) ` E\n\ngoal (1 subgoal):\n 1. (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. card E = card {(x, y). adjacent x y}", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. card E = card {(x, y). adjacent x y}", "have \"inj_on (\\<lambda>(v1,w,v2). (v1,v2)) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(v1, w, v2). (v1, v2)) E", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>E.\n       \\<forall>y\\<in>E.\n          (case x of (v1, w, xa) \\<Rightarrow> (v1, xa)) =\n          (case y of (v1, w, xa) \\<Rightarrow> (v1, xa)) \\<longrightarrow>\n          x = y", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(v1, w, v2). (v1, v2)) E\n\ngoal (1 subgoal):\n 1. card E = card {(x, y). adjacent x y}", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}\n  inj_on (\\<lambda>(v1, w, v2). (v1, v2)) E", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>(v1, w, v2). (v1, v2)) ` E = {(x, y). adjacent x y}\n  inj_on (\\<lambda>(v1, w, v2). (v1, v2)) E\n\ngoal (1 subgoal):\n 1. card E = card {(x, y). adjacent x y}", "by (metis card_image)"], ["proof (state)\nthis:\n  card E = card {(x, y). adjacent x y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card E = card {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. {(x, y). adjacent x y} \\<noteq> {} \\<Longrightarrow> finite E", "ultimately"], ["proof (chain)\npicking this:\n  card {(x, y). adjacent x y} \\<noteq> 0\n  card E = card {(x, y). adjacent x y}", "show \"finite E\""], ["proof (prove)\nusing this:\n  card {(x, y). adjacent x y} \\<noteq> 0\n  card E = card {(x, y). adjacent x y}\n\ngoal (1 subgoal):\n 1. finite E", "by (metis card.infinite)"], ["proof (state)\nthis:\n  finite E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_unEdge_valid'[simp]:\"valid_unSimpGraph G\\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unSimpGraph G \\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_unSimpGraph G \\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)", "assume \"valid_unSimpGraph G\""], ["proof (state)\nthis:\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph G \\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)", "hence \"valid_unMultigraph (del_unEdge v w u G)\""], ["proof (prove)\nusing this:\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w u G)", "using valid_unSimpGraph_def[of G] del_unEdge_valid[of G]"], ["proof (prove)\nusing this:\n  valid_unSimpGraph G\n  valid_unSimpGraph G \\<equiv>\n  valid_unMultigraph G \\<and> valid_unSimpGraph_axioms G\n  valid_unMultigraph G \\<Longrightarrow>\n  valid_unMultigraph (del_unEdge ?v ?e ?v' G)\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w u G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph G \\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)", "moreover"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph G \\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)", "have \"valid_unSimpGraph_axioms (del_unEdge v w u G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unSimpGraph_axioms (del_unEdge v w u G)", "using valid_unSimpGraph.no_multi[OF \\<open>valid_unSimpGraph G\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w, ?u) \\<in> edges G; (?v, ?w', ?u) \\<in> edges G\\<rbrakk>\n  \\<Longrightarrow> ?w = ?w'\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph_axioms (del_unEdge v w u G)", "unfolding valid_unSimpGraph_axioms_def del_unEdge_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?w, ?u) \\<in> edges G; (?v, ?w', ?u) \\<in> edges G\\<rbrakk>\n  \\<Longrightarrow> ?w = ?w'\n\ngoal (1 subgoal):\n 1. \\<forall>va wa ua w'.\n       (va, wa, ua)\n       \\<in> edges\n              \\<lparr>nodes = nodes G,\n                 edges =\n                   edges G -\n                   {(v, w, u), (u, w, v)}\\<rparr> \\<longrightarrow>\n       (va, w', ua)\n       \\<in> edges\n              \\<lparr>nodes = nodes G,\n                 edges =\n                   edges G -\n                   {(v, w, u), (u, w, v)}\\<rparr> \\<longrightarrow>\n       wa = w'", "by auto"], ["proof (state)\nthis:\n  valid_unSimpGraph_axioms (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph G \\<Longrightarrow>\n    valid_unSimpGraph (del_unEdge v w u G)", "ultimately"], ["proof (chain)\npicking this:\n  valid_unMultigraph (del_unEdge v w u G)\n  valid_unSimpGraph_axioms (del_unEdge v w u G)", "show \"valid_unSimpGraph (del_unEdge v w u G)\""], ["proof (prove)\nusing this:\n  valid_unMultigraph (del_unEdge v w u G)\n  valid_unSimpGraph_axioms (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph (del_unEdge v w u G)", "using valid_unSimpGraph_def"], ["proof (prove)\nusing this:\n  valid_unMultigraph (del_unEdge v w u G)\n  valid_unSimpGraph_axioms (del_unEdge v w u G)\n  valid_unSimpGraph ?G \\<equiv>\n  valid_unMultigraph ?G \\<and> valid_unSimpGraph_axioms ?G\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph (del_unEdge v w u G)", "by auto"], ["proof (state)\nthis:\n  valid_unSimpGraph (del_unEdge v w u G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) del_UnEdge_non_adj: \n    \"(v,w,u)\\<in>E \\<Longrightarrow> \\<not>valid_unMultigraph.adjacent (del_unEdge v w u G) v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w, u) \\<in> E \\<Longrightarrow>\n    \\<not> valid_unMultigraph.adjacent (del_unEdge v w u G) v u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"(v, w, u) \\<in> E\" \n      and ccontr:\"valid_unMultigraph.adjacent (del_unEdge v w u G) v u\""], ["proof (state)\nthis:\n  (v, w, u) \\<in> E\n  valid_unMultigraph.adjacent (del_unEdge v w u G) v u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "have valid:\"valid_unMultigraph (del_unEdge v w u G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w u G)", "using valid_unMultigraph_axioms"], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w u G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  valid_unMultigraph (del_unEdge v w u G)", "obtain w' where vw'u:\"(v,w',u)\\<in>edges (del_unEdge v w u G)\""], ["proof (prove)\nusing this:\n  valid_unMultigraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        (v, w', u) \\<in> edges (del_unEdge v w u G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ccontr"], ["proof (prove)\nusing this:\n  valid_unMultigraph (del_unEdge v w u G)\n  valid_unMultigraph.adjacent (del_unEdge v w u G) v u\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        (v, w', u) \\<in> edges (del_unEdge v w u G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding valid_unMultigraph.adjacent_def[OF valid]"], ["proof (prove)\nusing this:\n  valid_unMultigraph (del_unEdge v w u G)\n  \\<exists>wa. (v, wa, u) \\<in> edges (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        (v, w', u) \\<in> edges (del_unEdge v w u G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, w', u) \\<in> edges (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"(v,w',u)\\<notin>{(v,w,u),(u,w,v)}\""], ["proof (prove)\nusing this:\n  (v, w', u) \\<in> edges (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. (v, w', u) \\<notin> {(v, w, u), (u, w, v)}", "unfolding del_unEdge_def"], ["proof (prove)\nusing this:\n  (v, w', u)\n  \\<in> edges \\<lparr>nodes = V, edges = E - {(v, w, u), (u, w, v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. (v, w', u) \\<notin> {(v, w, u), (u, w, v)}", "by auto"], ["proof (state)\nthis:\n  (v, w', u) \\<notin> {(v, w, u), (u, w, v)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"w'\\<noteq>w\""], ["proof (prove)\nusing this:\n  (v, w', u) \\<notin> {(v, w, u), (u, w, v)}\n\ngoal (1 subgoal):\n 1. w' \\<noteq> w", "by auto"], ["proof (state)\nthis:\n  w' \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  w' \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(v,w',u)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w', u) \\<in> E", "using vw'u"], ["proof (prove)\nusing this:\n  (v, w', u) \\<in> edges (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. (v, w', u) \\<in> E", "unfolding del_unEdge_def"], ["proof (prove)\nusing this:\n  (v, w', u)\n  \\<in> edges \\<lparr>nodes = V, edges = E - {(v, w, u), (u, w, v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. (v, w', u) \\<in> E", "by auto"], ["proof (state)\nthis:\n  (v, w', u) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, w, u) \\<in> E;\n     valid_unMultigraph.adjacent (del_unEdge v w u G) v u\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  w' \\<noteq> w\n  (v, w', u) \\<in> E", "show False"], ["proof (prove)\nusing this:\n  w' \\<noteq> w\n  (v, w', u) \\<in> E\n\ngoal (1 subgoal):\n 1. False", "using no_multi[of v w u w'] \\<open>(v, w, u) \\<in> E\\<close>"], ["proof (prove)\nusing this:\n  w' \\<noteq> w\n  (v, w', u) \\<in> E\n  \\<lbrakk>(v, w, u) \\<in> E; (v, w', u) \\<in> E\\<rbrakk>\n  \\<Longrightarrow> w = w'\n  (v, w, u) \\<in> E\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) degree_adjacent: \"finite E \\<Longrightarrow> degree v G=card {n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> degree v G = card {n. adjacent v n}", "using valid_unSimpGraph_axioms"], ["proof (prove)\nusing this:\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> degree v G = card {n. adjacent v n}", "proof (induct \"degree v G\" arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>0 = degree v G; finite (edges G);\n        valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))\n 2. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "case 0"], ["proof (state)\nthis:\n  0 = degree v G\n  finite (edges G)\n  valid_unSimpGraph G\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>0 = degree v G; finite (edges G);\n        valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))\n 2. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "note valid3=\\<open>valid_unSimpGraph G\\<close>"], ["proof (state)\nthis:\n  valid_unSimpGraph G\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>0 = degree v G; finite (edges G);\n        valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))\n 2. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "hence valid2: \"valid_unMultigraph G\""], ["proof (prove)\nusing this:\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "using valid_unSimpGraph_def"], ["proof (prove)\nusing this:\n  valid_unSimpGraph G\n  valid_unSimpGraph ?G \\<equiv>\n  valid_unMultigraph ?G \\<and> valid_unSimpGraph_axioms ?G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph G\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>0 = degree v G; finite (edges G);\n        valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))\n 2. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "have \"{a. valid_unMultigraph.adjacent G v a}={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. valid_unMultigraph.adjacent G v a} = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. {a. valid_unMultigraph.adjacent G v a} \\<noteq> {} \\<Longrightarrow>\n    False", "assume \"{a. valid_unMultigraph.adjacent G v a} \\<noteq> {}\""], ["proof (state)\nthis:\n  {a. valid_unMultigraph.adjacent G v a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {a. valid_unMultigraph.adjacent G v a} \\<noteq> {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  {a. valid_unMultigraph.adjacent G v a} \\<noteq> {}", "obtain w u where \"(v,w,u)\\<in>edges G\""], ["proof (prove)\nusing this:\n  {a. valid_unMultigraph.adjacent G v a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w u.\n        (v, w, u) \\<in> edges G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding valid_unMultigraph.adjacent_def[OF valid2]"], ["proof (prove)\nusing this:\n  {a. \\<exists>w. (v, w, a) \\<in> edges G} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w u.\n        (v, w, u) \\<in> edges G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, w, u) \\<in> edges G\n\ngoal (1 subgoal):\n 1. {a. valid_unMultigraph.adjacent G v a} \\<noteq> {} \\<Longrightarrow>\n    False", "hence \"degree v G\\<noteq>0\""], ["proof (prove)\nusing this:\n  (v, w, u) \\<in> edges G\n\ngoal (1 subgoal):\n 1. degree v G \\<noteq> 0", "using \\<open>finite (edges G)\\<close>"], ["proof (prove)\nusing this:\n  (v, w, u) \\<in> edges G\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. degree v G \\<noteq> 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  (v, w, u) \\<in> edges G\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. card {e \\<in> edges G. fst e = v} \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree v G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {a. valid_unMultigraph.adjacent G v a} \\<noteq> {} \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  degree v G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>0 = degree v G\\<close>"], ["proof (prove)\nusing this:\n  degree v G \\<noteq> 0\n  0 = degree v G\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {a. valid_unMultigraph.adjacent G v a} = {}\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>0 = degree v G; finite (edges G);\n        valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))\n 2. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "thus ?case"], ["proof (prove)\nusing this:\n  {a. valid_unMultigraph.adjacent G v a} = {}\n\ngoal (1 subgoal):\n 1. degree v G = card {a. valid_unMultigraph.adjacent G v a}", "by (metis \"0.hyps\" card.empty)"], ["proof (state)\nthis:\n  degree v G = card {a. valid_unMultigraph.adjacent G v a}\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = degree v ?G; finite (edges ?G); valid_unSimpGraph ?G\\<rbrakk>\n  \\<Longrightarrow> degree v ?G =\n                    card (Collect (valid_unMultigraph.adjacent ?G v))\n  Suc n = degree v G\n  finite (edges G)\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "hence \"{e \\<in> edges G. fst e = v}\\<noteq>{}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = degree v ?G; finite (edges ?G); valid_unSimpGraph ?G\\<rbrakk>\n  \\<Longrightarrow> degree v ?G =\n                    card (Collect (valid_unMultigraph.adjacent ?G v))\n  Suc n = degree v G\n  finite (edges G)\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. {e \\<in> edges G. fst e = v} \\<noteq> {}", "using card.empty"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = degree v ?G; finite (edges ?G); valid_unSimpGraph ?G\\<rbrakk>\n  \\<Longrightarrow> degree v ?G =\n                    card (Collect (valid_unMultigraph.adjacent ?G v))\n  Suc n = degree v G\n  finite (edges G)\n  valid_unSimpGraph G\n  card {} = 0\n\ngoal (1 subgoal):\n 1. {e \\<in> edges G. fst e = v} \\<noteq> {}", "unfolding degree_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card {e \\<in> edges ?G. fst e = v}; finite (edges ?G);\n   valid_unSimpGraph ?G\\<rbrakk>\n  \\<Longrightarrow> card {e \\<in> edges ?G. fst e = v} =\n                    card (Collect (valid_unMultigraph.adjacent ?G v))\n  Suc n = card {e \\<in> edges G. fst e = v}\n  finite (edges G)\n  valid_unSimpGraph G\n  card {} = 0\n\ngoal (1 subgoal):\n 1. {e \\<in> edges G. fst e = v} \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  {e \\<in> edges G. fst e = v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "then"], ["proof (chain)\npicking this:\n  {e \\<in> edges G. fst e = v} \\<noteq> {}", "obtain w u where \"(v,w,u)\\<in>edges G\""], ["proof (prove)\nusing this:\n  {e \\<in> edges G. fst e = v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w u.\n        (v, w, u) \\<in> edges G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, w, u) \\<in> edges G\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "have valid:\"valid_unMultigraph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "using \\<open>valid_unSimpGraph G\\<close> valid_unSimpGraph_def"], ["proof (prove)\nusing this:\n  valid_unSimpGraph G\n  valid_unSimpGraph ?G \\<equiv>\n  valid_unMultigraph ?G \\<and> valid_unSimpGraph_axioms ?G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph G", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "hence valid':\"valid_unMultigraph (del_unEdge v w u G)\""], ["proof (prove)\nusing this:\n  valid_unMultigraph G\n\ngoal (1 subgoal):\n 1. valid_unMultigraph (del_unEdge v w u G)", "by auto"], ["proof (state)\nthis:\n  valid_unMultigraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "have \"valid_unSimpGraph (del_unEdge v w u G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_unSimpGraph (del_unEdge v w u G)", "using del_unEdge_valid' \\<open>valid_unSimpGraph G\\<close>"], ["proof (prove)\nusing this:\n  valid_unSimpGraph ?G \\<Longrightarrow>\n  valid_unSimpGraph (del_unEdge ?v ?w ?u ?G)\n  valid_unSimpGraph G\n\ngoal (1 subgoal):\n 1. valid_unSimpGraph (del_unEdge v w u G)", "by auto"], ["proof (state)\nthis:\n  valid_unSimpGraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "moreover"], ["proof (state)\nthis:\n  valid_unSimpGraph (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "have \"n = degree v (del_unEdge v w u G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = degree v (del_unEdge v w u G)", "using \\<open>Suc n = degree v G\\<close>\\<open>(v, w, u) \\<in> edges G\\<close>  del_edge_undirected_degree_plus[of G v w u]"], ["proof (prove)\nusing this:\n  Suc n = degree v G\n  (v, w, u) \\<in> edges G\n  \\<lbrakk>finite (edges G); (v, w, u) \\<in> edges G;\n   (u, w, v) \\<in> edges G\\<rbrakk>\n  \\<Longrightarrow> degree v (del_unEdge v w u G) + 1 = degree v G\n\ngoal (1 subgoal):\n 1. n = degree v (del_unEdge v w u G)", "by (metis Suc.prems(1) Suc_eq_plus1 diff_Suc_1 valid valid_unMultigraph.corres)"], ["proof (state)\nthis:\n  n = degree v (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "moreover"], ["proof (state)\nthis:\n  n = degree v (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "have \"finite (edges (del_unEdge v w u G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges (del_unEdge v w u G))", "using \\<open>finite (edges G)\\<close>"], ["proof (prove)\nusing this:\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. finite (edges (del_unEdge v w u G))", "unfolding del_unEdge_def"], ["proof (prove)\nusing this:\n  finite (edges G)\n\ngoal (1 subgoal):\n 1. finite\n     (edges\n       \\<lparr>nodes = nodes G,\n          edges = edges G - {(v, w, u), (u, w, v)}\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  finite (edges (del_unEdge v w u G))\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "ultimately"], ["proof (chain)\npicking this:\n  valid_unSimpGraph (del_unEdge v w u G)\n  n = degree v (del_unEdge v w u G)\n  finite (edges (del_unEdge v w u G))", "have \"degree v (del_unEdge v w u G) \n      = card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))\""], ["proof (prove)\nusing this:\n  valid_unSimpGraph (del_unEdge v w u G)\n  n = degree v (del_unEdge v w u G)\n  finite (edges (del_unEdge v w u G))\n\ngoal (1 subgoal):\n 1. degree v (del_unEdge v w u G) =\n    card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))", "using Suc.hyps"], ["proof (prove)\nusing this:\n  valid_unSimpGraph (del_unEdge v w u G)\n  n = degree v (del_unEdge v w u G)\n  finite (edges (del_unEdge v w u G))\n  \\<lbrakk>n = degree v ?G; finite (edges ?G); valid_unSimpGraph ?G\\<rbrakk>\n  \\<Longrightarrow> degree v ?G =\n                    card (Collect (valid_unMultigraph.adjacent ?G v))\n  Suc n = degree v G\n\ngoal (1 subgoal):\n 1. degree v (del_unEdge v w u G) =\n    card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))", "by auto"], ["proof (state)\nthis:\n  degree v (del_unEdge v w u G) =\n  card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "moreover"], ["proof (state)\nthis:\n  degree v (del_unEdge v w u G) =\n  card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "have \"Suc(card ({n. valid_unMultigraph.adjacent (del_unEdge v w u G)  \n      v n})) = card ({n. valid_unMultigraph.adjacent G v n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "using valid_unMultigraph.adjacent_def[OF valid']"], ["proof (prove)\nusing this:\n  valid_unMultigraph.adjacent (del_unEdge v w u G) ?v ?v' \\<equiv>\n  \\<exists>wa. (?v, wa, ?v') \\<in> edges (del_unEdge v w u G)\n\ngoal (1 subgoal):\n 1. Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "have \"{n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<subseteq> \n          {n. valid_unMultigraph.adjacent G v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n    \\<subseteq> {n. valid_unMultigraph.adjacent G v n}", "using del_unEdge_def[of v w u G]"], ["proof (prove)\nusing this:\n  del_unEdge v w u G \\<equiv>\n  \\<lparr>nodes = nodes G, edges = edges G - {(v, w, u), (u, w, v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n    \\<subseteq> {n. valid_unMultigraph.adjacent G v n}", "unfolding valid_unMultigraph.adjacent_def[OF valid'] \n          valid_unMultigraph.adjacent_def[OF valid]"], ["proof (prove)\nusing this:\n  del_unEdge v w u G \\<equiv>\n  \\<lparr>nodes = nodes G, edges = edges G - {(v, w, u), (u, w, v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. {n. \\<exists>wa. (v, wa, n) \\<in> edges (del_unEdge v w u G)}\n    \\<subseteq> {n. \\<exists>w. (v, w, n) \\<in> edges G}", "by auto"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "moreover"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "have \"u\\<in>{n. valid_unMultigraph.adjacent G v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> {n. valid_unMultigraph.adjacent G v n}", "using \\<open>(v,w,u)\\<in>edges G\\<close>"], ["proof (prove)\nusing this:\n  (v, w, u) \\<in> edges G\n\ngoal (1 subgoal):\n 1. u \\<in> {n. valid_unMultigraph.adjacent G v n}", "unfolding valid_unMultigraph.adjacent_def[OF valid]"], ["proof (prove)\nusing this:\n  (v, w, u) \\<in> edges G\n\ngoal (1 subgoal):\n 1. u \\<in> {n. \\<exists>w. (v, w, n) \\<in> edges G}", "by auto"], ["proof (state)\nthis:\n  u \\<in> {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "ultimately"], ["proof (chain)\npicking this:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n  u \\<in> {n. valid_unMultigraph.adjacent G v n}", "have \"{n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n          \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\""], ["proof (prove)\nusing this:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n  u \\<in> {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n    \\<subseteq> {n. valid_unMultigraph.adjacent G v n}", "by auto"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "moreover"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "have \"{n. valid_unMultigraph.adjacent G v n} - {u}\n          \\<subseteq> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. valid_unMultigraph.adjacent G v n} - {u}\n    \\<subseteq> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}", "using del_unEdge_def[of v w u G]"], ["proof (prove)\nusing this:\n  del_unEdge v w u G \\<equiv>\n  \\<lparr>nodes = nodes G, edges = edges G - {(v, w, u), (u, w, v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. {n. valid_unMultigraph.adjacent G v n} - {u}\n    \\<subseteq> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}", "unfolding valid_unMultigraph.adjacent_def[OF valid'] \n          valid_unMultigraph.adjacent_def[OF valid]"], ["proof (prove)\nusing this:\n  del_unEdge v w u G \\<equiv>\n  \\<lparr>nodes = nodes G, edges = edges G - {(v, w, u), (u, w, v)}\\<rparr>\n\ngoal (1 subgoal):\n 1. {n. \\<exists>w. (v, w, n) \\<in> edges G} - {u}\n    \\<subseteq> {n. \\<exists>wa.\n                       (v, wa, n) \\<in> edges (del_unEdge v w u G)}", "by auto"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent G v n} - {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "ultimately"], ["proof (chain)\npicking this:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n  {n. valid_unMultigraph.adjacent G v n} - {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}", "have \"{n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n          = {n. valid_unMultigraph.adjacent G v n}\""], ["proof (prove)\nusing this:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent G v n}\n  {n. valid_unMultigraph.adjacent G v n} - {u}\n  \\<subseteq> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n\ngoal (1 subgoal):\n 1. {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u} =\n    {n. valid_unMultigraph.adjacent G v n}", "by auto"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u} =\n  {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "moreover"], ["proof (state)\nthis:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u} =\n  {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "have \"u\\<notin>{n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}", "using valid_unSimpGraph.del_UnEdge_non_adj[OF \\<open>valid_unSimpGraph G\\<close> \\<open>(v,w,u)\\<in>edges G\\<close>]"], ["proof (prove)\nusing this:\n  \\<not> valid_unMultigraph.adjacent (del_unEdge v w u G) v u\n\ngoal (1 subgoal):\n 1. u \\<notin> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "moreover"], ["proof (state)\nthis:\n  u \\<notin> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "have \"finite {n. valid_unMultigraph.adjacent G v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {n. valid_unMultigraph.adjacent G v n}", "using valid_unMultigraph.adjacent_finite[OF valid \\<open>finite (edges G)\\<close>]"], ["proof (prove)\nusing this:\n  finite {n. valid_unMultigraph.adjacent G ?v n}\n\ngoal (1 subgoal):\n 1. finite {n. valid_unMultigraph.adjacent G v n}", "by simp"], ["proof (state)\nthis:\n  finite {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. (\\<And>va v'.\n        valid_unMultigraph.adjacent (del_unEdge v w u G) va v' \\<equiv>\n        \\<exists>wa.\n           (va, wa, v') \\<in> edges (del_unEdge v w u G)) \\<Longrightarrow>\n    Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "ultimately"], ["proof (chain)\npicking this:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u} =\n  {n. valid_unMultigraph.adjacent G v n}\n  u \\<notin> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n  finite {n. valid_unMultigraph.adjacent G v n}", "show ?thesis"], ["proof (prove)\nusing this:\n  {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n} \\<union> {u} =\n  {n. valid_unMultigraph.adjacent G v n}\n  u \\<notin> {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}\n  finite {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n    card {n. valid_unMultigraph.adjacent G v n}", "by (metis Un_insert_right card_insert_disjoint finite_Un sup_bot_right)"], ["proof (state)\nthis:\n  Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n  card {n. valid_unMultigraph.adjacent G v n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n  card {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. \\<And>x G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>x = degree v G; finite (edges G);\n                    valid_unSimpGraph G\\<rbrakk>\n                   \\<Longrightarrow> degree v G =\n                                     card\n(Collect (valid_unMultigraph.adjacent G v));\n        Suc x = degree v G; finite (edges G); valid_unSimpGraph G\\<rbrakk>\n       \\<Longrightarrow> degree v G =\n                         card (Collect (valid_unMultigraph.adjacent G v))", "ultimately"], ["proof (chain)\npicking this:\n  degree v (del_unEdge v w u G) =\n  card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))\n  Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n  card {n. valid_unMultigraph.adjacent G v n}", "show ?case"], ["proof (prove)\nusing this:\n  degree v (del_unEdge v w u G) =\n  card (Collect (valid_unMultigraph.adjacent (del_unEdge v w u G) v))\n  Suc (card {n. valid_unMultigraph.adjacent (del_unEdge v w u G) v n}) =\n  card {n. valid_unMultigraph.adjacent G v n}\n\ngoal (1 subgoal):\n 1. degree v G = card (Collect (valid_unMultigraph.adjacent G v))", "by (metis Suc.hyps(2) \\<open>n = degree v (del_unEdge v w u G)\\<close>)"], ["proof (state)\nthis:\n  degree v G = card (Collect (valid_unMultigraph.adjacent G v))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}