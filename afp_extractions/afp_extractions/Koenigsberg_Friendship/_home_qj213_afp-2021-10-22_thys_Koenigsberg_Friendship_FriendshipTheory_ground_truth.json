{"file_name": "/home/qj213/afp-2021-10-22/thys/Koenigsberg_Friendship/FriendshipTheory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Koenigsberg_Friendship", "problem_names": ["lemma (in valid_unSimpGraph) no_quad:\n  assumes \"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n  shows \"\\<not> (\\<exists>v1 v2 v3 v4. v2\\<noteq>v4 \\<and> v1\\<noteq>v3 \\<and> adjacent v1 v2 \\<and> adjacent v2 v3 \\<and> adjacent v3 v4 \n      \\<and> adjacent v4 v1)\"", "lemma even_card_set: \n  assumes \"finite A\" and \"\\<forall>x\\<in>A. f x\\<in>A \\<and> f x\\<noteq> x \\<and> f (f x)=x\"\n  shows \"even(card A)\"", "lemma (in valid_unSimpGraph) even_degree:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\" \n      and \"finite E\"\n  shows \"\\<forall>v\\<in>V. even(degree v G)\"", "lemma (in valid_unSimpGraph) degree_two_windmill:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n      and \"finite E\" and \"card V\\<ge>2\"\n  shows \"(\\<exists>v\\<in>V. degree v G = 2) \\<longleftrightarrow>(\\<exists>v. \\<forall>n\\<in>V. n\\<noteq>v \\<longrightarrow> adjacent v n)\"", "lemma (in valid_unSimpGraph) regular:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\" \n      and \"finite E\" and \"finite V\" and \"\\<not>(\\<exists>v\\<in>V. degree v G = 2)\"\n  shows \"\\<exists>k. \\<forall>v\\<in>V. degree v G = k\"", "lemma (in valid_unSimpGraph) adj_path_butlast:\n  \"adj_path v ps \\<Longrightarrow> adj_path v (butlast ps)\"", "lemma (in valid_unSimpGraph) adj_path_V:\n  \"adj_path v ps \\<Longrightarrow> set ps \\<subseteq> V\"", "lemma (in valid_unSimpGraph) adj_path_V':\n  \"adj_path v ps \\<Longrightarrow> v\\<in> V\"", "lemma (in valid_unSimpGraph) adj_path_app:\n  \"adj_path v ps \\<Longrightarrow> ps\\<noteq>[] \\<Longrightarrow> adjacent (last ps) u \\<Longrightarrow> adj_path v (ps@[u])\"", "lemma (in valid_unSimpGraph) adj_path_app':\n  \"adj_path v (ps @ [q] ) \\<Longrightarrow> ps \\<noteq> [] \\<Longrightarrow> adjacent (last ps) q\"", "lemma card_partition':\n  assumes \"\\<forall>v\\<in>A. card {n. R v n} = k\" \"k>0\" \"finite A\" \n      \"\\<forall>v1 v2. v1\\<noteq>v2 \\<longrightarrow> {n. R v1 n} \\<inter> {n. R v2 n}={}\"\n  shows \"card (\\<Union>v\\<in>A. {n. R v n}) = k * card A\"", "lemma (in valid_unSimpGraph) path_count:\n  assumes k_adj:\"\\<And>v. v\\<in>V \\<Longrightarrow> card {n. adjacent v n} = k\" and  \"v\\<in>V\" and \"finite V\" and \"k>0\"\n  shows \"card {ps. length ps=l \\<and> adj_path v ps}=k^l\"", "lemma (in valid_unSimpGraph) total_v_num:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\" \n      and \"finite E\" and \"finite V\" and \"V\\<noteq>{}\" and \" \\<forall>v\\<in>V. degree v G = k\" and \"k>0\"\n  shows \"card V= k*k - k +1\"", "lemma rotate_eq:\"rotate1 xs=rotate1 ys \\<Longrightarrow> xs=ys\"", "lemma rotate_diff:\"rotate m xs=rotate n xs \\<Longrightarrow>rotate (m-n) xs = xs\"", "lemma (in valid_unSimpGraph) exist_degree_two:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n      and \"finite E\" and \"finite V\" and \"card V\\<ge>2\" \n  shows \"\\<exists>v\\<in>V. degree v G = 2\"", "theorem (in valid_unSimpGraph) friendship_thm:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n      and \"finite V\" \n  shows \"\\<exists>v. \\<forall>n\\<in>V. n\\<noteq>v \\<longrightarrow> adjacent v n\""], "translations": [["", "lemma (in valid_unSimpGraph) no_quad:\n  assumes \"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n  shows \"\\<not> (\\<exists>v1 v2 v3 v4. v2\\<noteq>v4 \\<and> v1\\<noteq>v3 \\<and> adjacent v1 v2 \\<and> adjacent v2 v3 \\<and> adjacent v3 v4 \n      \\<and> adjacent v4 v1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v1 v2 v3 v4.\n       v2 \\<noteq> v4 \\<and>\n       v1 \\<noteq> v3 \\<and>\n       adjacent v1 v2 \\<and>\n       adjacent v2 v3 \\<and> adjacent v3 v4 \\<and> adjacent v4 v1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v1 v2 v3 v4.\n       v2 \\<noteq> v4 \\<and>\n       v1 \\<noteq> v3 \\<and>\n       adjacent v1 v2 \\<and>\n       adjacent v2 v3 \\<and>\n       adjacent v3 v4 \\<and> adjacent v4 v1 \\<Longrightarrow>\n    False", "assume \"\\<exists>v1 v2 v3 v4. v2\\<noteq>v4  \\<and> v1\\<noteq>v3 \\<and> adjacent v1 v2 \\<and> adjacent v2 v3 \\<and> adjacent v3 v4 \\<and> adjacent v4 v1\""], ["proof (state)\nthis:\n  \\<exists>v1 v2 v3 v4.\n     v2 \\<noteq> v4 \\<and>\n     v1 \\<noteq> v3 \\<and>\n     adjacent v1 v2 \\<and>\n     adjacent v2 v3 \\<and> adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. \\<exists>v1 v2 v3 v4.\n       v2 \\<noteq> v4 \\<and>\n       v1 \\<noteq> v3 \\<and>\n       adjacent v1 v2 \\<and>\n       adjacent v2 v3 \\<and>\n       adjacent v3 v4 \\<and> adjacent v4 v1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v1 v2 v3 v4.\n     v2 \\<noteq> v4 \\<and>\n     v1 \\<noteq> v3 \\<and>\n     adjacent v1 v2 \\<and>\n     adjacent v2 v3 \\<and> adjacent v3 v4 \\<and> adjacent v4 v1", "obtain v1 v2 v3 v4 where \n    \"v2\\<noteq>v4\" \"v1\\<noteq>v3\" \"adjacent v1 v2\" \"adjacent v2 v3\" \"adjacent v3 v4\" \"adjacent v4 v1\""], ["proof (prove)\nusing this:\n  \\<exists>v1 v2 v3 v4.\n     v2 \\<noteq> v4 \\<and>\n     v1 \\<noteq> v3 \\<and>\n     adjacent v1 v2 \\<and>\n     adjacent v2 v3 \\<and> adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. (\\<And>v2 v4 v1 v3.\n        \\<lbrakk>v2 \\<noteq> v4; v1 \\<noteq> v3; adjacent v1 v2;\n         adjacent v2 v3; adjacent v3 v4; adjacent v4 v1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v2 \\<noteq> v4\n  v1 \\<noteq> v3\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v4\n  adjacent v4 v1\n\ngoal (1 subgoal):\n 1. \\<exists>v1 v2 v3 v4.\n       v2 \\<noteq> v4 \\<and>\n       v1 \\<noteq> v3 \\<and>\n       adjacent v1 v2 \\<and>\n       adjacent v2 v3 \\<and>\n       adjacent v3 v4 \\<and> adjacent v4 v1 \\<Longrightarrow>\n    False", "hence \"\\<exists>!n. adjacent v1 n \\<and> adjacent v3 n\""], ["proof (prove)\nusing this:\n  v2 \\<noteq> v4\n  v1 \\<noteq> v3\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v4\n  adjacent v4 v1\n\ngoal (1 subgoal):\n 1. \\<exists>!n. adjacent v1 n \\<and> adjacent v3 n", "using assms[of v1 v3]"], ["proof (prove)\nusing this:\n  v2 \\<noteq> v4\n  v1 \\<noteq> v3\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v4\n  adjacent v4 v1\n  \\<lbrakk>v1 \\<in> V; v3 \\<in> V; v1 \\<noteq> v3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v1 n \\<and> adjacent v3 n\n\ngoal (1 subgoal):\n 1. \\<exists>!n. adjacent v1 n \\<and> adjacent v3 n", "by auto"], ["proof (state)\nthis:\n  \\<exists>!n. adjacent v1 n \\<and> adjacent v3 n\n\ngoal (1 subgoal):\n 1. \\<exists>v1 v2 v3 v4.\n       v2 \\<noteq> v4 \\<and>\n       v1 \\<noteq> v3 \\<and>\n       adjacent v1 v2 \\<and>\n       adjacent v2 v3 \\<and>\n       adjacent v3 v4 \\<and> adjacent v4 v1 \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>!n. adjacent v1 n \\<and> adjacent v3 n\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>adjacent v1 v2\\<close> \\<open>adjacent v2 v3\\<close> \\<open>adjacent v3 v4\\<close> \\<open>adjacent v4 v1\\<close> \\<open>v2 \\<noteq> v4\\<close> \n      adjacent_sym)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma even_card_set: \n  assumes \"finite A\" and \"\\<forall>x\\<in>A. f x\\<in>A \\<and> f x\\<noteq> x \\<and> f (f x)=x\"\n  shows \"even(card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (card A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<forall>x\\<in>A. f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal (1 subgoal):\n 1. even (card A)", "proof (induct \"card A\"  arbitrary:A rule:less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>Aa.\n                   \\<lbrakk>card Aa < card A; finite Aa;\n                    \\<forall>x\\<in>Aa.\n                       f x \\<in> Aa \\<and>\n                       f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n                   \\<Longrightarrow> even (card Aa);\n        finite A;\n        \\<forall>x\\<in>A.\n           f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n       \\<Longrightarrow> even (card A)", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>card ?A < card A; finite ?A;\n   \\<forall>x\\<in>?A.\n      f x \\<in> ?A \\<and> f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n  \\<Longrightarrow> even (card ?A)\n  finite A\n  \\<forall>x\\<in>A. f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>Aa.\n                   \\<lbrakk>card Aa < card A; finite Aa;\n                    \\<forall>x\\<in>Aa.\n                       f x \\<in> Aa \\<and>\n                       f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n                   \\<Longrightarrow> even (card Aa);\n        finite A;\n        \\<forall>x\\<in>A.\n           f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n       \\<Longrightarrow> even (card A)", "have \"A={}\\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> even (card A)", "by auto"], ["proof (state)\nthis:\n  A = {} \\<Longrightarrow> even (card A)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>Aa.\n                   \\<lbrakk>card Aa < card A; finite Aa;\n                    \\<forall>x\\<in>Aa.\n                       f x \\<in> Aa \\<and>\n                       f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n                   \\<Longrightarrow> even (card Aa);\n        finite A;\n        \\<forall>x\\<in>A.\n           f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n       \\<Longrightarrow> even (card A)", "moreover"], ["proof (state)\nthis:\n  A = {} \\<Longrightarrow> even (card A)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>Aa.\n                   \\<lbrakk>card Aa < card A; finite Aa;\n                    \\<forall>x\\<in>Aa.\n                       f x \\<in> Aa \\<and>\n                       f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n                   \\<Longrightarrow> even (card Aa);\n        finite A;\n        \\<forall>x\\<in>A.\n           f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n       \\<Longrightarrow> even (card A)", "have \"A\\<noteq>{}\\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "assume \"A\\<noteq>{}\""], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "obtain x where \"x\\<in>A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "hence \"f x\\<in>A\" and \"f x\\<noteq>x\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. f x \\<in> A &&& f x \\<noteq> x", "by (metis less.prems(2))+"], ["proof (state)\nthis:\n  f x \\<in> A\n  f x \\<noteq> x\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "obtain B where B:\"B=A-{x,f x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. B = A - {x, f x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B = A - {x, f x}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "hence \"finite B\""], ["proof (prove)\nusing this:\n  B = A - {x, f x}\n\ngoal (1 subgoal):\n 1. finite B", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  B = A - {x, f x}\n  finite A\n\ngoal (1 subgoal):\n 1. finite B", "by auto"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "moreover"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "have \"card B<card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card B < card A", "using B \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  B = A - {x, f x}\n  finite A\n\ngoal (1 subgoal):\n 1. card B < card A", "by (metis Diff_insert \\<open>f x \\<in> A\\<close> \\<open>x \\<in> A\\<close> card_Diff2_less)"], ["proof (state)\nthis:\n  card B < card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "moreover"], ["proof (state)\nthis:\n  card B < card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "have \"\\<forall>x\\<in>B. f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>B. f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "assume \"y\\<in>B\""], ["proof (state)\nthis:\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "hence \"y\\<in>A\""], ["proof (prove)\nusing this:\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. y \\<in> A", "using B"], ["proof (prove)\nusing this:\n  y \\<in> B\n  B = A - {x, f x}\n\ngoal (1 subgoal):\n 1. y \\<in> A", "by auto"], ["proof (state)\nthis:\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "hence \"f y\\<noteq>y\" and \"f (f y)=y\""], ["proof (prove)\nusing this:\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. f y \\<noteq> y &&& f (f y) = y", "by (metis less.prems(2))+"], ["proof (state)\nthis:\n  f y \\<noteq> y\n  f (f y) = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "moreover"], ["proof (state)\nthis:\n  f y \\<noteq> y\n  f (f y) = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "have \"f y\\<in>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y \\<in> B", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "assume \"f y\\<notin>B\""], ["proof (state)\nthis:\n  f y \\<notin> B\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "have \"f y\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y \\<in> A", "by (metis \\<open>y \\<in> A\\<close> less.prems(2))"], ["proof (state)\nthis:\n  f y \\<in> A\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "hence \"f y\\<in>{x, f x}\""], ["proof (prove)\nusing this:\n  f y \\<in> A\n\ngoal (1 subgoal):\n 1. f y \\<in> {x, f x}", "by (metis B DiffI \\<open>f y \\<notin> B\\<close>)"], ["proof (state)\nthis:\n  f y \\<in> {x, f x}\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  f y \\<in> {x, f x}\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "have \"f y=x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y = x \\<Longrightarrow> False", "by (metis B Diff_iff Diff_insert2 \\<open>f (f y) = y\\<close> \\<open>y \\<in> B\\<close> singleton_iff)"], ["proof (state)\nthis:\n  f y = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  f y = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "have \"f y= f x\\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y = f x \\<Longrightarrow> False", "by (metis B Diff_iff \\<open>x \\<in> A\\<close> \\<open>y \\<in> B\\<close> insertCI less.prems(2))"], ["proof (state)\nthis:\n  f y = f x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f y \\<notin> B \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  f y \\<in> {x, f x}\n  f y = x \\<Longrightarrow> False\n  f y = f x \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  f y \\<in> {x, f x}\n  f y = x \\<Longrightarrow> False\n  f y = f x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "ultimately"], ["proof (chain)\npicking this:\n  f y \\<noteq> y\n  f (f y) = y\n  f y \\<in> B", "show \"f y \\<in> B \\<and> f y \\<noteq> y \\<and> f (f y) = y\""], ["proof (prove)\nusing this:\n  f y \\<noteq> y\n  f (f y) = y\n  f y \\<in> B\n\ngoal (1 subgoal):\n 1. f y \\<in> B \\<and> f y \\<noteq> y \\<and> f (f y) = y", "by auto"], ["proof (state)\nthis:\n  f y \\<in> B \\<and> f y \\<noteq> y \\<and> f (f y) = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>B. f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "ultimately"], ["proof (chain)\npicking this:\n  finite B\n  card B < card A\n  \\<forall>x\\<in>B. f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x", "have \"even (card B)\""], ["proof (prove)\nusing this:\n  finite B\n  card B < card A\n  \\<forall>x\\<in>B. f x \\<in> B \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal (1 subgoal):\n 1. even (card B)", "by (metis (full_types) less.hyps)"], ["proof (state)\nthis:\n  even (card B)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "moreover"], ["proof (state)\nthis:\n  even (card B)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "have \"{x,f x}\\<subseteq>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, f x} \\<subseteq> A", "using \\<open>f x\\<in>A\\<close> \\<open>x\\<in>A\\<close>"], ["proof (prove)\nusing this:\n  f x \\<in> A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. {x, f x} \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  {x, f x} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "moreover"], ["proof (state)\nthis:\n  {x, f x} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "have \"card {x, f x} = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x, f x} = 2", "using \\<open>f x\\<noteq>x\\<close>"], ["proof (prove)\nusing this:\n  f x \\<noteq> x\n\ngoal (1 subgoal):\n 1. card {x, f x} = 2", "by auto"], ["proof (state)\nthis:\n  card {x, f x} = 2\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> even (card A)", "ultimately"], ["proof (chain)\npicking this:\n  even (card B)\n  {x, f x} \\<subseteq> A\n  card {x, f x} = 2", "show ?case"], ["proof (prove)\nusing this:\n  even (card B)\n  {x, f x} \\<subseteq> A\n  card {x, f x} = 2\n\ngoal (1 subgoal):\n 1. even (card A)", "using B \\<open>finite A\\<close> card_mono [of A \"{x, f x}\"]"], ["proof (prove)\nusing this:\n  even (card B)\n  {x, f x} \\<subseteq> A\n  card {x, f x} = 2\n  B = A - {x, f x}\n  finite A\n  \\<lbrakk>finite A; {x, f x} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> card {x, f x} \\<le> card A\n\ngoal (1 subgoal):\n 1. even (card A)", "by (simp add: card_Diff_subset)"], ["proof (state)\nthis:\n  even (card A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<Longrightarrow> even (card A)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>Aa.\n                   \\<lbrakk>card Aa < card A; finite Aa;\n                    \\<forall>x\\<in>Aa.\n                       f x \\<in> Aa \\<and>\n                       f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n                   \\<Longrightarrow> even (card Aa);\n        finite A;\n        \\<forall>x\\<in>A.\n           f x \\<in> A \\<and> f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n       \\<Longrightarrow> even (card A)", "ultimately"], ["proof (chain)\npicking this:\n  A = {} \\<Longrightarrow> even (card A)\n  A \\<noteq> {} \\<Longrightarrow> even (card A)", "show ?case"], ["proof (prove)\nusing this:\n  A = {} \\<Longrightarrow> even (card A)\n  A \\<noteq> {} \\<Longrightarrow> even (card A)\n\ngoal (1 subgoal):\n 1. even (card A)", "by metis"], ["proof (state)\nthis:\n  even (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) even_degree:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\" \n      and \"finite E\"\n  shows \"\\<forall>v\\<in>V. even(degree v G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. even (degree v G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "assume \"v\\<in>V\""], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "obtain f where f:\"f = (\\<lambda>n. (SOME v'. n\\<in>V \\<longrightarrow>n\\<noteq>v\\<longrightarrow>adjacent n v' \\<and> adjacent v v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f =\n        (\\<lambda>n.\n            SOME v'.\n               n \\<in> V \\<longrightarrow>\n               n \\<noteq> v \\<longrightarrow>\n               adjacent n v' \\<and> adjacent v v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f =\n  (\\<lambda>n.\n      SOME v'.\n         n \\<in> V \\<longrightarrow>\n         n \\<noteq> v \\<longrightarrow> adjacent n v' \\<and> adjacent v v')\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "have \"\\<And>n.  n\\<in>V \\<longrightarrow> n\\<noteq>v \\<longrightarrow> (\\<exists>v'. adjacent n v' \\<and> adjacent v v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> V \\<longrightarrow>\n       n \\<noteq> v \\<longrightarrow>\n       (\\<exists>v'. adjacent n v' \\<and> adjacent v v')", "proof (rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent v v'", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent v v'", "assume  \"n \\<in> V\" \"n \\<noteq> v\""], ["proof (state)\nthis:\n  n \\<in> V\n  n \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent v v'", "hence \"\\<exists>!v'. adjacent n v' \\<and> adjacent v v'\""], ["proof (prove)\nusing this:\n  n \\<in> V\n  n \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<exists>!v'. adjacent n v' \\<and> adjacent v v'", "using friend_assm[of n v] \\<open>v\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  n \\<in> V\n  n \\<noteq> v\n  \\<lbrakk>n \\<in> V; v \\<in> V; n \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!na. adjacent n na \\<and> adjacent v na\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>!v'. adjacent n v' \\<and> adjacent v v'", "unfolding non_adj_def"], ["proof (prove)\nusing this:\n  n \\<in> V\n  n \\<noteq> v\n  \\<lbrakk>n \\<in> V; v \\<in> V; n \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!na. adjacent n na \\<and> adjacent v na\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>!v'. adjacent n v' \\<and> adjacent v v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>!v'. adjacent n v' \\<and> adjacent v v'\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent v v'", "thus \"\\<exists>v'. adjacent n v' \\<and> adjacent v v'\""], ["proof (prove)\nusing this:\n  \\<exists>!v'. adjacent n v' \\<and> adjacent v v'\n\ngoal (1 subgoal):\n 1. \\<exists>v'. adjacent n v' \\<and> adjacent v v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>v'. adjacent n v' \\<and> adjacent v v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n \\<in> V \\<longrightarrow>\n  ?n \\<noteq> v \\<longrightarrow>\n  (\\<exists>v'. adjacent ?n v' \\<and> adjacent v v')\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "hence f_ex:\"\\<And>n.  (\\<exists>v'. n\\<in>V \\<longrightarrow> n\\<noteq>v \\<longrightarrow>  adjacent n v' \\<and> adjacent v v')\""], ["proof (prove)\nusing this:\n  ?n \\<in> V \\<longrightarrow>\n  ?n \\<noteq> v \\<longrightarrow>\n  (\\<exists>v'. adjacent ?n v' \\<and> adjacent v v')\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>v'.\n          n \\<in> V \\<longrightarrow>\n          n \\<noteq> v \\<longrightarrow> adjacent n v' \\<and> adjacent v v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>v'.\n     ?n \\<in> V \\<longrightarrow>\n     ?n \\<noteq> v \\<longrightarrow> adjacent ?n v' \\<and> adjacent v v'\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "have \"\\<forall>x\\<in>{n. adjacent v n}. f x\\<in>{n. adjacent v n} \\<and> f x\\<noteq> x \\<and> f (f x)=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{n. adjacent v n}.\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "assume \"x \\<in> {n. adjacent v n}\""], ["proof (state)\nthis:\n  x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "hence \"adjacent v x\""], ["proof (prove)\nusing this:\n  x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. adjacent v x", "by auto"], ["proof (state)\nthis:\n  adjacent v x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "have \"f x\\<in>{n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> {n. adjacent v n}", "using someI_ex[OF f_ex,of x]"], ["proof (prove)\nusing this:\n  x \\<in> V \\<longrightarrow>\n  x \\<noteq> v \\<longrightarrow>\n  adjacent x\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> v \\<longrightarrow>\n       adjacent x xa \\<and> adjacent v xa) \\<and>\n  adjacent v\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> v \\<longrightarrow> adjacent x xa \\<and> adjacent v xa)\n\ngoal (1 subgoal):\n 1. f x \\<in> {n. adjacent v n}", "by (metis \\<open>adjacent v x\\<close> adjacent_V(2) adjacent_no_loop f mem_Collect_eq)"], ["proof (state)\nthis:\n  f x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "moreover"], ["proof (state)\nthis:\n  f x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "have \"f x\\<noteq>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<noteq> x", "using someI_ex[OF f_ex,of x]"], ["proof (prove)\nusing this:\n  x \\<in> V \\<longrightarrow>\n  x \\<noteq> v \\<longrightarrow>\n  adjacent x\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> v \\<longrightarrow>\n       adjacent x xa \\<and> adjacent v xa) \\<and>\n  adjacent v\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> v \\<longrightarrow> adjacent x xa \\<and> adjacent v xa)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> x", "by (metis \\<open>adjacent v x\\<close> adjacent_V(2) adjacent_no_loop f)"], ["proof (state)\nthis:\n  f x \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "moreover"], ["proof (state)\nthis:\n  f x \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "have \"f (f x)=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (f x) = x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "assume \"f (f x)\\<noteq>x\""], ["proof (state)\nthis:\n  f (f x) \\<noteq> x\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "have \"adjacent (f x) (f (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (f x) (f (f x))", "using someI_ex[OF f_ex,of \"f x\"]"], ["proof (prove)\nusing this:\n  f x \\<in> V \\<longrightarrow>\n  f x \\<noteq> v \\<longrightarrow>\n  adjacent (f x)\n   (SOME xa.\n       f x \\<in> V \\<longrightarrow>\n       f x \\<noteq> v \\<longrightarrow>\n       adjacent (f x) xa \\<and> adjacent v xa) \\<and>\n  adjacent v\n   (SOME xa.\n       f x \\<in> V \\<longrightarrow>\n       f x \\<noteq> v \\<longrightarrow>\n       adjacent (f x) xa \\<and> adjacent v xa)\n\ngoal (1 subgoal):\n 1. adjacent (f x) (f (f x))", "by (metis (full_types) adjacent_V(2) adjacent_no_loop calculation(1) f mem_Collect_eq)"], ["proof (state)\nthis:\n  adjacent (f x) (f (f x))\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent (f x) (f (f x))\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "have \"adjacent (f (f x)) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (f (f x)) v", "using someI_ex[OF f_ex,of \"f x\"]"], ["proof (prove)\nusing this:\n  f x \\<in> V \\<longrightarrow>\n  f x \\<noteq> v \\<longrightarrow>\n  adjacent (f x)\n   (SOME xa.\n       f x \\<in> V \\<longrightarrow>\n       f x \\<noteq> v \\<longrightarrow>\n       adjacent (f x) xa \\<and> adjacent v xa) \\<and>\n  adjacent v\n   (SOME xa.\n       f x \\<in> V \\<longrightarrow>\n       f x \\<noteq> v \\<longrightarrow>\n       adjacent (f x) xa \\<and> adjacent v xa)\n\ngoal (1 subgoal):\n 1. adjacent (f (f x)) v", "by (metis adjacent_V(1) adjacent_sym calculation f)"], ["proof (state)\nthis:\n  adjacent (f (f x)) v\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent (f (f x)) v\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "have \"adjacent x (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent x (f x)", "using someI_ex[OF f_ex,of x]"], ["proof (prove)\nusing this:\n  x \\<in> V \\<longrightarrow>\n  x \\<noteq> v \\<longrightarrow>\n  adjacent x\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> v \\<longrightarrow>\n       adjacent x xa \\<and> adjacent v xa) \\<and>\n  adjacent v\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> v \\<longrightarrow> adjacent x xa \\<and> adjacent v xa)\n\ngoal (1 subgoal):\n 1. adjacent x (f x)", "by (metis \\<open>adjacent v x\\<close> adjacent_V(2) adjacent_no_loop f)"], ["proof (state)\nthis:\n  adjacent x (f x)\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent x (f x)\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "have \"v\\<noteq>f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> f x", "by (metis \\<open>f x \\<in> {n. adjacent v n}\\<close> adjacent_no_loop mem_Collect_eq)"], ["proof (state)\nthis:\n  v \\<noteq> f x\n\ngoal (1 subgoal):\n 1. f (f x) \\<noteq> x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent (f x) (f (f x))\n  adjacent (f (f x)) v\n  adjacent x (f x)\n  v \\<noteq> f x", "show False"], ["proof (prove)\nusing this:\n  adjacent (f x) (f (f x))\n  adjacent (f (f x)) v\n  adjacent x (f x)\n  v \\<noteq> f x\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  adjacent (f x) (f (f x))\n  adjacent (f (f x)) v\n  adjacent x (f x)\n  v \\<noteq> f x\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>adjacent v x\\<close> \\<open>f (f x)\\<noteq>x\\<close>"], ["proof (prove)\nusing this:\n  adjacent (f x) (f (f x))\n  adjacent (f (f x)) v\n  adjacent x (f x)\n  v \\<noteq> f x\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n  adjacent v x\n  f (f x) \\<noteq> x\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (f x) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n. adjacent v n} \\<Longrightarrow>\n       f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "ultimately"], ["proof (chain)\npicking this:\n  f x \\<in> {n. adjacent v n}\n  f x \\<noteq> x\n  f (f x) = x", "show \"f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\""], ["proof (prove)\nusing this:\n  f x \\<in> {n. adjacent v n}\n  f x \\<noteq> x\n  f (f x) = x\n\ngoal (1 subgoal):\n 1. f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x", "by auto"], ["proof (state)\nthis:\n  f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{n. adjacent v n}.\n     f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{n. adjacent v n}.\n     f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "have \"finite {n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {n. adjacent v n}", "by (metis adjacent_finite assms(2))"], ["proof (state)\nthis:\n  finite {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{n. adjacent v n}.\n     f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\n  finite {n. adjacent v n}", "have \"even (card {n. adjacent v n})\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{n. adjacent v n}.\n     f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\n  finite {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. even (card {n. adjacent v n})", "using even_card_set[of \"{n. adjacent v n}\" f]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{n. adjacent v n}.\n     f x \\<in> {n. adjacent v n} \\<and> f x \\<noteq> x \\<and> f (f x) = x\n  finite {n. adjacent v n}\n  \\<lbrakk>finite {n. adjacent v n};\n   \\<forall>x\\<in>{n. adjacent v n}.\n      f x \\<in> {n. adjacent v n} \\<and>\n      f x \\<noteq> x \\<and> f (f x) = x\\<rbrakk>\n  \\<Longrightarrow> even (card {n. adjacent v n})\n\ngoal (1 subgoal):\n 1. even (card {n. adjacent v n})", "by auto"], ["proof (state)\nthis:\n  even (card {n. adjacent v n})\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> even (degree v G)", "thus \"even(degree v G)\""], ["proof (prove)\nusing this:\n  even (card {n. adjacent v n})\n\ngoal (1 subgoal):\n 1. even (degree v G)", "by (metis assms(2) degree_adjacent)"], ["proof (state)\nthis:\n  even (degree v G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) degree_two_windmill:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n      and \"finite E\" and \"card V\\<ge>2\"\n  shows \"(\\<exists>v\\<in>V. degree v G = 2) \\<longleftrightarrow>(\\<exists>v. \\<forall>n\\<in>V. n\\<noteq>v \\<longrightarrow> adjacent v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v\\<in>V. degree v G = 2) =\n    (\\<exists>v.\n        \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "assume \"\\<exists>v\\<in>V. degree v G = 2 \""], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. degree v G = 2\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>V. degree v G = 2", "obtain v where \"degree v G=2\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. degree v G = 2\n\ngoal (1 subgoal):\n 1. (\\<And>v. degree v G = 2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree v G = 2\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "hence \"card {n. adjacent v n}=2\""], ["proof (prove)\nusing this:\n  degree v G = 2\n\ngoal (1 subgoal):\n 1. card {n. adjacent v n} = 2", "using degree_adjacent[OF \\<open>finite E\\<close>,of v]"], ["proof (prove)\nusing this:\n  degree v G = 2\n  degree v G = card {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. card {n. adjacent v n} = 2", "by auto"], ["proof (state)\nthis:\n  card {n. adjacent v n} = 2\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "then"], ["proof (chain)\npicking this:\n  card {n. adjacent v n} = 2", "obtain v1 v2 where v1v2:\"{n. adjacent v n}={v1,v2}\" and \"v1\\<noteq>v2\""], ["proof (prove)\nusing this:\n  card {n. adjacent v n} = 2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>{n. adjacent v n} = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2.\n                \\<lbrakk>{n. adjacent v n} = {v1, v2};\n                 v1 \\<noteq> v2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card {n. adjacent v n} = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain v1 S where \"{n. adjacent v n} = insert v1 S\" and  \"v1 \\<notin> S\" and \"card S = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 S.\n        \\<lbrakk>{n. adjacent v n} = insert v1 S; v1 \\<notin> S;\n         card S = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>card {n. adjacent v n}=2\\<close> card_Suc_eq[of \"{n. adjacent v n}\" 1]"], ["proof (prove)\nusing this:\n  card {n. adjacent v n} = 2\n  (card {n. adjacent v n} = Suc 1) =\n  (\\<exists>b B.\n      {n. adjacent v n} = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 1 \\<and> (1 = 0 \\<longrightarrow> B = {}))\n\ngoal (1 subgoal):\n 1. (\\<And>v1 S.\n        \\<lbrakk>{n. adjacent v n} = insert v1 S; v1 \\<notin> S;\n         card S = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {n. adjacent v n} = insert v1 S\n  v1 \\<notin> S\n  card S = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2.\n                \\<lbrakk>{n. adjacent v n} = {v1, v2};\n                 v1 \\<noteq> v2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card {n. adjacent v n} = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  {n. adjacent v n} = insert v1 S\n  v1 \\<notin> S\n  card S = 1", "obtain v2 where \"S=insert v2 {}\""], ["proof (prove)\nusing this:\n  {n. adjacent v n} = insert v1 S\n  v1 \\<notin> S\n  card S = 1\n\ngoal (1 subgoal):\n 1. (\\<And>v2. S = {v2} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using card_Suc_eq[of S 0]"], ["proof (prove)\nusing this:\n  {n. adjacent v n} = insert v1 S\n  v1 \\<notin> S\n  card S = 1\n  (card S = Suc 0) =\n  (\\<exists>b B.\n      S = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}))\n\ngoal (1 subgoal):\n 1. (\\<And>v2. S = {v2} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  S = {v2}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2.\n                \\<lbrakk>{n. adjacent v n} = {v1, v2};\n                 v1 \\<noteq> v2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card {n. adjacent v n} = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"{n. adjacent v n}={v1,v2}\" and \"v1\\<noteq>v2\""], ["proof (prove)\nusing this:\n  S = {v2}\n\ngoal (1 subgoal):\n 1. {n. adjacent v n} = {v1, v2} &&& v1 \\<noteq> v2", "using \\<open>{n. adjacent v n} = insert v1 S\\<close> \\<open>v1 \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  S = {v2}\n  {n. adjacent v n} = insert v1 S\n  v1 \\<notin> S\n\ngoal (1 subgoal):\n 1. {n. adjacent v n} = {v1, v2} &&& v1 \\<noteq> v2", "by auto"], ["proof (state)\nthis:\n  {n. adjacent v n} = {v1, v2}\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2.\n                \\<lbrakk>{n. adjacent v n} = {v1, v2};\n                 v1 \\<noteq> v2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card {n. adjacent v n} = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n. adjacent v n} = {v1, v2}\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. thesis", "using that[of v1 v2]"], ["proof (prove)\nusing this:\n  {n. adjacent v n} = {v1, v2}\n  v1 \\<noteq> v2\n  \\<lbrakk>{n. adjacent v n} = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {n. adjacent v n} = {v1, v2}\n  v1 \\<noteq> v2\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "have \"adjacent v1 v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v1 v2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjacent v1 v2", "obtain n where \"adjacent v n\" \"adjacent v1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>adjacent v n; adjacent v1 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v v1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> V; v1 \\<in> V; v \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v n \\<and> adjacent v1 n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>adjacent v n; adjacent v1 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) adjacent_V(2) adjacent_sym insertI1 mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  adjacent v n\n  adjacent v1 n\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "hence \"n\\<in>{n. adjacent v n}\""], ["proof (prove)\nusing this:\n  adjacent v n\n  adjacent v1 n\n\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v n}", "by auto"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "moreover"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "have \"n\\<noteq>v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> v1", "by (metis \\<open>adjacent v1 n\\<close> adjacent_no_loop)"], ["proof (state)\nthis:\n  n \\<noteq> v1\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> {n. adjacent v n}\n  n \\<noteq> v1", "have \"n=v2\""], ["proof (prove)\nusing this:\n  n \\<in> {n. adjacent v n}\n  n \\<noteq> v1\n\ngoal (1 subgoal):\n 1. n = v2", "using v1v2"], ["proof (prove)\nusing this:\n  n \\<in> {n. adjacent v n}\n  n \\<noteq> v1\n  {n. adjacent v n} = {v1, v2}\n\ngoal (1 subgoal):\n 1. n = v2", "by auto"], ["proof (state)\nthis:\n  n = v2\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = v2\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "by (metis \\<open>adjacent v1 n\\<close>)"], ["proof (state)\nthis:\n  adjacent v1 v2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adjacent v1 v2\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "have v1v2_adj:\"\\<forall>x\\<in>V. x\\<in>{n. adjacent v1 n} \\<union> {n. adjacent v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>V. x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "assume \"x\\<in>V\""], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "have \"x=v \\<Longrightarrow> x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = v \\<Longrightarrow>\n    x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "by (metis Un_iff adjacent_sym insertI1 mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  x = v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "moreover"], ["proof (state)\nthis:\n  x = v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "have \"x\\<noteq>v \\<Longrightarrow> x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "assume \"x\\<noteq>v\""], ["proof (state)\nthis:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> v", "obtain y where \"adjacent v y\" \"adjacent x y\""], ["proof (prove)\nusing this:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>adjacent v y; adjacent x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v x]"], ["proof (prove)\nusing this:\n  x \\<noteq> v\n  \\<lbrakk>v \\<in> V; x \\<in> V; v \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v n \\<and> adjacent x n\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>adjacent v y; adjacent x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Collect_empty_eq \\<open>x \\<in> V\\<close> adjacent_V(1) all_not_in_conv insertCI v1v2)"], ["proof (state)\nthis:\n  adjacent v y\n  adjacent x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "hence \"y=v1 \\<or> y=v2\""], ["proof (prove)\nusing this:\n  adjacent v y\n  adjacent x y\n\ngoal (1 subgoal):\n 1. y = v1 \\<or> y = v2", "using v1v2"], ["proof (prove)\nusing this:\n  adjacent v y\n  adjacent x y\n  {n. adjacent v n} = {v1, v2}\n\ngoal (1 subgoal):\n 1. y = v1 \\<or> y = v2", "by auto"], ["proof (state)\nthis:\n  y = v1 \\<or> y = v2\n\ngoal (1 subgoal):\n 1. x \\<noteq> v \\<Longrightarrow>\n    x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "thus \"x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\""], ["proof (prove)\nusing this:\n  y = v1 \\<or> y = v2\n\ngoal (1 subgoal):\n 1. x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "using \\<open>adjacent x y\\<close>"], ["proof (prove)\nusing this:\n  y = v1 \\<or> y = v2\n  adjacent x y\n\ngoal (1 subgoal):\n 1. x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "by (metis UnI1 UnI2 adjacent_sym mem_Collect_eq)"], ["proof (state)\nthis:\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> V \\<Longrightarrow>\n       x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "ultimately"], ["proof (chain)\npicking this:\n  x = v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n  x \\<noteq> v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "show \"x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\""], ["proof (prove)\nusing this:\n  x = v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n  x \\<noteq> v \\<Longrightarrow>\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>V. x \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "have \"{n. adjacent v1 n}-{v2,v}={} \\<Longrightarrow> \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. adjacent v1 n} - {v2, v} = {} \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "proof (rule exI[of _ v2],rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v1 n} - {v2, v} = {}; n \\<in> V;\n        n \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> adjacent v2 n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v1 n} - {v2, v} = {}; n \\<in> V;\n        n \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> adjacent v2 n", "assume v1_adj:\"{n. adjacent v1 n} - {v2, v} = {}\" and \"n \\<in> V\" and \"n \\<noteq> v2\""], ["proof (state)\nthis:\n  {n. adjacent v1 n} - {v2, v} = {}\n  n \\<in> V\n  n \\<noteq> v2\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v1 n} - {v2, v} = {}; n \\<in> V;\n        n \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> adjacent v2 n", "have \"n\\<in>{n. adjacent v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v2 n}", "proof (cases \"n=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}\n 2. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}", "case True"], ["proof (state)\nthis:\n  n = v\n\ngoal (2 subgoals):\n 1. n = v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}\n 2. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v2 n}", "by (metis True adjacent_sym insertI1 insert_commute mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> v\n\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}", "have \"n\\<notin>{n. adjacent v1 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> {n. adjacent v1 n}", "by (metis DiffI False \\<open>n \\<noteq> v2\\<close> empty_iff insert_iff v1_adj)"], ["proof (state)\nthis:\n  n \\<notin> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v2 n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<notin> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v2 n}", "by (metis Un_iff \\<open>n \\<in> V\\<close> v1v2_adj)"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v2 n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v1 n} - {v2, v} = {}; n \\<in> V;\n        n \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> adjacent v2 n", "thus \"adjacent v2 n\""], ["proof (prove)\nusing this:\n  n \\<in> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. adjacent v2 n", "by auto"], ["proof (state)\nthis:\n  adjacent v2 n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {n. adjacent v1 n} - {v2, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "moreover"], ["proof (state)\nthis:\n  {n. adjacent v1 n} - {v2, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "have \"{n. adjacent v2 n}-{v1,v}={} \\<Longrightarrow> \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. adjacent v2 n} - {v1, v} = {} \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "proof (rule exI[of _ v1],rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v2 n} - {v1, v} = {}; n \\<in> V;\n        n \\<noteq> v1\\<rbrakk>\n       \\<Longrightarrow> adjacent v1 n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v2 n} - {v1, v} = {}; n \\<in> V;\n        n \\<noteq> v1\\<rbrakk>\n       \\<Longrightarrow> adjacent v1 n", "assume v2_adj:\"{n. adjacent v2 n} - {v1, v} = {}\" and \"n \\<in> V\" and \"n \\<noteq> v1\""], ["proof (state)\nthis:\n  {n. adjacent v2 n} - {v1, v} = {}\n  n \\<in> V\n  n \\<noteq> v1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v2 n} - {v1, v} = {}; n \\<in> V;\n        n \\<noteq> v1\\<rbrakk>\n       \\<Longrightarrow> adjacent v1 n", "have \"n\\<in>{n. adjacent v1 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v1 n}", "proof (cases \"n=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}\n 2. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}", "case True"], ["proof (state)\nthis:\n  n = v\n\ngoal (2 subgoals):\n 1. n = v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}\n 2. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v1 n}", "by (metis True adjacent_sym insertI1 mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> v\n\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}", "have \"n\\<notin>{n. adjacent v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> {n. adjacent v2 n}", "by (metis DiffI False \\<open>n \\<noteq> v1\\<close> empty_iff insert_iff v2_adj)"], ["proof (state)\nthis:\n  n \\<notin> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. n \\<noteq> v \\<Longrightarrow> n \\<in> {n. adjacent v1 n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<notin> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. n \\<in> {n. adjacent v1 n}", "by (metis Un_iff \\<open>n \\<in> V\\<close> v1v2_adj)"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v1 n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{n. adjacent v2 n} - {v1, v} = {}; n \\<in> V;\n        n \\<noteq> v1\\<rbrakk>\n       \\<Longrightarrow> adjacent v1 n", "thus \"adjacent v1 n\""], ["proof (prove)\nusing this:\n  n \\<in> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. adjacent v1 n", "by auto"], ["proof (state)\nthis:\n  adjacent v1 n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {n. adjacent v2 n} - {v1, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "moreover"], ["proof (state)\nthis:\n  {n. adjacent v2 n} - {v1, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "have \"{n. adjacent v1 n}-{v2,v}\\<noteq>{} \\<Longrightarrow> {n. adjacent v2 n}-{v1,v}\\<noteq>{} \\<Longrightarrow>False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"{n. adjacent v1 n} - {v2, v} \\<noteq> {}\"  \"{n. adjacent v2 n} - {v1, v} \\<noteq> {}\""], ["proof (state)\nthis:\n  {n. adjacent v1 n} - {v2, v} \\<noteq> {}\n  {n. adjacent v2 n} - {v1, v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {n. adjacent v1 n} - {v2, v} \\<noteq> {}\n  {n. adjacent v2 n} - {v1, v} \\<noteq> {}", "obtain a b where a:\"a\\<in>{n. adjacent v1 n} - {v2, v}\" \n          and b:\"b\\<in>{n. adjacent v2 n} - {v1, v}\""], ["proof (prove)\nusing this:\n  {n. adjacent v1 n} - {v2, v} \\<noteq> {}\n  {n. adjacent v2 n} - {v1, v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> {n. adjacent v1 n} - {v2, v};\n         b \\<in> {n. adjacent v2 n} - {v1, v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> {n. adjacent v1 n} - {v2, v}\n  b \\<in> {n. adjacent v2 n} - {v1, v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "have \"a=b \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "assume \"a=b\""], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "have \"adjacent v1 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v1 a", "using a"], ["proof (prove)\nusing this:\n  a \\<in> {n. adjacent v1 n} - {v2, v}\n\ngoal (1 subgoal):\n 1. adjacent v1 a", "by auto"], ["proof (state)\nthis:\n  adjacent v1 a\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 a\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "have \"adjacent a v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent a v2", "using b \\<open>a=b\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  b \\<in> {n. adjacent v2 n} - {v1, v}\n  a = b\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent a v2", "by auto"], ["proof (state)\nthis:\n  adjacent a v2\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent a v2\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "have \"a\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> v", "by (metis DiffD2 \\<open>a = b\\<close> b doubleton_eq_iff insertI1)"], ["proof (state)\nthis:\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "have \"adjacent v2 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v", "by (metis (full_types) adjacent_sym inf_sup_aci(5) insertI1 insert_is_Un mem_Collect_eq \n              v1v2)"], ["proof (state)\nthis:\n  adjacent v2 v\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "have \"adjacent v v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v v1", "by (metis (full_types) insertI1 mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  adjacent v v1\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v1 a\n  adjacent a v2\n  a \\<noteq> v\n  adjacent v2 v\n  adjacent v v1", "show False"], ["proof (prove)\nusing this:\n  adjacent v1 a\n  adjacent a v2\n  a \\<noteq> v\n  adjacent v2 v\n  adjacent v v1\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  adjacent v1 a\n  adjacent a v2\n  a \\<noteq> v\n  adjacent v2 v\n  adjacent v v1\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>v1\\<noteq>v2\\<close>"], ["proof (prove)\nusing this:\n  adjacent v1 a\n  adjacent a v2\n  a \\<noteq> v\n  adjacent v2 v\n  adjacent v v1\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "have \"a\\<noteq>b\\<Longrightarrow>False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "assume \"a\\<noteq>b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "have \"a\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> V", "using a"], ["proof (prove)\nusing this:\n  a \\<in> {n. adjacent v1 n} - {v2, v}\n\ngoal (1 subgoal):\n 1. a \\<in> V", "by (metis DiffD1 adjacent_V(2) mem_Collect_eq)"], ["proof (state)\nthis:\n  a \\<in> V\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a \\<in> V\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "have \"b\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> V", "using b"], ["proof (prove)\nusing this:\n  b \\<in> {n. adjacent v2 n} - {v1, v}\n\ngoal (1 subgoal):\n 1. b \\<in> V", "by (metis DiffD1 adjacent_V(2) mem_Collect_eq)"], ["proof (state)\nthis:\n  b \\<in> V\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  a \\<in> V\n  b \\<in> V", "obtain c where \"adjacent a c\" \"adjacent b c\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<in> V\n  b \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>adjacent a c; adjacent b c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of a b]"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<in> V\n  b \\<in> V\n  \\<lbrakk>a \\<in> V; b \\<in> V; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent a n \\<and> adjacent b n\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>adjacent a c; adjacent b c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adjacent a c\n  adjacent b c\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "hence \"c\\<in>{n. adjacent v1 n} \\<union> {n. adjacent v2 n}\""], ["proof (prove)\nusing this:\n  adjacent a c\n  adjacent b c\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}", "by (metis (full_types) adjacent_V(2) v1v2_adj)"], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "have \"c\\<in>{n. adjacent v1 n} \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "assume \"c\\<in>{n. adjacent v1 n}\""], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "hence \"adjacent v1 c\""], ["proof (prove)\nusing this:\n  c \\<in> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. adjacent v1 c", "by auto"], ["proof (state)\nthis:\n  adjacent v1 c\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 c\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "have \"adjacent c b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent c b", "by (metis \\<open>adjacent b c\\<close> adjacent_sym)"], ["proof (state)\nthis:\n  adjacent c b\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent c b\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "have \"adjacent b v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent b v2", "by (metis (full_types) Diff_iff adjacent_sym b mem_Collect_eq)"], ["proof (state)\nthis:\n  adjacent b v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent b v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "have \"adjacent v2 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v1", "by (metis \\<open>adjacent v1 v2\\<close> adjacent_sym)"], ["proof (state)\nthis:\n  adjacent v2 v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "have \"c\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> v2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "assume \"\\<not> c \\<noteq> v2\""], ["proof (state)\nthis:\n  \\<not> c \\<noteq> v2\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "hence \"c=v2\""], ["proof (prove)\nusing this:\n  \\<not> c \\<noteq> v2\n\ngoal (1 subgoal):\n 1. c = v2", "by auto"], ["proof (state)\nthis:\n  c = v2\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "hence \"adjacent v2 a\""], ["proof (prove)\nusing this:\n  c = v2\n\ngoal (1 subgoal):\n 1. adjacent v2 a", "by (metis \\<open>adjacent a c\\<close> adjacent_sym)"], ["proof (state)\nthis:\n  adjacent v2 a\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 a\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "have \"adjacent v2 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v", "by (metis adjacent_sym insert_iff mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  adjacent v2 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "have \"adjacent v1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v1 v", "using adjacent_sym v1v2"], ["proof (prove)\nusing this:\n  adjacent ?v ?v' = adjacent ?v' ?v\n  {n. adjacent v n} = {v1, v2}\n\ngoal (1 subgoal):\n 1. adjacent v1 v", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "have \"adjacent v1 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v1 a", "by (metis (full_types) Diff_iff a mem_Collect_eq)"], ["proof (state)\nthis:\n  adjacent v1 a\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v2 a\n  adjacent v2 v\n  adjacent v1 v\n  adjacent v1 a", "have \"a=v\""], ["proof (prove)\nusing this:\n  adjacent v2 a\n  adjacent v2 v\n  adjacent v1 v\n  adjacent v1 a\n\ngoal (1 subgoal):\n 1. a = v", "using friend_assm[of v1 v2]"], ["proof (prove)\nusing this:\n  adjacent v2 a\n  adjacent v2 v\n  adjacent v1 v\n  adjacent v1 a\n  \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v1 \\<noteq> v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v1 n \\<and> adjacent v2 n\n\ngoal (1 subgoal):\n 1. a = v", "by (metis \\<open>v1 \\<noteq> v2\\<close> adjacent_V(1))"], ["proof (state)\nthis:\n  a = v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a = v\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  a = v\n  a \\<in> {n. adjacent v1 n} - {v2, v}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c \\<noteq> v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<noteq> v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "have \"b\\<noteq>v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> v1", "by (metis DiffD2 b insertI1)"], ["proof (state)\nthis:\n  b \\<noteq> v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v1 c\n  adjacent c b\n  adjacent b v2\n  adjacent v2 v1\n  c \\<noteq> v2\n  b \\<noteq> v1", "show False"], ["proof (prove)\nusing this:\n  adjacent v1 c\n  adjacent c b\n  adjacent b v2\n  adjacent v2 v1\n  c \\<noteq> v2\n  b \\<noteq> v1\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  adjacent v1 c\n  adjacent c b\n  adjacent b v2\n  adjacent v2 v1\n  c \\<noteq> v2\n  b \\<noteq> v1\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "have \"c\\<in>{n. adjacent v2 n} \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "assume \"c\\<in>{n. adjacent v2 n}\""], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "hence \"adjacent c v2\""], ["proof (prove)\nusing this:\n  c \\<in> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. adjacent c v2", "by (metis adjacent_sym mem_Collect_eq)"], ["proof (state)\nthis:\n  adjacent c v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent c v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "have \"adjacent a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent a c", "using \\<open>adjacent a c\\<close>"], ["proof (prove)\nusing this:\n  adjacent a c\n\ngoal (1 subgoal):\n 1. adjacent a c", "."], ["proof (state)\nthis:\n  adjacent a c\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent a c\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "have \"adjacent v1 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v1 a", "by (metis (full_types) Diff_iff a mem_Collect_eq)"], ["proof (state)\nthis:\n  adjacent v1 a\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 a\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "have \"adjacent v2 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v1", "by (metis \\<open>adjacent v1 v2\\<close> adjacent_sym)"], ["proof (state)\nthis:\n  adjacent v2 v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "have \"c\\<noteq>v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> v1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "assume \"\\<not> c \\<noteq> v1\""], ["proof (state)\nthis:\n  \\<not> c \\<noteq> v1\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "hence \"c=v1\""], ["proof (prove)\nusing this:\n  \\<not> c \\<noteq> v1\n\ngoal (1 subgoal):\n 1. c = v1", "by auto"], ["proof (state)\nthis:\n  c = v1\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "hence \"adjacent v1 b\""], ["proof (prove)\nusing this:\n  c = v1\n\ngoal (1 subgoal):\n 1. adjacent v1 b", "by (metis \\<open>adjacent b c\\<close> adjacent_sym)"], ["proof (state)\nthis:\n  adjacent v1 b\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 b\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "have \"adjacent v2 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v", "by (metis adjacent_sym insert_iff mem_Collect_eq v1v2)"], ["proof (state)\nthis:\n  adjacent v2 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "have \"adjacent v1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v1 v", "using adjacent_sym v1v2"], ["proof (prove)\nusing this:\n  adjacent ?v ?v' = adjacent ?v' ?v\n  {n. adjacent v n} = {v1, v2}\n\ngoal (1 subgoal):\n 1. adjacent v1 v", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "have \"adjacent v2 b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 b", "by (metis Diff_iff b mem_Collect_eq)"], ["proof (state)\nthis:\n  adjacent v2 b\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v1 b\n  adjacent v2 v\n  adjacent v1 v\n  adjacent v2 b", "have \"b=v\""], ["proof (prove)\nusing this:\n  adjacent v1 b\n  adjacent v2 v\n  adjacent v1 v\n  adjacent v2 b\n\ngoal (1 subgoal):\n 1. b = v", "using friend_assm[of v1 v2]"], ["proof (prove)\nusing this:\n  adjacent v1 b\n  adjacent v2 v\n  adjacent v1 v\n  adjacent v2 b\n  \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v1 \\<noteq> v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v1 n \\<and> adjacent v2 n\n\ngoal (1 subgoal):\n 1. b = v", "by (metis \\<open>v1 \\<noteq> v2\\<close> adjacent_V(1))"], ["proof (state)\nthis:\n  b = v\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> v1 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  b = v\n\ngoal (1 subgoal):\n 1. False", "using b"], ["proof (prove)\nusing this:\n  b = v\n  b \\<in> {n. adjacent v2 n} - {v1, v}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c \\<noteq> v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<noteq> v1\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "have \"a\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> v2", "by (metis DiffD2 a insertI1)"], ["proof (state)\nthis:\n  a \\<noteq> v2\n\ngoal (1 subgoal):\n 1. c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent c v2\n  adjacent a c\n  adjacent v1 a\n  adjacent v2 v1\n  c \\<noteq> v1\n  a \\<noteq> v2", "show False"], ["proof (prove)\nusing this:\n  adjacent c v2\n  adjacent a c\n  adjacent v1 a\n  adjacent v2 v1\n  c \\<noteq> v1\n  a \\<noteq> v2\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  adjacent c v2\n  adjacent a c\n  adjacent v1 a\n  adjacent v2 v1\n  c \\<noteq> v1\n  a \\<noteq> v2\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  c \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n  c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False\n  c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  c \\<in> {n. adjacent v1 n} \\<union> {n. adjacent v2 n}\n  c \\<in> {n. adjacent v1 n} \\<Longrightarrow> False\n  c \\<in> {n. adjacent v2 n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<noteq> b \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n     {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a = b \\<Longrightarrow> False\n  a \\<noteq> b \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  a = b \\<Longrightarrow> False\n  a \\<noteq> b \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n   {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>V. degree v G = 2 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n 2. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "ultimately"], ["proof (chain)\npicking this:\n  {n. adjacent v1 n} - {v2, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  {n. adjacent v2 n} - {v1, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n   {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> False", "show \"\\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\""], ["proof (prove)\nusing this:\n  {n. adjacent v1 n} - {v2, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  {n. adjacent v2 n} - {v1, v} = {} \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  \\<lbrakk>{n. adjacent v1 n} - {v2, v} \\<noteq> {};\n   {n. adjacent v2 n} - {v1, v} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "by auto"], ["proof (state)\nthis:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "assume \"\\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\""], ["proof (state)\nthis:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "obtain v where v:\"\\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\""], ["proof (prove)\nusing this:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>n\\<in>V.\n           n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "obtain v1 where \"v1\\<in>V\" \"v1\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1.\n        \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"v\\<in>V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  v \\<notin> V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"V\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<noteq> {}", "using \\<open>2\\<le>card V\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. V \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  V \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  V \\<noteq> {}", "obtain v1 where \"v1\\<in>V\""], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v1. v1 \\<in> V \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  v1 \\<in> V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<in> V\n\ngoal (1 subgoal):\n 1. thesis", "using False that[of v1]"], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v \\<notin> V\n  \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  v \\<in> V", "obtain S where  \"V = insert v S\" \"v \\<notin> S\""], ["proof (prove)\nusing this:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>V = insert v S; v \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  mk_disjoint_insert[OF True]"], ["proof (prove)\nusing this:\n  v \\<in> V\n  \\<exists>B. V = insert v B \\<and> v \\<notin> B\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>V = insert v S; v \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V = insert v S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  V = insert v S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "using \\<open>2\\<le>card V\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. finite V", "by (metis add_leE card.infinite not_one_le_zero numeral_Bit0 numeral_One)"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  V = insert v S\n  v \\<notin> S\n  finite V", "have \"1\\<le>card S\""], ["proof (prove)\nusing this:\n  V = insert v S\n  v \\<notin> S\n  finite V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card S", "using \\<open>2\\<le>card V\\<close>  card.insert[of S v]  finite_insert[of v S]"], ["proof (prove)\nusing this:\n  V = insert v S\n  v \\<notin> S\n  finite V\n  2 \\<le> card V\n  \\<lbrakk>finite S; v \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> card (insert v S) = Suc (card S)\n  finite (insert v S) = finite S\n\ngoal (1 subgoal):\n 1. 1 \\<le> card S", "by auto"], ["proof (state)\nthis:\n  1 \\<le> card S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"S\\<noteq>{}\""], ["proof (prove)\nusing this:\n  1 \\<le> card S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  S \\<noteq> {}", "obtain v1 where \"v1\\<in>S\""], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v1. v1 \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  v1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"v1\\<noteq>v\""], ["proof (prove)\nusing this:\n  v1 \\<in> S\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v", "using \\<open>v\\<notin>S\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<in> S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1.\n                \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. thesis", "using that[of v1] \\<open>v1\\<in>S\\<close> \\<open>V=insert v S\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n  \\<lbrakk>v1 \\<in> V; v1 \\<noteq> v\\<rbrakk> \\<Longrightarrow> thesis\n  v1 \\<in> S\n  V = insert v S\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v1 \\<in> V\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "hence \"v\\<in>V\""], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<in> V", "using v"], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v1 \\<noteq> v\n  \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. v \\<in> V", "by (metis adjacent_V(1))"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "then"], ["proof (chain)\npicking this:\n  v \\<in> V", "obtain v2 where \"adjacent v1 v2\" \"adjacent v v2\""], ["proof (prove)\nusing this:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v2.\n        \\<lbrakk>adjacent v1 v2; adjacent v v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v v1]"], ["proof (prove)\nusing this:\n  v \\<in> V\n  \\<lbrakk>v \\<in> V; v1 \\<in> V; v \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v n \\<and> adjacent v1 n\n\ngoal (1 subgoal):\n 1. (\\<And>v2.\n        \\<lbrakk>adjacent v1 v2; adjacent v v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>v1 \\<in> V\\<close> \\<open>v1 \\<noteq> v\\<close>)"], ["proof (state)\nthis:\n  adjacent v1 v2\n  adjacent v v2\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "have \"degree v1 G\\<noteq>2 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "assume \"degree v1 G\\<noteq>2\""], ["proof (state)\nthis:\n  degree v1 G \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "hence \"card {n. adjacent v1 n}\\<noteq>2\""], ["proof (prove)\nusing this:\n  degree v1 G \\<noteq> 2\n\ngoal (1 subgoal):\n 1. card {n. adjacent v1 n} \\<noteq> 2", "by (metis assms(2) degree_adjacent)"], ["proof (state)\nthis:\n  card {n. adjacent v1 n} \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"{v,v2} \\<subseteq> {n. adjacent v1 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v, v2} \\<subseteq> {n. adjacent v1 n}", "by (metis \\<open> adjacent v1 v2 \\<close> \\<open> v1 \\<in> V \\<close> \\<open> v1 \\<noteq> v \\<close> adjacent_sym bot_least insert_subset \n          mem_Collect_eq v)"], ["proof (state)\nthis:\n  {v, v2} \\<subseteq> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {v, v2} \\<subseteq> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"v\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v2", "using \\<open>adjacent v v2\\<close> adjacent_no_loop"], ["proof (prove)\nusing this:\n  adjacent v v2\n  adjacent ?v ?v' \\<Longrightarrow> ?v \\<noteq> ?v'\n\ngoal (1 subgoal):\n 1. v \\<noteq> v2", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> v2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "hence \"card {v,v2} = 2\""], ["proof (prove)\nusing this:\n  v \\<noteq> v2\n\ngoal (1 subgoal):\n 1. card {v, v2} = 2", "by auto"], ["proof (state)\nthis:\n  card {v, v2} = 2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {v, v2} \\<subseteq> {n. adjacent v1 n}\n  card {v, v2} = 2", "have \"card {n. adjacent v1 n} \\<ge>2\""], ["proof (prove)\nusing this:\n  {v, v2} \\<subseteq> {n. adjacent v1 n}\n  card {v, v2} = 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> card {n. adjacent v1 n}", "using adjacent_finite[OF \\<open>finite E\\<close>, of v1]"], ["proof (prove)\nusing this:\n  {v, v2} \\<subseteq> {n. adjacent v1 n}\n  card {v, v2} = 2\n  finite {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card {n. adjacent v1 n}", "by (metis card_mono)"], ["proof (state)\nthis:\n  2 \\<le> card {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "hence \"card {n. adjacent v1 n} \\<ge>3\""], ["proof (prove)\nusing this:\n  2 \\<le> card {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. 3 \\<le> card {n. adjacent v1 n}", "using \\<open>card {n. adjacent v1 n}\\<noteq>2\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> card {n. adjacent v1 n}\n  card {n. adjacent v1 n} \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 3 \\<le> card {n. adjacent v1 n}", "by auto"], ["proof (state)\nthis:\n  3 \\<le> card {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  3 \\<le> card {n. adjacent v1 n}", "obtain v3 where \"v3\\<in>{n. adjacent v1 n}\" and \"v3\\<notin>{v,v2}\""], ["proof (prove)\nusing this:\n  3 \\<le> card {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. (\\<And>v3.\n        \\<lbrakk>v3 \\<in> {n. adjacent v1 n}; v3 \\<notin> {v, v2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>{v,v2} \\<subseteq> {n. adjacent v1 n}\\<close> \\<open>card {v, v2} = 2\\<close>"], ["proof (prove)\nusing this:\n  3 \\<le> card {n. adjacent v1 n}\n  {v, v2} \\<subseteq> {n. adjacent v1 n}\n  card {v, v2} = 2\n\ngoal (1 subgoal):\n 1. (\\<And>v3.\n        \\<lbrakk>v3 \\<in> {n. adjacent v1 n}; v3 \\<notin> {v, v2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>card {n. adjacent v1 n} \\<noteq> 2\\<close> subsetI subset_antisym)"], ["proof (state)\nthis:\n  v3 \\<in> {n. adjacent v1 n}\n  v3 \\<notin> {v, v2}\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "hence \"adjacent v1 v3\""], ["proof (prove)\nusing this:\n  v3 \\<in> {n. adjacent v1 n}\n  v3 \\<notin> {v, v2}\n\ngoal (1 subgoal):\n 1. adjacent v1 v3", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v3\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 v3\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"adjacent v3 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v3 v", "using v"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. adjacent v3 v", "by (metis \\<open>v3 \\<notin> {v, v2}\\<close> adjacent_V(2) adjacent_sym calculation insertCI)"], ["proof (state)\nthis:\n  adjacent v3 v\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v3 v\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"adjacent v v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v v2", "using \\<open>adjacent v v2\\<close>"], ["proof (prove)\nusing this:\n  adjacent v v2\n\ngoal (1 subgoal):\n 1. adjacent v v2", "."], ["proof (state)\nthis:\n  adjacent v v2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v v2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"adjacent v2 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v1", "using \\<open>adjacent v1 v2\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent v1 v2\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent v2 v1", "by auto"], ["proof (state)\nthis:\n  adjacent v2 v1\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v1\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"v1\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v", "using \\<open>v1 \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v", "."], ["proof (state)\nthis:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "have \"v3\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v3 \\<noteq> v2", "by (metis \\<open>v3 \\<notin> {v, v2}\\<close> insert_subset subset_insertI)"], ["proof (state)\nthis:\n  v3 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. degree v1 G \\<noteq> 2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v1 v3\n  adjacent v3 v\n  adjacent v v2\n  adjacent v2 v1\n  v1 \\<noteq> v\n  v3 \\<noteq> v2", "show False"], ["proof (prove)\nusing this:\n  adjacent v1 v3\n  adjacent v3 v\n  adjacent v v2\n  adjacent v2 v1\n  v1 \\<noteq> v\n  v3 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  adjacent v1 v3\n  adjacent v3 v\n  adjacent v v2\n  adjacent v2 v1\n  v1 \\<noteq> v\n  v3 \\<noteq> v2\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree v1 G \\<noteq> 2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V.\n          n \\<noteq> v \\<longrightarrow> adjacent v n \\<Longrightarrow>\n    \\<exists>v\\<in>V. degree v G = 2", "thus \"\\<exists>v\\<in>V. degree v G = 2\""], ["proof (prove)\nusing this:\n  degree v1 G \\<noteq> 2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. degree v G = 2", "using \\<open>v1\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  degree v1 G \\<noteq> 2 \\<Longrightarrow> False\n  v1 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. degree v G = 2", "by auto"], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. degree v G = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) regular:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\" \n      and \"finite E\" and \"finite V\" and \"\\<not>(\\<exists>v\\<in>V. degree v G = 2)\"\n  shows \"\\<exists>k. \\<forall>v\\<in>V. degree v G = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "fix v u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "assume \"non_adj v u\""], ["proof (state)\nthis:\n  non_adj v u\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "obtain v_adj where v_adj:\"v_adj={n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v_adj.\n        v_adj = {n. adjacent v n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v_adj = {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "obtain u_adj where u_adj:\"u_adj={n. adjacent u n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u_adj.\n        u_adj = {n. adjacent u n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u_adj = {n. adjacent u n}\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "obtain f where f:\"f = (\\<lambda>n. (SOME v'. n\\<in>V \\<longrightarrow>n\\<noteq>u\\<longrightarrow>adjacent n v' \\<and> adjacent u v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f =\n        (\\<lambda>n.\n            SOME v'.\n               n \\<in> V \\<longrightarrow>\n               n \\<noteq> u \\<longrightarrow>\n               adjacent n v' \\<and> adjacent u v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f =\n  (\\<lambda>n.\n      SOME v'.\n         n \\<in> V \\<longrightarrow>\n         n \\<noteq> u \\<longrightarrow> adjacent n v' \\<and> adjacent u v')\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"\\<And>n.  n\\<in>V \\<longrightarrow> n\\<noteq>u \\<longrightarrow> (\\<exists>v'. adjacent n v' \\<and> adjacent u v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> V \\<longrightarrow>\n       n \\<noteq> u \\<longrightarrow>\n       (\\<exists>v'. adjacent n v' \\<and> adjacent u v')", "proof (rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent u v'", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent u v'", "assume  \"n \\<in> V\" \"n \\<noteq> u\""], ["proof (state)\nthis:\n  n \\<in> V\n  n \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent u v'", "hence \"\\<exists>!v'. adjacent n v' \\<and> adjacent u v'\""], ["proof (prove)\nusing this:\n  n \\<in> V\n  n \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<exists>!v'. adjacent n v' \\<and> adjacent u v'", "using friend_assm[of n u] \\<open>non_adj v u\\<close>"], ["proof (prove)\nusing this:\n  n \\<in> V\n  n \\<noteq> u\n  \\<lbrakk>n \\<in> V; u \\<in> V; n \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!na. adjacent n na \\<and> adjacent u na\n  non_adj v u\n\ngoal (1 subgoal):\n 1. \\<exists>!v'. adjacent n v' \\<and> adjacent u v'", "unfolding non_adj_def"], ["proof (prove)\nusing this:\n  n \\<in> V\n  n \\<noteq> u\n  \\<lbrakk>n \\<in> V; u \\<in> V; n \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!na. adjacent n na \\<and> adjacent u na\n  v \\<in> V \\<and> u \\<in> V \\<and> v \\<noteq> u \\<and> \\<not> adjacent v u\n\ngoal (1 subgoal):\n 1. \\<exists>!v'. adjacent n v' \\<and> adjacent u v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>!v'. adjacent n v' \\<and> adjacent u v'\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> V; n \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. adjacent n v' \\<and> adjacent u v'", "thus \"\\<exists>v'. adjacent n v' \\<and> adjacent u v'\""], ["proof (prove)\nusing this:\n  \\<exists>!v'. adjacent n v' \\<and> adjacent u v'\n\ngoal (1 subgoal):\n 1. \\<exists>v'. adjacent n v' \\<and> adjacent u v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>v'. adjacent n v' \\<and> adjacent u v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n \\<in> V \\<longrightarrow>\n  ?n \\<noteq> u \\<longrightarrow>\n  (\\<exists>v'. adjacent ?n v' \\<and> adjacent u v')\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "hence f_ex:\"\\<And>n.  (\\<exists>v'. n\\<in>V \\<longrightarrow> n\\<noteq>u \\<longrightarrow>  adjacent n v' \\<and> adjacent u v')\""], ["proof (prove)\nusing this:\n  ?n \\<in> V \\<longrightarrow>\n  ?n \\<noteq> u \\<longrightarrow>\n  (\\<exists>v'. adjacent ?n v' \\<and> adjacent u v')\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>v'.\n          n \\<in> V \\<longrightarrow>\n          n \\<noteq> u \\<longrightarrow> adjacent n v' \\<and> adjacent u v'", "by auto"], ["proof (state)\nthis:\n  \\<exists>v'.\n     ?n \\<in> V \\<longrightarrow>\n     ?n \\<noteq> u \\<longrightarrow> adjacent ?n v' \\<and> adjacent u v'\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "obtain v_adj_u where v_adj_u:\"v_adj_u= f ` v_adj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v_adj_u.\n        v_adj_u = f ` v_adj \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v_adj_u = f ` v_adj\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"finite u_adj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite u_adj", "using u_adj adjacent_finite[OF \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  u_adj = {n. adjacent u n}\n  finite {n. adjacent ?v n}\n\ngoal (1 subgoal):\n 1. finite u_adj", "by auto"], ["proof (state)\nthis:\n  finite u_adj\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"finite v_adj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite v_adj", "using v_adj adjacent_finite[OF \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  v_adj = {n. adjacent v n}\n  finite {n. adjacent ?v n}\n\ngoal (1 subgoal):\n 1. finite v_adj", "by auto"], ["proof (state)\nthis:\n  finite v_adj\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "hence \"finite v_adj_u\""], ["proof (prove)\nusing this:\n  finite v_adj\n\ngoal (1 subgoal):\n 1. finite v_adj_u", "using v_adj_u adjacent_finite[OF \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  finite v_adj\n  v_adj_u = f ` v_adj\n  finite {n. adjacent ?v n}\n\ngoal (1 subgoal):\n 1. finite v_adj_u", "by auto"], ["proof (state)\nthis:\n  finite v_adj_u\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"inj_on f v_adj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f v_adj", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>v_adj.\n       \\<forall>y\\<in>v_adj. f x = f y \\<longrightarrow> x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>x\\<in>v_adj. \\<forall>y\\<in>v_adj. f x = f y \\<longrightarrow> x = y)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>v_adj.\n             \\<forall>y\\<in>v_adj. f x = f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>v_adj.\n             \\<forall>y\\<in>v_adj. f x = f y \\<longrightarrow> x = y)", "obtain x y where \"x\\<in>v_adj\" \"y\\<in>v_adj\" \"f x=f y\" \"x\\<noteq>y\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>v_adj.\n             \\<forall>y\\<in>v_adj. f x = f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> v_adj; y \\<in> v_adj; f x = f y;\n         x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> v_adj\n  y \\<in> v_adj\n  f x = f y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "have \"x\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V", "by (metis \\<open>x \\<in> v_adj\\<close> adjacent_V(2) mem_Collect_eq v_adj)"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "have \"x\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> u", "by (metis \\<open>non_adj v u\\<close> \\<open>x \\<in> v_adj\\<close> mem_Collect_eq non_adj_def v_adj)"], ["proof (state)\nthis:\n  x \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> V\n  x \\<noteq> u", "have \"adjacent (f x) u\" and \"adjacent x (f x)\""], ["proof (prove)\nusing this:\n  x \\<in> V\n  x \\<noteq> u\n\ngoal (1 subgoal):\n 1. adjacent (f x) u &&& adjacent x (f x)", "using someI_ex[OF f_ex[of x]] adjacent_sym"], ["proof (prove)\nusing this:\n  x \\<in> V\n  x \\<noteq> u\n  x \\<in> V \\<longrightarrow>\n  x \\<noteq> u \\<longrightarrow>\n  adjacent x\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> u \\<longrightarrow>\n       adjacent x xa \\<and> adjacent u xa) \\<and>\n  adjacent u\n   (SOME xa.\n       x \\<in> V \\<longrightarrow>\n       x \\<noteq> u \\<longrightarrow> adjacent x xa \\<and> adjacent u xa)\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent (f x) u &&& adjacent x (f x)", "by (metis f)+"], ["proof (state)\nthis:\n  adjacent (f x) u\n  adjacent x (f x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "hence \"f x \\<noteq> v\""], ["proof (prove)\nusing this:\n  adjacent (f x) u\n  adjacent x (f x)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> v", "by (metis \\<open>non_adj v u\\<close> non_adj_def)"], ["proof (state)\nthis:\n  f x \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "have \"y\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> V", "by (metis \\<open>y \\<in> v_adj\\<close> adjacent_V(2) mem_Collect_eq v_adj)"], ["proof (state)\nthis:\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "have \"y\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> u", "by (metis \\<open>non_adj v u\\<close> \\<open>y \\<in> v_adj\\<close> mem_Collect_eq non_adj_def v_adj)"], ["proof (state)\nthis:\n  y \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> V\n  y \\<noteq> u", "have \"adjacent y (f y)\""], ["proof (prove)\nusing this:\n  y \\<in> V\n  y \\<noteq> u\n\ngoal (1 subgoal):\n 1. adjacent y (f y)", "using someI_ex[OF f_ex[of y]]"], ["proof (prove)\nusing this:\n  y \\<in> V\n  y \\<noteq> u\n  y \\<in> V \\<longrightarrow>\n  y \\<noteq> u \\<longrightarrow>\n  adjacent y\n   (SOME x.\n       y \\<in> V \\<longrightarrow>\n       y \\<noteq> u \\<longrightarrow>\n       adjacent y x \\<and> adjacent u x) \\<and>\n  adjacent u\n   (SOME x.\n       y \\<in> V \\<longrightarrow>\n       y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x)\n\ngoal (1 subgoal):\n 1. adjacent y (f y)", "by (metis f)"], ["proof (state)\nthis:\n  adjacent y (f y)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "hence \" x \\<noteq> y \\<and> v \\<noteq> f x \\<and> adjacent v x \\<and> adjacent x (f x) \\<and> adjacent (f x) y \n            \\<and> adjacent y v\""], ["proof (prove)\nusing this:\n  adjacent y (f y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<and>\n    v \\<noteq> f x \\<and>\n    adjacent v x \\<and>\n    adjacent x (f x) \\<and> adjacent (f x) y \\<and> adjacent y v", "using \\<open>x\\<in>v_adj\\<close> \\<open>y\\<in>v_adj\\<close> \\<open>f x=f y\\<close> \\<open>x\\<noteq>y\\<close> \\<open>adjacent x (f x)\\<close> v_adj adjacent_sym \\<open>f x \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  adjacent y (f y)\n  x \\<in> v_adj\n  y \\<in> v_adj\n  f x = f y\n  x \\<noteq> y\n  adjacent x (f x)\n  v_adj = {n. adjacent v n}\n  adjacent ?v ?v' = adjacent ?v' ?v\n  f x \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<and>\n    v \\<noteq> f x \\<and>\n    adjacent v x \\<and>\n    adjacent x (f x) \\<and> adjacent (f x) y \\<and> adjacent y v", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y \\<and>\n  v \\<noteq> f x \\<and>\n  adjacent v x \\<and>\n  adjacent x (f x) \\<and> adjacent (f x) y \\<and> adjacent y v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>v_adj.\n               \\<forall>y\\<in>v_adj.\n                  f x = f y \\<longrightarrow> x = y) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  x \\<noteq> y \\<and>\n  v \\<noteq> f x \\<and>\n  adjacent v x \\<and>\n  adjacent x (f x) \\<and> adjacent (f x) y \\<and> adjacent y v\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  x \\<noteq> y \\<and>\n  v \\<noteq> f x \\<and>\n  adjacent v x \\<and>\n  adjacent x (f x) \\<and> adjacent (f x) y \\<and> adjacent y v\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f v_adj\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "then"], ["proof (chain)\npicking this:\n  inj_on f v_adj", "have \"card v_adj =card v_adj_u\""], ["proof (prove)\nusing this:\n  inj_on f v_adj\n\ngoal (1 subgoal):\n 1. card v_adj = card v_adj_u", "by (metis card_image v_adj_u)"], ["proof (state)\nthis:\n  card v_adj = card v_adj_u\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  card v_adj = card v_adj_u\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"v_adj_u \\<subseteq> u_adj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v_adj_u \\<subseteq> u_adj", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "assume \"x\\<in>v_adj_u\""], ["proof (state)\nthis:\n  x \\<in> v_adj_u\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "then"], ["proof (chain)\npicking this:\n  x \\<in> v_adj_u", "obtain y where \"y\\<in>v_adj\" \n            and \"x = (SOME v'. y \\<in> V \\<longrightarrow> y \\<noteq> u \\<longrightarrow> adjacent y v' \\<and> adjacent u v')\""], ["proof (prove)\nusing this:\n  x \\<in> v_adj_u\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> v_adj;\n         x =\n         (SOME v'.\n             y \\<in> V \\<longrightarrow>\n             y \\<noteq> u \\<longrightarrow>\n             adjacent y v' \\<and> adjacent u v')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f image_def v_adj_u"], ["proof (prove)\nusing this:\n  x \\<in> v_adj_u\n  f =\n  (\\<lambda>n.\n      SOME v'.\n         n \\<in> V \\<longrightarrow>\n         n \\<noteq> u \\<longrightarrow> adjacent n v' \\<and> adjacent u v')\n  ?f ` ?A = {y. \\<exists>x\\<in>?A. y = ?f x}\n  v_adj_u = f ` v_adj\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> v_adj;\n         x =\n         (SOME v'.\n             y \\<in> V \\<longrightarrow>\n             y \\<noteq> u \\<longrightarrow>\n             adjacent y v' \\<and> adjacent u v')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> v_adj\n  x =\n  (SOME v'.\n      y \\<in> V \\<longrightarrow>\n      y \\<noteq> u \\<longrightarrow> adjacent y v' \\<and> adjacent u v')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "hence \"y \\<in> V \\<longrightarrow> y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x\""], ["proof (prove)\nusing this:\n  y \\<in> v_adj\n  x =\n  (SOME v'.\n      y \\<in> V \\<longrightarrow>\n      y \\<noteq> u \\<longrightarrow> adjacent y v' \\<and> adjacent u v')\n\ngoal (1 subgoal):\n 1. y \\<in> V \\<longrightarrow>\n    y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x", "using someI_ex[OF f_ex[of y]]"], ["proof (prove)\nusing this:\n  y \\<in> v_adj\n  x =\n  (SOME v'.\n      y \\<in> V \\<longrightarrow>\n      y \\<noteq> u \\<longrightarrow> adjacent y v' \\<and> adjacent u v')\n  y \\<in> V \\<longrightarrow>\n  y \\<noteq> u \\<longrightarrow>\n  adjacent y\n   (SOME x.\n       y \\<in> V \\<longrightarrow>\n       y \\<noteq> u \\<longrightarrow>\n       adjacent y x \\<and> adjacent u x) \\<and>\n  adjacent u\n   (SOME x.\n       y \\<in> V \\<longrightarrow>\n       y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x)\n\ngoal (1 subgoal):\n 1. y \\<in> V \\<longrightarrow>\n    y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x", "by auto"], ["proof (state)\nthis:\n  y \\<in> V \\<longrightarrow>\n  y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "moreover"], ["proof (state)\nthis:\n  y \\<in> V \\<longrightarrow>\n  y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "have \"y\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> V", "by (metis \\<open>y \\<in> v_adj\\<close> adjacent_V(2) mem_Collect_eq v_adj)"], ["proof (state)\nthis:\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "moreover"], ["proof (state)\nthis:\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "have \"y\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> u", "by (metis \\<open>non_adj v u\\<close> \\<open>y \\<in> v_adj\\<close> mem_Collect_eq non_adj_def v_adj)"], ["proof (state)\nthis:\n  y \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> V \\<longrightarrow>\n  y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x\n  y \\<in> V\n  y \\<noteq> u", "have \"adjacent u x\""], ["proof (prove)\nusing this:\n  y \\<in> V \\<longrightarrow>\n  y \\<noteq> u \\<longrightarrow> adjacent y x \\<and> adjacent u x\n  y \\<in> V\n  y \\<noteq> u\n\ngoal (1 subgoal):\n 1. adjacent u x", "by auto"], ["proof (state)\nthis:\n  adjacent u x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> v_adj_u \\<Longrightarrow> x \\<in> u_adj", "thus \"x\\<in>u_adj\""], ["proof (prove)\nusing this:\n  adjacent u x\n\ngoal (1 subgoal):\n 1. x \\<in> u_adj", "unfolding u_adj"], ["proof (prove)\nusing this:\n  adjacent u x\n\ngoal (1 subgoal):\n 1. x \\<in> Collect (adjacent u)", "by auto"], ["proof (state)\nthis:\n  x \\<in> u_adj\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v_adj_u \\<subseteq> u_adj\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  v_adj_u \\<subseteq> u_adj\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card v_adj=degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card v_adj = degree v G", "using degree_adjacent[OF \\<open>finite E\\<close>, of v] v_adj"], ["proof (prove)\nusing this:\n  degree v G = card {n. adjacent v n}\n  v_adj = {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. card v_adj = degree v G", "by auto"], ["proof (state)\nthis:\n  card v_adj = degree v G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  card v_adj = degree v G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card u_adj=degree u G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card u_adj = degree u G", "using degree_adjacent[OF \\<open>finite E\\<close>, of u] u_adj"], ["proof (prove)\nusing this:\n  degree u G = card {n. adjacent u n}\n  u_adj = {n. adjacent u n}\n\ngoal (1 subgoal):\n 1. card u_adj = degree u G", "by auto"], ["proof (state)\nthis:\n  card u_adj = degree u G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "ultimately"], ["proof (chain)\npicking this:\n  card v_adj = card v_adj_u\n  v_adj_u \\<subseteq> u_adj\n  card v_adj = degree v G\n  card u_adj = degree u G", "have \"degree v G \\<le> degree u G\""], ["proof (prove)\nusing this:\n  card v_adj = card v_adj_u\n  v_adj_u \\<subseteq> u_adj\n  card v_adj = degree v G\n  card u_adj = degree u G\n\ngoal (1 subgoal):\n 1. degree v G \\<le> degree u G", "using \\<open>finite u_adj\\<close>"], ["proof (prove)\nusing this:\n  card v_adj = card v_adj_u\n  v_adj_u \\<subseteq> u_adj\n  card v_adj = degree v G\n  card u_adj = degree u G\n  finite u_adj\n\ngoal (1 subgoal):\n 1. degree v G \\<le> degree u G", "by (metis \\<open>inj_on f v_adj\\<close> card_inj_on_le v_adj_u)"], ["proof (state)\nthis:\n  degree v G \\<le> degree u G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "}"], ["proof (state)\nthis:\n  non_adj ?v2 ?u2 \\<Longrightarrow> degree ?v2 G \\<le> degree ?u2 G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "hence non_adj_degree:\"\\<And>v u. non_adj v u \\<Longrightarrow> degree v G = degree u G\""], ["proof (prove)\nusing this:\n  non_adj ?v2 ?u2 \\<Longrightarrow> degree ?v2 G \\<le> degree ?u2 G\n\ngoal (1 subgoal):\n 1. \\<And>v u. non_adj v u \\<Longrightarrow> degree v G = degree u G", "by (metis adjacent_sym antisym non_adj_def)"], ["proof (state)\nthis:\n  non_adj ?v ?u \\<Longrightarrow> degree ?v G = degree ?u G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card V=3 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow>\n    \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "assume \"card V=3\""], ["proof (state)\nthis:\n  card V = 3\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "then"], ["proof (chain)\npicking this:\n  card V = 3", "obtain v1 v2 v3 where \"V={v1,v2,v3}\" \"v1\\<noteq>v2\" \"v2\\<noteq>v3\" \"v1\\<noteq>v3\""], ["proof (prove)\nusing this:\n  card V = 3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3.\n        \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n         v1 \\<noteq> v3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain v1 S1 where VS1:\"V = insert v1 S1\" and \"v1 \\<notin> S1\"  and \"card S1 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 S1.\n        \\<lbrakk>V = insert v1 S1; v1 \\<notin> S1; card S1 = 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_Suc_eq[of V 2] \\<open>card V=3\\<close>"], ["proof (prove)\nusing this:\n  (card V = Suc 2) =\n  (\\<exists>b B.\n      V = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 2 \\<and> (2 = 0 \\<longrightarrow> B = {}))\n  card V = 3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 S1.\n        \\<lbrakk>V = insert v1 S1; v1 \\<notin> S1; card S1 = 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 2", "obtain v2 S2 where S1S2:\"S1 = insert v2 S2\" and \"v2 \\<notin> S2\" and \"card S2 = 1\""], ["proof (prove)\nusing this:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 2\n\ngoal (1 subgoal):\n 1. (\\<And>v2 S2.\n        \\<lbrakk>S1 = insert v2 S2; v2 \\<notin> S2; card S2 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_Suc_eq[of S1 1]"], ["proof (prove)\nusing this:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 2\n  (card S1 = Suc 1) =\n  (\\<exists>b B.\n      S1 = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 1 \\<and> (1 = 0 \\<longrightarrow> B = {}))\n\ngoal (1 subgoal):\n 1. (\\<And>v2 S2.\n        \\<lbrakk>S1 = insert v2 S2; v2 \\<notin> S2; card S2 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S1 = insert v2 S2\n  v2 \\<notin> S2\n  card S2 = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  S1 = insert v2 S2\n  v2 \\<notin> S2\n  card S2 = 1", "obtain v3 where \"S2={v3}\""], ["proof (prove)\nusing this:\n  S1 = insert v2 S2\n  v2 \\<notin> S2\n  card S2 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>v3. S2 = {v3} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using card_Suc_eq[of S2 0]"], ["proof (prove)\nusing this:\n  S1 = insert v2 S2\n  v2 \\<notin> S2\n  card S2 = 1\n  (card S2 = Suc 0) =\n  (\\<exists>b B.\n      S2 = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}))\n\ngoal (1 subgoal):\n 1. (\\<And>v3. S2 = {v3} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  S2 = {v3}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"V={v1,v2,v3}\""], ["proof (prove)\nusing this:\n  S2 = {v3}\n\ngoal (1 subgoal):\n 1. V = {v1, v2, v3}", "using VS1 S1S2"], ["proof (prove)\nusing this:\n  S2 = {v3}\n  V = insert v1 S1\n  S1 = insert v2 S2\n\ngoal (1 subgoal):\n 1. V = {v1, v2, v3}", "by auto"], ["proof (state)\nthis:\n  V = {v1, v2, v3}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  V = {v1, v2, v3}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"v1\\<noteq>v2\" \"v2\\<noteq>v3\" \"v1\\<noteq>v3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2 &&& v2 \\<noteq> v3 &&& v1 \\<noteq> v3", "using VS1 S1S2 \\<open>v1\\<notin>S1\\<close> \\<open>v2\\<notin>S2\\<close> \\<open>S2={v3}\\<close>"], ["proof (prove)\nusing this:\n  V = insert v1 S1\n  S1 = insert v2 S2\n  v1 \\<notin> S1\n  v2 \\<notin> S2\n  S2 = {v3}\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2 &&& v2 \\<noteq> v3 &&& v1 \\<noteq> v3", "by auto"], ["proof (state)\nthis:\n  v1 \\<noteq> v2\n  v2 \\<noteq> v3\n  v1 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v1 v2 v3.\n                \\<lbrakk>V = {v1, v2, v3}; v1 \\<noteq> v2; v2 \\<noteq> v3;\n                 v1 \\<noteq> v3\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     card V = 3\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  V = {v1, v2, v3}\n  v1 \\<noteq> v2\n  v2 \\<noteq> v3\n  v1 \\<noteq> v3", "show ?thesis"], ["proof (prove)\nusing this:\n  V = {v1, v2, v3}\n  v1 \\<noteq> v2\n  v2 \\<noteq> v3\n  v1 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  V = {v1, v2, v3}\n  v1 \\<noteq> v2\n  v2 \\<noteq> v3\n  v1 \\<noteq> v3\n  \\<lbrakk>V = {?v1.0, ?v2.0, ?v3.0}; ?v1.0 \\<noteq> ?v2.0;\n   ?v2.0 \\<noteq> ?v3.0; ?v1.0 \\<noteq> ?v3.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V = {v1, v2, v3}\n  v1 \\<noteq> v2\n  v2 \\<noteq> v3\n  v1 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "obtain n where \"adjacent v1 n\" \"adjacent v2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>adjacent v1 n; adjacent v2 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v1 v2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v1 \\<noteq> v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v1 n \\<and> adjacent v2 n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>adjacent v1 n; adjacent v2 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>V = {v1, v2, v3}\\<close> \\<open>v1 \\<noteq> v2\\<close> insertI1 insertI2)"], ["proof (state)\nthis:\n  adjacent v1 n\n  adjacent v2 n\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "moreover"], ["proof (state)\nthis:\n  adjacent v1 n\n  adjacent v2 n\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "hence \"n=v3\""], ["proof (prove)\nusing this:\n  adjacent v1 n\n  adjacent v2 n\n\ngoal (1 subgoal):\n 1. n = v3", "using \\<open>V = {v1, v2, v3}\\<close> adjacent_V(2) adjacent_no_loop"], ["proof (prove)\nusing this:\n  adjacent v1 n\n  adjacent v2 n\n  V = {v1, v2, v3}\n  adjacent ?v ?v' \\<Longrightarrow> ?v' \\<in> V\n  adjacent ?v ?v' \\<Longrightarrow> ?v \\<noteq> ?v'\n\ngoal (1 subgoal):\n 1. n = v3", "by (metis (mono_tags) empty_iff insertE)"], ["proof (state)\nthis:\n  n = v3\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "moreover"], ["proof (state)\nthis:\n  n = v3\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "obtain n' where \"adjacent v2 n'\" \"adjacent v3 n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>adjacent v2 n'; adjacent v3 n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v2 v3]"], ["proof (prove)\nusing this:\n  \\<lbrakk>v2 \\<in> V; v3 \\<in> V; v2 \\<noteq> v3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v2 n \\<and> adjacent v3 n\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>adjacent v2 n'; adjacent v3 n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>V = {v1, v2, v3}\\<close> \\<open>v2 \\<noteq> v3\\<close> insertI1 insertI2)"], ["proof (state)\nthis:\n  adjacent v2 n'\n  adjacent v3 n'\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "moreover"], ["proof (state)\nthis:\n  adjacent v2 n'\n  adjacent v3 n'\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "hence \"n'=v1\""], ["proof (prove)\nusing this:\n  adjacent v2 n'\n  adjacent v3 n'\n\ngoal (1 subgoal):\n 1. n' = v1", "using \\<open>V = {v1, v2, v3}\\<close> adjacent_V(2) adjacent_no_loop"], ["proof (prove)\nusing this:\n  adjacent v2 n'\n  adjacent v3 n'\n  V = {v1, v2, v3}\n  adjacent ?v ?v' \\<Longrightarrow> ?v' \\<in> V\n  adjacent ?v ?v' \\<Longrightarrow> ?v \\<noteq> ?v'\n\ngoal (1 subgoal):\n 1. n' = v1", "by (metis (mono_tags) empty_iff insertE)"], ["proof (state)\nthis:\n  n' = v1\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v1 n\n  adjacent v2 n\n  n = v3\n  adjacent v2 n'\n  adjacent v3 n'\n  n' = v1", "have \"adjacent v1 v2\" and  \"adjacent v2 v3\" and \"adjacent v3 v1\""], ["proof (prove)\nusing this:\n  adjacent v1 n\n  adjacent v2 n\n  n = v3\n  adjacent v2 n'\n  adjacent v3 n'\n  n' = v1\n\ngoal (1 subgoal):\n 1. adjacent v1 v2 &&& adjacent v2 v3 &&& adjacent v3 v1", "using adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent v1 n\n  adjacent v2 n\n  n = v3\n  adjacent v2 n'\n  adjacent v3 n'\n  n' = v1\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent v1 v2 &&& adjacent v2 v3 &&& adjacent v3 v1", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v1\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "have \"degree v1 G=2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v1 G = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree v1 G = 2", "have \"v2\\<in>{n. adjacent v1 n}\" and \"v3\\<in>{n. adjacent v1 n}\" and \"v1\\<notin>{n. adjacent v1 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<in> {n. adjacent v1 n} &&&\n    v3 \\<in> {n. adjacent v1 n} &&& v1 \\<notin> {n. adjacent v1 n}", "using \\<open>adjacent v1 v2\\<close> \\<open>adjacent v3 v1\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent v1 v2\n  adjacent v3 v1\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. v2 \\<in> {n. adjacent v1 n} &&&\n    v3 \\<in> {n. adjacent v1 n} &&& v1 \\<notin> {n. adjacent v1 n}", "by (auto,metis adjacent_no_loop)"], ["proof (state)\nthis:\n  v2 \\<in> {n. adjacent v1 n}\n  v3 \\<in> {n. adjacent v1 n}\n  v1 \\<notin> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. degree v1 G = 2", "hence \"{n. adjacent v1 n}={v2,v3}\""], ["proof (prove)\nusing this:\n  v2 \\<in> {n. adjacent v1 n}\n  v3 \\<in> {n. adjacent v1 n}\n  v1 \\<notin> {n. adjacent v1 n}\n\ngoal (1 subgoal):\n 1. {n. adjacent v1 n} = {v2, v3}", "using \\<open>V={v1,v2,v3}\\<close>"], ["proof (prove)\nusing this:\n  v2 \\<in> {n. adjacent v1 n}\n  v3 \\<in> {n. adjacent v1 n}\n  v1 \\<notin> {n. adjacent v1 n}\n  V = {v1, v2, v3}\n\ngoal (1 subgoal):\n 1. {n. adjacent v1 n} = {v2, v3}", "by auto"], ["proof (state)\nthis:\n  {n. adjacent v1 n} = {v2, v3}\n\ngoal (1 subgoal):\n 1. degree v1 G = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n. adjacent v1 n} = {v2, v3}\n\ngoal (1 subgoal):\n 1. degree v1 G = 2", "using degree_adjacent[OF \\<open>finite E\\<close>,of v1] \\<open>v2\\<noteq>v3\\<close>"], ["proof (prove)\nusing this:\n  {n. adjacent v1 n} = {v2, v3}\n  degree v1 G = card {n. adjacent v1 n}\n  v2 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. degree v1 G = 2", "by auto"], ["proof (state)\nthis:\n  degree v1 G = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree v1 G = 2\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "moreover"], ["proof (state)\nthis:\n  degree v1 G = 2\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "have \"degree v2 G=2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v2 G = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree v2 G = 2", "have \"v1\\<in>{n. adjacent v2 n}\" and \"v3\\<in>{n. adjacent v2 n}\" and \"v2\\<notin>{n. adjacent v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<in> {n. adjacent v2 n} &&&\n    v3 \\<in> {n. adjacent v2 n} &&& v2 \\<notin> {n. adjacent v2 n}", "using \\<open>adjacent v1 v2\\<close> \\<open>adjacent v2 v3\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. v1 \\<in> {n. adjacent v2 n} &&&\n    v3 \\<in> {n. adjacent v2 n} &&& v2 \\<notin> {n. adjacent v2 n}", "by (auto,metis adjacent_no_loop)"], ["proof (state)\nthis:\n  v1 \\<in> {n. adjacent v2 n}\n  v3 \\<in> {n. adjacent v2 n}\n  v2 \\<notin> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. degree v2 G = 2", "hence \"{n. adjacent v2 n}={v1,v3}\""], ["proof (prove)\nusing this:\n  v1 \\<in> {n. adjacent v2 n}\n  v3 \\<in> {n. adjacent v2 n}\n  v2 \\<notin> {n. adjacent v2 n}\n\ngoal (1 subgoal):\n 1. {n. adjacent v2 n} = {v1, v3}", "using \\<open>V={v1,v2,v3}\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<in> {n. adjacent v2 n}\n  v3 \\<in> {n. adjacent v2 n}\n  v2 \\<notin> {n. adjacent v2 n}\n  V = {v1, v2, v3}\n\ngoal (1 subgoal):\n 1. {n. adjacent v2 n} = {v1, v3}", "by force"], ["proof (state)\nthis:\n  {n. adjacent v2 n} = {v1, v3}\n\ngoal (1 subgoal):\n 1. degree v2 G = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n. adjacent v2 n} = {v1, v3}\n\ngoal (1 subgoal):\n 1. degree v2 G = 2", "using degree_adjacent[OF \\<open>finite E\\<close>,of v2] \\<open>v1\\<noteq>v3\\<close>"], ["proof (prove)\nusing this:\n  {n. adjacent v2 n} = {v1, v3}\n  degree v2 G = card {n. adjacent v2 n}\n  v1 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. degree v2 G = 2", "by auto"], ["proof (state)\nthis:\n  degree v2 G = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree v2 G = 2\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "moreover"], ["proof (state)\nthis:\n  degree v2 G = 2\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "have \"degree v3 G=2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree v3 G = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree v3 G = 2", "have \"v1\\<in>{n. adjacent v3 n}\" and \"v2\\<in>{n. adjacent v3 n}\" and \"v3\\<notin>{n. adjacent v3 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<in> {n. adjacent v3 n} &&&\n    v2 \\<in> {n. adjacent v3 n} &&& v3 \\<notin> {n. adjacent v3 n}", "using \\<open>adjacent v3 v1\\<close> \\<open>adjacent v2 v3\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent v3 v1\n  adjacent v2 v3\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. v1 \\<in> {n. adjacent v3 n} &&&\n    v2 \\<in> {n. adjacent v3 n} &&& v3 \\<notin> {n. adjacent v3 n}", "by (auto,metis adjacent_no_loop)"], ["proof (state)\nthis:\n  v1 \\<in> {n. adjacent v3 n}\n  v2 \\<in> {n. adjacent v3 n}\n  v3 \\<notin> {n. adjacent v3 n}\n\ngoal (1 subgoal):\n 1. degree v3 G = 2", "hence \"{n. adjacent v3 n}={v1,v2}\""], ["proof (prove)\nusing this:\n  v1 \\<in> {n. adjacent v3 n}\n  v2 \\<in> {n. adjacent v3 n}\n  v3 \\<notin> {n. adjacent v3 n}\n\ngoal (1 subgoal):\n 1. {n. adjacent v3 n} = {v1, v2}", "using \\<open>V={v1,v2,v3}\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<in> {n. adjacent v3 n}\n  v2 \\<in> {n. adjacent v3 n}\n  v3 \\<notin> {n. adjacent v3 n}\n  V = {v1, v2, v3}\n\ngoal (1 subgoal):\n 1. {n. adjacent v3 n} = {v1, v2}", "by force"], ["proof (state)\nthis:\n  {n. adjacent v3 n} = {v1, v2}\n\ngoal (1 subgoal):\n 1. degree v3 G = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n. adjacent v3 n} = {v1, v2}\n\ngoal (1 subgoal):\n 1. degree v3 G = 2", "using degree_adjacent[OF \\<open>finite E\\<close>,of v3] \\<open>v1\\<noteq>v2\\<close>"], ["proof (prove)\nusing this:\n  {n. adjacent v3 n} = {v1, v2}\n  degree v3 G = card {n. adjacent v3 n}\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. degree v3 G = 2", "by auto"], ["proof (state)\nthis:\n  degree v3 G = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree v3 G = 2\n\ngoal (1 subgoal):\n 1. card V = 3 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "ultimately"], ["proof (chain)\npicking this:\n  degree v1 G = 2\n  degree v2 G = 2\n  degree v3 G = 2", "show \"\\<forall>v\\<in>V. degree v G = 2\""], ["proof (prove)\nusing this:\n  degree v1 G = 2\n  degree v2 G = 2\n  degree v3 G = 2\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. degree v G = 2", "using \\<open>V={v1,v2,v3}\\<close>"], ["proof (prove)\nusing this:\n  degree v1 G = 2\n  degree v2 G = 2\n  degree v3 G = 2\n  V = {v1, v2, v3}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. degree v G = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V. degree v G = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card V = 3 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  card V = 3 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card V=2 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "assume \"card V=2\""], ["proof (state)\nthis:\n  card V = 2\n\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "obtain v1 v2 where \"V={v1,v2}\" \"v1\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain v1 S1 where VS1:\"V = insert v1 S1\" and \"v1 \\<notin> S1\" and \"card S1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 S1.\n        \\<lbrakk>V = insert v1 S1; v1 \\<notin> S1; card S1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_Suc_eq[of V 1] \\<open>card V=2\\<close>"], ["proof (prove)\nusing this:\n  (card V = Suc 1) =\n  (\\<exists>b B.\n      V = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 1 \\<and> (1 = 0 \\<longrightarrow> B = {}))\n  card V = 2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 S1.\n        \\<lbrakk>V = insert v1 S1; v1 \\<notin> S1; card S1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 1", "obtain v2 where \"S1={v2}\""], ["proof (prove)\nusing this:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>v2. S1 = {v2} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using card_Suc_eq[of S1 0]"], ["proof (prove)\nusing this:\n  V = insert v1 S1\n  v1 \\<notin> S1\n  card S1 = 1\n  (card S1 = Suc 0) =\n  (\\<exists>b B.\n      S1 = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}))\n\ngoal (1 subgoal):\n 1. (\\<And>v2. S1 = {v2} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  S1 = {v2}\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"V={v1,v2}\""], ["proof (prove)\nusing this:\n  S1 = {v2}\n\ngoal (1 subgoal):\n 1. V = {v1, v2}", "using VS1"], ["proof (prove)\nusing this:\n  S1 = {v2}\n  V = insert v1 S1\n\ngoal (1 subgoal):\n 1. V = {v1, v2}", "by auto"], ["proof (state)\nthis:\n  V = {v1, v2}\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  V = {v1, v2}\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v1\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2", "using \\<open>v1\\<notin>S1\\<close> \\<open>S1={v2}\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<notin> S1\n  S1 = {v2}\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2", "by auto"], ["proof (state)\nthis:\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>V = {v1, v2}; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  V = {v1, v2}\n  v1 \\<noteq> v2", "show ?thesis"], ["proof (prove)\nusing this:\n  V = {v1, v2}\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  V = {v1, v2}\n  v1 \\<noteq> v2\n  \\<lbrakk>V = {?v1.0, ?v2.0}; ?v1.0 \\<noteq> ?v2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V = {v1, v2}\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  V = {v1, v2}\n  v1 \\<noteq> v2", "obtain v3 where \"adjacent v1 v3\" \"adjacent v2 v3\""], ["proof (prove)\nusing this:\n  V = {v1, v2}\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. (\\<And>v3.\n        \\<lbrakk>adjacent v1 v3; adjacent v2 v3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v1 v2]"], ["proof (prove)\nusing this:\n  V = {v1, v2}\n  v1 \\<noteq> v2\n  \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v1 \\<noteq> v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v1 n \\<and> adjacent v2 n\n\ngoal (1 subgoal):\n 1. (\\<And>v3.\n        \\<lbrakk>adjacent v1 v3; adjacent v2 v3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v3\n  adjacent v2 v3\n\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "hence \"v3\\<noteq>v2\" and \"v3\\<noteq>v1\""], ["proof (prove)\nusing this:\n  adjacent v1 v3\n  adjacent v2 v3\n\ngoal (1 subgoal):\n 1. v3 \\<noteq> v2 &&& v3 \\<noteq> v1", "by (metis adjacent_no_loop)+"], ["proof (state)\nthis:\n  v3 \\<noteq> v2\n  v3 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "hence \"v3\\<notin>V\""], ["proof (prove)\nusing this:\n  v3 \\<noteq> v2\n  v3 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v3 \\<notin> V", "using \\<open>V={v1,v2}\\<close>"], ["proof (prove)\nusing this:\n  v3 \\<noteq> v2\n  v3 \\<noteq> v1\n  V = {v1, v2}\n\ngoal (1 subgoal):\n 1. v3 \\<notin> V", "by auto"], ["proof (state)\nthis:\n  v3 \\<notin> V\n\ngoal (1 subgoal):\n 1. card V = 2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v3 \\<notin> V\n\ngoal (1 subgoal):\n 1. False", "using \\<open>adjacent v1 v3\\<close>"], ["proof (prove)\nusing this:\n  v3 \\<notin> V\n  adjacent v1 v3\n\ngoal (1 subgoal):\n 1. False", "by (metis (full_types) adjacent_V(2))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card V = 2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  card V = 2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card V=1 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow>\n    \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "assume \"card V=1\""], ["proof (state)\nthis:\n  card V = 1\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "then"], ["proof (chain)\npicking this:\n  card V = 1", "obtain v1 where \"V={v1}\""], ["proof (prove)\nusing this:\n  card V = 1\n\ngoal (1 subgoal):\n 1. (\\<And>v1. V = {v1} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using card_eq_SucD[of V 0]"], ["proof (prove)\nusing this:\n  card V = 1\n  card V = Suc 0 \\<Longrightarrow>\n  \\<exists>b B.\n     V = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. (\\<And>v1. V = {v1} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  V = {v1}\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "have \"E={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. E \\<noteq> {} \\<Longrightarrow> False", "assume \"E\\<noteq>{}\""], ["proof (state)\nthis:\n  E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. E \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  E \\<noteq> {}", "obtain x1 x2 x3 where x:\"(x1,x2,x3)\\<in>E\""], ["proof (prove)\nusing this:\n  E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 x3.\n        (x1, x2, x3) \\<in> E \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. E \\<noteq> {} \\<Longrightarrow> False", "hence \"x1=v1\" and \"x3=v1\""], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. x1 = v1 &&& x3 = v1", "using \\<open>V={v1}\\<close> E_validD"], ["proof (prove)\nusing this:\n  (x1, x2, x3) \\<in> E\n  V = {v1}\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v \\<in> V\n  (?v, ?e, ?v') \\<in> E \\<Longrightarrow> ?v' \\<in> V\n\ngoal (1 subgoal):\n 1. x1 = v1 &&& x3 = v1", "by auto"], ["proof (state)\nthis:\n  x1 = v1\n  x3 = v1\n\ngoal (1 subgoal):\n 1. E \\<noteq> {} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x1 = v1\n  x3 = v1\n\ngoal (1 subgoal):\n 1. False", "using no_id x"], ["proof (prove)\nusing this:\n  x1 = v1\n  x3 = v1\n  (?v, ?w, ?v) \\<notin> E\n  (x1, x2, x3) \\<in> E\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E = {}\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "hence \"degree v1 G=0\""], ["proof (prove)\nusing this:\n  E = {}\n\ngoal (1 subgoal):\n 1. degree v1 G = 0", "unfolding degree_def"], ["proof (prove)\nusing this:\n  E = {}\n\ngoal (1 subgoal):\n 1. card {e \\<in> E. fst e = v1} = 0", "by auto"], ["proof (state)\nthis:\n  degree v1 G = 0\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow> \\<forall>v\\<in>V. degree v G = ?k", "thus  \"\\<forall>v\\<in>V. degree v G =0\""], ["proof (prove)\nusing this:\n  degree v1 G = 0\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. degree v G = 0", "using \\<open>V={v1}\\<close>"], ["proof (prove)\nusing this:\n  degree v1 G = 0\n  V = {v1}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. degree v G = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V. degree v G = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card V = 1 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  card V = 1 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card V=0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 0 \\<Longrightarrow>\n    \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = 0 \\<Longrightarrow>\n    \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "assume \"card V=0\""], ["proof (state)\nthis:\n  card V = 0\n\ngoal (1 subgoal):\n 1. card V = 0 \\<Longrightarrow>\n    \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "hence \"V={}\""], ["proof (prove)\nusing this:\n  card V = 0\n\ngoal (1 subgoal):\n 1. V = {}", "using \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  card V = 0\n  finite V\n\ngoal (1 subgoal):\n 1. V = {}", "by auto"], ["proof (state)\nthis:\n  V = {}\n\ngoal (1 subgoal):\n 1. card V = 0 \\<Longrightarrow>\n    \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "thus ?thesis"], ["proof (prove)\nusing this:\n  V = {}\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card V = 0 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  card V = 0 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card V \\<ge>4 \\<Longrightarrow> \\<not>(\\<exists>v u. non_adj v u) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<not>(\\<exists>v u. non_adj v u)\" \"card V\\<ge>4\""], ["proof (state)\nthis:\n  \\<nexists>v u. non_adj v u\n  4 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "hence non_non_adj:\"\\<And>v u. v\\<notin>V \\<or> u\\<notin>V \\<or> v=u \\<or> adjacent v u\""], ["proof (prove)\nusing this:\n  \\<nexists>v u. non_adj v u\n  4 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<And>v u.\n       v \\<notin> V \\<or> u \\<notin> V \\<or> v = u \\<or> adjacent v u", "unfolding non_adj_def"], ["proof (prove)\nusing this:\n  \\<nexists>v u.\n     v \\<in> V \\<and>\n     u \\<in> V \\<and> v \\<noteq> u \\<and> \\<not> adjacent v u\n  4 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<And>v u.\n       v \\<notin> V \\<or> u \\<notin> V \\<or> v = u \\<or> adjacent v u", "by auto"], ["proof (state)\nthis:\n  ?v \\<notin> V \\<or> ?u \\<notin> V \\<or> ?v = ?u \\<or> adjacent ?v ?u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "obtain v1 v2 v3 v4 where \"v1\\<in>V\" \"v2\\<in>V\" \"v3\\<in>V\" \"v4\\<in>V\" \"v1\\<noteq>v2\" \"v1\\<noteq>v3\" \"v1\\<noteq>v4\"\n              \"v2\\<noteq>v3\" \"v2\\<noteq>v4\" \"v3\\<noteq>v4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain v1 B1 where \"V = insert v1 B1\"  \"v1 \\<notin> B1\"  \"card B1 \\<ge>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 B1.\n        \\<lbrakk>V = insert v1 B1; v1 \\<notin> B1; 3 \\<le> card B1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>card V\\<ge>4\\<close> card_le_Suc_iff[of 3 V]"], ["proof (prove)\nusing this:\n  4 \\<le> card V\n  (Suc 3 \\<le> card V) =\n  (\\<exists>a B.\n      V = insert a B \\<and>\n      a \\<notin> B \\<and> 3 \\<le> card B \\<and> finite B)\n\ngoal (1 subgoal):\n 1. (\\<And>v1 B1.\n        \\<lbrakk>V = insert v1 B1; v1 \\<notin> B1; 3 \\<le> card B1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V = insert v1 B1\n  v1 \\<notin> B1\n  3 \\<le> card B1\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  V = insert v1 B1\n  v1 \\<notin> B1\n  3 \\<le> card B1", "obtain v2 B2 where \"B1 = insert v2 B2\"  \"v2 \\<notin> B2\"  \"card B2 \\<ge>2\""], ["proof (prove)\nusing this:\n  V = insert v1 B1\n  v1 \\<notin> B1\n  3 \\<le> card B1\n\ngoal (1 subgoal):\n 1. (\\<And>v2 B2.\n        \\<lbrakk>B1 = insert v2 B2; v2 \\<notin> B2; 2 \\<le> card B2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_le_Suc_iff[of 2 B1]"], ["proof (prove)\nusing this:\n  V = insert v1 B1\n  v1 \\<notin> B1\n  3 \\<le> card B1\n  (Suc 2 \\<le> card B1) =\n  (\\<exists>a B.\n      B1 = insert a B \\<and>\n      a \\<notin> B \\<and> 2 \\<le> card B \\<and> finite B)\n\ngoal (1 subgoal):\n 1. (\\<And>v2 B2.\n        \\<lbrakk>B1 = insert v2 B2; v2 \\<notin> B2; 2 \\<le> card B2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B1 = insert v2 B2\n  v2 \\<notin> B2\n  2 \\<le> card B2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  B1 = insert v2 B2\n  v2 \\<notin> B2\n  2 \\<le> card B2", "obtain v3 B3 where \"B2= insert v3 B3\" \"v3\\<notin>B3\" \"card B3\\<ge>1\""], ["proof (prove)\nusing this:\n  B1 = insert v2 B2\n  v2 \\<notin> B2\n  2 \\<le> card B2\n\ngoal (1 subgoal):\n 1. (\\<And>v3 B3.\n        \\<lbrakk>B2 = insert v3 B3; v3 \\<notin> B3; 1 \\<le> card B3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_le_Suc_iff[of 1 B2]"], ["proof (prove)\nusing this:\n  B1 = insert v2 B2\n  v2 \\<notin> B2\n  2 \\<le> card B2\n  (Suc 1 \\<le> card B2) =\n  (\\<exists>a B.\n      B2 = insert a B \\<and>\n      a \\<notin> B \\<and> 1 \\<le> card B \\<and> finite B)\n\ngoal (1 subgoal):\n 1. (\\<And>v3 B3.\n        \\<lbrakk>B2 = insert v3 B3; v3 \\<notin> B3; 1 \\<le> card B3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B2 = insert v3 B3\n  v3 \\<notin> B3\n  1 \\<le> card B3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  B2 = insert v3 B3\n  v3 \\<notin> B3\n  1 \\<le> card B3", "obtain v4 B4 where \"B3=insert v4 B4\" \"v4\\<notin>B4\""], ["proof (prove)\nusing this:\n  B2 = insert v3 B3\n  v3 \\<notin> B3\n  1 \\<le> card B3\n\ngoal (1 subgoal):\n 1. (\\<And>v4 B4.\n        \\<lbrakk>B3 = insert v4 B4; v4 \\<notin> B4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using card_le_Suc_iff[of 0 B3]"], ["proof (prove)\nusing this:\n  B2 = insert v3 B3\n  v3 \\<notin> B3\n  1 \\<le> card B3\n  (Suc 0 \\<le> card B3) =\n  (\\<exists>a B.\n      B3 = insert a B \\<and>\n      a \\<notin> B \\<and> 0 \\<le> card B \\<and> finite B)\n\ngoal (1 subgoal):\n 1. (\\<And>v4 B4.\n        \\<lbrakk>B3 = insert v4 B4; v4 \\<notin> B4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B3 = insert v4 B4\n  v4 \\<notin> B4\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v1\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<in> V", "by (metis \\<open>V = insert v1 B1\\<close> insert_subset order_refl)"], ["proof (state)\nthis:\n  v1 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v1 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v2\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<in> V", "by (metis \\<open>B1 = insert v2 B2\\<close> \\<open>V = insert v1 B1\\<close> insert_subset subset_insertI)"], ["proof (state)\nthis:\n  v2 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v2 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v3\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v3 \\<in> V", "by (metis \\<open>B1 = insert v2 B2\\<close> \\<open>B2 = insert v3 B3\\<close> \\<open>V = insert v1 B1\\<close> insert_iff)"], ["proof (state)\nthis:\n  v3 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v3 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v4\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v4 \\<in> V", "by (metis \\<open>B1 = insert v2 B2\\<close> \\<open>B2 = insert v3 B3\\<close> \\<open>B3 = insert v4 B4\\<close> \n              \\<open>V = insert v1 B1\\<close> insert_iff)"], ["proof (state)\nthis:\n  v4 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v4 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v1\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2", "by (metis (full_types) \\<open>B1 = insert v2 B2\\<close> \\<open>v1 \\<notin> B1\\<close> insertI1)"], ["proof (state)\nthis:\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v1\\<noteq>v3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v3", "by (metis \\<open>B1 = insert v2 B2\\<close> \\<open>B2 = insert v3 B3\\<close> \\<open>v1 \\<notin> B1\\<close> insert_iff)"], ["proof (state)\nthis:\n  v1 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v1 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v1\\<noteq>v4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v4", "by (metis \\<open>B1 = insert v2 B2\\<close> \\<open>B2 = insert v3 B3\\<close> \\<open>B3 = insert v4 B4\\<close> \\<open>v1 \\<notin> B1\\<close> \n              insert_iff)"], ["proof (state)\nthis:\n  v1 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v1 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v2\\<noteq>v3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<noteq> v3", "by (metis (full_types) \\<open>B2 = insert v3 B3\\<close> \\<open>v2 \\<notin> B2\\<close> insertI1)"], ["proof (state)\nthis:\n  v2 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v2 \\<noteq> v3\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v2\\<noteq>v4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<noteq> v4", "by (metis \\<open>B2 = insert v3 B3\\<close> \\<open>B3 = insert v4 B4\\<close> \\<open>v2 \\<notin> B2\\<close> insert_iff)"], ["proof (state)\nthis:\n  v2 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  v2 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v3\\<noteq>v4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v3 \\<noteq> v4", "by (metis (full_types) \\<open>B3 = insert v4 B4\\<close> \\<open>v3 \\<notin> B3\\<close> insertI1)"], ["proof (state)\nthis:\n  v3 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2 v3 v4.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v3 \\<in> V; v4 \\<in> V;\n         v1 \\<noteq> v2; v1 \\<noteq> v3; v1 \\<noteq> v4; v2 \\<noteq> v3;\n         v2 \\<noteq> v4; v3 \\<noteq> v4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  v1 \\<in> V\n  v2 \\<in> V\n  v3 \\<in> V\n  v4 \\<in> V\n  v1 \\<noteq> v2\n  v1 \\<noteq> v3\n  v1 \\<noteq> v4\n  v2 \\<noteq> v3\n  v2 \\<noteq> v4\n  v3 \\<noteq> v4", "show ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v2 \\<in> V\n  v3 \\<in> V\n  v4 \\<in> V\n  v1 \\<noteq> v2\n  v1 \\<noteq> v3\n  v1 \\<noteq> v4\n  v2 \\<noteq> v3\n  v2 \\<noteq> v4\n  v3 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v2 \\<in> V\n  v3 \\<in> V\n  v4 \\<in> V\n  v1 \\<noteq> v2\n  v1 \\<noteq> v3\n  v1 \\<noteq> v4\n  v2 \\<noteq> v3\n  v2 \\<noteq> v4\n  v3 \\<noteq> v4\n  \\<lbrakk>?v1.0 \\<in> V; ?v2.0 \\<in> V; ?v3.0 \\<in> V; ?v4.0 \\<in> V;\n   ?v1.0 \\<noteq> ?v2.0; ?v1.0 \\<noteq> ?v3.0; ?v1.0 \\<noteq> ?v4.0;\n   ?v2.0 \\<noteq> ?v3.0; ?v2.0 \\<noteq> ?v4.0; ?v3.0 \\<noteq> ?v4.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v1 \\<in> V\n  v2 \\<in> V\n  v3 \\<in> V\n  v4 \\<in> V\n  v1 \\<noteq> v2\n  v1 \\<noteq> v3\n  v1 \\<noteq> v4\n  v2 \\<noteq> v3\n  v2 \\<noteq> v4\n  v3 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"adjacent v1 v2\""], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v2 \\<in> V\n  v3 \\<in> V\n  v4 \\<in> V\n  v1 \\<noteq> v2\n  v1 \\<noteq> v3\n  v1 \\<noteq> v4\n  v2 \\<noteq> v3\n  v2 \\<noteq> v4\n  v3 \\<noteq> v4\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "using non_non_adj"], ["proof (prove)\nusing this:\n  v1 \\<in> V\n  v2 \\<in> V\n  v3 \\<in> V\n  v4 \\<in> V\n  v1 \\<noteq> v2\n  v1 \\<noteq> v3\n  v1 \\<noteq> v4\n  v2 \\<noteq> v3\n  v2 \\<noteq> v4\n  v3 \\<noteq> v4\n  ?v \\<notin> V \\<or> ?u \\<notin> V \\<or> ?v = ?u \\<or> adjacent ?v ?u\n\ngoal (1 subgoal):\n 1. adjacent v1 v2", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v1 v2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "have \"adjacent v2 v3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v2 v3", "using non_non_adj"], ["proof (prove)\nusing this:\n  ?v \\<notin> V \\<or> ?u \\<notin> V \\<or> ?v = ?u \\<or> adjacent ?v ?u\n\ngoal (1 subgoal):\n 1. adjacent v2 v3", "by (metis \\<open>v2 \\<in> V\\<close> \\<open>v2 \\<noteq> v3\\<close> \\<open>v3 \\<in> V\\<close>)"], ["proof (state)\nthis:\n  adjacent v2 v3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v2 v3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "have \"adjacent v3 v4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v3 v4", "using non_non_adj"], ["proof (prove)\nusing this:\n  ?v \\<notin> V \\<or> ?u \\<notin> V \\<or> ?v = ?u \\<or> adjacent ?v ?u\n\ngoal (1 subgoal):\n 1. adjacent v3 v4", "by (metis \\<open>v3 \\<in> V\\<close> \\<open>v3 \\<noteq> v4\\<close> \\<open>v4 \\<in> V\\<close>)"], ["proof (state)\nthis:\n  adjacent v3 v4\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  adjacent v3 v4\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "have \"adjacent v4 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v4 v1", "using non_non_adj"], ["proof (prove)\nusing this:\n  ?v \\<notin> V \\<or> ?u \\<notin> V \\<or> ?v = ?u \\<or> adjacent ?v ?u\n\ngoal (1 subgoal):\n 1. adjacent v4 v1", "by (metis \\<open>v1 \\<in> V\\<close> \\<open>v1 \\<noteq> v4\\<close> \\<open>v4 \\<in> V\\<close>)"], ["proof (state)\nthis:\n  adjacent v4 v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v4\n  adjacent v4 v1", "show False"], ["proof (prove)\nusing this:\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v4\n  adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "using no_quad[OF friend_assm]"], ["proof (prove)\nusing this:\n  adjacent v1 v2\n  adjacent v2 v3\n  adjacent v3 v4\n  adjacent v4 v1\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>v1 v2 v3 v4.\n                       v2 \\<noteq> v4 \\<and>\n                       v1 \\<noteq> v3 \\<and>\n                       adjacent v1 v2 \\<and>\n                       adjacent v2 v3 \\<and>\n                       adjacent v3 v4 \\<and> adjacent v4 v1\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>v1 \\<noteq> v3\\<close> \\<open>v2 \\<noteq> v4\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"card V\\<ge>4 \\<Longrightarrow> (\\<exists>v u. non_adj v u) \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "assume \"(\\<exists>v u. non_adj v u)\" \"card V\\<ge>4\""], ["proof (state)\nthis:\n  \\<exists>v u. non_adj v u\n  4 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "then"], ["proof (chain)\npicking this:\n  \\<exists>v u. non_adj v u\n  4 \\<le> card V", "obtain v u where \"non_adj v u\""], ["proof (prove)\nusing this:\n  \\<exists>v u. non_adj v u\n  4 \\<le> card V\n\ngoal (1 subgoal):\n 1. (\\<And>v u. non_adj v u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  non_adj v u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "then"], ["proof (chain)\npicking this:\n  non_adj v u", "obtain w where \"adjacent v w\" and \"adjacent u w\" \n          and unique:\"\\<forall>n. adjacent v n \\<and> adjacent u n \\<longrightarrow> n=w\""], ["proof (prove)\nusing this:\n  non_adj v u\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>adjacent v w; adjacent u w;\n         \\<forall>n.\n            adjacent v n \\<and> adjacent u n \\<longrightarrow>\n            n = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v u]"], ["proof (prove)\nusing this:\n  non_adj v u\n  \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v n \\<and> adjacent u n\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>adjacent v w; adjacent u w;\n         \\<forall>n.\n            adjacent v n \\<and> adjacent u n \\<longrightarrow>\n            n = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding non_adj_def"], ["proof (prove)\nusing this:\n  v \\<in> V \\<and> u \\<in> V \\<and> v \\<noteq> u \\<and> \\<not> adjacent v u\n  \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v n \\<and> adjacent u n\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>adjacent v w; adjacent u w;\n         \\<forall>n.\n            adjacent v n \\<and> adjacent u n \\<longrightarrow>\n            n = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adjacent v w\n  adjacent u w\n  \\<forall>n. adjacent v n \\<and> adjacent u n \\<longrightarrow> n = w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "have \"\\<forall>n\\<in>V. degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>V. degree n G = degree v G", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "assume \"n\\<in>V\""], ["proof (state)\nthis:\n  n \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  n \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "have \"n=v \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = v \\<Longrightarrow> degree n G = degree v G", "by auto"], ["proof (state)\nthis:\n  n = v \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  n = v \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "have \"n=u \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = u \\<Longrightarrow> degree n G = degree v G", "using non_adj_degree \\<open>non_adj v u\\<close>"], ["proof (prove)\nusing this:\n  non_adj ?v ?u \\<Longrightarrow> degree ?v G = degree ?u G\n  non_adj v u\n\ngoal (1 subgoal):\n 1. n = u \\<Longrightarrow> degree n G = degree v G", "by auto"], ["proof (state)\nthis:\n  n = u \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  n = u \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "have \"n\\<noteq>v \\<Longrightarrow> n\\<noteq>u \\<Longrightarrow> n\\<noteq>w \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "assume \"n\\<noteq>v\" \"n\\<noteq>u\" \"n\\<noteq>w\""], ["proof (state)\nthis:\n  n \\<noteq> v\n  n \\<noteq> u\n  n \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "have \"non_adj v n \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_adj v n \\<Longrightarrow> degree n G = degree v G", "by (metis non_adj_degree)"], ["proof (state)\nthis:\n  non_adj v n \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  non_adj v n \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "have \"non_adj u n \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_adj u n \\<Longrightarrow> degree n G = degree v G", "by (metis \\<open>non_adj v u\\<close> non_adj_degree)"], ["proof (state)\nthis:\n  non_adj u n \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  non_adj u n \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "have \"\\<not>non_adj u n \\<Longrightarrow> \\<not>non_adj v n \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> non_adj u n; \\<not> non_adj v n\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "by (metis \\<open>n \\<in> V\\<close> \\<open>n \\<noteq> w\\<close> \\<open>non_adj v u\\<close> non_adj_def unique)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> non_adj u n; \\<not> non_adj v n\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "ultimately"], ["proof (chain)\npicking this:\n  non_adj v n \\<Longrightarrow> degree n G = degree v G\n  non_adj u n \\<Longrightarrow> degree n G = degree v G\n  \\<lbrakk>\\<not> non_adj u n; \\<not> non_adj v n\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G", "show \"degree n G = degree v G\""], ["proof (prove)\nusing this:\n  non_adj v n \\<Longrightarrow> degree n G = degree v G\n  non_adj u n \\<Longrightarrow> degree n G = degree v G\n  \\<lbrakk>\\<not> non_adj u n; \\<not> non_adj v n\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. degree n G = degree v G", "by auto"], ["proof (state)\nthis:\n  degree n G = degree v G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "have \"n=w \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "assume \"n=w\""], ["proof (state)\nthis:\n  n = w\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  n = w\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "have \"\\<not>(\\<exists>v. \\<forall>n\\<in>V. n\\<noteq>v \\<longrightarrow> adjacent v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "using \\<open>card V\\<ge>4\\<close> degree_two_windmill assms(2) assms(4) friend_assm"], ["proof (prove)\nusing this:\n  4 \\<le> card V\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> \\<exists>!n.\n                                   adjacent v n \\<and> adjacent u n;\n   finite E; 2 \\<le> card V\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>v\\<in>V. degree v G = 2) =\n                    (\\<exists>v.\n                        \\<forall>n\\<in>V.\n                           n \\<noteq> v \\<longrightarrow> adjacent v n)\n  finite E\n  \\<not> (\\<exists>v\\<in>V. degree v G = 2)\n  \\<lbrakk>?v \\<in> V; ?u \\<in> V; ?v \\<noteq> ?u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent ?v n \\<and> adjacent ?u n\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "by auto"], ["proof (state)\nthis:\n  \\<nexists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "ultimately"], ["proof (chain)\npicking this:\n  n = w\n  \\<nexists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "obtain w1 where \"w1\\<in>V\" \"w1\\<noteq>w\" \"non_adj w w1\""], ["proof (prove)\nusing this:\n  n = w\n  \\<nexists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. (\\<And>w1.\n        \\<lbrakk>w1 \\<in> V; w1 \\<noteq> w; non_adj w w1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>n\\<in>V\\<close> non_adj_def)"], ["proof (state)\nthis:\n  w1 \\<in> V\n  w1 \\<noteq> w\n  non_adj w w1\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "have \"w1=v \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 = v \\<Longrightarrow> degree n G = degree v G", "by (metis \\<open>n = w\\<close> \\<open>non_adj w w1\\<close> non_adj_degree)"], ["proof (state)\nthis:\n  w1 = v \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  w1 = v \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "have \"w1=u \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 = u \\<Longrightarrow> degree n G = degree v G", "by (metis \\<open>adjacent u w\\<close> \\<open>non_adj w w1\\<close> adjacent_sym non_adj_def)"], ["proof (state)\nthis:\n  w1 = u \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "moreover"], ["proof (state)\nthis:\n  w1 = u \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "have \"w1\\<noteq>u \\<Longrightarrow> w1\\<noteq>v \\<Longrightarrow> degree n G = degree v G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w1 \\<noteq> u; w1 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> degree n G = degree v G", "by (metis \\<open>n = w\\<close> \\<open>non_adj v u\\<close> \\<open>non_adj w w1\\<close> non_adj_def non_adj_degree unique)"], ["proof (state)\nthis:\n  \\<lbrakk>w1 \\<noteq> u; w1 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. n = w \\<Longrightarrow> degree n G = degree v G", "ultimately"], ["proof (chain)\npicking this:\n  w1 = v \\<Longrightarrow> degree n G = degree v G\n  w1 = u \\<Longrightarrow> degree n G = degree v G\n  \\<lbrakk>w1 \\<noteq> u; w1 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G", "show \"degree n G = degree v G\""], ["proof (prove)\nusing this:\n  w1 = v \\<Longrightarrow> degree n G = degree v G\n  w1 = u \\<Longrightarrow> degree n G = degree v G\n  \\<lbrakk>w1 \\<noteq> u; w1 \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. degree n G = degree v G", "by auto"], ["proof (state)\nthis:\n  degree n G = degree v G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = w \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> V \\<Longrightarrow> degree n G = degree v G", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> V\n  n = v \\<Longrightarrow> degree n G = degree v G\n  n = u \\<Longrightarrow> degree n G = degree v G\n  \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n  n = w \\<Longrightarrow> degree n G = degree v G", "show \"degree n G = degree v G\""], ["proof (prove)\nusing this:\n  n \\<in> V\n  n = v \\<Longrightarrow> degree n G = degree v G\n  n = u \\<Longrightarrow> degree n G = degree v G\n  \\<lbrakk>n \\<noteq> v; n \\<noteq> u; n \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> degree n G = degree v G\n  n = w \\<Longrightarrow> degree n G = degree v G\n\ngoal (1 subgoal):\n 1. degree n G = degree v G", "by auto"], ["proof (state)\nthis:\n  degree n G = degree v G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>V. degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>V. degree n G = degree v G\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "ultimately"], ["proof (chain)\npicking this:\n  card V = 3 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n  card V = 2 \\<Longrightarrow> False\n  card V = 1 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n  card V = 0 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n  \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "show ?thesis"], ["proof (prove)\nusing this:\n  card V = 3 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n  card V = 2 \\<Longrightarrow> False\n  card V = 1 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n  card V = 0 \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n  \\<lbrakk>4 \\<le> card V; \\<nexists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>4 \\<le> card V; \\<exists>v u. non_adj v u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. \\<exists>k. \\<forall>v\\<in>V. degree v G = k", "by force"], ["proof (state)\nthis:\n  \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal:\nNo subgoals!", "qed"], ["", "(*In this section, combinatorial proofs for the Friendship Theorem differ from the algebraic ones.\nThe main difference between these two approaches is that combinatorial proofs show Lemma \nexist_degree_two by counting the number of paths while algebraic proofs show it by computing\nthe eigenvalue of adjacency matrices.*)"], ["", "section\\<open>Exclusive steps for combinatorial proofs\\<close>"], ["", "fun (in valid_unSimpGraph) adj_path:: \"'v \\<Rightarrow> 'v list \\<Rightarrow>bool\" where\n  \"adj_path v [] =  (v\\<in>V)\" \n  | \"adj_path v (u#us)= (adjacent v u \\<and> adj_path u us)\""], ["", "lemma (in valid_unSimpGraph) adj_path_butlast:\n  \"adj_path v ps \\<Longrightarrow> adj_path v (butlast ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path v ps \\<Longrightarrow> adj_path v (butlast ps)", "by (induct ps arbitrary:v,auto)"], ["", "lemma (in valid_unSimpGraph) adj_path_V:\n  \"adj_path v ps \\<Longrightarrow> set ps \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path v ps \\<Longrightarrow> set ps \\<subseteq> V", "by (induct ps arbitrary:v, auto)"], ["", "lemma (in valid_unSimpGraph) adj_path_V':\n  \"adj_path v ps \\<Longrightarrow> v\\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path v ps \\<Longrightarrow> v \\<in> V", "by (induct ps arbitrary:v, auto)"], ["", "lemma (in valid_unSimpGraph) adj_path_app:\n  \"adj_path v ps \\<Longrightarrow> ps\\<noteq>[] \\<Longrightarrow> adjacent (last ps) u \\<Longrightarrow> adj_path v (ps@[u])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>adj_path v ps; ps \\<noteq> []; adjacent (last ps) u\\<rbrakk>\n    \\<Longrightarrow> adj_path v (ps @ [u])", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>adj_path v []; [] \\<noteq> []; adjacent (last []) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ([] @ [u])\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v ps; ps \\<noteq> [];\n                    adjacent (last ps) u\\<rbrakk>\n                   \\<Longrightarrow> adj_path v (ps @ [u]);\n        adj_path v (a # ps); a # ps \\<noteq> [];\n        adjacent (last (a # ps)) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ((a # ps) @ [u])", "case Nil"], ["proof (state)\nthis:\n  adj_path v []\n  [] \\<noteq> []\n  adjacent (last []) u\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>adj_path v []; [] \\<noteq> []; adjacent (last []) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ([] @ [u])\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v ps; ps \\<noteq> [];\n                    adjacent (last ps) u\\<rbrakk>\n                   \\<Longrightarrow> adj_path v (ps @ [u]);\n        adj_path v (a # ps); a # ps \\<noteq> [];\n        adjacent (last (a # ps)) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ((a # ps) @ [u])", "thus ?case"], ["proof (prove)\nusing this:\n  adj_path v []\n  [] \\<noteq> []\n  adjacent (last []) u\n\ngoal (1 subgoal):\n 1. adj_path v ([] @ [u])", "by auto"], ["proof (state)\nthis:\n  adj_path v ([] @ [u])\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v ps; ps \\<noteq> [];\n                    adjacent (last ps) u\\<rbrakk>\n                   \\<Longrightarrow> adj_path v (ps @ [u]);\n        adj_path v (a # ps); a # ps \\<noteq> [];\n        adjacent (last (a # ps)) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ((a # ps) @ [u])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v ps; ps \\<noteq> [];\n                    adjacent (last ps) u\\<rbrakk>\n                   \\<Longrightarrow> adj_path v (ps @ [u]);\n        adj_path v (a # ps); a # ps \\<noteq> [];\n        adjacent (last (a # ps)) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ((a # ps) @ [u])", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>adj_path ?v xs; xs \\<noteq> []; adjacent (last xs) u\\<rbrakk>\n  \\<Longrightarrow> adj_path ?v (xs @ [u])\n  adj_path v (x # xs)\n  x # xs \\<noteq> []\n  adjacent (last (x # xs)) u\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v ps; ps \\<noteq> [];\n                    adjacent (last ps) u\\<rbrakk>\n                   \\<Longrightarrow> adj_path v (ps @ [u]);\n        adj_path v (a # ps); a # ps \\<noteq> [];\n        adjacent (last (a # ps)) u\\<rbrakk>\n       \\<Longrightarrow> adj_path v ((a # ps) @ [u])", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>adj_path ?v xs; xs \\<noteq> []; adjacent (last xs) u\\<rbrakk>\n  \\<Longrightarrow> adj_path ?v (xs @ [u])\n  adj_path v (x # xs)\n  x # xs \\<noteq> []\n  adjacent (last (x # xs)) u\n\ngoal (1 subgoal):\n 1. adj_path v ((x # xs) @ [u])", "by (cases xs,auto)"], ["proof (state)\nthis:\n  adj_path v ((x # xs) @ [u])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) adj_path_app':\n  \"adj_path v (ps @ [q] ) \\<Longrightarrow> ps \\<noteq> [] \\<Longrightarrow> adjacent (last ps) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>adj_path v (ps @ [q]); ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> adjacent (last ps) q", "proof (induct ps arbitrary:v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>adj_path v ([] @ [q]); [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last []) q\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v (ps @ [q]); ps \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> adjacent (last ps) q;\n        adj_path v ((a # ps) @ [q]); a # ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last (a # ps)) q", "case Nil"], ["proof (state)\nthis:\n  adj_path v ([] @ [q])\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>adj_path v ([] @ [q]); [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last []) q\n 2. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v (ps @ [q]); ps \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> adjacent (last ps) q;\n        adj_path v ((a # ps) @ [q]); a # ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last (a # ps)) q", "thus ?case"], ["proof (prove)\nusing this:\n  adj_path v ([] @ [q])\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (last []) q", "by auto"], ["proof (state)\nthis:\n  adjacent (last []) q\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v (ps @ [q]); ps \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> adjacent (last ps) q;\n        adj_path v ((a # ps) @ [q]); a # ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last (a # ps)) q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v (ps @ [q]); ps \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> adjacent (last ps) q;\n        adj_path v ((a # ps) @ [q]); a # ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last (a # ps)) q", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>adj_path ?v (xs @ [q]); xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> adjacent (last xs) q\n  adj_path v ((x # xs) @ [q])\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a ps v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>adj_path v (ps @ [q]); ps \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> adjacent (last ps) q;\n        adj_path v ((a # ps) @ [q]); a # ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> adjacent (last (a # ps)) q", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>adj_path ?v (xs @ [q]); xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> adjacent (last xs) q\n  adj_path v ((x # xs) @ [q])\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (last (x # xs)) q", "by (cases xs,auto)"], ["proof (state)\nthis:\n  adjacent (last (x # xs)) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_partition':\n  assumes \"\\<forall>v\\<in>A. card {n. R v n} = k\" \"k>0\" \"finite A\" \n      \"\\<forall>v1 v2. v1\\<noteq>v2 \\<longrightarrow> {n. R v1 n} \\<inter> {n. R v2 n}={}\"\n  shows \"card (\\<Union>v\\<in>A. {n. R v n}) = k * card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "have \"\\<And>C. C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card C = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card C = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card C = k", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card C = k", "assume \"C \\<in> (\\<lambda>x. {n. R x n}) ` A\""], ["proof (state)\nthis:\n  C \\<in> (\\<lambda>x. {n. R x n}) ` A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card C = k", "show \"card C=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card C = k", "by (metis (mono_tags) \\<open>C \\<in> (\\<lambda>x. {n. R x n}) ` A\\<close> assms(1) imageE)"], ["proof (state)\nthis:\n  card C = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card ?C = k\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "moreover"], ["proof (state)\nthis:\n  ?C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card ?C = k\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "have \"\\<And>C1 C2. C1 \\<in>(\\<lambda>x. {n. R x n}) ` A  \\<Longrightarrow> C2 \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> C1 \\<noteq> C2 \n      \\<Longrightarrow> C1 \\<inter> C2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "fix C1 C2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "assume \"C1 \\<in> (\\<lambda>x. {n. R x n}) ` A\"  \"C2 \\<in> (\\<lambda>x. {n. R x n}) ` A\"  \"C1 \\<noteq> C2\""], ["proof (state)\nthis:\n  C1 \\<in> (\\<lambda>x. {n. R x n}) ` A\n  C2 \\<in> (\\<lambda>x. {n. R x n}) ` A\n  C1 \\<noteq> C2\n\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "obtain v1 where \"v1\\<in>A\" \"C1={n. R v1 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1.\n        \\<lbrakk>v1 \\<in> A; C1 = {n. R v1 n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A\\<close> imageE)"], ["proof (state)\nthis:\n  v1 \\<in> A\n  C1 = {n. R v1 n}\n\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "obtain v2 where \"v2\\<in>A\" \"C2={n. R v2 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v2.\n        \\<lbrakk>v2 \\<in> A; C2 = {n. R v2 n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>C2 \\<in> (\\<lambda>x. {n. R x n}) ` A\\<close> imageE)"], ["proof (state)\nthis:\n  v2 \\<in> A\n  C2 = {n. R v2 n}\n\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "have \"v1\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2", "by (metis \\<open>C1 = {n. R v1 n}\\<close> \\<open>C1 \\<noteq> C2\\<close> \\<open>C2 = {n. R v2 n}\\<close>)"], ["proof (state)\nthis:\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. \\<And>C1 C2.\n       \\<lbrakk>C1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n        C2 \\<in> (\\<lambda>x. {n. R x n}) ` A; C1 \\<noteq> C2\\<rbrakk>\n       \\<Longrightarrow> C1 \\<inter> C2 = {}", "thus \"C1 \\<inter> C2 ={}\""], ["proof (prove)\nusing this:\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. C1 \\<inter> C2 = {}", "by (metis \\<open>C1 = {n. R v1 n}\\<close> \\<open>C2 = {n. R v2 n}\\<close> assms(4))"], ["proof (state)\nthis:\n  C1 \\<inter> C2 = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?C1.0 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n   ?C2.0 \\<in> (\\<lambda>x. {n. R x n}) ` A; ?C1.0 \\<noteq> ?C2.0\\<rbrakk>\n  \\<Longrightarrow> ?C1.0 \\<inter> ?C2.0 = {}\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?C1.0 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n   ?C2.0 \\<in> (\\<lambda>x. {n. R x n}) ` A; ?C1.0 \\<noteq> ?C2.0\\<rbrakk>\n  \\<Longrightarrow> ?C1.0 \\<inter> ?C2.0 = {}\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "have \"\\<Union>((\\<lambda>x. {n. R x n}) ` A) = (\\<Union>x\\<in>A. {n. R x n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. {n. R x n}) = (\\<Union>x\\<in>A. {n. R x n})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>A. {n. R x n}) = (\\<Union>x\\<in>A. {n. R x n})\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "moreover"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>A. {n. R x n}) = (\\<Union>x\\<in>A. {n. R x n})\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "have \"finite ((\\<lambda>x. {n. R x n}) ` A )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>x. {n. R x n}) ` A)", "by (metis assms(3) finite_imageI)"], ["proof (state)\nthis:\n  finite ((\\<lambda>x. {n. R x n}) ` A)\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "moreover"], ["proof (state)\nthis:\n  finite ((\\<lambda>x. {n. R x n}) ` A)\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "have \"finite (\\<Union>((\\<lambda>x. {n. R x n}) ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>x\\<in>A. {n. R x n})", "by (metis (full_types) assms(1) \n    assms(2) assms(3) card_eq_0_iff finite_UN_I less_nat_zero_code)"], ["proof (state)\nthis:\n  finite (\\<Union>x\\<in>A. {n. R x n})\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "moreover"], ["proof (state)\nthis:\n  finite (\\<Union>x\\<in>A. {n. R x n})\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "have \" card A = card ((\\<lambda>x. {n. R x n}) ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A = card ((\\<lambda>x. {n. R x n}) ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card A = card ((\\<lambda>x. {n. R x n}) ` A)", "have \"inj_on (\\<lambda>x. {n. R x n}) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. {n. R x n}) A", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A.\n          Collect (R x) = Collect (R y) \\<longrightarrow> x = y", "using \\<open>\\<forall>v1 v2. v1\\<noteq>v2 \\<longrightarrow> {n. R v1 n} \\<inter> {n. R v2 n}={}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>v1 v2.\n     v1 \\<noteq> v2 \\<longrightarrow> {n. R v1 n} \\<inter> {n. R v2 n} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A.\n          Collect (R x) = Collect (R y) \\<longrightarrow> x = y", "by (metis assms(1) assms(2) card.empty inf.idem less_le)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. {n. R x n}) A\n\ngoal (1 subgoal):\n 1. card A = card ((\\<lambda>x. {n. R x n}) ` A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>x. {n. R x n}) A\n\ngoal (1 subgoal):\n 1. card A = card ((\\<lambda>x. {n. R x n}) ` A)", "by (metis card_image)"], ["proof (state)\nthis:\n  card A = card ((\\<lambda>x. {n. R x n}) ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card A = card ((\\<lambda>x. {n. R x n}) ` A)\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "ultimately"], ["proof (chain)\npicking this:\n  ?C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card ?C = k\n  \\<lbrakk>?C1.0 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n   ?C2.0 \\<in> (\\<lambda>x. {n. R x n}) ` A; ?C1.0 \\<noteq> ?C2.0\\<rbrakk>\n  \\<Longrightarrow> ?C1.0 \\<inter> ?C2.0 = {}\n  (\\<Union>x\\<in>A. {n. R x n}) = (\\<Union>x\\<in>A. {n. R x n})\n  finite ((\\<lambda>x. {n. R x n}) ` A)\n  finite (\\<Union>x\\<in>A. {n. R x n})\n  card A = card ((\\<lambda>x. {n. R x n}) ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card ?C = k\n  \\<lbrakk>?C1.0 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n   ?C2.0 \\<in> (\\<lambda>x. {n. R x n}) ` A; ?C1.0 \\<noteq> ?C2.0\\<rbrakk>\n  \\<Longrightarrow> ?C1.0 \\<inter> ?C2.0 = {}\n  (\\<Union>x\\<in>A. {n. R x n}) = (\\<Union>x\\<in>A. {n. R x n})\n  finite ((\\<lambda>x. {n. R x n}) ` A)\n  finite (\\<Union>x\\<in>A. {n. R x n})\n  card A = card ((\\<lambda>x. {n. R x n}) ` A)\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "using card_partition[of \"(\\<lambda>x. {n. R x n}) ` A\"]"], ["proof (prove)\nusing this:\n  ?C \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card ?C = k\n  \\<lbrakk>?C1.0 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n   ?C2.0 \\<in> (\\<lambda>x. {n. R x n}) ` A; ?C1.0 \\<noteq> ?C2.0\\<rbrakk>\n  \\<Longrightarrow> ?C1.0 \\<inter> ?C2.0 = {}\n  (\\<Union>x\\<in>A. {n. R x n}) = (\\<Union>x\\<in>A. {n. R x n})\n  finite ((\\<lambda>x. {n. R x n}) ` A)\n  finite (\\<Union>x\\<in>A. {n. R x n})\n  card A = card ((\\<lambda>x. {n. R x n}) ` A)\n  \\<lbrakk>finite ((\\<lambda>x. {n. R x n}) ` A);\n   finite (\\<Union>x\\<in>A. {n. R x n});\n   \\<And>c.\n      c \\<in> (\\<lambda>x. {n. R x n}) ` A \\<Longrightarrow> card c = ?k;\n   \\<And>c1 c2.\n      \\<lbrakk>c1 \\<in> (\\<lambda>x. {n. R x n}) ` A;\n       c2 \\<in> (\\<lambda>x. {n. R x n}) ` A; c1 \\<noteq> c2\\<rbrakk>\n      \\<Longrightarrow> c1 \\<inter> c2 = {}\\<rbrakk>\n  \\<Longrightarrow> ?k * card ((\\<lambda>x. {n. R x n}) ` A) =\n                    card (\\<Union>x\\<in>A. {n. R x n})\n\ngoal (1 subgoal):\n 1. card (\\<Union>v\\<in>A. {n. R v n}) = k * card A", "by auto"], ["proof (state)\nthis:\n  card (\\<Union>v\\<in>A. {n. R v n}) = k * card A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) path_count:\n  assumes k_adj:\"\\<And>v. v\\<in>V \\<Longrightarrow> card {n. adjacent v n} = k\" and  \"v\\<in>V\" and \"finite V\" and \"k>0\"\n  shows \"card {ps. length ps=l \\<and> adj_path v ps}=k^l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {ps. length ps = l \\<and> adj_path v ps} = k ^ l", "proof (induct l rule:nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. card {ps. length ps = 0 \\<and> adj_path v ps} = k ^ 0\n 2. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. card {ps. length ps = 0 \\<and> adj_path v ps} = k ^ 0\n 2. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "have \"{ps. length ps=0 \\<and> adj_path v ps}={[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ps. length ps = 0 \\<and> adj_path v ps} = {[]}", "using \\<open>v\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. {ps. length ps = 0 \\<and> adj_path v ps} = {[]}", "by auto"], ["proof (state)\nthis:\n  {ps. length ps = 0 \\<and> adj_path v ps} = {[]}\n\ngoal (2 subgoals):\n 1. card {ps. length ps = 0 \\<and> adj_path v ps} = k ^ 0\n 2. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "thus ?case"], ["proof (prove)\nusing this:\n  {ps. length ps = 0 \\<and> adj_path v ps} = {[]}\n\ngoal (1 subgoal):\n 1. card {ps. length ps = 0 \\<and> adj_path v ps} = k ^ 0", "by auto"], ["proof (state)\nthis:\n  card {ps. length ps = 0 \\<and> adj_path v ps} = k ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "case (Suc n)"], ["proof (state)\nthis:\n  card {ps. length ps = n \\<and> adj_path v ps} = k ^ n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "obtain ext where ext: \"ext=(\\<lambda>ps ps'.  ps'\\<noteq>[] \\<and> (butlast ps'=ps) \\<and> adj_path v ps')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ext.\n        ext =\n        (\\<lambda>ps ps'.\n            ps' \\<noteq> [] \\<and>\n            butlast ps' = ps \\<and> adj_path v ps') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "have \"\\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}. card {ps'. ext ps ps'} = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n       card {ps'. ext ps ps'} = k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "assume \"ps\\<in>{ps. length ps = n \\<and> adj_path v ps}\""], ["proof (state)\nthis:\n  ps \\<in> {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "hence \"adj_path v ps\" and \"length ps = n\""], ["proof (prove)\nusing this:\n  ps \\<in> {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. adj_path v ps &&& length ps = n", "by auto"], ["proof (state)\nthis:\n  adj_path v ps\n  length ps = n\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "obtain qs where qs:\"qs = {n. if ps=[] then adjacent v n else adjacent (last ps) n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        qs =\n        {n. if ps = [] then adjacent v n\n            else adjacent (last ps) n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "hence \"card qs = k\""], ["proof (prove)\nusing this:\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n\ngoal (1 subgoal):\n 1. card qs = k", "proof (cases \"ps=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps = []\\<rbrakk>\n    \\<Longrightarrow> card qs = k\n 2. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> card qs = k", "case True"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps = []\\<rbrakk>\n    \\<Longrightarrow> card qs = k\n 2. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> card qs = k", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = []\n\ngoal (1 subgoal):\n 1. card qs = k", "using qs k_adj[OF \\<open>v\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  ps = []\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n  card {n. adjacent v n} = k\n\ngoal (1 subgoal):\n 1. card qs = k", "by auto"], ["proof (state)\nthis:\n  card qs = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> card qs = k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> card qs = k", "case False"], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> card qs = k", "have \"last ps \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last ps \\<in> V", "using adj_path_V"], ["proof (prove)\nusing this:\n  adj_path ?v ?ps \\<Longrightarrow> set ?ps \\<subseteq> V\n\ngoal (1 subgoal):\n 1. last ps \\<in> V", "by (metis False \\<open>adj_path v ps\\<close> last_in_set subsetD)"], ["proof (state)\nthis:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>qs =\n             {n. if ps = [] then adjacent v n else adjacent (last ps) n};\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> card qs = k", "thus ?thesis"], ["proof (prove)\nusing this:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. card qs = k", "using k_adj[of \"last ps\"] False qs"], ["proof (prove)\nusing this:\n  last ps \\<in> V\n  last ps \\<in> V \\<Longrightarrow> card {n. adjacent (last ps) n} = k\n  ps \\<noteq> []\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n\ngoal (1 subgoal):\n 1. card qs = k", "by auto"], ["proof (state)\nthis:\n  card qs = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card qs = k\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "obtain app where app:\"app=(\\<lambda>q. ps@[q])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>app.\n        app = (\\<lambda>q. ps @ [q]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  app = (\\<lambda>q. ps @ [q])\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "have \"app ` qs = {ps'. ext ps ps'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "have \"\\<And>xs. xs\\<in> app ` qs \\<Longrightarrow> xs \\<in> {ps'. ext ps ps'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> app ` qs \\<Longrightarrow> xs \\<in> {ps'. ext ps ps'}", "proof (rule,cases \"ps=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "case True"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "assume \"xs\\<in> app ` qs\""], ["proof (state)\nthis:\n  xs \\<in> app ` qs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "then"], ["proof (chain)\npicking this:\n  xs \\<in> app ` qs", "obtain q where \"q\\<in> qs\" \"app q=xs\""], ["proof (prove)\nusing this:\n  xs \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> qs; app q = xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis imageE)"], ["proof (state)\nthis:\n  q \\<in> qs\n  app q = xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "hence  \"adjacent v q\" and \"xs=ps@[q]\""], ["proof (prove)\nusing this:\n  q \\<in> qs\n  app q = xs\n\ngoal (1 subgoal):\n 1. adjacent v q &&& xs = ps @ [q]", "using qs app True"], ["proof (prove)\nusing this:\n  q \\<in> qs\n  app q = xs\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n  app = (\\<lambda>q. ps @ [q])\n  ps = []\n\ngoal (1 subgoal):\n 1. adjacent v q &&& xs = ps @ [q]", "by auto"], ["proof (state)\nthis:\n  adjacent v q\n  xs = ps @ [q]\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "hence \"adj_path v xs\""], ["proof (prove)\nusing this:\n  adjacent v q\n  xs = ps @ [q]\n\ngoal (1 subgoal):\n 1. adj_path v xs", "by (metis True adj_path.simps(1) adj_path.simps(2) adjacent_V(2) append_Nil)"], ["proof (state)\nthis:\n  adj_path v xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "moreover"], ["proof (state)\nthis:\n  adj_path v xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "have \"butlast xs = ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast xs = ps", "using  \\<open>xs=ps@[q]\\<close>"], ["proof (prove)\nusing this:\n  xs = ps @ [q]\n\ngoal (1 subgoal):\n 1. butlast xs = ps", "by auto"], ["proof (state)\nthis:\n  butlast xs = ps\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps = []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "ultimately"], ["proof (chain)\npicking this:\n  adj_path v xs\n  butlast xs = ps", "show \"ext ps xs\""], ["proof (prove)\nusing this:\n  adj_path v xs\n  butlast xs = ps\n\ngoal (1 subgoal):\n 1. ext ps xs", "using ext \\<open>xs=ps@[q]\\<close>"], ["proof (prove)\nusing this:\n  adj_path v xs\n  butlast xs = ps\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n  xs = ps @ [q]\n\ngoal (1 subgoal):\n 1. ext ps xs", "by auto"], ["proof (state)\nthis:\n  ext ps xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "case False"], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "assume \"xs\\<in> app ` qs\""], ["proof (state)\nthis:\n  xs \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "then"], ["proof (chain)\npicking this:\n  xs \\<in> app ` qs", "obtain q where \"q\\<in> qs\" \"app q=xs\""], ["proof (prove)\nusing this:\n  xs \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> qs; app q = xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis imageE)"], ["proof (state)\nthis:\n  q \\<in> qs\n  app q = xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "hence  \"adjacent (last ps) q\""], ["proof (prove)\nusing this:\n  q \\<in> qs\n  app q = xs\n\ngoal (1 subgoal):\n 1. adjacent (last ps) q", "using qs app False"], ["proof (prove)\nusing this:\n  q \\<in> qs\n  app q = xs\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n  app = (\\<lambda>q. ps @ [q])\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (last ps) q", "by auto"], ["proof (state)\nthis:\n  adjacent (last ps) q\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "hence \"adj_path v (ps@[q])\""], ["proof (prove)\nusing this:\n  adjacent (last ps) q\n\ngoal (1 subgoal):\n 1. adj_path v (ps @ [q])", "using  \\<open>adj_path v ps\\<close> False adj_path_app"], ["proof (prove)\nusing this:\n  adjacent (last ps) q\n  adj_path v ps\n  ps \\<noteq> []\n  \\<lbrakk>adj_path ?v ?ps; ?ps \\<noteq> []; adjacent (last ?ps) ?u\\<rbrakk>\n  \\<Longrightarrow> adj_path ?v (?ps @ [?u])\n\ngoal (1 subgoal):\n 1. adj_path v (ps @ [q])", "by auto"], ["proof (state)\nthis:\n  adj_path v (ps @ [q])\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "hence \"adj_path v xs\""], ["proof (prove)\nusing this:\n  adj_path v (ps @ [q])\n\ngoal (1 subgoal):\n 1. adj_path v xs", "by (metis \\<open>app q = xs\\<close> app)"], ["proof (state)\nthis:\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "moreover"], ["proof (state)\nthis:\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "have \"butlast xs=ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast xs = ps", "by (metis \\<open>app q = xs\\<close> app butlast_snoc)"], ["proof (state)\nthis:\n  butlast xs = ps\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> app ` qs; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ext ps xs", "ultimately"], ["proof (chain)\npicking this:\n  adj_path v xs\n  butlast xs = ps", "show \"ext ps xs\""], ["proof (prove)\nusing this:\n  adj_path v xs\n  butlast xs = ps\n\ngoal (1 subgoal):\n 1. ext ps xs", "by (metis False butlast.simps(1) ext)"], ["proof (state)\nthis:\n  ext ps xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xs \\<in> app ` qs \\<Longrightarrow> ?xs \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "moreover"], ["proof (state)\nthis:\n  ?xs \\<in> app ` qs \\<Longrightarrow> ?xs \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "have \"\\<And>xs. xs\\<in>{ps'. ext ps ps'} \\<Longrightarrow> xs\\<in> app ` qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> {ps'. ext ps ps'} \\<Longrightarrow> xs \\<in> app ` qs", "proof (cases \"ps=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "case True"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "hence \"qs = {n. adjacent v n }\""], ["proof (prove)\nusing this:\n  ps = []\n\ngoal (1 subgoal):\n 1. qs = {n. adjacent v n}", "using qs"], ["proof (prove)\nusing this:\n  ps = []\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n\ngoal (1 subgoal):\n 1. qs = {n. adjacent v n}", "by auto"], ["proof (state)\nthis:\n  qs = {n. adjacent v n}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "assume \"xs \\<in> {ps'. ext ps ps'}\""], ["proof (state)\nthis:\n  xs \\<in> {ps'. ext ps ps'}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "hence \"xs\\<noteq>[]\" and \"(butlast xs=ps)\" and \"adj_path v xs\""], ["proof (prove)\nusing this:\n  xs \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& butlast xs = ps &&& adj_path v xs", "using ext"], ["proof (prove)\nusing this:\n  xs \\<in> {ps'. ext ps ps'}\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& butlast xs = ps &&& adj_path v xs", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  butlast xs = ps\n  adj_path v xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps = []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs\n 2. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "thus \"xs \\<in> app ` qs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  butlast xs = ps\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. xs \\<in> app ` qs", "using True app \\<open>qs = {n. adjacent v n}\\<close>"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  butlast xs = ps\n  adj_path v xs\n  ps = []\n  app = (\\<lambda>q. ps @ [q])\n  qs = {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. xs \\<in> app ` qs", "by (metis  adj_path.simps(2) append_butlast_last_id append_self_conv2 image_iff \n                  mem_Collect_eq)"], ["proof (state)\nthis:\n  xs \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "case False"], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "assume \"xs \\<in> {ps'. ext ps ps'}\""], ["proof (state)\nthis:\n  xs \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "hence \"xs\\<noteq>[]\" and \"(butlast xs=ps)\" and \"adj_path v xs\""], ["proof (prove)\nusing this:\n  xs \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& butlast xs = ps &&& adj_path v xs", "using ext"], ["proof (prove)\nusing this:\n  xs \\<in> {ps'. ext ps ps'}\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& butlast xs = ps &&& adj_path v xs", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  butlast xs = ps\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  butlast xs = ps\n  adj_path v xs", "obtain q where \"xs=ps@[q]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  butlast xs = ps\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. (\\<And>q. xs = ps @ [q] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id)"], ["proof (state)\nthis:\n  xs = ps @ [q]\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "hence \"adjacent (last ps) q\""], ["proof (prove)\nusing this:\n  xs = ps @ [q]\n\ngoal (1 subgoal):\n 1. adjacent (last ps) q", "using \\<open>adj_path v xs\\<close> False adj_path_app'"], ["proof (prove)\nusing this:\n  xs = ps @ [q]\n  adj_path v xs\n  ps \\<noteq> []\n  \\<lbrakk>adj_path ?v (?ps @ [?q]); ?ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> adjacent (last ?ps) ?q\n\ngoal (1 subgoal):\n 1. adjacent (last ps) q", "by auto"], ["proof (state)\nthis:\n  adjacent (last ps) q\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<in> {ps'. ext ps ps'}; ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> app ` qs", "thus \"xs \\<in> app ` qs\""], ["proof (prove)\nusing this:\n  adjacent (last ps) q\n\ngoal (1 subgoal):\n 1. xs \\<in> app ` qs", "using qs"], ["proof (prove)\nusing this:\n  adjacent (last ps) q\n  qs = {n. if ps = [] then adjacent v n else adjacent (last ps) n}\n\ngoal (1 subgoal):\n 1. xs \\<in> app ` qs", "by (metis (lifting, full_types) False \\<open>xs = ps @ [q]\\<close> app imageI mem_Collect_eq)"], ["proof (state)\nthis:\n  xs \\<in> app ` qs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xs \\<in> {ps'. ext ps ps'} \\<Longrightarrow> ?xs \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "ultimately"], ["proof (chain)\npicking this:\n  ?xs \\<in> app ` qs \\<Longrightarrow> ?xs \\<in> {ps'. ext ps ps'}\n  ?xs \\<in> {ps'. ext ps ps'} \\<Longrightarrow> ?xs \\<in> app ` qs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?xs \\<in> app ` qs \\<Longrightarrow> ?xs \\<in> {ps'. ext ps ps'}\n  ?xs \\<in> {ps'. ext ps ps'} \\<Longrightarrow> ?xs \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "by auto"], ["proof (state)\nthis:\n  app ` qs = {ps'. ext ps ps'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  app ` qs = {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "moreover"], ["proof (state)\nthis:\n  app ` qs = {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "have \"inj_on app qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on app qs", "using app"], ["proof (prove)\nusing this:\n  app = (\\<lambda>q. ps @ [q])\n\ngoal (1 subgoal):\n 1. inj_on app qs", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  app = (\\<lambda>q. ps @ [q])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>qs.\n       \\<forall>y\\<in>qs. app x = app y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on app qs\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = n \\<and> adj_path v ps} \\<Longrightarrow>\n       card {ps'. ext ps ps'} = k", "ultimately"], ["proof (chain)\npicking this:\n  app ` qs = {ps'. ext ps ps'}\n  inj_on app qs", "show \"card {ps'. ext ps ps'}=k\""], ["proof (prove)\nusing this:\n  app ` qs = {ps'. ext ps ps'}\n  inj_on app qs\n\ngoal (1 subgoal):\n 1. card {ps'. ext ps ps'} = k", "by (metis \\<open>card qs = k\\<close> card_image)"], ["proof (state)\nthis:\n  card {ps'. ext ps ps'} = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n     card {ps'. ext ps ps'} = k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "moreover"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n     card {ps'. ext ps ps'} = k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "have \"\\<forall>ps1 ps2. ps1\\<noteq>ps2 \\<longrightarrow> {n. ext ps1 n} \\<inter> {n. ext ps2 n}={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps1 ps2.\n       ps1 \\<noteq> ps2 \\<longrightarrow>\n       {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}", "using ext"], ["proof (prove)\nusing this:\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n\ngoal (1 subgoal):\n 1. \\<forall>ps1 ps2.\n       ps1 \\<noteq> ps2 \\<longrightarrow>\n       {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "moreover"], ["proof (state)\nthis:\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "have \"finite {ps. length ps = n \\<and> adj_path v ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {ps. length ps = n \\<and> adj_path v ps}", "using Suc.hyps assms"], ["proof (prove)\nusing this:\n  card {ps. length ps = n \\<and> adj_path v ps} = k ^ n\n  ?v \\<in> V \\<Longrightarrow> card {n. adjacent ?v n} = k\n  v \\<in> V\n  finite V\n  0 < k\n\ngoal (1 subgoal):\n 1. finite {ps. length ps = n \\<and> adj_path v ps}", "by (auto intro: card_ge_0_finite)"], ["proof (state)\nthis:\n  finite {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n     card {ps'. ext ps ps'} = k\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}\n  finite {ps. length ps = n \\<and> adj_path v ps}", "have \"card (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}. {n. ext v n}) \n      = k * card {ps. length ps = n \\<and> adj_path v ps}\""], ["proof (prove)\nusing this:\n  \\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n     card {ps'. ext ps ps'} = k\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}\n  finite {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n         {n. ext v n}) =\n    k * card {ps. length ps = n \\<and> adj_path v ps}", "using card_partition'[of \"{ps. length ps = n \\<and> adj_path v ps}\" ext k] \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n     card {ps'. ext ps ps'} = k\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {n. ext ps1 n} \\<inter> {n. ext ps2 n} = {}\n  finite {ps. length ps = n \\<and> adj_path v ps}\n  \\<lbrakk>\\<forall>v\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n              card {n. ext v n} = k;\n   0 < k; finite {ps. length ps = n \\<and> adj_path v ps};\n   \\<forall>v1 v2.\n      v1 \\<noteq> v2 \\<longrightarrow>\n      {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>v\\<in>{ps.\n                                     length ps = n \\<and> adj_path v ps}.\n                         {n. ext v n}) =\n                    k * card {ps. length ps = n \\<and> adj_path v ps}\n  0 < k\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n         {n. ext v n}) =\n    k * card {ps. length ps = n \\<and> adj_path v ps}", "by auto"], ["proof (state)\nthis:\n  card\n   (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}. {n. ext v n}) =\n  k * card {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "moreover"], ["proof (state)\nthis:\n  card\n   (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}. {n. ext v n}) =\n  k * card {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "have \"{ps. length ps = n+1 \\<and> adj_path v ps}\n      =(\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}. {ps'. ext ps ps'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ps. length ps = n + 1 \\<and> adj_path v ps} =\n    (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n        {ps'. ext ps ps'})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {ps. length ps = n + 1 \\<and> adj_path v ps} =\n    (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n        {ps'. ext ps ps'})", "have \"\\<And>xs. xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow> \n          xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}. {ps'. ext ps ps'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {ps.\n                 length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {ps.\n                 length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'})", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {ps.\n                 length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'})", "assume \"xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\""], ["proof (state)\nthis:\n  xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {ps.\n                 length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'})", "hence \"length xs = n +1\" and \"adj_path v xs\""], ["proof (prove)\nusing this:\n  xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. length xs = n + 1 &&& adj_path v xs", "by auto"], ["proof (state)\nthis:\n  length xs = n + 1\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {ps.\n                 length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'})", "hence \"butlast xs \\<in>{ps. length ps = n \\<and> adj_path v ps}\""], ["proof (prove)\nusing this:\n  length xs = n + 1\n  adj_path v xs\n\ngoal (1 subgoal):\n 1. butlast xs \\<in> {ps. length ps = n \\<and> adj_path v ps}", "using adj_path_butlast length_butlast mem_Collect_eq"], ["proof (prove)\nusing this:\n  length xs = n + 1\n  adj_path v xs\n  adj_path ?v ?ps \\<Longrightarrow> adj_path ?v (butlast ?ps)\n  length (butlast ?xs) = length ?xs - 1\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. butlast xs \\<in> {ps. length ps = n \\<and> adj_path v ps}", "by auto"], ["proof (state)\nthis:\n  butlast xs \\<in> {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {ps.\n                 length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'})", "thus \"xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}. {ps'. ext ps ps'})\""], ["proof (prove)\nusing this:\n  butlast xs \\<in> {ps. length ps = n \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                 {ps'. ext ps ps'})", "using \\<open>adj_path v xs\\<close> \\<open>length xs = n + 1\\<close> UN_iff  ext length_greater_0_conv \n              mem_Collect_eq"], ["proof (prove)\nusing this:\n  butlast xs \\<in> {ps. length ps = n \\<and> adj_path v ps}\n  adj_path v xs\n  length xs = n + 1\n  (?b \\<in> \\<Union> (?B ` ?A)) = (\\<exists>x\\<in>?A. ?b \\<in> ?B x)\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n  (0 < length ?xs) = (?xs \\<noteq> [])\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                 {ps'. ext ps ps'})", "by auto"], ["proof (state)\nthis:\n  xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n               {ps'. ext ps ps'})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. {ps. length ps = n + 1 \\<and> adj_path v ps} =\n    (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n        {ps'. ext ps ps'})", "moreover"], ["proof (state)\nthis:\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. {ps. length ps = n + 1 \\<and> adj_path v ps} =\n    (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n        {ps'. ext ps ps'})", "have \"\\<And>xs . xs\\<in>(\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}. {ps'. ext ps ps'}) \\<Longrightarrow>\n          xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'}) \\<Longrightarrow>\n       xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'}) \\<Longrightarrow>\n       xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'}) \\<Longrightarrow>\n       xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "assume \"xs\\<in>(\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}. {ps'. ext ps ps'})\""], ["proof (state)\nthis:\n  xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n               {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'}) \\<Longrightarrow>\n       xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "then"], ["proof (chain)\npicking this:\n  xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n               {ps'. ext ps ps'})", "obtain ys where \"length ys=n\" \"adj_path v ys\" \"ext ys xs\""], ["proof (prove)\nusing this:\n  xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n               {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>length ys = n; adj_path v ys; ext ys xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length ys = n\n  adj_path v ys\n  ext ys xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'}) \\<Longrightarrow>\n       xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "hence \"length xs=n+1\""], ["proof (prove)\nusing this:\n  length ys = n\n  adj_path v ys\n  ext ys xs\n\ngoal (1 subgoal):\n 1. length xs = n + 1", "using ext"], ["proof (prove)\nusing this:\n  length ys = n\n  adj_path v ys\n  ext ys xs\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and> butlast ps' = ps \\<and> adj_path v ps')\n\ngoal (1 subgoal):\n 1. length xs = n + 1", "by auto"], ["proof (state)\nthis:\n  length xs = n + 1\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n                    {ps'. ext ps ps'}) \\<Longrightarrow>\n       xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "thus \"xs\\<in>{ps. length ps = n + 1 \\<and> adj_path v ps}\""], ["proof (prove)\nusing this:\n  length xs = n + 1\n\ngoal (1 subgoal):\n 1. xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "by (metis (lifting, full_types) \\<open>ext ys xs\\<close> ext mem_Collect_eq)"], ["proof (state)\nthis:\n  xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. {ps. length ps = n + 1 \\<and> adj_path v ps} =\n    (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n        {ps'. ext ps ps'})", "ultimately"], ["proof (chain)\npicking this:\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'})\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps} \\<Longrightarrow>\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'})\n  ?xs\n  \\<in> (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n            {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?xs \\<in> {ps. length ps = n + 1 \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. {ps. length ps = n + 1 \\<and> adj_path v ps} =\n    (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n        {ps'. ext ps ps'})", "by fast"], ["proof (state)\nthis:\n  {ps. length ps = n + 1 \\<and> adj_path v ps} =\n  (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n      {ps'. ext ps ps'})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {ps. length ps = n + 1 \\<and> adj_path v ps} =\n  (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n      {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       card {ps. length ps = nat \\<and> adj_path v ps} =\n       k ^ nat \\<Longrightarrow>\n       card {ps. length ps = Suc nat \\<and> adj_path v ps} = k ^ Suc nat", "ultimately"], ["proof (chain)\npicking this:\n  card\n   (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}. {n. ext v n}) =\n  k * card {ps. length ps = n \\<and> adj_path v ps}\n  {ps. length ps = n + 1 \\<and> adj_path v ps} =\n  (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n      {ps'. ext ps ps'})", "show \"card {ps. length ps = (Suc n) \\<and> adj_path v ps} = k ^ (Suc n)\""], ["proof (prove)\nusing this:\n  card\n   (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}. {n. ext v n}) =\n  k * card {ps. length ps = n \\<and> adj_path v ps}\n  {ps. length ps = n + 1 \\<and> adj_path v ps} =\n  (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n      {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. card {ps. length ps = Suc n \\<and> adj_path v ps} = k ^ Suc n", "using Suc.hyps"], ["proof (prove)\nusing this:\n  card\n   (\\<Union>v\\<in>{ps. length ps = n \\<and> adj_path v ps}. {n. ext v n}) =\n  k * card {ps. length ps = n \\<and> adj_path v ps}\n  {ps. length ps = n + 1 \\<and> adj_path v ps} =\n  (\\<Union>ps\\<in>{ps. length ps = n \\<and> adj_path v ps}.\n      {ps'. ext ps ps'})\n  card {ps. length ps = n \\<and> adj_path v ps} = k ^ n\n\ngoal (1 subgoal):\n 1. card {ps. length ps = Suc n \\<and> adj_path v ps} = k ^ Suc n", "by auto"], ["proof (state)\nthis:\n  card {ps. length ps = Suc n \\<and> adj_path v ps} = k ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) total_v_num:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\" \n      and \"finite E\" and \"finite V\" and \"V\\<noteq>{}\" and \" \\<forall>v\\<in>V. degree v G = k\" and \"k>0\"\n  shows \"card V= k*k - k +1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "have k_adj:\"\\<And>v. v\\<in>V\\<Longrightarrow>card ({n. adjacent v n})=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {n. adjacent v n} = k", "by (metis assms(2) assms(5) degree_adjacent)"], ["proof (state)\nthis:\n  ?v \\<in> V \\<Longrightarrow> card {n. adjacent ?v n} = k\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "obtain v where \"v\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> V \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>V\\<noteq>{}\\<close>"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> V \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "obtain l2_eq_v where l2_eq_v: \"l2_eq_v={ps. length ps=2 \\<and> adj_path v ps \\<and> last ps=v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2_eq_v.\n        l2_eq_v =\n        {ps.\n         length ps = 2 \\<and>\n         adj_path v ps \\<and> last ps = v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l2_eq_v = {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps = v}\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "have \"card l2_eq_v=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "obtain hds where hds:\"hds= hd` l2_eq_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>hds.\n        hds = hd ` l2_eq_v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hds = hd ` l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "moreover"], ["proof (state)\nthis:\n  hds = hd ` l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "have \"hds={n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hds = {n. adjacent v n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hds = {n. adjacent v n}", "have \"\\<And>x. x\\<in>hds \\<Longrightarrow> x\\<in> {n. adjacent v n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hds \\<Longrightarrow> x \\<in> {n. adjacent v n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hds \\<Longrightarrow> adjacent v x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hds \\<Longrightarrow> adjacent v x", "assume \"x\\<in>hds\""], ["proof (state)\nthis:\n  x \\<in> hds\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hds \\<Longrightarrow> adjacent v x", "then"], ["proof (chain)\npicking this:\n  x \\<in> hds", "obtain ps where \"hd ps=x\" \"length ps=2\" \"adj_path v ps\" \"last ps=v\""], ["proof (prove)\nusing this:\n  x \\<in> hds\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>hd ps = x; length ps = 2; adj_path v ps;\n         last ps = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hds l2_eq_v"], ["proof (prove)\nusing this:\n  x \\<in> hds\n  hds = hd ` l2_eq_v\n  l2_eq_v = {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps = v}\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>hd ps = x; length ps = 2; adj_path v ps;\n         last ps = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd ps = x\n  length ps = 2\n  adj_path v ps\n  last ps = v\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hds \\<Longrightarrow> adjacent v x", "thus \"adjacent v x\""], ["proof (prove)\nusing this:\n  hd ps = x\n  length ps = 2\n  adj_path v ps\n  last ps = v\n\ngoal (1 subgoal):\n 1. adjacent v x", "by (metis (full_types) adj_path.simps(2) list.sel(1) length_0_conv neq_Nil_conv \n                  zero_neq_numeral)"], ["proof (state)\nthis:\n  adjacent v x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> hds \\<Longrightarrow> ?x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. hds = {n. adjacent v n}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> hds \\<Longrightarrow> ?x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. hds = {n. adjacent v n}", "have \"\\<And>x. x\\<in>{n. adjacent v n} \\<Longrightarrow> x\\<in>hds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {n. adjacent v n} \\<Longrightarrow> x \\<in> hds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {n. adjacent v n} \\<Longrightarrow> x \\<in> hds", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {n. adjacent v n} \\<Longrightarrow> x \\<in> hds", "assume \"x\\<in>{n. adjacent v n}\""], ["proof (state)\nthis:\n  x \\<in> {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {n. adjacent v n} \\<Longrightarrow> x \\<in> hds", "obtain ps where \"ps=[x,v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps. ps = [x, v] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps = [x, v]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {n. adjacent v n} \\<Longrightarrow> x \\<in> hds", "hence \"hd ps=x\" and \"length ps=2\" and \"adj_path v ps\" and \"last ps=v\""], ["proof (prove)\nusing this:\n  ps = [x, v]\n\ngoal (1 subgoal):\n 1. (hd ps = x &&& length ps = 2) &&& adj_path v ps &&& last ps = v", "using \\<open>x\\<in>{n. adjacent v n}\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  ps = [x, v]\n  x \\<in> {n. adjacent v n}\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. (hd ps = x &&& length ps = 2) &&& adj_path v ps &&& last ps = v", "by auto"], ["proof (state)\nthis:\n  hd ps = x\n  length ps = 2\n  adj_path v ps\n  last ps = v\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {n. adjacent v n} \\<Longrightarrow> x \\<in> hds", "thus \"x\\<in>hds\""], ["proof (prove)\nusing this:\n  hd ps = x\n  length ps = 2\n  adj_path v ps\n  last ps = v\n\ngoal (1 subgoal):\n 1. x \\<in> hds", "by (metis (lifting, mono_tags) hds image_eqI l2_eq_v mem_Collect_eq)"], ["proof (state)\nthis:\n  x \\<in> hds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {n. adjacent v n} \\<Longrightarrow> ?x \\<in> hds\n\ngoal (1 subgoal):\n 1. hds = {n. adjacent v n}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> hds \\<Longrightarrow> ?x \\<in> {n. adjacent v n}\n  ?x \\<in> {n. adjacent v n} \\<Longrightarrow> ?x \\<in> hds", "show \"hds={n. adjacent v n}\""], ["proof (prove)\nusing this:\n  ?x \\<in> hds \\<Longrightarrow> ?x \\<in> {n. adjacent v n}\n  ?x \\<in> {n. adjacent v n} \\<Longrightarrow> ?x \\<in> hds\n\ngoal (1 subgoal):\n 1. hds = {n. adjacent v n}", "by auto"], ["proof (state)\nthis:\n  hds = {n. adjacent v n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hds = {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "moreover"], ["proof (state)\nthis:\n  hds = {n. adjacent v n}\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "have \"inj_on hd l2_eq_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on hd l2_eq_v", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>l2_eq_v.\n       \\<forall>y\\<in>l2_eq_v. hd x = hd y \\<longrightarrow> x = y", "proof (rule+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> l2_eq_v\" \"y \\<in> l2_eq_v\" \"hd x = hd y\""], ["proof (state)\nthis:\n  x \\<in> l2_eq_v\n  y \\<in> l2_eq_v\n  hd x = hd y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"length x=2\" and \"last x=last y\" and \"length y=2\""], ["proof (prove)\nusing this:\n  x \\<in> l2_eq_v\n  y \\<in> l2_eq_v\n  hd x = hd y\n\ngoal (1 subgoal):\n 1. length x = 2 &&& last x = last y &&& length y = 2", "using l2_eq_v"], ["proof (prove)\nusing this:\n  x \\<in> l2_eq_v\n  y \\<in> l2_eq_v\n  hd x = hd y\n  l2_eq_v = {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps = v}\n\ngoal (1 subgoal):\n 1. length x = 2 &&& last x = last y &&& length y = 2", "by auto"], ["proof (state)\nthis:\n  length x = 2\n  last x = last y\n  length y = 2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"x!1=y!1\""], ["proof (prove)\nusing this:\n  length x = 2\n  last x = last y\n  length y = 2\n\ngoal (1 subgoal):\n 1. x ! 1 = y ! 1", "using last_conv_nth[of x] last_conv_nth[of y]"], ["proof (prove)\nusing this:\n  length x = 2\n  last x = last y\n  length y = 2\n  x \\<noteq> [] \\<Longrightarrow> last x = x ! (length x - 1)\n  y \\<noteq> [] \\<Longrightarrow> last y = y ! (length y - 1)\n\ngoal (1 subgoal):\n 1. x ! 1 = y ! 1", "by force"], ["proof (state)\nthis:\n  x ! 1 = y ! 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  x ! 1 = y ! 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"x!0=y!0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ! 0 = y ! 0", "using \\<open>hd x=hd y\\<close> \\<open>length x=2\\<close> \\<open>length y=2\\<close>"], ["proof (prove)\nusing this:\n  hd x = hd y\n  length x = 2\n  length y = 2\n\ngoal (1 subgoal):\n 1. x ! 0 = y ! 0", "by(metis hd_conv_nth length_greater_0_conv)"], ["proof (state)\nthis:\n  x ! 0 = y ! 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_eq_v; y \\<in> l2_eq_v; hd x = hd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  x ! 1 = y ! 1\n  x ! 0 = y ! 0", "show \"x=y\""], ["proof (prove)\nusing this:\n  x ! 1 = y ! 1\n  x ! 0 = y ! 0\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>length x=2\\<close> \\<open>length y=2\\<close>"], ["proof (prove)\nusing this:\n  x ! 1 = y ! 1\n  x ! 0 = y ! 0\n  length x = 2\n  length y = 2\n\ngoal (1 subgoal):\n 1. x = y", "using  nth_equalityI[of x y]"], ["proof (prove)\nusing this:\n  x ! 1 = y ! 1\n  x ! 0 = y ! 0\n  length x = 2\n  length y = 2\n  \\<lbrakk>length x = length y;\n   \\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i\\<rbrakk>\n  \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. x = y", "by (metis One_nat_def less_2_cases)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on hd l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "ultimately"], ["proof (chain)\npicking this:\n  hds = hd ` l2_eq_v\n  hds = {n. adjacent v n}\n  inj_on hd l2_eq_v", "show \"card l2_eq_v=k\""], ["proof (prove)\nusing this:\n  hds = hd ` l2_eq_v\n  hds = {n. adjacent v n}\n  inj_on hd l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "using k_adj[OF \\<open>v\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  hds = hd ` l2_eq_v\n  hds = {n. adjacent v n}\n  inj_on hd l2_eq_v\n  card {n. adjacent v n} = k\n\ngoal (1 subgoal):\n 1. card l2_eq_v = k", "by (metis card_image)"], ["proof (state)\nthis:\n  card l2_eq_v = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card l2_eq_v = k\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "obtain l2_neq_v where l2_neq_v:\"l2_neq_v={ps. length ps=2 \\<and> adj_path v ps \\<and> last ps\\<noteq>v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2_neq_v.\n        l2_neq_v =\n        {ps.\n         length ps = 2 \\<and>\n         adj_path v ps \\<and> last ps \\<noteq> v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l2_neq_v =\n  {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "have \"card l2_neq_v = k*k-k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "obtain l2_v where l2_v:\"l2_v={ps. length ps=2\\<and> adj_path v ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2_v.\n        l2_v = {ps. length ps = 2 \\<and> adj_path v ps} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l2_v = {ps. length ps = 2 \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "hence \"card l2_v=k*k\""], ["proof (prove)\nusing this:\n  l2_v = {ps. length ps = 2 \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. card l2_v = k * k", "using path_count[OF k_adj,of v 2] \\<open>0<k\\<close> \\<open>finite V\\<close> \\<open>v\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  l2_v = {ps. length ps = 2 \\<and> adj_path v ps}\n  \\<lbrakk>\\<And>v. v \\<in> V \\<Longrightarrow> v \\<in> V; v \\<in> V;\n   finite V; 0 < k\\<rbrakk>\n  \\<Longrightarrow> card {ps. length ps = 2 \\<and> adj_path v ps} =\n                    k\\<^sup>2\n  0 < k\n  finite V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. card l2_v = k * k", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  card l2_v = k * k\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "hence \"finite l2_v\""], ["proof (prove)\nusing this:\n  card l2_v = k * k\n\ngoal (1 subgoal):\n 1. finite l2_v", "using \\<open>k>0\\<close>"], ["proof (prove)\nusing this:\n  card l2_v = k * k\n  0 < k\n\ngoal (1 subgoal):\n 1. finite l2_v", "by (metis card.infinite mult_is_0 neq0_conv)"], ["proof (state)\nthis:\n  finite l2_v\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "moreover"], ["proof (state)\nthis:\n  finite l2_v\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "have \"l2_v=l2_neq_v \\<union> l2_eq_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2_v = l2_neq_v \\<union> l2_eq_v", "using l2_v l2_neq_v l2_eq_v"], ["proof (prove)\nusing this:\n  l2_v = {ps. length ps = 2 \\<and> adj_path v ps}\n  l2_neq_v =\n  {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps \\<noteq> v}\n  l2_eq_v = {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps = v}\n\ngoal (1 subgoal):\n 1. l2_v = l2_neq_v \\<union> l2_eq_v", "by auto"], ["proof (state)\nthis:\n  l2_v = l2_neq_v \\<union> l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "moreover"], ["proof (state)\nthis:\n  l2_v = l2_neq_v \\<union> l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "have \"l2_neq_v \\<inter> l2_eq_v ={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2_neq_v \\<inter> l2_eq_v = {}", "using l2_neq_v l2_eq_v"], ["proof (prove)\nusing this:\n  l2_neq_v =\n  {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps \\<noteq> v}\n  l2_eq_v = {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps = v}\n\ngoal (1 subgoal):\n 1. l2_neq_v \\<inter> l2_eq_v = {}", "by auto"], ["proof (state)\nthis:\n  l2_neq_v \\<inter> l2_eq_v = {}\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "ultimately"], ["proof (chain)\npicking this:\n  finite l2_v\n  l2_v = l2_neq_v \\<union> l2_eq_v\n  l2_neq_v \\<inter> l2_eq_v = {}", "have \"card l2_neq_v = card l2_v - card l2_eq_v\""], ["proof (prove)\nusing this:\n  finite l2_v\n  l2_v = l2_neq_v \\<union> l2_eq_v\n  l2_neq_v \\<inter> l2_eq_v = {}\n\ngoal (1 subgoal):\n 1. card l2_neq_v = card l2_v - card l2_eq_v", "by (metis Int_commute Nat.add_0_right Un_commute card_Diff_subset_Int card_Un_Int\n                  card_gt_0_iff diff_add_inverse finite_Diff finite_Un inf_sup_absorb\n                  less_nat_zero_code)"], ["proof (state)\nthis:\n  card l2_neq_v = card l2_v - card l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "thus \"card l2_neq_v = k*k-k\""], ["proof (prove)\nusing this:\n  card l2_neq_v = card l2_v - card l2_eq_v\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "using \\<open>card l2_eq_v=k\\<close>"], ["proof (prove)\nusing this:\n  card l2_neq_v = card l2_v - card l2_eq_v\n  card l2_eq_v = k\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "using \\<open>card l2_v=k*k\\<close>"], ["proof (prove)\nusing this:\n  card l2_neq_v = card l2_v - card l2_eq_v\n  card l2_eq_v = k\n  card l2_v = k * k\n\ngoal (1 subgoal):\n 1. card l2_neq_v = k * k - k", "by auto"], ["proof (state)\nthis:\n  card l2_neq_v = k * k - k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card l2_neq_v = k * k - k\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "moreover"], ["proof (state)\nthis:\n  card l2_neq_v = k * k - k\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "have \"bij_betw last l2_neq_v {n. n\\<in>V \\<and> n\\<noteq>v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}", "have \"last ` l2_neq_v = {n. n\\<in>V \\<and> n\\<noteq>v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "have \"\\<And>x. x\\<in> last` l2_neq_v \\<Longrightarrow> x\\<in>{n. n\\<in>V \\<and> n\\<noteq>v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last ` l2_neq_v \\<Longrightarrow>\n       x \\<in> {n \\<in> V. n \\<noteq> v}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last ` l2_neq_v \\<Longrightarrow>\n       x \\<in> V \\<and> x \\<noteq> v", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last ` l2_neq_v \\<Longrightarrow>\n       x \\<in> V \\<and> x \\<noteq> v", "assume \"x\\<in>last` l2_neq_v\""], ["proof (state)\nthis:\n  x \\<in> last ` l2_neq_v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last ` l2_neq_v \\<Longrightarrow>\n       x \\<in> V \\<and> x \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  x \\<in> last ` l2_neq_v", "obtain ps where \"length ps = 2\"  \"adj_path v ps\" \"last ps=x\" \"last ps\\<noteq>v\""], ["proof (prove)\nusing this:\n  x \\<in> last ` l2_neq_v\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>length ps = 2; adj_path v ps; last ps = x;\n         last ps \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using l2_neq_v"], ["proof (prove)\nusing this:\n  x \\<in> last ` l2_neq_v\n  l2_neq_v =\n  {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>length ps = 2; adj_path v ps; last ps = x;\n         last ps \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length ps = 2\n  adj_path v ps\n  last ps = x\n  last ps \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last ` l2_neq_v \\<Longrightarrow>\n       x \\<in> V \\<and> x \\<noteq> v", "hence \"(last ps)\\<in>V\""], ["proof (prove)\nusing this:\n  length ps = 2\n  adj_path v ps\n  last ps = x\n  last ps \\<noteq> v\n\ngoal (1 subgoal):\n 1. last ps \\<in> V", "by (metis (full_types) adj_path_V last_in_set length_0_conv rev_subsetD \n                  zero_neq_numeral)"], ["proof (state)\nthis:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last ` l2_neq_v \\<Longrightarrow>\n       x \\<in> V \\<and> x \\<noteq> v", "thus \" x \\<in> V \\<and> x \\<noteq> v\""], ["proof (prove)\nusing this:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. x \\<in> V \\<and> x \\<noteq> v", "using \\<open>last ps=x\\<close> \\<open>last ps\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  last ps \\<in> V\n  last ps = x\n  last ps \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<in> V \\<and> x \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  x \\<in> V \\<and> x \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> last ` l2_neq_v \\<Longrightarrow>\n  ?x \\<in> {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> last ` l2_neq_v \\<Longrightarrow>\n  ?x \\<in> {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "have \"\\<And>x. x\\<in>{n. n\\<in>V \\<and> n\\<noteq>v} \\<Longrightarrow> x\\<in> last` l2_neq_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "assume x:\"x \\<in> {n \\<in> V. n \\<noteq> v}\""], ["proof (state)\nthis:\n  x \\<in> {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "then"], ["proof (chain)\npicking this:\n  x \\<in> {n \\<in> V. n \\<noteq> v}", "obtain y where \"adjacent v y\" \"adjacent x y\""], ["proof (prove)\nusing this:\n  x \\<in> {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>adjacent v y; adjacent x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[of v x] \\<open>v\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {n \\<in> V. n \\<noteq> v}\n  \\<lbrakk>v \\<in> V; x \\<in> V; v \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent v n \\<and> adjacent x n\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>adjacent v y; adjacent x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adjacent v y\n  adjacent x y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "hence \"adj_path v [y,x]\""], ["proof (prove)\nusing this:\n  adjacent v y\n  adjacent x y\n\ngoal (1 subgoal):\n 1. adj_path v [y, x]", "using adjacent_sym[of x y]"], ["proof (prove)\nusing this:\n  adjacent v y\n  adjacent x y\n  adjacent x y = adjacent y x\n\ngoal (1 subgoal):\n 1. adj_path v [y, x]", "by auto"], ["proof (state)\nthis:\n  adj_path v [y, x]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "hence \"[y,x]\\<in>l2_neq_v\""], ["proof (prove)\nusing this:\n  adj_path v [y, x]\n\ngoal (1 subgoal):\n 1. [y, x] \\<in> l2_neq_v", "using l2_neq_v x"], ["proof (prove)\nusing this:\n  adj_path v [y, x]\n  l2_neq_v =\n  {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps \\<noteq> v}\n  x \\<in> {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. [y, x] \\<in> l2_neq_v", "by auto"], ["proof (state)\nthis:\n  [y, x] \\<in> l2_neq_v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n       x \\<in> last ` l2_neq_v", "thus \"x\\<in> last` l2_neq_v\""], ["proof (prove)\nusing this:\n  [y, x] \\<in> l2_neq_v\n\ngoal (1 subgoal):\n 1. x \\<in> last ` l2_neq_v", "by (metis imageI last.simps not_Cons_self2)"], ["proof (state)\nthis:\n  x \\<in> last ` l2_neq_v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n  ?x \\<in> last ` l2_neq_v\n\ngoal (1 subgoal):\n 1. last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> last ` l2_neq_v \\<Longrightarrow>\n  ?x \\<in> {n \\<in> V. n \\<noteq> v}\n  ?x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n  ?x \\<in> last ` l2_neq_v", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> last ` l2_neq_v \\<Longrightarrow>\n  ?x \\<in> {n \\<in> V. n \\<noteq> v}\n  ?x \\<in> {n \\<in> V. n \\<noteq> v} \\<Longrightarrow>\n  ?x \\<in> last ` l2_neq_v\n\ngoal (1 subgoal):\n 1. last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "by fast"], ["proof (state)\nthis:\n  last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}", "moreover"], ["proof (state)\nthis:\n  last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}", "have \"inj_on last l2_neq_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on last l2_neq_v", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>l2_neq_v.\n       \\<forall>y\\<in>l2_neq_v. last x = last y \\<longrightarrow> x = y", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> l2_neq_v\"  \"y \\<in> l2_neq_v\"  \"last x = last y\""], ["proof (state)\nthis:\n  x \\<in> l2_neq_v\n  y \\<in> l2_neq_v\n  last x = last y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"length x=2\" and \"adj_path v x\" and \"last x\\<noteq>v\" and \"length y=2\" and \"adj_path v y\"\n              and \"last y\\<noteq>v\""], ["proof (prove)\nusing this:\n  x \\<in> l2_neq_v\n  y \\<in> l2_neq_v\n  last x = last y\n\ngoal (1 subgoal):\n 1. (length x = 2 &&& adj_path v x &&& last x \\<noteq> v) &&&\n    length y = 2 &&& adj_path v y &&& last y \\<noteq> v", "using l2_neq_v"], ["proof (prove)\nusing this:\n  x \\<in> l2_neq_v\n  y \\<in> l2_neq_v\n  last x = last y\n  l2_neq_v =\n  {ps. length ps = 2 \\<and> adj_path v ps \\<and> last ps \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (length x = 2 &&& adj_path v x &&& last x \\<noteq> v) &&&\n    length y = 2 &&& adj_path v y &&& last y \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  length x = 2\n  adj_path v x\n  last x \\<noteq> v\n  length y = 2\n  adj_path v y\n  last y \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "obtain x1 x2 y1 y2 where x:\"x=[x1,x2]\" and y:\"y=[y1,y2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"length l=2\""], ["proof (state)\nthis:\n  length l = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain h1 t where \"l=h1#t\" and \"length t=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h1 t.\n        \\<lbrakk>l = h1 # t; length t = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>length l=2\\<close> Suc_length_conv[of 1 l]"], ["proof (prove)\nusing this:\n  length l = 2\n  (Suc 1 = length l) = (\\<exists>y ys. l = y # ys \\<and> length ys = 1)\n\ngoal (1 subgoal):\n 1. (\\<And>h1 t.\n        \\<lbrakk>l = h1 # t; length t = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = h1 # t\n  length t = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  l = h1 # t\n  length t = 1", "obtain h2 where \"t=[h2]\""], ["proof (prove)\nusing this:\n  l = h1 # t\n  length t = 1\n\ngoal (1 subgoal):\n 1. (\\<And>h2. t = [h2] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using Suc_length_conv[of 0 t]"], ["proof (prove)\nusing this:\n  l = h1 # t\n  length t = 1\n  (Suc 0 = length t) = (\\<exists>y ys. t = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>h2. t = [h2] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  t = [h2]\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>h1 h2. l=[h1,h2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h1 h2. l = [h1, h2]", "using \\<open>l=h1#t\\<close> \\<open>t=[h2]\\<close>"], ["proof (prove)\nusing this:\n  l = h1 # t\n  t = [h2]\n\ngoal (1 subgoal):\n 1. \\<exists>h1 h2. l = [h1, h2]", "by auto"], ["proof (state)\nthis:\n  \\<exists>h1 h2. l = [h1, h2]\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  length ?l2 = 2 \\<Longrightarrow> \\<exists>h1 h2. ?l2 = [h1, h2]\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = [x1, x2]; y = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  length ?l2 = 2 \\<Longrightarrow> \\<exists>h1 h2. ?l2 = [h1, h2]\n\ngoal (1 subgoal):\n 1. thesis", "using that \\<open>length x=2\\<close> \\<open>length y=2\\<close>"], ["proof (prove)\nusing this:\n  length ?l2 = 2 \\<Longrightarrow> \\<exists>h1 h2. ?l2 = [h1, h2]\n  \\<lbrakk>x = [?x1.0, ?x2.0]; y = [?y1.0, ?y2.0]\\<rbrakk>\n  \\<Longrightarrow> thesis\n  length x = 2\n  length y = 2\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = [x1, x2]\n  y = [y1, y2]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"x2\\<noteq>v\" and \"y2\\<noteq>v\""], ["proof (prove)\nusing this:\n  x = [x1, x2]\n  y = [y1, y2]\n\ngoal (1 subgoal):\n 1. x2 \\<noteq> v &&& y2 \\<noteq> v", "using \\<open>last x\\<noteq>v\\<close> \\<open>last y\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  x = [x1, x2]\n  y = [y1, y2]\n  last x \\<noteq> v\n  last y \\<noteq> v\n\ngoal (1 subgoal):\n 1. x2 \\<noteq> v &&& y2 \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  x2 \\<noteq> v\n  y2 \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  x2 \\<noteq> v\n  y2 \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"adjacent v x1\" and \"adjacent x2 x1\" and \"x2\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v x1 &&& adjacent x2 x1 &&& x2 \\<in> V", "using \\<open>adj_path v x\\<close> x adjacent_sym"], ["proof (prove)\nusing this:\n  adj_path v x\n  x = [x1, x2]\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent v x1 &&& adjacent x2 x1 &&& x2 \\<in> V", "by auto"], ["proof (state)\nthis:\n  adjacent v x1\n  adjacent x2 x1\n  x2 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  adjacent v x1\n  adjacent x2 x1\n  x2 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"adjacent v y1\" and \"adjacent y2 y1\" and \"y2\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v y1 &&& adjacent y2 y1 &&& y2 \\<in> V", "using \\<open>adj_path v y\\<close> y adjacent_sym"], ["proof (prove)\nusing this:\n  adj_path v y\n  y = [y1, y2]\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent v y1 &&& adjacent y2 y1 &&& y2 \\<in> V", "by auto"], ["proof (state)\nthis:\n  adjacent v y1\n  adjacent y2 y1\n  y2 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  x2 \\<noteq> v\n  y2 \\<noteq> v\n  adjacent v x1\n  adjacent x2 x1\n  x2 \\<in> V\n  adjacent v y1\n  adjacent y2 y1\n  y2 \\<in> V", "have \"x1=y1\""], ["proof (prove)\nusing this:\n  x2 \\<noteq> v\n  y2 \\<noteq> v\n  adjacent v x1\n  adjacent x2 x1\n  x2 \\<in> V\n  adjacent v y1\n  adjacent y2 y1\n  y2 \\<in> V\n\ngoal (1 subgoal):\n 1. x1 = y1", "using friend_assm \\<open>v\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  x2 \\<noteq> v\n  y2 \\<noteq> v\n  adjacent v x1\n  adjacent x2 x1\n  x2 \\<in> V\n  adjacent v y1\n  adjacent y2 y1\n  y2 \\<in> V\n  \\<lbrakk>?v \\<in> V; ?u \\<in> V; ?v \\<noteq> ?u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent ?v n \\<and> adjacent ?u n\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. x1 = y1", "by (metis \\<open>last x = last y\\<close> last_ConsL last_ConsR not_Cons_self2 x y)"], ["proof (state)\nthis:\n  x1 = y1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> l2_neq_v; y \\<in> l2_neq_v; last x = last y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x=y\""], ["proof (prove)\nusing this:\n  x1 = y1\n\ngoal (1 subgoal):\n 1. x = y", "using x y \\<open>last x = last y\\<close>"], ["proof (prove)\nusing this:\n  x1 = y1\n  x = [x1, x2]\n  y = [y1, y2]\n  last x = last y\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on last l2_neq_v\n\ngoal (1 subgoal):\n 1. bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}", "ultimately"], ["proof (chain)\npicking this:\n  last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}\n  inj_on last l2_neq_v", "show ?thesis"], ["proof (prove)\nusing this:\n  last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}\n  inj_on last l2_neq_v\n\ngoal (1 subgoal):\n 1. bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}\n  inj_on last l2_neq_v\n\ngoal (1 subgoal):\n 1. inj_on last l2_neq_v \\<and> last ` l2_neq_v = {n \\<in> V. n \\<noteq> v}", "by auto"], ["proof (state)\nthis:\n  bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "hence \"card l2_neq_v = card {n. n\\<in>V \\<and> n\\<noteq>v}\""], ["proof (prove)\nusing this:\n  bij_betw last l2_neq_v {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card l2_neq_v = card {n \\<in> V. n \\<noteq> v}", "by (metis bij_betw_same_card)"], ["proof (state)\nthis:\n  card l2_neq_v = card {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "ultimately"], ["proof (chain)\npicking this:\n  card l2_neq_v = k * k - k\n  card l2_neq_v = card {n \\<in> V. n \\<noteq> v}", "have \"card {n. n\\<in>V \\<and> n\\<noteq>v}=k*k-k\""], ["proof (prove)\nusing this:\n  card l2_neq_v = k * k - k\n  card l2_neq_v = card {n \\<in> V. n \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card {n \\<in> V. n \\<noteq> v} = k * k - k", "by auto"], ["proof (state)\nthis:\n  card {n \\<in> V. n \\<noteq> v} = k * k - k\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "moreover"], ["proof (state)\nthis:\n  card {n \\<in> V. n \\<noteq> v} = k * k - k\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "have \"card V = card {n. n\\<in>V\\<and>n\\<noteq>v} + card {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "have \"V={n. n\\<in>V \\<and> n\\<noteq>v} \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = {n \\<in> V. n \\<noteq> v} \\<union> {v}", "using \\<open>v\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. V = {n \\<in> V. n \\<noteq> v} \\<union> {v}", "by auto"], ["proof (state)\nthis:\n  V = {n \\<in> V. n \\<noteq> v} \\<union> {v}\n\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "moreover"], ["proof (state)\nthis:\n  V = {n \\<in> V. n \\<noteq> v} \\<union> {v}\n\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "have \"{n. n\\<in>V \\<and> n\\<noteq>v} \\<inter> {v}={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n \\<in> V. n \\<noteq> v} \\<inter> {v} = {}", "by auto"], ["proof (state)\nthis:\n  {n \\<in> V. n \\<noteq> v} \\<inter> {v} = {}\n\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "ultimately"], ["proof (chain)\npicking this:\n  V = {n \\<in> V. n \\<noteq> v} \\<union> {v}\n  {n \\<in> V. n \\<noteq> v} \\<inter> {v} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  V = {n \\<in> V. n \\<noteq> v} \\<union> {v}\n  {n \\<in> V. n \\<noteq> v} \\<inter> {v} = {}\n\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "using \\<open>finite V\\<close> card_Un_disjoint[of \"{n \\<in> V. n \\<noteq> v}\" \"{v}\"] finite_Un"], ["proof (prove)\nusing this:\n  V = {n \\<in> V. n \\<noteq> v} \\<union> {v}\n  {n \\<in> V. n \\<noteq> v} \\<inter> {v} = {}\n  finite V\n  \\<lbrakk>finite {n \\<in> V. n \\<noteq> v}; finite {v};\n   {n \\<in> V. n \\<noteq> v} \\<inter> {v} = {}\\<rbrakk>\n  \\<Longrightarrow> card ({n \\<in> V. n \\<noteq> v} \\<union> {v}) =\n                    card {n \\<in> V. n \\<noteq> v} + card {v}\n  finite (?F \\<union> ?G) = (finite ?F \\<and> finite ?G)\n\ngoal (1 subgoal):\n 1. card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "by auto"], ["proof (state)\nthis:\n  card V = card {n \\<in> V. n \\<noteq> v} + card {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card V = card {n \\<in> V. n \\<noteq> v} + card {v}\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "ultimately"], ["proof (chain)\npicking this:\n  card {n \\<in> V. n \\<noteq> v} = k * k - k\n  card V = card {n \\<in> V. n \\<noteq> v} + card {v}", "show \"card V = k*k-k+1\""], ["proof (prove)\nusing this:\n  card {n \\<in> V. n \\<noteq> v} = k * k - k\n  card V = card {n \\<in> V. n \\<noteq> v} + card {v}\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "by auto"], ["proof (state)\nthis:\n  card V = k * k - k + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_eq:\"rotate1 xs=rotate1 ys \\<Longrightarrow> xs=ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys", "proof (induct xs arbitrary:ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. rotate1 [] = rotate1 ys \\<Longrightarrow> [] = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys;\n        rotate1 (a # xs) = rotate1 ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "case Nil"], ["proof (state)\nthis:\n  rotate1 [] = rotate1 ys\n\ngoal (2 subgoals):\n 1. \\<And>ys. rotate1 [] = rotate1 ys \\<Longrightarrow> [] = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys;\n        rotate1 (a # xs) = rotate1 ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "thus ?case"], ["proof (prove)\nusing this:\n  rotate1 [] = rotate1 ys\n\ngoal (1 subgoal):\n 1. [] = ys", "by (metis rotate1_is_Nil_conv)"], ["proof (state)\nthis:\n  [] = ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys;\n        rotate1 (a # xs) = rotate1 ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys;\n        rotate1 (a # xs) = rotate1 ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "case (Cons n ns)"], ["proof (state)\nthis:\n  rotate1 ns = rotate1 ?ys \\<Longrightarrow> ns = ?ys\n  rotate1 (n # ns) = rotate1 ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys;\n        rotate1 (a # xs) = rotate1 ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "hence \"ys\\<noteq>[]\""], ["proof (prove)\nusing this:\n  rotate1 ns = rotate1 ?ys \\<Longrightarrow> ns = ?ys\n  rotate1 (n # ns) = rotate1 ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by (metis list.distinct(1) rotate1_is_Nil_conv)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. rotate1 xs = rotate1 ys \\<Longrightarrow> xs = ys;\n        rotate1 (a # xs) = rotate1 ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "thus \"?case\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. n # ns = ys", "using Cons"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  rotate1 ns = rotate1 ?ys \\<Longrightarrow> ns = ?ys\n  rotate1 (n # ns) = rotate1 ys\n\ngoal (1 subgoal):\n 1. n # ns = ys", "by (metis butlast_snoc last_snoc list.exhaust rotate1.simps(2))"], ["proof (state)\nthis:\n  n # ns = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_diff:\"rotate m xs=rotate n xs \\<Longrightarrow>rotate (m-n) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate m xs = rotate n xs \\<Longrightarrow> rotate (m - n) xs = xs", "proof (induct m arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       rotate 0 xs = rotate n xs \\<Longrightarrow> rotate (0 - n) xs = xs\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "case 0"], ["proof (state)\nthis:\n  rotate 0 xs = rotate n xs\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       rotate 0 xs = rotate n xs \\<Longrightarrow> rotate (0 - n) xs = xs\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "thus ?case"], ["proof (prove)\nusing this:\n  rotate 0 xs = rotate n xs\n\ngoal (1 subgoal):\n 1. rotate (0 - n) xs = xs", "by auto"], ["proof (state)\nthis:\n  rotate (0 - n) xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "case (Suc m')"], ["proof (state)\nthis:\n  rotate m' xs = rotate ?n xs \\<Longrightarrow> rotate (m' - ?n) xs = xs\n  rotate (Suc m') xs = rotate n xs\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "hence \"n=0 \\<Longrightarrow> ?case\""], ["proof (prove)\nusing this:\n  rotate m' xs = rotate ?n xs \\<Longrightarrow> rotate (m' - ?n) xs = xs\n  rotate (Suc m') xs = rotate n xs\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "by auto"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "moreover"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "have \"n\\<noteq>0 \\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "assume \"n\\<noteq>0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain n' where n': \"n = Suc n'\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = Suc n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis nat.exhaust)"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "hence \"rotate m' xs = rotate n' xs\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. rotate m' xs = rotate n' xs", "using \\<open>rotate (Suc m') xs = rotate n xs\\<close> rotate_eq rotate_Suc"], ["proof (prove)\nusing this:\n  n = Suc n'\n  rotate (Suc m') xs = rotate n xs\n  rotate1 ?xs = rotate1 ?ys \\<Longrightarrow> ?xs = ?ys\n  rotate (Suc ?n) ?xs = rotate1 (rotate ?n ?xs)\n\ngoal (1 subgoal):\n 1. rotate m' xs = rotate n' xs", "by auto"], ["proof (state)\nthis:\n  rotate m' xs = rotate n' xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "hence \"rotate (m' - n') xs = xs\""], ["proof (prove)\nusing this:\n  rotate m' xs = rotate n' xs\n\ngoal (1 subgoal):\n 1. rotate (m' - n') xs = xs", "by (metis Suc.hyps)"], ["proof (state)\nthis:\n  rotate (m' - n') xs = xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "moreover"], ["proof (state)\nthis:\n  rotate (m' - n') xs = xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "have \"Suc m' - n = m'-n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m' - n = m' - n'", "by (metis n' diff_Suc_Suc)"], ["proof (state)\nthis:\n  Suc m' - n = m' - n'\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "ultimately"], ["proof (chain)\npicking this:\n  rotate (m' - n') xs = xs\n  Suc m' - n = m' - n'", "show ?case"], ["proof (prove)\nusing this:\n  rotate (m' - n') xs = xs\n  Suc m' - n = m' - n'\n\ngoal (1 subgoal):\n 1. rotate (Suc m' - n) xs = xs", "by auto"], ["proof (state)\nthis:\n  rotate (Suc m' - n) xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   rotate m xs = rotate n xs \\<Longrightarrow>\n                   rotate (m - n) xs = xs;\n        rotate (Suc m) xs = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc m - n) xs = xs", "ultimately"], ["proof (chain)\npicking this:\n  n = 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs\n  n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs", "show ?case"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs\n  n \\<noteq> 0 \\<Longrightarrow> rotate (Suc m' - n) xs = xs\n\ngoal (1 subgoal):\n 1. rotate (Suc m' - n) xs = xs", "by fast"], ["proof (state)\nthis:\n  rotate (Suc m' - n) xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in valid_unSimpGraph) exist_degree_two:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n      and \"finite E\" and \"finite V\" and \"card V\\<ge>2\" \n  shows \"\\<exists>v\\<in>V. degree v G = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. degree v G = 2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>v\\<in>V. degree v G = 2)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>V. degree v G = 2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "hence \"\\<And>v. v\\<in>V \\<Longrightarrow> degree v G\\<noteq>2\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>V. degree v G = 2)\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> degree v G \\<noteq> 2", "by auto"], ["proof (state)\nthis:\n  ?v \\<in> V \\<Longrightarrow> degree ?v G \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "obtain k where k_adj: \"\\<And>v. v\\<in>V\\<Longrightarrow> card {n. adjacent v n}=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (\\<And>v.\n            v \\<in> V \\<Longrightarrow>\n            card {n. adjacent v n} = k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using regular[OF friend_assm]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u;\n   finite E; finite V; \\<not> (\\<exists>v\\<in>V. degree v G = 2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. \\<forall>v\\<in>V. degree v G = k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (\\<And>v.\n            v \\<in> V \\<Longrightarrow>\n            card {n. adjacent v n} = k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>\\<not> (\\<exists>v\\<in>V. degree v G = 2)\\<close> assms(2) assms(3) degree_adjacent)"], ["proof (state)\nthis:\n  ?v \\<in> V \\<Longrightarrow> card {n. adjacent ?v n} = k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "have \"k\\<ge>4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 \\<le> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 4 \\<le> k", "obtain v1 v2 where \"v1\\<in>V\" \"v2\\<in>V\" \"v1\\<noteq>v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>card V\\<ge>2\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        \\<lbrakk>v1 \\<in> V; v2 \\<in> V; v1 \\<noteq> v2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>\\<not>(\\<exists>v\\<in>V. degree v G = 2)\\<close> assms(2) degree_two_windmill)"], ["proof (state)\nthis:\n  v1 \\<in> V\n  v2 \\<in> V\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "have \"k\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "assume \"k=0\""], ["proof (state)\nthis:\n  k = 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "obtain v3 where \"adjacent v1 v3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v3. adjacent v1 v3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using friend_assm[OF \\<open>v1\\<in>V\\<close> \\<open>v2\\<in>V\\<close> \\<open>v1\\<noteq>v2\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>!n. adjacent v1 n \\<and> adjacent v2 n\n\ngoal (1 subgoal):\n 1. (\\<And>v3. adjacent v1 v3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adjacent v1 v3\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "hence \"card {n. adjacent v1 n} \\<noteq> 0\""], ["proof (prove)\nusing this:\n  adjacent v1 v3\n\ngoal (1 subgoal):\n 1. card {n. adjacent v1 n} \\<noteq> 0", "using adjacent_finite[OF \\<open>finite E\\<close>]"], ["proof (prove)\nusing this:\n  adjacent v1 v3\n  finite {n. adjacent ?v n}\n\ngoal (1 subgoal):\n 1. card {n. adjacent v1 n} \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card {n. adjacent v1 n} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card {n. adjacent v1 n} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "have \"card {n. adjacent v1 n} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {n. adjacent v1 n} = 0", "using k_adj[OF \\<open>v1\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  card {n. adjacent v1 n} = k\n\ngoal (1 subgoal):\n 1. card {n. adjacent v1 n} = 0", "by (metis \\<open>k = 0\\<close>)"], ["proof (state)\nthis:\n  card {n. adjacent v1 n} = 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  card {n. adjacent v1 n} \\<noteq> 0\n  card {n. adjacent v1 n} = 0", "show False"], ["proof (prove)\nusing this:\n  card {n. adjacent v1 n} \\<noteq> 0\n  card {n. adjacent v1 n} = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "moreover"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "have \"even k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even k", "using even_degree[OF friend_assm]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u;\n   finite E\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>V. even (degree v G)\n\ngoal (1 subgoal):\n 1. even k", "by (metis \\<open>v1 \\<in> V\\<close> assms(2) degree_adjacent k_adj)"], ["proof (state)\nthis:\n  even k\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "hence \"k\\<noteq>1\" and \"k\\<noteq>3\""], ["proof (prove)\nusing this:\n  even k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 &&& k \\<noteq> 3", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 1\n  k \\<noteq> 3\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "moreover"], ["proof (state)\nthis:\n  k \\<noteq> 1\n  k \\<noteq> 3\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "have \"k\\<noteq>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 2", "using \\<open>\\<And>v. v\\<in>V \\<Longrightarrow> degree v G\\<noteq>2\\<close> degree_adjacent k_adj"], ["proof (prove)\nusing this:\n  ?v \\<in> V \\<Longrightarrow> degree ?v G \\<noteq> 2\n  finite E \\<Longrightarrow> degree ?v G = card {n. adjacent ?v n}\n  ?v \\<in> V \\<Longrightarrow> card {n. adjacent ?v n} = k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 2", "by (metis \\<open>v1 \\<in> V\\<close> assms(2))"], ["proof (state)\nthis:\n  k \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "ultimately"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k \\<noteq> 1\n  k \\<noteq> 3\n  k \\<noteq> 2", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k \\<noteq> 1\n  k \\<noteq> 3\n  k \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 4 \\<le> k", "by auto"], ["proof (state)\nthis:\n  4 \\<le> k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "obtain T where T:\"T=(\\<lambda>l::nat. {ps. length ps = l+1 \\<and> adj_path (hd ps) (tl ps)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        T =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and>\n             adj_path (hd ps) (tl ps)}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "have T_count:\"\\<And>l::nat. card (T l) = (k*k-k+1)*k^l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l. card (T l) = (k * k - k + 1) * k ^ l", "using card_partition'"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v\\<in>?A. card {n. ?R v n} = ?k; 0 < ?k; finite ?A;\n   \\<forall>v1 v2.\n      v1 \\<noteq> v2 \\<longrightarrow>\n      {n. ?R v1 n} \\<inter> {n. ?R v2 n} = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union>v\\<in>?A. {n. ?R v n}) = ?k * card ?A\n\ngoal (1 subgoal):\n 1. \\<And>l. card (T l) = (k * k - k + 1) * k ^ l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "fix l::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "obtain ext where ext:\"ext=(\\<lambda>v ps. adj_path v (tl ps) \\<and> hd ps=v \\<and> length ps=l+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ext.\n        ext =\n        (\\<lambda>v ps.\n            adj_path v (tl ps) \\<and>\n            hd ps = v \\<and> length ps = l + 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ext =\n  (\\<lambda>v ps.\n      adj_path v (tl ps) \\<and> hd ps = v \\<and> length ps = l + 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "have \"\\<forall>v\\<in>V. card {ps. ext v ps} = k^l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. card {ps. ext v ps} = k ^ l", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "assume \"v \\<in> V\""], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "have \"\\<And>ps. ps\\<in>tl ` {ps. ext v ps} \\<Longrightarrow>  ps\\<in>{ps. length ps=l \\<and> adj_path v ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "assume  \"ps \\<in> tl ` {ps. ext v ps}\""], ["proof (state)\nthis:\n  ps \\<in> tl ` {ps. ext v ps}\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "then"], ["proof (chain)\npicking this:\n  ps \\<in> tl ` {ps. ext v ps}", "obtain ps' where \"adj_path v (tl ps')\" \"hd ps'=v\" \"length ps'=l+1\" \"ps=tl ps'\""], ["proof (prove)\nusing this:\n  ps \\<in> tl ` {ps. ext v ps}\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        \\<lbrakk>adj_path v (tl ps'); hd ps' = v; length ps' = l + 1;\n         ps = tl ps'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ext"], ["proof (prove)\nusing this:\n  ps \\<in> tl ` {ps. ext v ps}\n  ext =\n  (\\<lambda>v ps.\n      adj_path v (tl ps) \\<and> hd ps = v \\<and> length ps = l + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        \\<lbrakk>adj_path v (tl ps'); hd ps' = v; length ps' = l + 1;\n         ps = tl ps'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adj_path v (tl ps')\n  hd ps' = v\n  length ps' = l + 1\n  ps = tl ps'\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "hence \"adj_path v ps\" and \"length ps=l\""], ["proof (prove)\nusing this:\n  adj_path v (tl ps')\n  hd ps' = v\n  length ps' = l + 1\n  ps = tl ps'\n\ngoal (1 subgoal):\n 1. adj_path v ps &&& length ps = l", "by auto"], ["proof (state)\nthis:\n  adj_path v ps\n  length ps = l\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "thus \"ps\\<in>{ps. length ps=l \\<and> adj_path v ps}\""], ["proof (prove)\nusing this:\n  adj_path v ps\n  length ps = l\n\ngoal (1 subgoal):\n 1. ps \\<in> {ps. length ps = l \\<and> adj_path v ps}", "by auto"], ["proof (state)\nthis:\n  ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "moreover"], ["proof (state)\nthis:\n  ?ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "have \"\\<And>ps. ps\\<in>{ps. length ps=l \\<and> adj_path v ps} \\<Longrightarrow> ps\\<in> tl ` {ps. ext v ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "assume \"ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\""], ["proof (state)\nthis:\n  ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "hence \"length ps=l\" and \"adj_path v ps\""], ["proof (prove)\nusing this:\n  ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. length ps = l &&& adj_path v ps", "by auto"], ["proof (state)\nthis:\n  length ps = l\n  adj_path v ps\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "moreover"], ["proof (state)\nthis:\n  length ps = l\n  adj_path v ps\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "obtain ps' where \"ps'=v#ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps'. ps' = v # ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps' = v # ps\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "ultimately"], ["proof (chain)\npicking this:\n  length ps = l\n  adj_path v ps\n  ps' = v # ps", "have \"adj_path v (tl ps')\" and \"hd ps'=v\" and \"length ps'=l+1\""], ["proof (prove)\nusing this:\n  length ps = l\n  adj_path v ps\n  ps' = v # ps\n\ngoal (1 subgoal):\n 1. adj_path v (tl ps') &&& hd ps' = v &&& length ps' = l + 1", "by auto"], ["proof (state)\nthis:\n  adj_path v (tl ps')\n  hd ps' = v\n  length ps' = l + 1\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n       ps \\<in> tl ` {ps. ext v ps}", "thus \"ps \\<in> tl ` {ps. ext v ps}\""], ["proof (prove)\nusing this:\n  adj_path v (tl ps')\n  hd ps' = v\n  length ps' = l + 1\n\ngoal (1 subgoal):\n 1. ps \\<in> tl ` {ps. ext v ps}", "by (metis \\<open>ps' = v # ps\\<close> ext imageI mem_Collect_eq list.sel(3))"], ["proof (state)\nthis:\n  ps \\<in> tl ` {ps. ext v ps}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n  ?ps \\<in> tl ` {ps. ext v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "ultimately"], ["proof (chain)\npicking this:\n  ?ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n  ?ps \\<in> tl ` {ps. ext v ps}", "have \"tl ` {ps. ext v ps} = {ps. length ps=l \\<and> adj_path v ps}\""], ["proof (prove)\nusing this:\n  ?ps \\<in> tl ` {ps. ext v ps} \\<Longrightarrow>\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps}\n  ?ps \\<in> {ps. length ps = l \\<and> adj_path v ps} \\<Longrightarrow>\n  ?ps \\<in> tl ` {ps. ext v ps}\n\ngoal (1 subgoal):\n 1. tl ` {ps. ext v ps} = {ps. length ps = l \\<and> adj_path v ps}", "by fast"], ["proof (state)\nthis:\n  tl ` {ps. ext v ps} = {ps. length ps = l \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "moreover"], ["proof (state)\nthis:\n  tl ` {ps. ext v ps} = {ps. length ps = l \\<and> adj_path v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "have \"inj_on tl {ps. ext v ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on tl {ps. ext v ps}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Collect (ext v).\n       \\<forall>y\\<in>Collect (ext v). tl x = tl y \\<longrightarrow> x = y", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Collect (ext v); y \\<in> Collect (ext v);\n        tl x = tl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Collect (ext v); y \\<in> Collect (ext v);\n        tl x = tl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> Collect (ext v)\"  \"y \\<in> Collect (ext v)\"  \"tl x = tl y\""], ["proof (state)\nthis:\n  x \\<in> Collect (ext v)\n  y \\<in> Collect (ext v)\n  tl x = tl y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Collect (ext v); y \\<in> Collect (ext v);\n        tl x = tl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"hd x=hd y\" and \"x\\<noteq>[]\" and \"y\\<noteq>[]\""], ["proof (prove)\nusing this:\n  x \\<in> Collect (ext v)\n  y \\<in> Collect (ext v)\n  tl x = tl y\n\ngoal (1 subgoal):\n 1. hd x = hd y &&& x \\<noteq> [] &&& y \\<noteq> []", "using ext"], ["proof (prove)\nusing this:\n  x \\<in> Collect (ext v)\n  y \\<in> Collect (ext v)\n  tl x = tl y\n  ext =\n  (\\<lambda>v ps.\n      adj_path v (tl ps) \\<and> hd ps = v \\<and> length ps = l + 1)\n\ngoal (1 subgoal):\n 1. hd x = hd y &&& x \\<noteq> [] &&& y \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  hd x = hd y\n  x \\<noteq> []\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Collect (ext v); y \\<in> Collect (ext v);\n        tl x = tl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x=y\""], ["proof (prove)\nusing this:\n  hd x = hd y\n  x \\<noteq> []\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>tl x= tl y\\<close>"], ["proof (prove)\nusing this:\n  hd x = hd y\n  x \\<noteq> []\n  y \\<noteq> []\n  tl x = tl y\n\ngoal (1 subgoal):\n 1. x = y", "by (metis list.sel(1,3) list.exhaust)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on tl {ps. ext v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "moreover"], ["proof (state)\nthis:\n  inj_on tl {ps. ext v ps}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "have \"card {ps. length ps=l \\<and> adj_path v ps} = k^l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {ps. length ps = l \\<and> adj_path v ps} = k ^ l", "using path_count[OF k_adj,of v l]  \\<open>4 \\<le> k\\<close> \\<open>v \\<in> V\\<close> assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>v. v \\<in> V \\<Longrightarrow> v \\<in> V; v \\<in> V;\n   finite V; 0 < k\\<rbrakk>\n  \\<Longrightarrow> card {ps. length ps = l \\<and> adj_path v ps} = k ^ l\n  4 \\<le> k\n  v \\<in> V\n  finite V\n\ngoal (1 subgoal):\n 1. card {ps. length ps = l \\<and> adj_path v ps} = k ^ l", "by auto"], ["proof (state)\nthis:\n  card {ps. length ps = l \\<and> adj_path v ps} = k ^ l\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> V \\<Longrightarrow> card {ps. ext v ps} = k ^ l", "ultimately"], ["proof (chain)\npicking this:\n  tl ` {ps. ext v ps} = {ps. length ps = l \\<and> adj_path v ps}\n  inj_on tl {ps. ext v ps}\n  card {ps. length ps = l \\<and> adj_path v ps} = k ^ l", "show \" card {ps. ext v ps} = k ^ l\""], ["proof (prove)\nusing this:\n  tl ` {ps. ext v ps} = {ps. length ps = l \\<and> adj_path v ps}\n  inj_on tl {ps. ext v ps}\n  card {ps. length ps = l \\<and> adj_path v ps} = k ^ l\n\ngoal (1 subgoal):\n 1. card {ps. ext v ps} = k ^ l", "by (metis card_image)"], ["proof (state)\nthis:\n  card {ps. ext v ps} = k ^ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V. card {ps. ext v ps} = k ^ l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V. card {ps. ext v ps} = k ^ l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "have \"\\<forall>v1 v2. v1 \\<noteq> v2 \\<longrightarrow> {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v1 v2.\n       v1 \\<noteq> v2 \\<longrightarrow>\n       {n. ext v1 n} \\<inter> {n. ext v2 n} = {}", "using ext"], ["proof (prove)\nusing this:\n  ext =\n  (\\<lambda>v ps.\n      adj_path v (tl ps) \\<and> hd ps = v \\<and> length ps = l + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>v1 v2.\n       v1 \\<noteq> v2 \\<longrightarrow>\n       {n. ext v1 n} \\<inter> {n. ext v2 n} = {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>v1 v2.\n     v1 \\<noteq> v2 \\<longrightarrow>\n     {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "moreover"], ["proof (state)\nthis:\n  \\<forall>v1 v2.\n     v1 \\<noteq> v2 \\<longrightarrow>\n     {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "have \"(\\<Union>v\\<in>V. {n. ext v n})=T l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>V. {n. ext v n}) = T l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>V. {n. ext v n}) = T l", "have \"\\<And>ps. ps\\<in>(\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow> ps\\<in>T l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow>\n       ps \\<in> T l", "using T"], ["proof (prove)\nusing this:\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow>\n       ps \\<in> T l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<in> (\\<Union>v\\<in>V. {n. ext v n});\n        T =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\\<rbrakk>\n       \\<Longrightarrow> ps \\<in> T l", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<in> (\\<Union>v\\<in>V. {n. ext v n});\n        T =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\\<rbrakk>\n       \\<Longrightarrow> ps \\<in> T l", "assume \"ps\\<in>(\\<Union>v\\<in>V. {n. ext v n})\""], ["proof (state)\nthis:\n  ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<in> (\\<Union>v\\<in>V. {n. ext v n});\n        T =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\\<rbrakk>\n       \\<Longrightarrow> ps \\<in> T l", "then"], ["proof (chain)\npicking this:\n  ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "obtain v where \"v\\<in>V\" \"adj_path v (tl ps)\" \"hd ps = v\" \"length ps = l + 1\""], ["proof (prove)\nusing this:\n  ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> V; adj_path v (tl ps); hd ps = v;\n         length ps = l + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ext"], ["proof (prove)\nusing this:\n  ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})\n  ext =\n  (\\<lambda>v ps.\n      adj_path v (tl ps) \\<and> hd ps = v \\<and> length ps = l + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> V; adj_path v (tl ps); hd ps = v;\n         length ps = l + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> V\n  adj_path v (tl ps)\n  hd ps = v\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<in> (\\<Union>v\\<in>V. {n. ext v n});\n        T =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\\<rbrakk>\n       \\<Longrightarrow> ps \\<in> T l", "hence \"length ps = l + 1\" and  \"adj_path (hd ps) (tl ps)\""], ["proof (prove)\nusing this:\n  v \\<in> V\n  adj_path v (tl ps)\n  hd ps = v\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. length ps = l + 1 &&& adj_path (hd ps) (tl ps)", "by auto"], ["proof (state)\nthis:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>ps \\<in> (\\<Union>v\\<in>V. {n. ext v n});\n        T =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\\<rbrakk>\n       \\<Longrightarrow> ps \\<in> T l", "thus \"ps\\<in>T l\""], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. ps \\<in> T l", "using T"], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. ps \\<in> T l", "by auto"], ["proof (state)\nthis:\n  ps \\<in> T l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow> ?ps \\<in> T l\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>V. {n. ext v n}) = T l", "moreover"], ["proof (state)\nthis:\n  ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow> ?ps \\<in> T l\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>V. {n. ext v n}) = T l", "have \"\\<And>ps. ps\\<in>T l \\<Longrightarrow> ps\\<in>(\\<Union>v\\<in>V. {n. ext v n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "assume \"ps\\<in>T l\""], ["proof (state)\nthis:\n  ps \\<in> T l\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "hence \"length ps = l + 1\" and  \"adj_path (hd ps) (tl ps)\""], ["proof (prove)\nusing this:\n  ps \\<in> T l\n\ngoal (1 subgoal):\n 1. length ps = l + 1 &&& adj_path (hd ps) (tl ps)", "using T"], ["proof (prove)\nusing this:\n  ps \\<in> T l\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. length ps = l + 1 &&& adj_path (hd ps) (tl ps)", "by auto"], ["proof (state)\nthis:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "moreover"], ["proof (state)\nthis:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "then"], ["proof (chain)\npicking this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)", "obtain v where \"v=hd ps\" \"v\\<in>V\""], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v = hd ps; v \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis adj_path.simps(1) adj_path.simps(2) adjacent_V(1) list.exhaust)"], ["proof (state)\nthis:\n  v = hd ps\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> T l \\<Longrightarrow>\n       ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "ultimately"], ["proof (chain)\npicking this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  v = hd ps\n  v \\<in> V", "show \"ps\\<in>(\\<Union>v\\<in>V. {n. ext v n})\""], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  v = hd ps\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "using ext"], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  v = hd ps\n  v \\<in> V\n  ext =\n  (\\<lambda>v ps.\n      adj_path v (tl ps) \\<and> hd ps = v \\<and> length ps = l + 1)\n\ngoal (1 subgoal):\n 1. ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "by auto"], ["proof (state)\nthis:\n  ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?ps \\<in> T l \\<Longrightarrow> ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>V. {n. ext v n}) = T l", "ultimately"], ["proof (chain)\npicking this:\n  ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow> ?ps \\<in> T l\n  ?ps \\<in> T l \\<Longrightarrow> ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})", "show ?thesis"], ["proof (prove)\nusing this:\n  ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n}) \\<Longrightarrow> ?ps \\<in> T l\n  ?ps \\<in> T l \\<Longrightarrow> ?ps \\<in> (\\<Union>v\\<in>V. {n. ext v n})\n\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>V. {n. ext v n}) = T l", "by auto"], ["proof (state)\nthis:\n  (\\<Union>v\\<in>V. {n. ext v n}) = T l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>v\\<in>V. {n. ext v n}) = T l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>V. card {ps. ext v ps} = k ^ l\n  \\<forall>v1 v2.\n     v1 \\<noteq> v2 \\<longrightarrow>\n     {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\n  (\\<Union>v\\<in>V. {n. ext v n}) = T l", "have \"card (T l) = card V * k^l\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V. card {ps. ext v ps} = k ^ l\n  \\<forall>v1 v2.\n     v1 \\<noteq> v2 \\<longrightarrow>\n     {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\n  (\\<Union>v\\<in>V. {n. ext v n}) = T l\n\ngoal (1 subgoal):\n 1. card (T l) = card V * k ^ l", "using card_partition'[of V ext \"k^l\"] \\<open> 4 \\<le> k \\<close> assms(3) mult.commute nat_one_le_power"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V. card {ps. ext v ps} = k ^ l\n  \\<forall>v1 v2.\n     v1 \\<noteq> v2 \\<longrightarrow>\n     {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\n  (\\<Union>v\\<in>V. {n. ext v n}) = T l\n  \\<lbrakk>\\<forall>v\\<in>V. card {n. ext v n} = k ^ l; 0 < k ^ l; finite V;\n   \\<forall>v1 v2.\n      v1 \\<noteq> v2 \\<longrightarrow>\n      {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union>v\\<in>V. {n. ext v n}) = k ^ l * card V\n  4 \\<le> k\n  finite V\n  ?a * ?b = ?b * ?a\n  Suc 0 \\<le> ?i \\<Longrightarrow> Suc 0 \\<le> ?i ^ ?n\n\ngoal (1 subgoal):\n 1. card (T l) = card V * k ^ l", "by auto"], ["proof (state)\nthis:\n  card (T l) = card V * k ^ l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "moreover"], ["proof (state)\nthis:\n  card (T l) = card V * k ^ l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "have \"card V=(k * k - k + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "using total_v_num[OF friend_assm,of k] k_adj degree_adjacent \\<open>finite E\\<close> \\<open>finite V\\<close> \n          \\<open>card V\\<ge>2\\<close> \\<open>4 \\<le> k\\<close> card_gt_0_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u;\n   finite E; finite V; V \\<noteq> {}; \\<forall>v\\<in>V. degree v G = k;\n   0 < k\\<rbrakk>\n  \\<Longrightarrow> card V = k * k - k + 1\n  ?v \\<in> V \\<Longrightarrow> card {n. adjacent ?v n} = k\n  finite E \\<Longrightarrow> degree ?v G = card {n. adjacent ?v n}\n  finite E\n  finite V\n  2 \\<le> card V\n  4 \\<le> k\n  (0 < card ?A) = (?A \\<noteq> {} \\<and> finite ?A)\n\ngoal (1 subgoal):\n 1. card V = k * k - k + 1", "by force"], ["proof (state)\nthis:\n  card V = k * k - k + 1\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>A R k.\n           \\<lbrakk>\\<forall>v\\<in>A. card {n. R v n} = k; 0 < k; finite A;\n            \\<forall>v1 v2.\n               v1 \\<noteq> v2 \\<longrightarrow>\n               {n. R v1 n} \\<inter> {n. R v2 n} = {}\\<rbrakk>\n           \\<Longrightarrow> card (\\<Union>v\\<in>A. {n. R v n}) =\n                             k * card A) \\<Longrightarrow>\n       card (T l) = (k * k - k + 1) * k ^ l", "ultimately"], ["proof (chain)\npicking this:\n  card (T l) = card V * k ^ l\n  card V = k * k - k + 1", "show \"card (T l) = (k * k - k + 1) * k ^ l\""], ["proof (prove)\nusing this:\n  card (T l) = card V * k ^ l\n  card V = k * k - k + 1\n\ngoal (1 subgoal):\n 1. card (T l) = (k * k - k + 1) * k ^ l", "by auto"], ["proof (state)\nthis:\n  card (T l) = (k * k - k + 1) * k ^ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (T ?l) = (k * k - k + 1) * k ^ ?l\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "obtain C where C:\"C=(\\<lambda>l::nat. {ps. length ps = l+1 \\<and> adj_path (hd ps) (tl ps) \n      \\<and> adjacent (last ps) (hd ps)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        C =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and>\n             adj_path (hd ps) (tl ps) \\<and>\n             adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "obtain C_star where C_star:\"C_star=(\\<lambda>l::nat. {ps. length ps = l+1 \\<and> adj_path (hd ps) (tl ps) \n      \\<and> (last ps) = (hd ps)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C_star.\n        C_star =\n        (\\<lambda>l.\n            {ps.\n             length ps = l + 1 \\<and>\n             adj_path (hd ps) (tl ps) \\<and>\n             last ps = hd ps}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "have \"\\<And>l::nat. card (C (l+1)) = k* card (C_star l) + card (T l - C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "fix l::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "have \"C (l+1) = {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)\n          \\<and> last (butlast ps)=hd ps} \\<union> {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n          adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (l + 1) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}", "using C"], ["proof (prove)\nusing this:\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n\ngoal (1 subgoal):\n 1. C (l + 1) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}", "by auto"], ["proof (state)\nthis:\n  C (l + 1) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  C (l + 1) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "have \" {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)\n          \\<and> last (butlast ps)=hd ps} \\<inter> {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n          adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps} ={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "have \"finite (C (l+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "have \"C (l+1) \\<subseteq> T (l+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (l + 1) \\<subseteq> T (l + 1)", "using C T"], ["proof (prove)\nusing this:\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. C (l + 1) \\<subseteq> T (l + 1)", "by auto"], ["proof (state)\nthis:\n  C (l + 1) \\<subseteq> T (l + 1)\n\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "moreover"], ["proof (state)\nthis:\n  C (l + 1) \\<subseteq> T (l + 1)\n\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "have \"(k * k - k + 1) * k ^ (l + 1)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ (l + 1) \\<noteq> 0", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ (l + 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (k * k - k + 1) * k ^ (l + 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "hence \"finite (T (l+1))\""], ["proof (prove)\nusing this:\n  (k * k - k + 1) * k ^ (l + 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (T (l + 1))", "using T_count[of \"l+1\"]"], ["proof (prove)\nusing this:\n  (k * k - k + 1) * k ^ (l + 1) \\<noteq> 0\n  card (T (l + 1)) = (k * k - k + 1) * k ^ (l + 1)\n\ngoal (1 subgoal):\n 1. finite (T (l + 1))", "by (metis card.infinite)"], ["proof (state)\nthis:\n  finite (T (l + 1))\n\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "ultimately"], ["proof (chain)\npicking this:\n  C (l + 1) \\<subseteq> T (l + 1)\n  finite (T (l + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  C (l + 1) \\<subseteq> T (l + 1)\n  finite (T (l + 1))\n\ngoal (1 subgoal):\n 1. finite (C (l + 1))", "by (metis finite_subset)"], ["proof (state)\nthis:\n  finite (C (l + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (C (l + 1))\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  C (l + 1) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  {}\n  finite (C (l + 1))", "have \"card (C (l+1)) = card {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \n          \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)=hd ps} + card {ps. length ps = l+2 \\<and> \n          adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}\""], ["proof (prove)\nusing this:\n  C (l + 1) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  {}\n  finite (C (l + 1))\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) =\n    card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} +\n    card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}", "using card_Un_disjoint[of \"{ps. length ps = l + 2 \\<and> adj_path (hd ps) (tl ps) \\<and> adjacent \n          (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\" \"{ps. length ps = l + 2 \\<and> adj_path (hd ps) \n          (tl ps) \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\"] finite_Un"], ["proof (prove)\nusing this:\n  C (l + 1) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<union>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  {}\n  finite (C (l + 1))\n  \\<lbrakk>finite\n            {ps.\n             length ps = l + 2 \\<and>\n             adj_path (hd ps) (tl ps) \\<and>\n             adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps};\n   finite\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps};\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} \\<inter>\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n   {}\\<rbrakk>\n  \\<Longrightarrow> card\n                     ({ps.\n                       length ps = l + 2 \\<and>\n                       adj_path (hd ps) (tl ps) \\<and>\n                       adjacent (last ps) (hd ps) \\<and>\n                       last (butlast ps) = hd ps} \\<union>\n                      {ps.\n                       length ps = l + 2 \\<and>\n                       adj_path (hd ps) (tl ps) \\<and>\n                       adjacent (last ps) (hd ps) \\<and>\n                       last (butlast ps) \\<noteq> hd ps}) =\n                    card\n                     {ps.\n                      length ps = l + 2 \\<and>\n                      adj_path (hd ps) (tl ps) \\<and>\n                      adjacent (last ps) (hd ps) \\<and>\n                      last (butlast ps) = hd ps} +\n                    card\n                     {ps.\n                      length ps = l + 2 \\<and>\n                      adj_path (hd ps) (tl ps) \\<and>\n                      adjacent (last ps) (hd ps) \\<and>\n                      last (butlast ps) \\<noteq> hd ps}\n  finite (?F \\<union> ?G) = (finite ?F \\<and> finite ?G)\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) =\n    card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} +\n    card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}", "by auto"], ["proof (state)\nthis:\n  card (C (l + 1)) =\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} +\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  card (C (l + 1)) =\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} +\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "have \"card {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \n          \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)=hd ps}=k * card (C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "obtain ext where ext: \"ext=(\\<lambda>ps ps'.  ps'\\<noteq>[] \\<and> (butlast ps'=ps) \n              \\<and> adj_path (hd ps') (tl ps'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ext.\n        ext =\n        (\\<lambda>ps ps'.\n            ps' \\<noteq> [] \\<and>\n            butlast ps' = ps \\<and>\n            adj_path (hd ps') (tl ps')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and>\n      butlast ps' = ps \\<and> adj_path (hd ps') (tl ps'))\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "have \"\\<forall>ps\\<in>(C_star l). card {ps'. ext ps ps'} = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<in>C_star l. card {ps'. ext ps ps'} = k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "assume \"ps\\<in>C_star l\""], ["proof (state)\nthis:\n  ps \\<in> C_star l\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "hence \"length ps = l + 1\" and \"adj_path (hd ps) (tl ps)\" and \"last ps = hd ps\""], ["proof (prove)\nusing this:\n  ps \\<in> C_star l\n\ngoal (1 subgoal):\n 1. length ps = l + 1 &&& adj_path (hd ps) (tl ps) &&& last ps = hd ps", "using C_star"], ["proof (prove)\nusing this:\n  ps \\<in> C_star l\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n\ngoal (1 subgoal):\n 1. length ps = l + 1 &&& adj_path (hd ps) (tl ps) &&& last ps = hd ps", "by auto"], ["proof (state)\nthis:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps = hd ps\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "obtain qs where qs:\"qs={v. adjacent (last ps) v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        qs = {v. adjacent (last ps) v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qs = {v. adjacent (last ps) v}\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "obtain app where app:\"app=(\\<lambda>v. ps@[v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>app.\n        app = (\\<lambda>v. ps @ [v]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  app = (\\<lambda>v. ps @ [v])\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "have \"app ` qs = {ps'. ext ps ps'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "have \"\\<And>x. x\\<in>app`qs \\<Longrightarrow> x\\<in>{ps'. ext ps ps'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> x \\<in> {ps'. ext ps ps'}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> ext ps x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> ext ps x", "assume \"x \\<in> app ` qs\""], ["proof (state)\nthis:\n  x \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> ext ps x", "then"], ["proof (chain)\npicking this:\n  x \\<in> app ` qs", "obtain y where \"adjacent (last ps) y\" \"x=ps@[y]\""], ["proof (prove)\nusing this:\n  x \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>adjacent (last ps) y; x = ps @ [y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using qs app"], ["proof (prove)\nusing this:\n  x \\<in> app ` qs\n  qs = {v. adjacent (last ps) v}\n  app = (\\<lambda>v. ps @ [v])\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>adjacent (last ps) y; x = ps @ [y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  adjacent (last ps) y\n  x = ps @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> ext ps x", "moreover"], ["proof (state)\nthis:\n  adjacent (last ps) y\n  x = ps @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> ext ps x", "hence \"adj_path (hd x) (tl x)\""], ["proof (prove)\nusing this:\n  adjacent (last ps) y\n  x = ps @ [y]\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "by (cases \"tl ps = []\", metis adj_path.simps(1) adj_path.simps(2) \n                          adjacent_V(2) append_Nil list.sel(1,3) hd_append snoc_eq_iff_butlast \n                          tl_append2, metis \\<open>adj_path (hd ps) (tl ps)\\<close> adj_path_app hd_append\n                          last_tl list.sel(2) tl_append2)"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> app ` qs \\<Longrightarrow> ext ps x", "ultimately"], ["proof (chain)\npicking this:\n  adjacent (last ps) y\n  x = ps @ [y]\n  adj_path (hd x) (tl x)", "show \"ext ps x\""], ["proof (prove)\nusing this:\n  adjacent (last ps) y\n  x = ps @ [y]\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. ext ps x", "using ext"], ["proof (prove)\nusing this:\n  adjacent (last ps) y\n  x = ps @ [y]\n  adj_path (hd x) (tl x)\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and>\n      butlast ps' = ps \\<and> adj_path (hd ps') (tl ps'))\n\ngoal (1 subgoal):\n 1. ext ps x", "by (metis snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  ext ps x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> app ` qs \\<Longrightarrow> ?x \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> app ` qs \\<Longrightarrow> ?x \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "have \"\\<And>x. x\\<in>{ps'. ext ps ps'}\\<Longrightarrow> x\\<in> app`qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> x \\<in> app ` qs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> x \\<in> app ` qs", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> x \\<in> app ` qs", "assume \"x \\<in> {ps'. ext ps ps'}\""], ["proof (state)\nthis:\n  x \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> x \\<in> app ` qs", "hence \"x\\<noteq>[]\" and \"butlast x=ps\" and \"adj_path (hd x) (tl x)\""], ["proof (prove)\nusing this:\n  x \\<in> {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] &&& butlast x = ps &&& adj_path (hd x) (tl x)", "using ext"], ["proof (prove)\nusing this:\n  x \\<in> {ps'. ext ps ps'}\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and>\n      butlast ps' = ps \\<and> adj_path (hd ps') (tl ps'))\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] &&& butlast x = ps &&& adj_path (hd x) (tl x)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> []\n  butlast x = ps\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> x \\<in> app ` qs", "have \"adjacent (last ps) (last x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x)", "proof (cases \"length ps=1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length ps = 1 \\<Longrightarrow> adjacent (last ps) (last x)\n 2. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "case True"], ["proof (state)\nthis:\n  length ps = 1\n\ngoal (2 subgoals):\n 1. length ps = 1 \\<Longrightarrow> adjacent (last ps) (last x)\n 2. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "hence \"length x=2\""], ["proof (prove)\nusing this:\n  length ps = 1\n\ngoal (1 subgoal):\n 1. length x = 2", "using \\<open>butlast x=ps\\<close>"], ["proof (prove)\nusing this:\n  length ps = 1\n  butlast x = ps\n\ngoal (1 subgoal):\n 1. length x = 2", "by auto"], ["proof (state)\nthis:\n  length x = 2\n\ngoal (2 subgoals):\n 1. length ps = 1 \\<Longrightarrow> adjacent (last ps) (last x)\n 2. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "then"], ["proof (chain)\npicking this:\n  length x = 2", "obtain x1 t1 where \"x=x1#t1\" and \"length t1=1\""], ["proof (prove)\nusing this:\n  length x = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 t1.\n        \\<lbrakk>x = x1 # t1; length t1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc_length_conv[of 1 x]"], ["proof (prove)\nusing this:\n  length x = 2\n  (Suc 1 = length x) = (\\<exists>y ys. x = y # ys \\<and> length ys = 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x1 t1.\n        \\<lbrakk>x = x1 # t1; length t1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = x1 # t1\n  length t1 = 1\n\ngoal (2 subgoals):\n 1. length ps = 1 \\<Longrightarrow> adjacent (last ps) (last x)\n 2. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "then"], ["proof (chain)\npicking this:\n  x = x1 # t1\n  length t1 = 1", "obtain x2 where \"t1=[x2]\""], ["proof (prove)\nusing this:\n  x = x1 # t1\n  length t1 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x2. t1 = [x2] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using Suc_length_conv[of 0 t1]"], ["proof (prove)\nusing this:\n  x = x1 # t1\n  length t1 = 1\n  (Suc 0 = length t1) = (\\<exists>y ys. t1 = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x2. t1 = [x2] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  t1 = [x2]\n\ngoal (2 subgoals):\n 1. length ps = 1 \\<Longrightarrow> adjacent (last ps) (last x)\n 2. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "have \"x=[x1,x2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = [x1, x2]", "using \\<open>x=x1#t1\\<close> \\<open>t1=[x2]\\<close>"], ["proof (prove)\nusing this:\n  x = x1 # t1\n  t1 = [x2]\n\ngoal (1 subgoal):\n 1. x = [x1, x2]", "by auto"], ["proof (state)\nthis:\n  x = [x1, x2]\n\ngoal (2 subgoals):\n 1. length ps = 1 \\<Longrightarrow> adjacent (last ps) (last x)\n 2. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "thus \"adjacent (last ps) (last x)\""], ["proof (prove)\nusing this:\n  x = [x1, x2]\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x)", "using \\<open>adj_path (hd x) (tl x)\\<close> \\<open>butlast x=ps\\<close>"], ["proof (prove)\nusing this:\n  x = [x1, x2]\n  adj_path (hd x) (tl x)\n  butlast x = ps\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x)", "by auto"], ["proof (state)\nthis:\n  adjacent (last ps) (last x)\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "case False"], ["proof (state)\nthis:\n  length ps \\<noteq> 1\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "hence \"tl ps\\<noteq>[]\""], ["proof (prove)\nusing this:\n  length ps \\<noteq> 1\n\ngoal (1 subgoal):\n 1. tl ps \\<noteq> []", "by (metis \\<open>length ps = l + 1\\<close> add_0_iff add_diff_cancel_left' \n                              length_0_conv length_tl add.commute)"], ["proof (state)\nthis:\n  tl ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "moreover"], ["proof (state)\nthis:\n  tl ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "have \"adj_path (hd x) (tl ps @ [last x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl ps @ [last x])", "using \\<open>adj_path (hd x) (tl x)\\<close> \\<open>butlast x=ps\\<close> \\<open>x \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  adj_path (hd x) (tl x)\n  butlast x = ps\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl ps @ [last x])", "by (metis append_butlast_last_id calculation list.sel(2) tl_append2)"], ["proof (state)\nthis:\n  adj_path (hd x) (tl ps @ [last x])\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "ultimately"], ["proof (chain)\npicking this:\n  tl ps \\<noteq> []\n  adj_path (hd x) (tl ps @ [last x])", "have \"adjacent (last (tl ps)) (last x)\""], ["proof (prove)\nusing this:\n  tl ps \\<noteq> []\n  adj_path (hd x) (tl ps @ [last x])\n\ngoal (1 subgoal):\n 1. adjacent (last (tl ps)) (last x)", "using adj_path_app'[of \"hd x\" \"tl ps\" \"last x\"]"], ["proof (prove)\nusing this:\n  tl ps \\<noteq> []\n  adj_path (hd x) (tl ps @ [last x])\n  \\<lbrakk>adj_path (hd x) (tl ps @ [last x]); tl ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> adjacent (last (tl ps)) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last (tl ps)) (last x)", "by auto"], ["proof (state)\nthis:\n  adjacent (last (tl ps)) (last x)\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1 \\<Longrightarrow> adjacent (last ps) (last x)", "thus \"adjacent (last ps) (last x)\""], ["proof (prove)\nusing this:\n  adjacent (last (tl ps)) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x)", "by (metis \\<open>tl ps \\<noteq> []\\<close> last_tl)"], ["proof (state)\nthis:\n  adjacent (last ps) (last x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adjacent (last ps) (last x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> x \\<in> app ` qs", "thus \"x \\<in> app ` qs\""], ["proof (prove)\nusing this:\n  adjacent (last ps) (last x)\n\ngoal (1 subgoal):\n 1. x \\<in> app ` qs", "using app qs"], ["proof (prove)\nusing this:\n  adjacent (last ps) (last x)\n  app = (\\<lambda>v. ps @ [v])\n  qs = {v. adjacent (last ps) v}\n\ngoal (1 subgoal):\n 1. x \\<in> app ` qs", "by (metis \\<open>butlast x = ps\\<close> \\<open>x \\<noteq> []\\<close> append_butlast_last_id mem_Collect_eq \n                          rev_image_eqI)"], ["proof (state)\nthis:\n  x \\<in> app ` qs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> ?x \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> app ` qs \\<Longrightarrow> ?x \\<in> {ps'. ext ps ps'}\n  ?x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> ?x \\<in> app ` qs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> app ` qs \\<Longrightarrow> ?x \\<in> {ps'. ext ps ps'}\n  ?x \\<in> {ps'. ext ps ps'} \\<Longrightarrow> ?x \\<in> app ` qs\n\ngoal (1 subgoal):\n 1. app ` qs = {ps'. ext ps ps'}", "by auto"], ["proof (state)\nthis:\n  app ` qs = {ps'. ext ps ps'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  app ` qs = {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "moreover"], ["proof (state)\nthis:\n  app ` qs = {ps'. ext ps ps'}\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "have \"inj_on app qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on app qs", "using app"], ["proof (prove)\nusing this:\n  app = (\\<lambda>v. ps @ [v])\n\ngoal (1 subgoal):\n 1. inj_on app qs", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  app = (\\<lambda>v. ps @ [v])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>qs.\n       \\<forall>y\\<in>qs. app x = app y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on app qs\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "moreover"], ["proof (state)\nthis:\n  inj_on app qs\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "have \"last ps\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last ps \\<in> V", "using \\<open>length ps = l + 1\\<close>  \\<open>adj_path (hd ps) (tl ps)\\<close> adj_path_V"], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  adj_path ?v ?ps \\<Longrightarrow> set ?ps \\<subseteq> V\n\ngoal (1 subgoal):\n 1. last ps \\<in> V", "by (metis \\<open>last ps = hd ps\\<close> adj_path.simps(1) last_in_set last_tl subset_code(1))"], ["proof (state)\nthis:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "hence \"card qs=k\""], ["proof (prove)\nusing this:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. card qs = k", "using qs k_adj"], ["proof (prove)\nusing this:\n  last ps \\<in> V\n  qs = {v. adjacent (last ps) v}\n  ?v \\<in> V \\<Longrightarrow> card {n. adjacent ?v n} = k\n\ngoal (1 subgoal):\n 1. card qs = k", "by auto"], ["proof (state)\nthis:\n  card qs = k\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> C_star l \\<Longrightarrow> card {ps'. ext ps ps'} = k", "ultimately"], ["proof (chain)\npicking this:\n  app ` qs = {ps'. ext ps ps'}\n  inj_on app qs\n  card qs = k", "show \"card {ps'. ext ps ps'} = k\""], ["proof (prove)\nusing this:\n  app ` qs = {ps'. ext ps ps'}\n  inj_on app qs\n  card qs = k\n\ngoal (1 subgoal):\n 1. card {ps'. ext ps ps'} = k", "by (metis card_image)"], ["proof (state)\nthis:\n  card {ps'. ext ps ps'} = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>C_star l. card {ps'. ext ps ps'} = k\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>C_star l. card {ps'. ext ps ps'} = k\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "have \"finite (C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (C_star l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (C_star l)", "have \"C_star l \\<subseteq> T l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_star l \\<subseteq> T l", "using C_star T"], ["proof (prove)\nusing this:\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. C_star l \\<subseteq> T l", "by auto"], ["proof (state)\nthis:\n  C_star l \\<subseteq> T l\n\ngoal (1 subgoal):\n 1. finite (C_star l)", "moreover"], ["proof (state)\nthis:\n  C_star l \\<subseteq> T l\n\ngoal (1 subgoal):\n 1. finite (C_star l)", "have \"(k * k - k + 1) * k ^ l\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ l \\<noteq> 0", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ l \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (k * k - k + 1) * k ^ l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (C_star l)", "hence \"finite (T l)\""], ["proof (prove)\nusing this:\n  (k * k - k + 1) * k ^ l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (T l)", "using T_count[of \"l\"]"], ["proof (prove)\nusing this:\n  (k * k - k + 1) * k ^ l \\<noteq> 0\n  card (T l) = (k * k - k + 1) * k ^ l\n\ngoal (1 subgoal):\n 1. finite (T l)", "by (metis card.infinite)"], ["proof (state)\nthis:\n  finite (T l)\n\ngoal (1 subgoal):\n 1. finite (C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  C_star l \\<subseteq> T l\n  finite (T l)", "show ?thesis"], ["proof (prove)\nusing this:\n  C_star l \\<subseteq> T l\n  finite (T l)\n\ngoal (1 subgoal):\n 1. finite (C_star l)", "by (metis finite_subset)"], ["proof (state)\nthis:\n  finite (C_star l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (C_star l)\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "moreover"], ["proof (state)\nthis:\n  finite (C_star l)\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "have \"\\<forall>ps1 ps2. ps1 \\<noteq> ps2 \\<longrightarrow> {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps1 ps2.\n       ps1 \\<noteq> ps2 \\<longrightarrow>\n       {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}", "using ext"], ["proof (prove)\nusing this:\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and>\n      butlast ps' = ps \\<and> adj_path (hd ps') (tl ps'))\n\ngoal (1 subgoal):\n 1. \\<forall>ps1 ps2.\n       ps1 \\<noteq> ps2 \\<longrightarrow>\n       {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "have \"(\\<Union>ps\\<in>(C_star l). {ps'. ext ps ps'}) = {ps. length ps = l+2 \n              \\<and> adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)=hd ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "have \"\\<And>x. x\\<in>(\\<Union>ps\\<in>(C_star l). {ps'. ext ps ps'}) \\<Longrightarrow> x\\<in>{ps. length ps = l+2 \n                  \\<and> adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)=hd ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "assume \"x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "obtain ps where \"ps\\<in>C_star l\" \"ext ps x\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>ps \\<in> C_star l; ext ps x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps \\<in> C_star l\n  ext ps x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "hence \"length ps = l + 1\" and \"adj_path (hd ps) (tl ps)\" and \"last ps = hd ps\" \n                      and \"x \\<noteq> []\" and  \"butlast x = ps\" \"adj_path (hd x) (tl x)\""], ["proof (prove)\nusing this:\n  ps \\<in> C_star l\n  ext ps x\n\ngoal (1 subgoal):\n 1. (length ps = l + 1 &&& adj_path (hd ps) (tl ps)) &&&\n    last ps = hd ps &&&\n    x \\<noteq> [] &&& butlast x = ps &&& adj_path (hd x) (tl x)", "using C_star ext"], ["proof (prove)\nusing this:\n  ps \\<in> C_star l\n  ext ps x\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and>\n      butlast ps' = ps \\<and> adj_path (hd ps') (tl ps'))\n\ngoal (1 subgoal):\n 1. (length ps = l + 1 &&& adj_path (hd ps) (tl ps)) &&&\n    last ps = hd ps &&&\n    x \\<noteq> [] &&& butlast x = ps &&& adj_path (hd x) (tl x)", "by auto"], ["proof (state)\nthis:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps = hd ps\n  x \\<noteq> []\n  butlast x = ps\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "have \"length x = l + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = l + 2", "using \\<open> butlast x = ps \\<close> \\<open> length ps = l + 1 \\<close> length_butlast"], ["proof (prove)\nusing this:\n  butlast x = ps\n  length ps = l + 1\n  length (butlast ?xs) = length ?xs - 1\n\ngoal (1 subgoal):\n 1. length x = l + 2", "by auto"], ["proof (state)\nthis:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "moreover"], ["proof (state)\nthis:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "have \"adj_path (hd x) (tl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "by (metis \\<open>adj_path (hd x) (tl x)\\<close>)"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "moreover"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "have \"adjacent (last x) (hd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "have \"length x\\<ge>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "using \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "by auto"], ["proof (state)\nthis:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "hence \"adjacent (last (butlast x)) (last x)\""], ["proof (prove)\nusing this:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. adjacent (last (butlast x)) (last x)", "using \\<open>adj_path (hd x) (tl x)\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> length x\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. adjacent (last (butlast x)) (last x)", "by (induct x,auto, metis adj_path.simps(2) append_butlast_last_id \n                          append_eq_Cons_conv, metis adj_path_app' append_butlast_last_id)"], ["proof (state)\nthis:\n  adjacent (last (butlast x)) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "hence \"adjacent (last ps) (last x)\""], ["proof (prove)\nusing this:\n  adjacent (last (butlast x)) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x)", "using \\<open>butlast x=ps\\<close>"], ["proof (prove)\nusing this:\n  adjacent (last (butlast x)) (last x)\n  butlast x = ps\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x)", "by auto"], ["proof (state)\nthis:\n  adjacent (last ps) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "hence \"adjacent (hd ps) (last x)\""], ["proof (prove)\nusing this:\n  adjacent (last ps) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (hd ps) (last x)", "using \\<open>last ps=hd ps\\<close>"], ["proof (prove)\nusing this:\n  adjacent (last ps) (last x)\n  last ps = hd ps\n\ngoal (1 subgoal):\n 1. adjacent (hd ps) (last x)", "by auto"], ["proof (state)\nthis:\n  adjacent (hd ps) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "hence \"adjacent (hd x) (last x)\""], ["proof (prove)\nusing this:\n  adjacent (hd ps) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (hd x) (last x)", "using \\<open>butlast x=ps\\<close> \\<open>length ps=l+1\\<close>"], ["proof (prove)\nusing this:\n  adjacent (hd ps) (last x)\n  butlast x = ps\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. adjacent (hd x) (last x)", "by (cases x)  auto"], ["proof (state)\nthis:\n  adjacent (hd x) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  adjacent (hd x) (last x)\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "using adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent (hd x) (last x)\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "by auto"], ["proof (state)\nthis:\n  adjacent (last x) (hd x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adjacent (last x) (hd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "moreover"], ["proof (state)\nthis:\n  adjacent (last x) (hd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "have \"last (butlast x) = hd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (butlast x) = hd x", "by (metis \\<open>butlast x = ps\\<close> \\<open>last ps = hd ps\\<close> \\<open>x \\<noteq> []\\<close> adjacent_no_loop \n                      butlast.simps(2) calculation(3) list.sel(1) last_ConsL neq_Nil_conv)"], ["proof (state)\nthis:\n  last (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>ps\\<in>C_star l.\n                   {ps'. ext ps ps'}) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "ultimately"], ["proof (chain)\npicking this:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) = hd x", "show \"length x = l + 2 \\<and> adj_path (hd x) (tl x) \n                      \\<and> adjacent (last x) (hd x) \\<and> last (butlast x) = hd x\""], ["proof (prove)\nusing this:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. length x = l + 2 \\<and>\n    adj_path (hd x) (tl x) \\<and>\n    adjacent (last x) (hd x) \\<and> last (butlast x) = hd x", "by auto"], ["proof (state)\nthis:\n  length x = l + 2 \\<and>\n  adj_path (hd x) (tl x) \\<and>\n  adjacent (last x) (hd x) \\<and> last (butlast x) = hd x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal (1 subgoal):\n 1. (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal (1 subgoal):\n 1. (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "have \"\\<And>x. x\\<in>{ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \n                  \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)=hd ps} \\<Longrightarrow>  \n                  x\\<in>(\\<Union>ps\\<in>(C_star l). {ps'. ext ps ps'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "assume \"x\\<in>{ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \n                      \\<and> adjacent (last ps) (hd ps) \\<and> last (butlast ps)=hd ps}\""], ["proof (state)\nthis:\n  x \\<in> {ps.\n           length ps = l + 2 \\<and>\n           adj_path (hd ps) (tl ps) \\<and>\n           adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "hence \"length x=l+2\" and \"adj_path (hd x) (tl x)\" and \"adjacent (last x) (hd x)\"\n                      and \"last (butlast x)=hd x\""], ["proof (prove)\nusing this:\n  x \\<in> {ps.\n           length ps = l + 2 \\<and>\n           adj_path (hd ps) (tl ps) \\<and>\n           adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal (1 subgoal):\n 1. (length x = l + 2 &&& adj_path (hd x) (tl x)) &&&\n    adjacent (last x) (hd x) &&& last (butlast x) = hd x", "by auto"], ["proof (state)\nthis:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "obtain ps where ps:\"ps=butlast x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps. ps = butlast x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps = butlast x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "have \"ps\\<in>C_star l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "have \"length ps = l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps = l + 1", "using ps \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  ps = butlast x\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. length ps = l + 1", "by auto"], ["proof (state)\nthis:\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "moreover"], ["proof (state)\nthis:\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "have \"hd ps=hd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ps = hd x", "using ps \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  ps = butlast x\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. hd ps = hd x", "by (metis (full_types) \\<open> adjacent (last x) (hd x) \\<close> adjacent_no_loop \n                          append_Nil append_butlast_last_id butlast.simps(1) list.sel(1) hd_append2)"], ["proof (state)\nthis:\n  hd ps = hd x\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "hence \"adj_path (hd ps) (tl ps)\""], ["proof (prove)\nusing this:\n  hd ps = hd x\n\ngoal (1 subgoal):\n 1. adj_path (hd ps) (tl ps)", "using adj_path_butlast"], ["proof (prove)\nusing this:\n  hd ps = hd x\n  adj_path ?v ?ps \\<Longrightarrow> adj_path ?v (butlast ?ps)\n\ngoal (1 subgoal):\n 1. adj_path (hd ps) (tl ps)", "by (metis \\<open>adj_path (hd x) (tl x)\\<close> butlast_tl ps)"], ["proof (state)\nthis:\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "moreover"], ["proof (state)\nthis:\n  adj_path (hd ps) (tl ps)\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "have \"last ps = hd ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last ps = hd ps", "by (metis \\<open>hd ps = hd x\\<close> \\<open>last (butlast x) = hd x\\<close> ps)"], ["proof (state)\nthis:\n  last ps = hd ps\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "ultimately"], ["proof (chain)\npicking this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps = hd ps", "show ?thesis"], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps = hd ps\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "using C_star"], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps = hd ps\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n\ngoal (1 subgoal):\n 1. ps \\<in> C_star l", "by auto"], ["proof (state)\nthis:\n  ps \\<in> C_star l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps \\<in> C_star l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "moreover"], ["proof (state)\nthis:\n  ps \\<in> C_star l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "have \"ext ps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ext ps x", "using ext"], ["proof (prove)\nusing this:\n  ext =\n  (\\<lambda>ps ps'.\n      ps' \\<noteq> [] \\<and>\n      butlast ps' = ps \\<and> adj_path (hd ps') (tl ps'))\n\ngoal (1 subgoal):\n 1. ext ps x", "by (metis \\<open>adj_path (hd x) (tl x)\\<close> \\<open>adjacent (last x) (hd x)\\<close> \n                      \\<open>last (butlast x) = hd x\\<close> adjacent_no_loop butlast.simps(1) ps)"], ["proof (state)\nthis:\n  ext ps x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) = hd ps} \\<Longrightarrow>\n       x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "ultimately"], ["proof (chain)\npicking this:\n  ps \\<in> C_star l\n  ext ps x", "show \"x\\<in>(\\<Union>ps\\<in>(C_star l). {ps'. ext ps ps'})\""], ["proof (prove)\nusing this:\n  ps \\<in> C_star l\n  ext ps x\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) = hd ps} \\<Longrightarrow>\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) = hd ps} \\<Longrightarrow>\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) = hd ps} \\<Longrightarrow>\n  ?x \\<in> (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'})\n\ngoal (1 subgoal):\n 1. (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "by fast"], ["proof (state)\nthis:\n  (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>ps\\<in>C_star l. card {ps'. ext ps ps'} = k\n  finite (C_star l)\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}\n  (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ps\\<in>C_star l. card {ps'. ext ps ps'} = k\n  finite (C_star l)\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}\n  (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "using card_partition'[of \"C_star l\" ext k] \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>ps\\<in>C_star l. card {ps'. ext ps ps'} = k\n  finite (C_star l)\n  \\<forall>ps1 ps2.\n     ps1 \\<noteq> ps2 \\<longrightarrow>\n     {ps'. ext ps1 ps'} \\<inter> {ps'. ext ps2 ps'} = {}\n  (\\<Union>ps\\<in>C_star l. {ps'. ext ps ps'}) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps}\n  \\<lbrakk>\\<forall>v\\<in>C_star l. card {n. ext v n} = k; 0 < k;\n   finite (C_star l);\n   \\<forall>v1 v2.\n      v1 \\<noteq> v2 \\<longrightarrow>\n      {n. ext v1 n} \\<inter> {n. ext v2 n} = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union>v\\<in>C_star l. {n. ext v n}) =\n                    k * card (C_star l)\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n    k * card (C_star l)", "by auto"], ["proof (state)\nthis:\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n  k * card (C_star l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n  k * card (C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n  k * card (C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "have \"card {ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n          adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}=card (T l - C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "obtain app where app:\"app=(\\<lambda>ps. ps@[SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>app.\n        app =\n        (\\<lambda>ps.\n            ps @\n            [SOME n.\n                adjacent (last ps) n \\<and>\n                adjacent (hd ps) n]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "have \"\\<And>x. x\\<in>app`(T l - C_star l) \\<Longrightarrow> x\\<in>{ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n              adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "assume \"x \\<in> app ` (T l - C_star l)\""], ["proof (state)\nthis:\n  x \\<in> app ` (T l - C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "then"], ["proof (chain)\npicking this:\n  x \\<in> app ` (T l - C_star l)", "obtain ps where \"length ps = l + 1\" \"adj_path (hd ps) (tl ps)\" \"last ps \\<noteq> hd ps\"\n                  \"x=app ps\""], ["proof (prove)\nusing this:\n  x \\<in> app ` (T l - C_star l)\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>length ps = l + 1; adj_path (hd ps) (tl ps);\n         last ps \\<noteq> hd ps; x = app ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using T C_star"], ["proof (prove)\nusing this:\n  x \\<in> app ` (T l - C_star l)\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>length ps = l + 1; adj_path (hd ps) (tl ps);\n         last ps \\<noteq> hd ps; x = app ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps \\<noteq> hd ps\n  x = app ps\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "hence \"last ps\\<in>V\""], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps \\<noteq> hd ps\n  x = app ps\n\ngoal (1 subgoal):\n 1. last ps \\<in> V", "using adj_path_V[OF \\<open>adj_path (hd ps) (tl ps)\\<close>]"], ["proof (prove)\nusing this:\n  length ps = l + 1\n  adj_path (hd ps) (tl ps)\n  last ps \\<noteq> hd ps\n  x = app ps\n  set (tl ps) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. last ps \\<in> V", "by (cases ps) auto"], ["proof (state)\nthis:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "hence \"\\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n\""], ["proof (prove)\nusing this:\n  last ps \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n", "using adj_path_V'[OF \\<open>adj_path (hd ps) (tl ps)\\<close>] \\<open>last ps\\<noteq>hd ps\\<close>  \n                  friend_assm[of \"last ps\" \"hd ps\"]"], ["proof (prove)\nusing this:\n  last ps \\<in> V\n  hd ps \\<in> V\n  last ps \\<noteq> hd ps\n  \\<lbrakk>last ps \\<in> V; hd ps \\<in> V; last ps \\<noteq> hd ps\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n.\n                       adjacent (last ps) n \\<and> adjacent (hd ps) n\n\ngoal (1 subgoal):\n 1. \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "moreover"], ["proof (state)\nthis:\n  \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "have \"last x=(SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)", "using app \\<open>x=app ps\\<close>"], ["proof (prove)\nusing this:\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n  x = app ps\n\ngoal (1 subgoal):\n 1. last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)", "by auto"], ["proof (state)\nthis:\n  last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n\n  last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)", "have \"adjacent (last ps) (last x)\" and \"adjacent (hd ps) (last x)\""], ["proof (prove)\nusing this:\n  \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n\n  last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x) &&& adjacent (hd ps) (last x)", "using someI_ex"], ["proof (prove)\nusing this:\n  \\<exists>n. adjacent (last ps) n \\<and> adjacent (hd ps) n\n  last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n)\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (SOME x. ?P x)\n\ngoal (1 subgoal):\n 1. adjacent (last ps) (last x) &&& adjacent (hd ps) (last x)", "by (metis (lifting))+"], ["proof (state)\nthis:\n  adjacent (last ps) (last x)\n  adjacent (hd ps) (last x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "have \"hd x=hd ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd x = hd ps", "using \\<open>x=app ps\\<close> \\<open>length ps=l+1\\<close> app"], ["proof (prove)\nusing this:\n  x = app ps\n  length ps = l + 1\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. hd x = hd ps", "by (cases ps) auto"], ["proof (state)\nthis:\n  hd x = hd ps\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "have \"length x = l + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = l + 2", "using \\<open>x=app ps\\<close> \\<open>length ps=l+1\\<close> app"], ["proof (prove)\nusing this:\n  x = app ps\n  length ps = l + 1\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. length x = l + 2", "by auto"], ["proof (state)\nthis:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "moreover"], ["proof (state)\nthis:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "have \"adj_path (hd x) (tl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "have \"last (tl ps)=last ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (tl ps) = last ps", "using \\<open>length ps=l+1\\<close>"], ["proof (prove)\nusing this:\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. last (tl ps) = last ps", "by (metis \\<open>last ps \\<noteq> hd ps\\<close> list.sel(1,3) last_ConsL last_tl neq_Nil_conv)"], ["proof (state)\nthis:\n  last (tl ps) = last ps\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "moreover"], ["proof (state)\nthis:\n  last (tl ps) = last ps\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "have \"length ps\\<noteq>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1", "using \\<open>last ps \\<noteq> hd ps\\<close>"], ["proof (prove)\nusing this:\n  last ps \\<noteq> hd ps\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> 1", "by (metis Suc_eq_plus1_left gen_length_code(1) gen_length_def list.sel(1) \n                      last_ConsL length_Suc_conv neq_Nil_conv)"], ["proof (state)\nthis:\n  length ps \\<noteq> 1\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "hence \"tl ps\\<noteq>[]\""], ["proof (prove)\nusing this:\n  length ps \\<noteq> 1\n\ngoal (1 subgoal):\n 1. tl ps \\<noteq> []", "using \\<open>length ps=l+1\\<close>"], ["proof (prove)\nusing this:\n  length ps \\<noteq> 1\n  length ps = l + 1\n\ngoal (1 subgoal):\n 1. tl ps \\<noteq> []", "by(auto simp: length_Suc_conv)"], ["proof (state)\nthis:\n  tl ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "ultimately"], ["proof (chain)\npicking this:\n  last (tl ps) = last ps\n  tl ps \\<noteq> []", "have \"adj_path (hd ps) (tl ps @ [last x])\""], ["proof (prove)\nusing this:\n  last (tl ps) = last ps\n  tl ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd ps) (tl ps @ [last x])", "using  adj_path_app[OF \\<open>adj_path (hd ps) (tl ps)\\<close>,of \"last x\"]  \n                      \\<open>adjacent (last ps) (last x)\\<close>"], ["proof (prove)\nusing this:\n  last (tl ps) = last ps\n  tl ps \\<noteq> []\n  \\<lbrakk>tl ps \\<noteq> []; adjacent (last (tl ps)) (last x)\\<rbrakk>\n  \\<Longrightarrow> adj_path (hd ps) (tl ps @ [last x])\n  adjacent (last ps) (last x)\n\ngoal (1 subgoal):\n 1. adj_path (hd ps) (tl ps @ [last x])", "by auto"], ["proof (state)\nthis:\n  adj_path (hd ps) (tl ps @ [last x])\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "moreover"], ["proof (state)\nthis:\n  adj_path (hd ps) (tl ps @ [last x])\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "have \"tl ps @ [last x]=tl x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl ps @ [last x] = tl x", "using \\<open>x=app ps\\<close> app"], ["proof (prove)\nusing this:\n  x = app ps\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. tl ps @ [last x] = tl x", "by (metis \\<open> last x = (SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n) \\<close> \n                      \\<open> tl ps \\<noteq> [] \\<close> list.sel(2) tl_append2)"], ["proof (state)\nthis:\n  tl ps @ [last x] = tl x\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "ultimately"], ["proof (chain)\npicking this:\n  adj_path (hd ps) (tl ps @ [last x])\n  tl ps @ [last x] = tl x", "show ?thesis"], ["proof (prove)\nusing this:\n  adj_path (hd ps) (tl ps @ [last x])\n  tl ps @ [last x] = tl x\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "using \\<open>hd x=hd ps\\<close>"], ["proof (prove)\nusing this:\n  adj_path (hd ps) (tl ps @ [last x])\n  tl ps @ [last x] = tl x\n  hd x = hd ps\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "by auto"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "moreover"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "have \"adjacent (last x) (hd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "using \\<open>hd x=hd ps\\<close> \\<open>adjacent (hd ps) (last x)\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  hd x = hd ps\n  adjacent (hd ps) (last x)\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent (last x) (hd x)", "by auto"], ["proof (state)\nthis:\n  adjacent (last x) (hd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "moreover"], ["proof (state)\nthis:\n  adjacent (last x) (hd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "have \"last (butlast x) \\<noteq> hd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (butlast x) \\<noteq> hd x", "using \\<open>last ps \\<noteq> hd ps\\<close> \\<open>hd x=hd ps\\<close>"], ["proof (prove)\nusing this:\n  last ps \\<noteq> hd ps\n  hd x = hd ps\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<noteq> hd x", "by (metis \\<open>x = app ps\\<close> app butlast_snoc)"], ["proof (state)\nthis:\n  last (butlast x) \\<noteq> hd x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n       length x = l + 2 \\<and>\n       adj_path (hd x) (tl x) \\<and>\n       adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "ultimately"], ["proof (chain)\npicking this:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) \\<noteq> hd x", "show \"length x = l + 2 \\<and> adj_path (hd x) (tl x) \\<and> adjacent (last x) (hd x) \n                  \\<and> last (butlast x) \\<noteq> hd x\""], ["proof (prove)\nusing this:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) \\<noteq> hd x\n\ngoal (1 subgoal):\n 1. length x = l + 2 \\<and>\n    adj_path (hd x) (tl x) \\<and>\n    adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x", "by auto"], ["proof (state)\nthis:\n  length x = l + 2 \\<and>\n  adj_path (hd x) (tl x) \\<and>\n  adjacent (last x) (hd x) \\<and> last (butlast x) \\<noteq> hd x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "have \"\\<And>x. x\\<in>{ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n              adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}\\<Longrightarrow> x\\<in>app`(T l - C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "assume \"x\\<in>{ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n                  adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}\""], ["proof (state)\nthis:\n  x \\<in> {ps.\n           length ps = l + 2 \\<and>\n           adj_path (hd ps) (tl ps) \\<and>\n           adjacent (last ps) (hd ps) \\<and>\n           last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "hence \"length x=l+2\" and \"adj_path (hd x) (tl x)\" and \"adjacent (last x) (hd x)\"\n                  and \"last (butlast x)\\<noteq>hd x\""], ["proof (prove)\nusing this:\n  x \\<in> {ps.\n           length ps = l + 2 \\<and>\n           adj_path (hd ps) (tl ps) \\<and>\n           adjacent (last ps) (hd ps) \\<and>\n           last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. (length x = l + 2 &&& adj_path (hd x) (tl x)) &&&\n    adjacent (last x) (hd x) &&& last (butlast x) \\<noteq> hd x", "by auto"], ["proof (state)\nthis:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) \\<noteq> hd x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "hence \"butlast x\\<in>T l - C_star l\""], ["proof (prove)\nusing this:\n  length x = l + 2\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  last (butlast x) \\<noteq> hd x\n\ngoal (1 subgoal):\n 1. butlast x \\<in> T l - C_star l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "have \"length (butlast x) = l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (butlast x) = l + 1", "using \\<open>length x = l + 2\\<close> length_butlast"], ["proof (prove)\nusing this:\n  length x = l + 2\n  length (butlast ?xs) = length ?xs - 1\n\ngoal (1 subgoal):\n 1. length (butlast x) = l + 1", "by auto"], ["proof (state)\nthis:\n  length (butlast x) = l + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "moreover"], ["proof (state)\nthis:\n  length (butlast x) = l + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "have \"hd (butlast x)=hd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (butlast x) = hd x", "using \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. hd (butlast x) = hd x", "by (metis append_butlast_last_id butlast.simps(1) calculation diff_add_inverse \n                      diff_cancel2 hd_append length_butlast add.commute num.distinct(1) \n                      one_eq_numeral_iff)"], ["proof (state)\nthis:\n  hd (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "hence \"adj_path (hd (butlast x)) (tl (butlast x))\""], ["proof (prove)\nusing this:\n  hd (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. adj_path (hd (butlast x)) (tl (butlast x))", "using \\<open>adj_path (hd x) (tl x)\\<close>"], ["proof (prove)\nusing this:\n  hd (butlast x) = hd x\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. adj_path (hd (butlast x)) (tl (butlast x))", "by (metis adj_path_butlast butlast_tl)"], ["proof (state)\nthis:\n  adj_path (hd (butlast x)) (tl (butlast x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "moreover"], ["proof (state)\nthis:\n  adj_path (hd (butlast x)) (tl (butlast x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "have \"last (butlast x) \\<noteq> hd (butlast x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (butlast x) \\<noteq> hd (butlast x)", "using \\<open>last (butlast x)\\<noteq>hd x\\<close> \\<open>hd (butlast x)=hd x\\<close>"], ["proof (prove)\nusing this:\n  last (butlast x) \\<noteq> hd x\n  hd (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<noteq> hd (butlast x)", "by auto"], ["proof (state)\nthis:\n  last (butlast x) \\<noteq> hd (butlast x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = l + 2; adj_path (hd x) (tl x);\n     adjacent (last x) (hd x); last (butlast x) \\<noteq> hd x\\<rbrakk>\n    \\<Longrightarrow> butlast x \\<in> T l - C_star l", "ultimately"], ["proof (chain)\npicking this:\n  length (butlast x) = l + 1\n  adj_path (hd (butlast x)) (tl (butlast x))\n  last (butlast x) \\<noteq> hd (butlast x)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (butlast x) = l + 1\n  adj_path (hd (butlast x)) (tl (butlast x))\n  last (butlast x) \\<noteq> hd (butlast x)\n\ngoal (1 subgoal):\n 1. butlast x \\<in> T l - C_star l", "using T C_star"], ["proof (prove)\nusing this:\n  length (butlast x) = l + 1\n  adj_path (hd (butlast x)) (tl (butlast x))\n  last (butlast x) \\<noteq> hd (butlast x)\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n\ngoal (1 subgoal):\n 1. butlast x \\<in> T l - C_star l", "by auto"], ["proof (state)\nthis:\n  butlast x \\<in> T l - C_star l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  butlast x \\<in> T l - C_star l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  butlast x \\<in> T l - C_star l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "have \"app (butlast x)=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app (butlast x) = x", "using app"], ["proof (prove)\nusing this:\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. app (butlast x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "have \"last (butlast x)\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (butlast x) \\<in> V", "proof (cases \"length x\\<ge>3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V\n 2. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "case True"], ["proof (state)\nthis:\n  3 \\<le> length x\n\ngoal (2 subgoals):\n 1. 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V\n 2. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "hence \"last (butlast x)\\<in>set (tl x)\""], ["proof (prove)\nusing this:\n  3 \\<le> length x\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<in> set (tl x)", "proof (induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. 3 \\<le> length [] \\<Longrightarrow> last (butlast []) \\<in> set (tl [])\n 2. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "case Nil"], ["proof (state)\nthis:\n  3 \\<le> length []\n\ngoal (2 subgoals):\n 1. 3 \\<le> length [] \\<Longrightarrow> last (butlast []) \\<in> set (tl [])\n 2. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "thus ?case"], ["proof (prove)\nusing this:\n  3 \\<le> length []\n\ngoal (1 subgoal):\n 1. last (butlast []) \\<in> set (tl [])", "by auto"], ["proof (state)\nthis:\n  last (butlast []) \\<in> set (tl [])\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "case (Cons x1 t1)"], ["proof (state)\nthis:\n  3 \\<le> length t1 \\<Longrightarrow> last (butlast t1) \\<in> set (tl t1)\n  3 \\<le> length (x1 # t1)\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "have \"length t1<3 \\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "assume \"length t1<3\""], ["proof (state)\nthis:\n  length t1 < 3\n\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "hence \"length t1=2\""], ["proof (prove)\nusing this:\n  length t1 < 3\n\ngoal (1 subgoal):\n 1. length t1 = 2", "using \\<open>3 \\<le> length (x1 # t1)\\<close>"], ["proof (prove)\nusing this:\n  length t1 < 3\n  3 \\<le> length (x1 # t1)\n\ngoal (1 subgoal):\n 1. length t1 = 2", "by auto"], ["proof (state)\nthis:\n  length t1 = 2\n\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "then"], ["proof (chain)\npicking this:\n  length t1 = 2", "obtain x2 t2 where \"t1=x2#t2\" \"length t2=1\""], ["proof (prove)\nusing this:\n  length t1 = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x2 t2.\n        \\<lbrakk>t1 = x2 # t2; length t2 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc_length_conv[of 1 t1]"], ["proof (prove)\nusing this:\n  length t1 = 2\n  (Suc 1 = length t1) = (\\<exists>y ys. t1 = y # ys \\<and> length ys = 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x2 t2.\n        \\<lbrakk>t1 = x2 # t2; length t2 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t1 = x2 # t2\n  length t2 = 1\n\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "then"], ["proof (chain)\npicking this:\n  t1 = x2 # t2\n  length t2 = 1", "obtain x3 where \"t2=[x3]\""], ["proof (prove)\nusing this:\n  t1 = x2 # t2\n  length t2 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x3. t2 = [x3] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using  Suc_length_conv[of 0 t2]"], ["proof (prove)\nusing this:\n  t1 = x2 # t2\n  length t2 = 1\n  (Suc 0 = length t2) = (\\<exists>y ys. t2 = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x3. t2 = [x3] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  t2 = [x3]\n\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "have \"t1=[x2,x3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 = [x2, x3]", "using \\<open>t1=x2#t2\\<close> \\<open>t2=[x3]\\<close>"], ["proof (prove)\nusing this:\n  t1 = x2 # t2\n  t2 = [x3]\n\ngoal (1 subgoal):\n 1. t1 = [x2, x3]", "by auto"], ["proof (state)\nthis:\n  t1 = [x2, x3]\n\ngoal (1 subgoal):\n 1. length t1 < 3 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "thus ?case"], ["proof (prove)\nusing this:\n  t1 = [x2, x3]\n\ngoal (1 subgoal):\n 1. last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "by auto"], ["proof (state)\nthis:\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length t1 < 3 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "moreover"], ["proof (state)\nthis:\n  length t1 < 3 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "have \"length t1\\<ge>3\\<Longrightarrow>?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> length t1 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> length t1 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "assume \"length t1\\<ge>3\""], ["proof (state)\nthis:\n  3 \\<le> length t1\n\ngoal (1 subgoal):\n 1. 3 \\<le> length t1 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "hence \"last (butlast t1) \\<in> set (tl t1)\""], ["proof (prove)\nusing this:\n  3 \\<le> length t1\n\ngoal (1 subgoal):\n 1. last (butlast t1) \\<in> set (tl t1)", "using Cons.hyps"], ["proof (prove)\nusing this:\n  3 \\<le> length t1\n  3 \\<le> length t1 \\<Longrightarrow> last (butlast t1) \\<in> set (tl t1)\n\ngoal (1 subgoal):\n 1. last (butlast t1) \\<in> set (tl t1)", "by auto"], ["proof (state)\nthis:\n  last (butlast t1) \\<in> set (tl t1)\n\ngoal (1 subgoal):\n 1. 3 \\<le> length t1 \\<Longrightarrow>\n    last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "thus ?case"], ["proof (prove)\nusing this:\n  last (butlast t1) \\<in> set (tl t1)\n\ngoal (1 subgoal):\n 1. last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "by (metis butlast.simps(2) in_set_butlastD last.simps last_in_set \n                                  length_butlast length_greater_0_conv length_pos_if_in_set \n                                  length_tl list.sel(3))"], ["proof (state)\nthis:\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  3 \\<le> length t1 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>3 \\<le> length x \\<Longrightarrow>\n                last (butlast x) \\<in> set (tl x);\n        3 \\<le> length (a # x)\\<rbrakk>\n       \\<Longrightarrow> last (butlast (a # x)) \\<in> set (tl (a # x))", "ultimately"], ["proof (chain)\npicking this:\n  length t1 < 3 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n  3 \\<le> length t1 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "show ?case"], ["proof (prove)\nusing this:\n  length t1 < 3 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n  3 \\<le> length t1 \\<Longrightarrow>\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal (1 subgoal):\n 1. last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))", "by force"], ["proof (state)\nthis:\n  last (butlast (x1 # t1)) \\<in> set (tl (x1 # t1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (butlast x) \\<in> set (tl x)\n\ngoal (2 subgoals):\n 1. 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V\n 2. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "thus ?thesis"], ["proof (prove)\nusing this:\n  last (butlast x) \\<in> set (tl x)\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<in> V", "using adj_path_V[OF \\<open>adj_path (hd x) (tl x)\\<close>]"], ["proof (prove)\nusing this:\n  last (butlast x) \\<in> set (tl x)\n  set (tl x) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<in> V", "by auto"], ["proof (state)\nthis:\n  last (butlast x) \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "case False"], ["proof (state)\nthis:\n  \\<not> 3 \\<le> length x\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "hence \"length x=2\""], ["proof (prove)\nusing this:\n  \\<not> 3 \\<le> length x\n\ngoal (1 subgoal):\n 1. length x = 2", "using \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 3 \\<le> length x\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. length x = 2", "by auto"], ["proof (state)\nthis:\n  length x = 2\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "then"], ["proof (chain)\npicking this:\n  length x = 2", "obtain x1 x2 where \"x=[x1,x2]\""], ["proof (prove)\nusing this:\n  length x = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2. x = [x1, x2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x1 x2. x = [x1, x2] \\<Longrightarrow> thesis;\n     length x = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain x1 t1 where \"x=x1#t1\" \"length t1=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 t1.\n        \\<lbrakk>x = x1 # t1; length t1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc_length_conv[of 1 x] \\<open>length x=2\\<close>"], ["proof (prove)\nusing this:\n  (Suc 1 = length x) = (\\<exists>y ys. x = y # ys \\<and> length ys = 1)\n  length x = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 t1.\n        \\<lbrakk>x = x1 # t1; length t1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = x1 # t1\n  length t1 = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x1 x2. x = [x1, x2] \\<Longrightarrow> thesis;\n     length x = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x = x1 # t1\n  length t1 = 1", "obtain x2 where \"t1=[x2]\""], ["proof (prove)\nusing this:\n  x = x1 # t1\n  length t1 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x2. t1 = [x2] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using  Suc_length_conv[of 0 t1]"], ["proof (prove)\nusing this:\n  x = x1 # t1\n  length t1 = 1\n  (Suc 0 = length t1) = (\\<exists>y ys. t1 = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x2. t1 = [x2] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  t1 = [x2]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x1 x2. x = [x1, x2] \\<Longrightarrow> thesis;\n     length x = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"x=[x1,x2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = [x1, x2]", "using \\<open>x=x1#t1\\<close> \\<open>t1=[x2]\\<close>"], ["proof (prove)\nusing this:\n  x = x1 # t1\n  t1 = [x2]\n\ngoal (1 subgoal):\n 1. x = [x1, x2]", "by auto"], ["proof (state)\nthis:\n  x = [x1, x2]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x1 x2. x = [x1, x2] \\<Longrightarrow> thesis;\n     length x = 2\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = [x1, x2]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  x = [x1, x2]\n  x = [?x1.0, ?x2.0] \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = [x1, x2]\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "hence \"last (butlast x)=hd x\""], ["proof (prove)\nusing this:\n  x = [x1, x2]\n\ngoal (1 subgoal):\n 1. last (butlast x) = hd x", "by auto"], ["proof (state)\nthis:\n  last (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> length x \\<Longrightarrow> last (butlast x) \\<in> V", "thus ?thesis"], ["proof (prove)\nusing this:\n  last (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<in> V", "using adj_path_V'[OF \\<open>adj_path (hd x) (tl x)\\<close>]"], ["proof (prove)\nusing this:\n  last (butlast x) = hd x\n  hd x \\<in> V\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<in> V", "by auto"], ["proof (state)\nthis:\n  last (butlast x) \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (butlast x) \\<in> V\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "moreover"], ["proof (state)\nthis:\n  last (butlast x) \\<in> V\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "have \"hd (butlast x)=hd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (butlast x) = hd x", "using \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. hd (butlast x) = hd x", "by (metis \\<open>adjacent (last x) (hd x)\\<close> adjacent_no_loop append_butlast_last_id \n                      butlast.simps(1) list.sel(1) hd_append)"], ["proof (state)\nthis:\n  hd (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "hence  \"hd (butlast x)\\<in>V\""], ["proof (prove)\nusing this:\n  hd (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. hd (butlast x) \\<in> V", "using adj_path_V'[OF \\<open>adj_path (hd x) (tl x)\\<close>]"], ["proof (prove)\nusing this:\n  hd (butlast x) = hd x\n  hd x \\<in> V\n\ngoal (1 subgoal):\n 1. hd (butlast x) \\<in> V", "by auto"], ["proof (state)\nthis:\n  hd (butlast x) \\<in> V\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "moreover"], ["proof (state)\nthis:\n  hd (butlast x) \\<in> V\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "have \"last (butlast x)\\<noteq>hd (butlast x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (butlast x) \\<noteq> hd (butlast x)", "using \\<open>last (butlast x)\\<noteq>hd x\\<close> \\<open>hd (butlast x)=hd x\\<close>"], ["proof (prove)\nusing this:\n  last (butlast x) \\<noteq> hd x\n  hd (butlast x) = hd x\n\ngoal (1 subgoal):\n 1. last (butlast x) \\<noteq> hd (butlast x)", "by auto"], ["proof (state)\nthis:\n  last (butlast x) \\<noteq> hd (butlast x)\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "ultimately"], ["proof (chain)\npicking this:\n  last (butlast x) \\<in> V\n  hd (butlast x) \\<in> V\n  last (butlast x) \\<noteq> hd (butlast x)", "have \"\\<exists>! n. adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n\""], ["proof (prove)\nusing this:\n  last (butlast x) \\<in> V\n  hd (butlast x) \\<in> V\n  last (butlast x) \\<noteq> hd (butlast x)\n\ngoal (1 subgoal):\n 1. \\<exists>!n.\n       adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n", "using friend_assm"], ["proof (prove)\nusing this:\n  last (butlast x) \\<in> V\n  hd (butlast x) \\<in> V\n  last (butlast x) \\<noteq> hd (butlast x)\n  \\<lbrakk>?v \\<in> V; ?u \\<in> V; ?v \\<noteq> ?u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!n. adjacent ?v n \\<and> adjacent ?u n\n\ngoal (1 subgoal):\n 1. \\<exists>!n.\n       adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n", "by auto"], ["proof (state)\nthis:\n  \\<exists>!n.\n     adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "moreover"], ["proof (state)\nthis:\n  \\<exists>!n.\n     adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "have \"length x\\<ge>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "using \\<open>length x=l+2\\<close>"], ["proof (prove)\nusing this:\n  length x = l + 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "by auto"], ["proof (state)\nthis:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "hence \"adjacent (last (butlast x)) (last x)\""], ["proof (prove)\nusing this:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. adjacent (last (butlast x)) (last x)", "using \\<open>adj_path (hd x) (tl x)\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> length x\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. adjacent (last (butlast x)) (last x)", "by (induct x,auto, metis (full_types) adj_path.simps(2) append_Nil \n                      append_butlast_last_id, metis adj_path_app' append_butlast_last_id)"], ["proof (state)\nthis:\n  adjacent (last (butlast x)) (last x)\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "moreover"], ["proof (state)\nthis:\n  adjacent (last (butlast x)) (last x)\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "have \"adjacent (hd (butlast x)) (last x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (hd (butlast x)) (last x)", "using \\<open>adjacent (last x) (hd x)\\<close> \\<open>hd (butlast x)=hd x\\<close> adjacent_sym"], ["proof (prove)\nusing this:\n  adjacent (last x) (hd x)\n  hd (butlast x) = hd x\n  adjacent ?v ?v' = adjacent ?v' ?v\n\ngoal (1 subgoal):\n 1. adjacent (hd (butlast x)) (last x)", "by auto"], ["proof (state)\nthis:\n  adjacent (hd (butlast x)) (last x)\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!n.\n     adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n\n  adjacent (last (butlast x)) (last x)\n  adjacent (hd (butlast x)) (last x)", "have \"(SOME n. adjacent (last (butlast x)) n \n                      \\<and> adjacent (hd (butlast x)) n) = last x\""], ["proof (prove)\nusing this:\n  \\<exists>!n.\n     adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n\n  adjacent (last (butlast x)) (last x)\n  adjacent (hd (butlast x)) (last x)\n\ngoal (1 subgoal):\n 1. (SOME n.\n        adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n    last x", "using some1_equality"], ["proof (prove)\nusing this:\n  \\<exists>!n.\n     adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n\n  adjacent (last (butlast x)) (last x)\n  adjacent (hd (butlast x)) (last x)\n  \\<lbrakk>\\<exists>!x. ?P x; ?P ?a\\<rbrakk>\n  \\<Longrightarrow> (SOME x. ?P x) = ?a\n\ngoal (1 subgoal):\n 1. (SOME n.\n        adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n    last x", "by fast"], ["proof (state)\nthis:\n  (SOME n.\n      adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n  last x\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "moreover"], ["proof (state)\nthis:\n  (SOME n.\n      adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n  last x\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "have \"x=(butlast x)@[last x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = butlast x @ [last x]", "by (metis \\<open>adjacent (last (butlast x)) (last x)\\<close> adjacent_no_loop \n                      append_butlast_last_id butlast.simps(1))"], ["proof (state)\nthis:\n  x = butlast x @ [last x]\n\ngoal (1 subgoal):\n 1. app =\n    (\\<lambda>ps.\n        ps @\n        [SOME n.\n            adjacent (last ps) n \\<and>\n            adjacent (hd ps) n]) \\<Longrightarrow>\n    app (butlast x) = x", "ultimately"], ["proof (chain)\npicking this:\n  (SOME n.\n      adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n  last x\n  x = butlast x @ [last x]", "show ?thesis"], ["proof (prove)\nusing this:\n  (SOME n.\n      adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n  last x\n  x = butlast x @ [last x]\n\ngoal (1 subgoal):\n 1. app (butlast x) = x", "using app"], ["proof (prove)\nusing this:\n  (SOME n.\n      adjacent (last (butlast x)) n \\<and> adjacent (hd (butlast x)) n) =\n  last x\n  x = butlast x @ [last x]\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. app (butlast x) = x", "by auto"], ["proof (state)\nthis:\n  app (butlast x) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  app (butlast x) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {ps.\n                length ps = l + 2 \\<and>\n                adj_path (hd ps) (tl ps) \\<and>\n                adjacent (last ps) (hd ps) \\<and>\n                last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n       x \\<in> app ` (T l - C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  butlast x \\<in> T l - C_star l\n  app (butlast x) = x", "show \"x\\<in>app`(T l - C_star l)\""], ["proof (prove)\nusing this:\n  butlast x \\<in> T l - C_star l\n  app (butlast x) = x\n\ngoal (1 subgoal):\n 1. x \\<in> app ` (T l - C_star l)", "by (metis image_iff)"], ["proof (state)\nthis:\n  x \\<in> app ` (T l - C_star l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n  ?x \\<in> app ` (T l - C_star l)\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps}\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n  ?x \\<in> app ` (T l - C_star l)", "have \"app`(T l - C_star l)={ps. length ps = l+2 \\<and> adj_path (hd ps) (tl ps) \\<and> \n              adjacent (last ps) (hd ps) \\<and> last (butlast ps)\\<noteq>hd ps}\""], ["proof (prove)\nusing this:\n  ?x \\<in> app ` (T l - C_star l) \\<Longrightarrow>\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps}\n  ?x \\<in> {ps.\n            length ps = l + 2 \\<and>\n            adj_path (hd ps) (tl ps) \\<and>\n            adjacent (last ps) (hd ps) \\<and>\n            last (butlast ps) \\<noteq> hd ps} \\<Longrightarrow>\n  ?x \\<in> app ` (T l - C_star l)\n\ngoal (1 subgoal):\n 1. app ` (T l - C_star l) =\n    {ps.\n     length ps = l + 2 \\<and>\n     adj_path (hd ps) (tl ps) \\<and>\n     adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}", "by fast"], ["proof (state)\nthis:\n  app ` (T l - C_star l) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "moreover"], ["proof (state)\nthis:\n  app ` (T l - C_star l) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "have \"inj_on app (T l - C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on app (T l - C_star l)", "using app"], ["proof (prove)\nusing this:\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. inj_on app (T l - C_star l)", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  app =\n  (\\<lambda>ps.\n      ps @ [SOME n. adjacent (last ps) n \\<and> adjacent (hd ps) n])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>T l - C_star l.\n       \\<forall>y\\<in>T l - C_star l. app x = app y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on app (T l - C_star l)\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  app ` (T l - C_star l) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  inj_on app (T l - C_star l)", "show ?thesis"], ["proof (prove)\nusing this:\n  app ` (T l - C_star l) =\n  {ps.\n   length ps = l + 2 \\<and>\n   adj_path (hd ps) (tl ps) \\<and>\n   adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  inj_on app (T l - C_star l)\n\ngoal (1 subgoal):\n 1. card\n     {ps.\n      length ps = l + 2 \\<and>\n      adj_path (hd ps) (tl ps) \\<and>\n      adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n    card (T l - C_star l)", "by (metis card_image)"], ["proof (state)\nthis:\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  card (T l - C_star l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  card (T l - C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "ultimately"], ["proof (chain)\npicking this:\n  card (C (l + 1)) =\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} +\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n  k * card (C_star l)\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  card (T l - C_star l)", "show \"card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)\""], ["proof (prove)\nusing this:\n  card (C (l + 1)) =\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} +\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps}\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) = hd ps} =\n  k * card (C_star l)\n  card\n   {ps.\n    length ps = l + 2 \\<and>\n    adj_path (hd ps) (tl ps) \\<and>\n    adjacent (last ps) (hd ps) \\<and> last (butlast ps) \\<noteq> hd ps} =\n  card (T l - C_star l)\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)", "by auto"], ["proof (state)\nthis:\n  card (C (l + 1)) = k * card (C_star l) + card (T l - C_star l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (C (?l + 1)) = k * card (C_star ?l) + card (T ?l - C_star ?l)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "hence \"\\<And>l::nat. card (C (l+1)) mod (k-(1::nat))=1\""], ["proof (prove)\nusing this:\n  card (C (?l + 1)) = k * card (C_star ?l) + card (T ?l - C_star ?l)\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) mod (k - 1) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "fix l::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"C_star l \\<subseteq> T l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_star l \\<subseteq> T l", "using C_star T"], ["proof (prove)\nusing this:\n  C_star =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> last ps = hd ps})\n  T = (\\<lambda>l. {ps. length ps = l + 1 \\<and> adj_path (hd ps) (tl ps)})\n\ngoal (1 subgoal):\n 1. C_star l \\<subseteq> T l", "by auto"], ["proof (state)\nthis:\n  C_star l \\<subseteq> T l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "moreover"], ["proof (state)\nthis:\n  C_star l \\<subseteq> T l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"card (T l)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (T l) \\<noteq> 0", "using T_count \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  card (T ?l) = (k * k - k + 1) * k ^ ?l\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. card (T l) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (T l) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "hence \"finite (T l)\""], ["proof (prove)\nusing this:\n  card (T l) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (T l)", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  card (T l) \\<noteq> 0\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. finite (T l)", "by (metis card.infinite)"], ["proof (state)\nthis:\n  finite (T l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "ultimately"], ["proof (chain)\npicking this:\n  C_star l \\<subseteq> T l\n  finite (T l)", "have \"card (T l - C_star l)=card(T l) - card(C_star l)\""], ["proof (prove)\nusing this:\n  C_star l \\<subseteq> T l\n  finite (T l)\n\ngoal (1 subgoal):\n 1. card (T l - C_star l) = card (T l) - card (C_star l)", "by (metis card_Diff_subset rev_finite_subset)"], ["proof (state)\nthis:\n  card (T l - C_star l) = card (T l) - card (C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "hence \"card (C (l + 1))=k*card (C_star l) + (card (T l) - card (C_star l))\""], ["proof (prove)\nusing this:\n  card (T l - C_star l) = card (T l) - card (C_star l)\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) = k * card (C_star l) + (card (T l) - card (C_star l))", "using \\<open>\\<And>l::nat. card (C (l+1)) = k* card (C_star l) + card (T l - C_star l)\\<close>"], ["proof (prove)\nusing this:\n  card (T l - C_star l) = card (T l) - card (C_star l)\n  card (C (?l + 1)) = k * card (C_star ?l) + card (T ?l - C_star ?l)\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) = k * card (C_star l) + (card (T l) - card (C_star l))", "by auto"], ["proof (state)\nthis:\n  card (C (l + 1)) = k * card (C_star l) + (card (T l) - card (C_star l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  card (C (l + 1)) = k * card (C_star l) + (card (T l) - card (C_star l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=k*card (C_star l) + card (T l) - card (C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * card (C_star l) + (card (T l) - card (C_star l)) =\n    k * card (C_star l) + card (T l) - card (C_star l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k * card (C_star l) + (card (T l) - card (C_star l)) =\n    k * card (C_star l) + card (T l) - card (C_star l)", "have \"card (T l) \\<ge> card (C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (C_star l) \\<le> card (T l)", "using \\<open>C_star l \\<subseteq> T l\\<close> \\<open>finite (T l)\\<close>"], ["proof (prove)\nusing this:\n  C_star l \\<subseteq> T l\n  finite (T l)\n\ngoal (1 subgoal):\n 1. card (C_star l) \\<le> card (T l)", "by (metis card_mono)"], ["proof (state)\nthis:\n  card (C_star l) \\<le> card (T l)\n\ngoal (1 subgoal):\n 1. k * card (C_star l) + (card (T l) - card (C_star l)) =\n    k * card (C_star l) + card (T l) - card (C_star l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  card (C_star l) \\<le> card (T l)\n\ngoal (1 subgoal):\n 1. k * card (C_star l) + (card (T l) - card (C_star l)) =\n    k * card (C_star l) + card (T l) - card (C_star l)", "by auto"], ["proof (state)\nthis:\n  k * card (C_star l) + (card (T l) - card (C_star l)) =\n  k * card (C_star l) + card (T l) - card (C_star l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k * card (C_star l) + (card (T l) - card (C_star l)) =\n  k * card (C_star l) + card (T l) - card (C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  k * card (C_star l) + (card (T l) - card (C_star l)) =\n  k * card (C_star l) + card (T l) - card (C_star l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=k*card (C_star l) - card (C_star l) + card (T l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * card (C_star l) + card (T l) - card (C_star l) =\n    k * card (C_star l) - card (C_star l) + card (T l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k * card (C_star l) + card (T l) - card (C_star l) =\n    k * card (C_star l) - card (C_star l) + card (T l)", "have \"card (T l) \\<ge> card (C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (C_star l) \\<le> card (T l)", "using \\<open>C_star l \\<subseteq> T l\\<close> \\<open>finite (T l)\\<close>"], ["proof (prove)\nusing this:\n  C_star l \\<subseteq> T l\n  finite (T l)\n\ngoal (1 subgoal):\n 1. card (C_star l) \\<le> card (T l)", "by (metis card_mono)"], ["proof (state)\nthis:\n  card (C_star l) \\<le> card (T l)\n\ngoal (1 subgoal):\n 1. k * card (C_star l) + card (T l) - card (C_star l) =\n    k * card (C_star l) - card (C_star l) + card (T l)", "moreover"], ["proof (state)\nthis:\n  card (C_star l) \\<le> card (T l)\n\ngoal (1 subgoal):\n 1. k * card (C_star l) + card (T l) - card (C_star l) =\n    k * card (C_star l) - card (C_star l) + card (T l)", "have \"k*card (C_star l) \\<ge> card (C_star l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (C_star l) \\<le> k * card (C_star l)", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. card (C_star l) \\<le> k * card (C_star l)", "by auto"], ["proof (state)\nthis:\n  card (C_star l) \\<le> k * card (C_star l)\n\ngoal (1 subgoal):\n 1. k * card (C_star l) + card (T l) - card (C_star l) =\n    k * card (C_star l) - card (C_star l) + card (T l)", "ultimately"], ["proof (chain)\npicking this:\n  card (C_star l) \\<le> card (T l)\n  card (C_star l) \\<le> k * card (C_star l)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (C_star l) \\<le> card (T l)\n  card (C_star l) \\<le> k * card (C_star l)\n\ngoal (1 subgoal):\n 1. k * card (C_star l) + card (T l) - card (C_star l) =\n    k * card (C_star l) - card (C_star l) + card (T l)", "by auto"], ["proof (state)\nthis:\n  k * card (C_star l) + card (T l) - card (C_star l) =\n  k * card (C_star l) - card (C_star l) + card (T l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k * card (C_star l) + card (T l) - card (C_star l) =\n  k * card (C_star l) - card (C_star l) + card (T l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  k * card (C_star l) + card (T l) - card (C_star l) =\n  k * card (C_star l) - card (C_star l) + card (T l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=(k-(1::nat))*card(C_star l)+card(T l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * card (C_star l) - card (C_star l) + card (T l) =\n    (k - 1) * card (C_star l) + card (T l)", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. k * card (C_star l) - card (C_star l) + card (T l) =\n    (k - 1) * card (C_star l) + card (T l)", "by (metis monoid_mult_class.mult.left_neutral diff_mult_distrib)"], ["proof (state)\nthis:\n  k * card (C_star l) - card (C_star l) + card (T l) =\n  (k - 1) * card (C_star l) + card (T l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "finally"], ["proof (chain)\npicking this:\n  card (C (l + 1)) = (k - 1) * card (C_star l) + card (T l)", "have \"card (C (l + 1))=(k-(1::nat))*card(C_star l)+card(T l)\""], ["proof (prove)\nusing this:\n  card (C (l + 1)) = (k - 1) * card (C_star l) + card (T l)\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) = (k - 1) * card (C_star l) + card (T l)", "."], ["proof (state)\nthis:\n  card (C (l + 1)) = (k - 1) * card (C_star l) + card (T l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "hence \"card (C (l+1)) mod (k-(1::nat)) = card(T l) mod (k-(1::nat))\""], ["proof (prove)\nusing this:\n  card (C (l + 1)) = (k - 1) * card (C_star l) + card (T l)\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) mod (k - 1) = card (T l) mod (k - 1)", "using \\<open>k>=4\\<close>"], ["proof (prove)\nusing this:\n  card (C (l + 1)) = (k - 1) * card (C_star l) + card (T l)\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) mod (k - 1) = card (T l) mod (k - 1)", "by (metis mod_mult_self3 mult.commute)"], ["proof (state)\nthis:\n  card (C (l + 1)) mod (k - 1) = card (T l) mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  card (C (l + 1)) mod (k - 1) = card (T l) mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=((k*k-k+1)*k^l) mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (T l) mod (k - 1) = (k * k - k + 1) * k ^ l mod (k - 1)", "using T_count"], ["proof (prove)\nusing this:\n  card (T ?l) = (k * k - k + 1) * k ^ ?l\n\ngoal (1 subgoal):\n 1. card (T l) mod (k - 1) = (k * k - k + 1) * k ^ l mod (k - 1)", "by auto"], ["proof (state)\nthis:\n  card (T l) mod (k - 1) = (k * k - k + 1) * k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  card (T l) mod (k - 1) = (k * k - k + 1) * k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=((k-(1::nat))*k+1)*k^l  mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ l mod (k - 1) =\n    ((k - 1) * k + 1) * k ^ l mod (k - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ l mod (k - 1) =\n    ((k - 1) * k + 1) * k ^ l mod (k - 1)", "have \"k*k-k+1=(k-(1::nat))*k+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * k - k + 1 = (k - 1) * k + 1", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. k * k - k + 1 = (k - 1) * k + 1", "by (metis diff_mult_distrib nat_mult_1)"], ["proof (state)\nthis:\n  k * k - k + 1 = (k - 1) * k + 1\n\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ l mod (k - 1) =\n    ((k - 1) * k + 1) * k ^ l mod (k - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k * k - k + 1 = (k - 1) * k + 1\n\ngoal (1 subgoal):\n 1. (k * k - k + 1) * k ^ l mod (k - 1) =\n    ((k - 1) * k + 1) * k ^ l mod (k - 1)", "by auto"], ["proof (state)\nthis:\n  (k * k - k + 1) * k ^ l mod (k - 1) =\n  ((k - 1) * k + 1) * k ^ l mod (k - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (k * k - k + 1) * k ^ l mod (k - 1) =\n  ((k - 1) * k + 1) * k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  (k * k - k + 1) * k ^ l mod (k - 1) =\n  ((k - 1) * k + 1) * k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=1*k^l  mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((k - 1) * k + 1) * k ^ l mod (k - 1) = 1 * k ^ l mod (k - 1)", "by (metis mod_mult_right_eq mod_mult_self1 add.commute mult.commute)"], ["proof (state)\nthis:\n  ((k - 1) * k + 1) * k ^ l mod (k - 1) = 1 * k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  ((k - 1) * k + 1) * k ^ l mod (k - 1) = 1 * k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=k^l mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * k ^ l mod (k - 1) = k ^ l mod (k - 1)", "by auto"], ["proof (state)\nthis:\n  1 * k ^ l mod (k - 1) = k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  1 * k ^ l mod (k - 1) = k ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=(k-(1::nat)+1)^l mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k ^ l mod (k - 1) = (k - 1 + 1) ^ l mod (k - 1)", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. k ^ l mod (k - 1) = (k - 1 + 1) ^ l mod (k - 1)", "by auto"], ["proof (state)\nthis:\n  k ^ l mod (k - 1) = (k - 1 + 1) ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  k ^ l mod (k - 1) = (k - 1 + 1) ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=1^l mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k - 1 + 1) ^ l mod (k - 1) = 1 ^ l mod (k - 1)", "by (metis mod_add_self2 add.commute power_mod)"], ["proof (state)\nthis:\n  (k - 1 + 1) ^ l mod (k - 1) = 1 ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  (k - 1 + 1) ^ l mod (k - 1) = 1 ^ l mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=1 mod (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ^ l mod (k - 1) = 1 mod (k - 1)", "by auto"], ["proof (state)\nthis:\n  1 ^ l mod (k - 1) = 1 mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "also"], ["proof (state)\nthis:\n  1 ^ l mod (k - 1) = 1 mod (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "have \"...=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod (k - 1) = 1", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. 1 mod (k - 1) = 1", "by auto"], ["proof (state)\nthis:\n  1 mod (k - 1) = 1\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       (\\<And>l.\n           card (C (l + 1)) =\n           k * card (C_star l) + card (T l - C_star l)) \\<Longrightarrow>\n       card (C (l + 1)) mod (k - 1) = 1", "finally"], ["proof (chain)\npicking this:\n  card (C (l + 1)) mod (k - 1) = 1", "show \"card (C (l+1)) mod (k-(1::nat)) =1\""], ["proof (prove)\nusing this:\n  card (C (l + 1)) mod (k - 1) = 1\n\ngoal (1 subgoal):\n 1. card (C (l + 1)) mod (k - 1) = 1", "."], ["proof (state)\nthis:\n  card (C (l + 1)) mod (k - 1) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (C (?l + 1)) mod (k - 1) = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "obtain p::nat where \"prime p\" \"p dvd (k-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd k - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>k\\<ge>4\\<close>"], ["proof (prove)\nusing this:\n  4 \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd k - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_eq_plus1 Suc_numeral add_One_commute eq_iff le_diff_conv numeral_le_iff  \n      one_le_numeral one_plus_BitM prime_factor_nat semiring_norm(69) semiring_norm(71))"], ["proof (state)\nthis:\n  prime p\n  p dvd k - 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "hence p_minus_1:\"p-(1::nat)+1=p\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd k - 1\n\ngoal (1 subgoal):\n 1. p - 1 + 1 = p", "by (metis add_diff_inverse add.commute not_less_iff_gr_or_eq prime_nat_iff)"], ["proof (state)\nthis:\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "hence *: \"\\<And>l::nat. card (C (l+1)) mod p=1\""], ["proof (prove)\nusing this:\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) mod p = 1", "using \\<open>\\<And>l::nat. card (C (l+1)) mod (k-(1::nat))=1\\<close> mod_mod_cancel[OF \\<open>p dvd (k-(1::nat))\\<close>]\n      \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  p - 1 + 1 = p\n  card (C (?l + 1)) mod (k - 1) = 1\n  ?a mod (k - 1) mod p = ?a mod p\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>l. card (C (l + 1)) mod p = 1", "by (metis mod_if prime_gt_1_nat)"], ["proof (state)\nthis:\n  card (C (?l + 1)) mod p = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "have \"card (C (p - 1)) mod p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (C (p - 1)) mod p = 1", "proof (cases \"2 \\<le> p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1\n 2. \\<not> 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1", "case True"], ["proof (state)\nthis:\n  2 \\<le> p\n\ngoal (2 subgoals):\n 1. 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1\n 2. \\<not> 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1", "with * [of \"p - 2\"]"], ["proof (chain)\npicking this:\n  card (C (p - 2 + 1)) mod p = 1\n  2 \\<le> p", "show ?thesis"], ["proof (prove)\nusing this:\n  card (C (p - 2 + 1)) mod p = 1\n  2 \\<le> p\n\ngoal (1 subgoal):\n 1. card (C (p - 1)) mod p = 1", "by (metis Nat.add_diff_assoc2 add_le_cancel_right diff_diff_left one_add_one p_minus_1)"], ["proof (state)\nthis:\n  card (C (p - 1)) mod p = 1\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1", "case False"], ["proof (state)\nthis:\n  \\<not> 2 \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> p \\<Longrightarrow> card (C (p - 1)) mod p = 1", "with * [of \"p - 2\"] \\<open>prime p\\<close> prime_ge_2_nat"], ["proof (chain)\npicking this:\n  card (C (p - 2 + 1)) mod p = 1\n  prime p\n  prime ?p \\<Longrightarrow> 2 \\<le> ?p\n  \\<not> 2 \\<le> p", "show ?thesis"], ["proof (prove)\nusing this:\n  card (C (p - 2 + 1)) mod p = 1\n  prime p\n  prime ?p \\<Longrightarrow> 2 \\<le> ?p\n  \\<not> 2 \\<le> p\n\ngoal (1 subgoal):\n 1. card (C (p - 1)) mod p = 1", "by blast"], ["proof (state)\nthis:\n  card (C (p - 1)) mod p = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (C (p - 1)) mod p = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card (C (p - 1)) mod p = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "have \"card (C (p-(1::nat))) mod p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (C (p - 1)) mod p = 0", "using C"], ["proof (prove)\nusing this:\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n\ngoal (1 subgoal):\n 1. card (C (p - 1)) mod p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have closure1:\"\\<And>x. x\\<in>C (p-(1::nat))\\<Longrightarrow> rotate1 x \\<in>C (p-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "assume \"x\\<in>C (p-(1::nat))\""], ["proof (state)\nthis:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "hence \"length x = p\" and  \"adj_path (hd x) (tl x)\" and \"adjacent (last x) (hd x)\""], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. length x = p &&& adj_path (hd x) (tl x) &&& adjacent (last x) (hd x)", "using C p_minus_1"], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. length x = p &&& adj_path (hd x) (tl x) &&& adjacent (last x) (hd x)", "by auto"], ["proof (state)\nthis:\n  length x = p\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "have \"adjacent (last (rotate1 x)) (hd (rotate1 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "have \"x\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> []", "using \\<open>length x=p\\<close> \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  length x = p\n  prime p\n\ngoal (1 subgoal):\n 1. x \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "hence \"adjacent (last (rotate1 x)) (hd (rotate1 x))=adjacent (hd x) (hd (tl x))\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x)) =\n    adjacent (hd x) (hd (tl x))", "by (metis \\<open> adjacent (last x) (hd x) \\<close> adjacent_no_loop append_Nil list.sel(1,3)\n                  hd_append2 last_snoc list.exhaust rotate1_hd_tl)"], ["proof (state)\nthis:\n  adjacent (last (rotate1 x)) (hd (rotate1 x)) = adjacent (hd x) (hd (tl x))\n\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "also"], ["proof (state)\nthis:\n  adjacent (last (rotate1 x)) (hd (rotate1 x)) = adjacent (hd x) (hd (tl x))\n\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "have \"...=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent (hd x) (hd (tl x)) = True", "using \\<open>adj_path (hd x) (tl x)\\<close>"], ["proof (prove)\nusing this:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. adjacent (hd x) (hd (tl x)) = True", "using \\<open>adjacent (last x) (hd x)\\<close> \\<open>x \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  adj_path (hd x) (tl x)\n  adjacent (last x) (hd x)\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (hd x) (hd (tl x)) = True", "by (metis  adj_path.simps(2) adjacent_no_loop append1_eq_conv append_Nil \n                  append_butlast_last_id list.sel(1,3) list.exhaust)"], ["proof (state)\nthis:\n  adjacent (hd x) (hd (tl x)) = True\n\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "finally"], ["proof (chain)\npicking this:\n  adjacent (last (rotate1 x)) (hd (rotate1 x)) = True", "show ?thesis"], ["proof (prove)\nusing this:\n  adjacent (last (rotate1 x)) (hd (rotate1 x)) = True\n\ngoal (1 subgoal):\n 1. adjacent (last (rotate1 x)) (hd (rotate1 x))", "by auto"], ["proof (state)\nthis:\n  adjacent (last (rotate1 x)) (hd (rotate1 x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adjacent (last (rotate1 x)) (hd (rotate1 x))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "moreover"], ["proof (state)\nthis:\n  adjacent (last (rotate1 x)) (hd (rotate1 x))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "have \"adj_path (hd (rotate1 x)) (tl (rotate1 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "have \"x\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> []", "using \\<open>length x=p\\<close> \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  length x = p\n  prime p\n\ngoal (1 subgoal):\n 1. x \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> []", "obtain y ys where \"y=hd x\" \"ys=tl x\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>y = hd x; ys = tl x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = hd x\n  ys = tl x\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "hence  \"adj_path y ys\" and \"adjacent (last ys) y\" and \"ys\\<noteq>[]\""], ["proof (prove)\nusing this:\n  y = hd x\n  ys = tl x\n\ngoal (1 subgoal):\n 1. adj_path y ys &&& adjacent (last ys) y &&& ys \\<noteq> []", "by (metis \\<open>adj_path (hd x) (tl x)\\<close>, metis \\<open>adjacent (last x) (hd x)\\<close> \\<open>y = hd x\\<close> \n                  \\<open>ys = tl x\\<close> adjacent_no_loop list.sel(1,3) last.simps last_tl list.exhaust\n                  , metis \\<open>adjacent (last x) (hd x)\\<close> \\<open>x \\<noteq> []\\<close> \\<open>ys = tl x\\<close> adjacent_no_loop list.sel(1,3)\n                  last_ConsL neq_Nil_conv)"], ["proof (state)\nthis:\n  adj_path y ys\n  adjacent (last ys) y\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "hence \"adj_path (hd (rotate1 x)) (tl (rotate1 x))\n                  =adj_path (hd (ys@[y])) (tl (ys@[y]))\""], ["proof (prove)\nusing this:\n  adj_path y ys\n  adjacent (last ys) y\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x)) =\n    adj_path (hd (ys @ [y])) (tl (ys @ [y]))", "using \\<open>x\\<noteq>[]\\<close> \\<open>y=hd x\\<close> \\<open>ys=tl x\\<close>"], ["proof (prove)\nusing this:\n  adj_path y ys\n  adjacent (last ys) y\n  ys \\<noteq> []\n  x \\<noteq> []\n  y = hd x\n  ys = tl x\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x)) =\n    adj_path (hd (ys @ [y])) (tl (ys @ [y]))", "by (metis rotate1_hd_tl)"], ["proof (state)\nthis:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x)) =\n  adj_path (hd (ys @ [y])) (tl (ys @ [y]))\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "also"], ["proof (state)\nthis:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x)) =\n  adj_path (hd (ys @ [y])) (tl (ys @ [y]))\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "have \"...=adj_path (hd ys) ((tl ys)@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd (ys @ [y])) (tl (ys @ [y])) =\n    adj_path (hd ys) (tl ys @ [y])", "by (metis \\<open>ys \\<noteq> []\\<close> hd_append tl_append2)"], ["proof (state)\nthis:\n  adj_path (hd (ys @ [y])) (tl (ys @ [y])) = adj_path (hd ys) (tl ys @ [y])\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "also"], ["proof (state)\nthis:\n  adj_path (hd (ys @ [y])) (tl (ys @ [y])) = adj_path (hd ys) (tl ys @ [y])\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "have \"...=True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd ys) (tl ys @ [y]) = True", "using adj_path_app[OF \\<open>adj_path y ys\\<close> \\<open>ys\\<noteq>[]\\<close> \\<open>adjacent (last ys) y\\<close>] \\<open>ys\\<noteq>[]\\<close>"], ["proof (prove)\nusing this:\n  adj_path y (ys @ [y])\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. adj_path (hd ys) (tl ys @ [y]) = True", "by (metis adj_path.simps(2) append_Cons list.sel(1,3) list.exhaust)"], ["proof (state)\nthis:\n  adj_path (hd ys) (tl ys @ [y]) = True\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "finally"], ["proof (chain)\npicking this:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x)) = True", "show ?thesis"], ["proof (prove)\nusing this:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x)) = True\n\ngoal (1 subgoal):\n 1. adj_path (hd (rotate1 x)) (tl (rotate1 x))", "by auto"], ["proof (state)\nthis:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "moreover"], ["proof (state)\nthis:\n  adj_path (hd (rotate1 x)) (tl (rotate1 x))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "have \"length (rotate1 x) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rotate1 x) = p", "using \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  length x = p\n\ngoal (1 subgoal):\n 1. length (rotate1 x) = p", "by auto"], ["proof (state)\nthis:\n  length (rotate1 x) = p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> rotate1 x \\<in> C (p - 1)", "ultimately"], ["proof (chain)\npicking this:\n  adjacent (last (rotate1 x)) (hd (rotate1 x))\n  adj_path (hd (rotate1 x)) (tl (rotate1 x))\n  length (rotate1 x) = p", "show \"rotate1 x \\<in> C (p-(1::nat))\""], ["proof (prove)\nusing this:\n  adjacent (last (rotate1 x)) (hd (rotate1 x))\n  adj_path (hd (rotate1 x)) (tl (rotate1 x))\n  length (rotate1 x) = p\n\ngoal (1 subgoal):\n 1. rotate1 x \\<in> C (p - 1)", "using C p_minus_1"], ["proof (prove)\nusing this:\n  adjacent (last (rotate1 x)) (hd (rotate1 x))\n  adj_path (hd (rotate1 x)) (tl (rotate1 x))\n  length (rotate1 x) = p\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. rotate1 x \\<in> C (p - 1)", "by auto"], ["proof (state)\nthis:\n  rotate1 x \\<in> C (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> C (p - 1) \\<Longrightarrow> rotate1 ?x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have closure:\"\\<And>n x. x\\<in>C (p-(1::nat))\\<Longrightarrow> rotate n x \\<in>C (p-(1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<in> C (p - 1) \\<Longrightarrow> rotate n x \\<in> C (p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<in> C (p - 1) \\<Longrightarrow> rotate n x \\<in> C (p - 1)", "fix n x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<in> C (p - 1) \\<Longrightarrow> rotate n x \\<in> C (p - 1)", "assume \"x\\<in>C (p-(1::nat))\""], ["proof (state)\nthis:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<in> C (p - 1) \\<Longrightarrow> rotate n x \\<in> C (p - 1)", "thus \"rotate n x \\<in>C (p-(1::nat))\""], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. rotate n x \\<in> C (p - 1)", "by (induct n,auto,metis One_nat_def closure1)"], ["proof (state)\nthis:\n  rotate n x \\<in> C (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> C (p - 1) \\<Longrightarrow> rotate ?n ?x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "obtain r where r:\"r={(x,y). x\\<in>C (p-(1::nat)) \\<and> (\\<exists>n<p. rotate n x=y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r =\n        {(x, y).\n         x \\<in> C (p - 1) \\<and>\n         (\\<exists>n<p. rotate n x = y)} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have \"\\<And>x. x\\<in>C (p-(1::nat)) \\<Longrightarrow> p dvd card {y.(\\<exists>n<p. rotate n x=y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "assume \"x \\<in> C (p-(1::nat))\""], ["proof (state)\nthis:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "hence \"length x=p\""], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. length x = p", "using C p_minus_1"], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. length x = p", "by auto"], ["proof (state)\nthis:\n  length x = p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "have \"{y. (\\<exists>n<p. rotate n x=y)}= (\\<lambda>n. rotate n x)` {0..<p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>n<p. rotate n x = y} = (\\<lambda>n. rotate n x) ` {0..<p}", "by auto"], ["proof (state)\nthis:\n  {y. \\<exists>n<p. rotate n x = y} = (\\<lambda>n. rotate n x) ` {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "moreover"], ["proof (state)\nthis:\n  {y. \\<exists>n<p. rotate n x = y} = (\\<lambda>n. rotate n x) ` {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "have \"\\<And>n1 n2. n1\\<in>{0..<p} \\<Longrightarrow> n2\\<in>{0..<p} \\<Longrightarrow> n1\\<noteq>n2 \\<Longrightarrow> rotate n1 x\\<noteq>rotate n2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2\\<rbrakk>\n       \\<Longrightarrow> rotate n1 x \\<noteq> rotate n2 x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "fix n1 n2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"n1 \\<in> {0..<p}\" \"n2 \\<in> {0..<p}\" \"n1 \\<noteq> n2\" \"rotate n1 x = rotate n2 x\""], ["proof (state)\nthis:\n  n1 \\<in> {0..<p}\n  n2 \\<in> {0..<p}\n  n1 \\<noteq> n2\n  rotate n1 x = rotate n2 x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  n1 \\<in> {0..<p}\n  n2 \\<in> {0..<p}\n  n1 \\<noteq> n2\n  rotate n1 x = rotate n2 x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "fix n1 n2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"n1 \\<in> {0..<p}\" \"n2 \\<in> {0..<p}\" \"rotate n1 x = rotate n2 x\" \"n1>n2\""], ["proof (state)\nthis:\n  n1 \\<in> {0..<p}\n  n2 \\<in> {0..<p}\n  rotate n1 x = rotate n2 x\n  n2 < n1\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "obtain s::nat where \"s*(n1-n2) mod p=1\" \"s>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"n1-n2>0\" and \"n1-n2<p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n1 - n2 &&& n1 - n2 < p", "using \\<open>n1 \\<in> {0..<p}\\<close> \\<open>n2 \\<in> {0..<p}\\<close> \\<open>n1>n2\\<close>"], ["proof (prove)\nusing this:\n  n1 \\<in> {0..<p}\n  n2 \\<in> {0..<p}\n  n2 < n1\n\ngoal (1 subgoal):\n 1. 0 < n1 - n2 &&& n1 - n2 < p", "by auto"], ["proof (state)\nthis:\n  0 < n1 - n2\n  n1 - n2 < p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  0 < n1 - n2\n  n1 - n2 < p", "have \"coprime (n1 - n2) p\""], ["proof (prove)\nusing this:\n  prime p\n  0 < n1 - n2\n  n1 - n2 < p\n\ngoal (1 subgoal):\n 1. coprime (n1 - n2) p", "by (simp add: prime_nat_iff'' coprime_commute [of p])"], ["proof (state)\nthis:\n  coprime (n1 - n2) p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  coprime (n1 - n2) p", "have \"\\<exists>x. [(n1 - n2) * x = 1] (mod p)\""], ["proof (prove)\nusing this:\n  coprime (n1 - n2) p\n\ngoal (1 subgoal):\n 1. \\<exists>x. [(n1 - n2) * x = 1] (mod p)", "by (simp add: cong_solve_coprime_nat)"], ["proof (state)\nthis:\n  \\<exists>x. [(n1 - n2) * x = 1] (mod p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. [(n1 - n2) * x = 1] (mod p)", "obtain s where \"s * (n1 - n2) mod p = 1\""], ["proof (prove)\nusing this:\n  \\<exists>x. [(n1 - n2) * x = 1] (mod p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s * (n1 - n2) mod p = 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>prime p\\<close> prime_gt_1_nat [of p]"], ["proof (prove)\nusing this:\n  \\<exists>x. [(n1 - n2) * x = 1] (mod p)\n  prime p\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s * (n1 - n2) mod p = 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: cong_def ac_simps)"], ["proof (state)\nthis:\n  s * (n1 - n2) mod p = 1\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  s * (n1 - n2) mod p = 1\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"s>0\""], ["proof (prove)\nusing this:\n  s * (n1 - n2) mod p = 1\n\ngoal (1 subgoal):\n 1. 0 < s", "by (metis mod_0 mult_0 neq0_conv zero_neq_one)"], ["proof (state)\nthis:\n  0 < s\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s * (n1 - n2) mod p = 1; 0 < s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  s * (n1 - n2) mod p = 1\n  0 < s", "show ?thesis"], ["proof (prove)\nusing this:\n  s * (n1 - n2) mod p = 1\n  0 < s\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  s * (n1 - n2) mod p = 1\n  0 < s\n  \\<lbrakk>?s * (n1 - n2) mod p = 1; 0 < ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s * (n1 - n2) mod p = 1\n  0 < s\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "have \"rotate (s*n1) x=rotate (s*n2) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (s * n1) x = rotate (s * n2) x", "using \\<open>rotate n1 x=rotate n2 x\\<close>"], ["proof (prove)\nusing this:\n  rotate n1 x = rotate n2 x\n\ngoal (1 subgoal):\n 1. rotate (s * n1) x = rotate (s * n2) x", "apply (induct s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rotate n1 x = rotate n2 x \\<Longrightarrow>\n    rotate (0 * n1) x = rotate (0 * n2) x\n 2. \\<And>s.\n       \\<lbrakk>rotate n1 x = rotate n2 x \\<Longrightarrow>\n                rotate (s * n1) x = rotate (s * n2) x;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc s * n1) x = rotate (Suc s * n2) x", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rotate (s * n1) x = rotate (s * n2) x;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> rotate (n1 + s * n1) x = rotate (n2 + s * n2) x", "by (metis add.commute rotate_rotate)"], ["proof (state)\nthis:\n  rotate (s * n1) x = rotate (s * n2) x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"rotate (s*n1 - s*n2) x= x\""], ["proof (prove)\nusing this:\n  rotate (s * n1) x = rotate (s * n2) x\n\ngoal (1 subgoal):\n 1. rotate (s * n1 - s * n2) x = x", "using rotate_diff"], ["proof (prove)\nusing this:\n  rotate (s * n1) x = rotate (s * n2) x\n  rotate ?m ?xs = rotate ?n ?xs \\<Longrightarrow> rotate (?m - ?n) ?xs = ?xs\n\ngoal (1 subgoal):\n 1. rotate (s * n1 - s * n2) x = x", "by auto"], ["proof (state)\nthis:\n  rotate (s * n1 - s * n2) x = x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"rotate (s*(n1-n2)) x=x\""], ["proof (prove)\nusing this:\n  rotate (s * n1 - s * n2) x = x\n\ngoal (1 subgoal):\n 1. rotate (s * (n1 - n2)) x = x", "by (metis diff_mult_distrib mult.commute)"], ["proof (state)\nthis:\n  rotate (s * (n1 - n2)) x = x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"rotate 1 x = x\""], ["proof (prove)\nusing this:\n  rotate (s * (n1 - n2)) x = x\n\ngoal (1 subgoal):\n 1. rotate 1 x = x", "using \\<open>s*(n1-n2) mod p=1\\<close> \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  rotate (s * (n1 - n2)) x = x\n  s * (n1 - n2) mod p = 1\n  length x = p\n\ngoal (1 subgoal):\n 1. rotate 1 x = x", "by (metis rotate_conv_mod)"], ["proof (state)\nthis:\n  rotate 1 x = x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"rotate1 x=x\""], ["proof (prove)\nusing this:\n  rotate 1 x = x\n\ngoal (1 subgoal):\n 1. rotate1 x = x", "by auto"], ["proof (state)\nthis:\n  rotate1 x = x\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "have \"hd x=hd (tl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd x = hd (tl x)", "using \\<open>prime p\\<close> \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  length x = p\n\ngoal (1 subgoal):\n 1. hd x = hd (tl x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; length x = p\\<rbrakk>\n    \\<Longrightarrow> hd x = hd (tl x)", "have \"length x\\<ge>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "using \\<open>prime p\\<close> \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  length x = p\n\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "using prime_ge_2_nat"], ["proof (prove)\nusing this:\n  prime p\n  length x = p\n  prime ?p \\<Longrightarrow> 2 \\<le> ?p\n\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "by blast"], ["proof (state)\nthis:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; length x = p\\<rbrakk>\n    \\<Longrightarrow> hd x = hd (tl x)", "hence \"length (tl x)\\<ge>1\""], ["proof (prove)\nusing this:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. 1 \\<le> length (tl x)", "by force"], ["proof (state)\nthis:\n  1 \\<le> length (tl x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; length x = p\\<rbrakk>\n    \\<Longrightarrow> hd x = hd (tl x)", "hence \"x\\<noteq>[]\" and \"tl x\\<noteq>[]\""], ["proof (prove)\nusing this:\n  1 \\<le> length (tl x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] &&& tl x \\<noteq> []", "by auto+"], ["proof (state)\nthis:\n  x \\<noteq> []\n  tl x \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; length x = p\\<rbrakk>\n    \\<Longrightarrow> hd x = hd (tl x)", "hence \"x=(hd x)#(hd (tl x))#(tl (tl x))\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n  tl x \\<noteq> []\n\ngoal (1 subgoal):\n 1. x = hd x # hd (tl x) # tl (tl x)", "using hd_Cons_tl"], ["proof (prove)\nusing this:\n  x \\<noteq> []\n  tl x \\<noteq> []\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs # tl ?xs = ?xs\n\ngoal (1 subgoal):\n 1. x = hd x # hd (tl x) # tl (tl x)", "by auto"], ["proof (state)\nthis:\n  x = hd x # hd (tl x) # tl (tl x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; length x = p\\<rbrakk>\n    \\<Longrightarrow> hd x = hd (tl x)", "hence \"(hd (tl x))#(tl (tl x))@[hd x]=(hd x)#(hd (tl x))#(tl (tl x))\""], ["proof (prove)\nusing this:\n  x = hd x # hd (tl x) # tl (tl x)\n\ngoal (1 subgoal):\n 1. hd (tl x) # tl (tl x) @ [hd x] = hd x # hd (tl x) # tl (tl x)", "using \\<open>rotate1 x = x\\<close>"], ["proof (prove)\nusing this:\n  x = hd x # hd (tl x) # tl (tl x)\n  rotate1 x = x\n\ngoal (1 subgoal):\n 1. hd (tl x) # tl (tl x) @ [hd x] = hd x # hd (tl x) # tl (tl x)", "by (metis Cons_eq_appendI rotate1.simps(2))"], ["proof (state)\nthis:\n  hd (tl x) # tl (tl x) @ [hd x] = hd x # hd (tl x) # tl (tl x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; length x = p\\<rbrakk>\n    \\<Longrightarrow> hd x = hd (tl x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hd (tl x) # tl (tl x) @ [hd x] = hd x # hd (tl x) # tl (tl x)\n\ngoal (1 subgoal):\n 1. hd x = hd (tl x)", "by auto"], ["proof (state)\nthis:\n  hd x = hd (tl x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd x = hd (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  hd x = hd (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "have \"hd x\\<noteq>hd (tl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "have \"adj_path (hd x) (tl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "using \\<open>x \\<in> C (p-(1::nat))\\<close> C"], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n\ngoal (1 subgoal):\n 1. adj_path (hd x) (tl x)", "by auto"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "moreover"], ["proof (state)\nthis:\n  adj_path (hd x) (tl x)\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "have \"length x\\<ge>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "using \\<open>prime p\\<close> \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  length x = p\n\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "using prime_ge_2_nat"], ["proof (prove)\nusing this:\n  prime p\n  length x = p\n  prime ?p \\<Longrightarrow> 2 \\<le> ?p\n\ngoal (1 subgoal):\n 1. 2 \\<le> length x", "by blast"], ["proof (state)\nthis:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "hence \"length (tl x)\\<ge>1\""], ["proof (prove)\nusing this:\n  2 \\<le> length x\n\ngoal (1 subgoal):\n 1. 1 \\<le> length (tl x)", "by force"], ["proof (state)\nthis:\n  1 \\<le> length (tl x)\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "hence \"tl x\\<noteq>[]\""], ["proof (prove)\nusing this:\n  1 \\<le> length (tl x)\n\ngoal (1 subgoal):\n 1. tl x \\<noteq> []", "by force"], ["proof (state)\nthis:\n  tl x \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "ultimately"], ["proof (chain)\npicking this:\n  adj_path (hd x) (tl x)\n  tl x \\<noteq> []", "have \"adjacent (hd x) (hd (tl x))\""], ["proof (prove)\nusing this:\n  adj_path (hd x) (tl x)\n  tl x \\<noteq> []\n\ngoal (1 subgoal):\n 1. adjacent (hd x) (hd (tl x))", "by (metis adj_path.simps(2) list.sel(1) list.exhaust)"], ["proof (state)\nthis:\n  adjacent (hd x) (hd (tl x))\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  adjacent (hd x) (hd (tl x))\n\ngoal (1 subgoal):\n 1. hd x \\<noteq> hd (tl x)", "by (metis adjacent_no_loop)"], ["proof (state)\nthis:\n  hd x \\<noteq> hd (tl x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd x \\<noteq> hd (tl x)\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  hd x = hd (tl x)\n  hd x \\<noteq> hd (tl x)", "have False"], ["proof (prove)\nusing this:\n  hd x = hd (tl x)\n  hd x \\<noteq> hd (tl x)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?n1a2 \\<in> {0..<p}; ?n2a2 \\<in> {0..<p};\n   rotate ?n1a2 x = rotate ?n2a2 x; ?n2a2 < ?n1a2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>n1 n2.\n       \\<lbrakk>n1 \\<in> {0..<p}; n2 \\<in> {0..<p}; n1 \\<noteq> n2;\n        rotate n1 x = rotate n2 x\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n1a2 \\<in> {0..<p}; ?n2a2 \\<in> {0..<p};\n   rotate ?n1a2 x = rotate ?n2a2 x; ?n2a2 < ?n1a2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>n1 \\<in> {0..<p}\\<close> \\<open>n1 \\<noteq> n2\\<close> \\<open>n2 \\<in> {0..<p}\\<close> \\<open>rotate n1 x = rotate n2 x\\<close> \n                  less_linear)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?n1.0 \\<in> {0..<p}; ?n2.0 \\<in> {0..<p};\n   ?n1.0 \\<noteq> ?n2.0\\<rbrakk>\n  \\<Longrightarrow> rotate ?n1.0 x \\<noteq> rotate ?n2.0 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "hence \"inj_on (\\<lambda>n. rotate n x) {0..<p}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n1.0 \\<in> {0..<p}; ?n2.0 \\<in> {0..<p};\n   ?n1.0 \\<noteq> ?n2.0\\<rbrakk>\n  \\<Longrightarrow> rotate ?n1.0 x \\<noteq> rotate ?n2.0 x\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. rotate n x) {0..<p}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n1.0 \\<in> {0..<p}; ?n2.0 \\<in> {0..<p};\n   ?n1.0 \\<noteq> ?n2.0\\<rbrakk>\n  \\<Longrightarrow> rotate ?n1.0 x \\<noteq> rotate ?n2.0 x\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>{0..<p}.\n       \\<forall>y\\<in>{0..<p}.\n          rotate xa x = rotate y x \\<longrightarrow> xa = y", "by fast"], ["proof (state)\nthis:\n  inj_on (\\<lambda>n. rotate n x) {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "ultimately"], ["proof (chain)\npicking this:\n  {y. \\<exists>n<p. rotate n x = y} = (\\<lambda>n. rotate n x) ` {0..<p}\n  inj_on (\\<lambda>n. rotate n x) {0..<p}", "have \"card {y. (\\<exists>n<p. rotate n x=y)}=card {0..<p}\""], ["proof (prove)\nusing this:\n  {y. \\<exists>n<p. rotate n x = y} = (\\<lambda>n. rotate n x) ` {0..<p}\n  inj_on (\\<lambda>n. rotate n x) {0..<p}\n\ngoal (1 subgoal):\n 1. card {y. \\<exists>n<p. rotate n x = y} = card {0..<p}", "by (metis card_image)"], ["proof (state)\nthis:\n  card {y. \\<exists>n<p. rotate n x = y} = card {0..<p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "hence \"card {y. (\\<exists>n<p. rotate n x=y)}=p\""], ["proof (prove)\nusing this:\n  card {y. \\<exists>n<p. rotate n x = y} = card {0..<p}\n\ngoal (1 subgoal):\n 1. card {y. \\<exists>n<p. rotate n x = y} = p", "by auto"], ["proof (state)\nthis:\n  card {y. \\<exists>n<p. rotate n x = y} = p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C (p - 1) \\<Longrightarrow>\n       p dvd card {y. \\<exists>n<p. rotate n x = y}", "thus \"p dvd card {y. (\\<exists>n<p. rotate n x=y)}\""], ["proof (prove)\nusing this:\n  card {y. \\<exists>n<p. rotate n x = y} = p\n\ngoal (1 subgoal):\n 1. p dvd card {y. \\<exists>n<p. rotate n x = y}", "by auto"], ["proof (state)\nthis:\n  p dvd card {y. \\<exists>n<p. rotate n x = y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> C (p - 1) \\<Longrightarrow>\n  p dvd card {y. \\<exists>n<p. rotate n ?x = y}\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "hence \"\\<forall>X\\<in>C (p-(1::nat)) // r. p dvd card X\""], ["proof (prove)\nusing this:\n  ?x \\<in> C (p - 1) \\<Longrightarrow>\n  p dvd card {y. \\<exists>n<p. rotate n ?x = y}\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>C (p - 1) // r. p dvd card X", "unfolding quotient_def Image_def r"], ["proof (prove)\nusing this:\n  ?x \\<in> C (p - 1) \\<Longrightarrow>\n  p dvd card {y. \\<exists>n<p. rotate n ?x = y}\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>\\<Union>x\\<in>C (p - 1).\n                      {{y. \\<exists>x\\<in>{x}.\n                              (x, y)\n                              \\<in> {(x, y).\n                                     x \\<in> C (p - 1) \\<and>\n                                     (\\<exists>n<p. rotate n x = y)}}}.\n       p dvd card X", "by auto"], ["proof (state)\nthis:\n  \\<forall>X\\<in>C (p - 1) // r. p dvd card X\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>C (p - 1) // r. p dvd card X\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have \"refl_on (C (p - 1)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "have \"r \\<subseteq> C (p - 1) \\<times> C (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> C (p - 1) \\<times> C (p - 1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "assume \"x\\<in>r\""], ["proof (state)\nthis:\n  x \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "hence \"fst x\\<in>C (p - 1)\" and \"\\<exists>n. snd x=rotate n (fst x)\""], ["proof (prove)\nusing this:\n  x \\<in> r\n\ngoal (1 subgoal):\n 1. fst x \\<in> C (p - 1) &&& \\<exists>n. snd x = rotate n (fst x)", "using r"], ["proof (prove)\nusing this:\n  x \\<in> r\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. fst x \\<in> C (p - 1) &&& \\<exists>n. snd x = rotate n (fst x)", "by auto"], ["proof (state)\nthis:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "moreover"], ["proof (state)\nthis:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "then"], ["proof (chain)\npicking this:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)", "obtain n where \"snd x=rotate n (fst x)\""], ["proof (prove)\nusing this:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        snd x = rotate n (fst x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd x = rotate n (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "ultimately"], ["proof (chain)\npicking this:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)\n  snd x = rotate n (fst x)", "have \"snd x\\<in>C (p - 1)\""], ["proof (prove)\nusing this:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)\n  snd x = rotate n (fst x)\n\ngoal (1 subgoal):\n 1. snd x \\<in> C (p - 1)", "using closure"], ["proof (prove)\nusing this:\n  fst x \\<in> C (p - 1)\n  \\<exists>n. snd x = rotate n (fst x)\n  snd x = rotate n (fst x)\n  ?x \\<in> C (p - 1) \\<Longrightarrow> rotate ?n ?x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. snd x \\<in> C (p - 1)", "by auto"], ["proof (state)\nthis:\n  snd x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "moreover"], ["proof (state)\nthis:\n  snd x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "have \"x=(fst x,snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (fst x, snd x)", "using \\<open>x\\<in>r\\<close> r"], ["proof (prove)\nusing this:\n  x \\<in> r\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. x = (fst x, snd x)", "by auto"], ["proof (state)\nthis:\n  x = (fst x, snd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> r \\<Longrightarrow> x \\<in> C (p - 1) \\<times> C (p - 1)", "ultimately"], ["proof (chain)\npicking this:\n  snd x \\<in> C (p - 1)\n  x = (fst x, snd x)", "show  \"x \\<in> C (p - 1) \\<times> C (p - 1)\""], ["proof (prove)\nusing this:\n  snd x \\<in> C (p - 1)\n  x = (fst x, snd x)\n\ngoal (1 subgoal):\n 1. x \\<in> C (p - 1) \\<times> C (p - 1)", "using \\<open>fst x\\<in> C (p - 1)\\<close>"], ["proof (prove)\nusing this:\n  snd x \\<in> C (p - 1)\n  x = (fst x, snd x)\n  fst x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. x \\<in> C (p - 1) \\<times> C (p - 1)", "by (metis SigmaI)"], ["proof (state)\nthis:\n  x \\<in> C (p - 1) \\<times> C (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<subseteq> C (p - 1) \\<times> C (p - 1)\n\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "moreover"], ["proof (state)\nthis:\n  r \\<subseteq> C (p - 1) \\<times> C (p - 1)\n\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "have \"\\<forall>x\\<in>C (p - 1). (x, x) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>C (p - 1). (x, x) \\<in> r", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "assume \"x \\<in> C (p - 1)\""], ["proof (state)\nthis:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "hence \"rotate 0 x \\<in> C (p - 1)\""], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. rotate 0 x \\<in> C (p - 1)", "using closure"], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n  ?x \\<in> C (p - 1) \\<Longrightarrow> rotate ?n ?x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. rotate 0 x \\<in> C (p - 1)", "by auto"], ["proof (state)\nthis:\n  rotate 0 x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "moreover"], ["proof (state)\nthis:\n  rotate 0 x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "have \"0<p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p", "using \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 0 < p", "by (auto intro: prime_gt_0_nat)"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  rotate 0 x \\<in> C (p - 1)\n  0 < p", "have \"(x,rotate 0 x)\\<in> r\""], ["proof (prove)\nusing this:\n  rotate 0 x \\<in> C (p - 1)\n  0 < p\n\ngoal (1 subgoal):\n 1. (x, rotate 0 x) \\<in> r", "using \\<open>x\\<in>C (p - 1 )\\<close> r"], ["proof (prove)\nusing this:\n  rotate 0 x \\<in> C (p - 1)\n  0 < p\n  x \\<in> C (p - 1)\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. (x, rotate 0 x) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (x, rotate 0 x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "moreover"], ["proof (state)\nthis:\n  (x, rotate 0 x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "have \"rotate 0 x=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate 0 x = x", "by auto"], ["proof (state)\nthis:\n  rotate 0 x = x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C (p - 1) \\<Longrightarrow> (x, x) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  (x, rotate 0 x) \\<in> r\n  rotate 0 x = x", "show \"(x,x)\\<in>r\""], ["proof (prove)\nusing this:\n  (x, rotate 0 x) \\<in> r\n  rotate 0 x = x\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (x, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>C (p - 1). (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "ultimately"], ["proof (chain)\npicking this:\n  r \\<subseteq> C (p - 1) \\<times> C (p - 1)\n  \\<forall>x\\<in>C (p - 1). (x, x) \\<in> r", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<subseteq> C (p - 1) \\<times> C (p - 1)\n  \\<forall>x\\<in>C (p - 1). (x, x) \\<in> r\n\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "using refl_on_def"], ["proof (prove)\nusing this:\n  r \\<subseteq> C (p - 1) \\<times> C (p - 1)\n  \\<forall>x\\<in>C (p - 1). (x, x) \\<in> r\n  refl_on ?A ?r =\n  (?r \\<subseteq> ?A \\<times> ?A \\<and>\n   (\\<forall>x\\<in>?A. (x, x) \\<in> ?r))\n\ngoal (1 subgoal):\n 1. refl_on (C (p - 1)) r", "by auto"], ["proof (state)\nthis:\n  refl_on (C (p - 1)) r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  refl_on (C (p - 1)) r\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "moreover"], ["proof (state)\nthis:\n  refl_on (C (p - 1)) r\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have \"sym r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym r", "unfolding sym_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (x, y) \\<in> r \\<longrightarrow> (y, x) \\<in> r", "proof (rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "assume \"(x, y) \\<in> r\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "hence \"x\\<in>C (p - 1)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> C (p - 1)", "using r"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. x \\<in> C (p - 1)", "by auto"], ["proof (state)\nthis:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "hence \"length x=p\""], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. length x = p", "using C p_minus_1"], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. length x = p", "by auto"], ["proof (state)\nthis:\n  length x = p\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "obtain n where \"n<p\" \"rotate n x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < p; rotate n x = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(x,y)\\<in>r\\<close> r"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < p; rotate n x = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < p\n  rotate n x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "hence \"y\\<in> C (p - 1)\""], ["proof (prove)\nusing this:\n  n < p\n  rotate n x = y\n\ngoal (1 subgoal):\n 1. y \\<in> C (p - 1)", "using closure[OF \\<open>x\\<in> C (p - 1)\\<close>]"], ["proof (prove)\nusing this:\n  n < p\n  rotate n x = y\n  rotate ?n x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. y \\<in> C (p - 1)", "by auto"], ["proof (state)\nthis:\n  y \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "have \"n=0\\<Longrightarrow>(y, x) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> (y, x) \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> (y, x) \\<in> r", "assume \"n=0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> (y, x) \\<in> r", "hence \"x=y\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>rotate n x=y\\<close>"], ["proof (prove)\nusing this:\n  n = 0\n  rotate n x = y\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> (y, x) \\<in> r", "thus \"(y,x)\\<in>r\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "using \\<open>refl_on (C (p - 1)) r\\<close> \\<open>y \\<in> C (p - 1)\\<close> refl_on_def"], ["proof (prove)\nusing this:\n  x = y\n  refl_on (C (p - 1)) r\n  y \\<in> C (p - 1)\n  refl_on ?A ?r =\n  (?r \\<subseteq> ?A \\<times> ?A \\<and>\n   (\\<forall>x\\<in>?A. (x, x) \\<in> ?r))\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by fast"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow> (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "moreover"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow> (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "have \"n\\<noteq>0 \\<Longrightarrow> (y,x)\\<in>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "assume \"n\\<noteq>0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "have \"rotate (p-n) y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "have \"rotate (p-n) y = rotate (p-n) (rotate n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (p - n) y = rotate (p - n) (rotate n x)", "using \\<open>rotate n x=y\\<close>"], ["proof (prove)\nusing this:\n  rotate n x = y\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = rotate (p - n) (rotate n x)", "by auto"], ["proof (state)\nthis:\n  rotate (p - n) y = rotate (p - n) (rotate n x)\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "also"], ["proof (state)\nthis:\n  rotate (p - n) y = rotate (p - n) (rotate n x)\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "have \"rotate (p-n) (rotate n x)=rotate (p-n+n) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (p - n) (rotate n x) = rotate (p - n + n) x", "using rotate_rotate"], ["proof (prove)\nusing this:\n  rotate ?m (rotate ?n ?xs) = rotate (?m + ?n) ?xs\n\ngoal (1 subgoal):\n 1. rotate (p - n) (rotate n x) = rotate (p - n + n) x", "by auto"], ["proof (state)\nthis:\n  rotate (p - n) (rotate n x) = rotate (p - n + n) x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "also"], ["proof (state)\nthis:\n  rotate (p - n) (rotate n x) = rotate (p - n + n) x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "have \"...=rotate p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (p - n + n) x = rotate p x", "using \\<open>n<p\\<close>"], ["proof (prove)\nusing this:\n  n < p\n\ngoal (1 subgoal):\n 1. rotate (p - n + n) x = rotate p x", "by auto"], ["proof (state)\nthis:\n  rotate (p - n + n) x = rotate p x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "also"], ["proof (state)\nthis:\n  rotate (p - n + n) x = rotate p x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "have \"...=rotate 0 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate p x = rotate 0 x", "using \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  length x = p\n\ngoal (1 subgoal):\n 1. rotate p x = rotate 0 x", "by auto"], ["proof (state)\nthis:\n  rotate p x = rotate 0 x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "also"], ["proof (state)\nthis:\n  rotate p x = rotate 0 x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "have \"...=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate 0 x = x", "by auto"], ["proof (state)\nthis:\n  rotate 0 x = x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "finally"], ["proof (chain)\npicking this:\n  rotate (p - n) y = x", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate (p - n) y = x\n\ngoal (1 subgoal):\n 1. rotate (p - n) y = x", "."], ["proof (state)\nthis:\n  rotate (p - n) y = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rotate (p - n) y = x\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "moreover"], ["proof (state)\nthis:\n  rotate (p - n) y = x\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "have \"p-n<p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - n < p", "using \\<open>n<p\\<close> \\<open>n\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  n < p\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p - n < p", "by auto"], ["proof (state)\nthis:\n  p - n < p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  rotate (p - n) y = x\n  p - n < p", "show \"(y,x)\\<in>r\""], ["proof (prove)\nusing this:\n  rotate (p - n) y = x\n  p - n < p\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "using r \\<open>y\\<in> C (p - 1)\\<close>"], ["proof (prove)\nusing this:\n  rotate (p - n) y = x\n  p - n < p\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n  y \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x, y) \\<in> r \\<Longrightarrow> (y, x) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  n = 0 \\<Longrightarrow> (y, x) \\<in> r\n  n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r", "show \"(y,x)\\<in>r\""], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow> (y, x) \\<in> r\n  n \\<noteq> 0 \\<Longrightarrow> (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sym r\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "moreover"], ["proof (state)\nthis:\n  sym r\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have \"trans r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans r", "unfolding trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> r \\<longrightarrow>\n       (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r", "proof (rule,rule,rule,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "assume \"(x, y) \\<in> r\" \"(y, z) \\<in> r\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "hence \"x\\<in>C (p - 1)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<in> C (p - 1)", "using r"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. x \\<in> C (p - 1)", "by auto"], ["proof (state)\nthis:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "hence \"length x=p\""], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n\ngoal (1 subgoal):\n 1. length x = p", "using C p_minus_1"], ["proof (prove)\nusing this:\n  x \\<in> C (p - 1)\n  C =\n  (\\<lambda>l.\n      {ps.\n       length ps = l + 1 \\<and>\n       adj_path (hd ps) (tl ps) \\<and> adjacent (last ps) (hd ps)})\n  p - 1 + 1 = p\n\ngoal (1 subgoal):\n 1. length x = p", "by auto"], ["proof (state)\nthis:\n  length x = p\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "obtain n1 n2 where \"n1<p\" \"n2<p\" \"y=rotate n1 x\" \"z=rotate n2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n1 n2.\n        \\<lbrakk>n1 < p; n2 < p; y = rotate n1 x; z = rotate n2 y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r \\<open>(x,y)\\<in>r\\<close> \\<open>(y,z)\\<in>r\\<close>"], ["proof (prove)\nusing this:\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (\\<And>n1 n2.\n        \\<lbrakk>n1 < p; n2 < p; y = rotate n1 x; z = rotate n2 y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n1 < p\n  n2 < p\n  y = rotate n1 x\n  z = rotate n2 y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "hence \"z=rotate (n2+n1) x\""], ["proof (prove)\nusing this:\n  n1 < p\n  n2 < p\n  y = rotate n1 x\n  z = rotate n2 y\n\ngoal (1 subgoal):\n 1. z = rotate (n2 + n1) x", "by (metis rotate_rotate)"], ["proof (state)\nthis:\n  z = rotate (n2 + n1) x\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "hence \"z=rotate ((n2+n1) mod p) x\""], ["proof (prove)\nusing this:\n  z = rotate (n2 + n1) x\n\ngoal (1 subgoal):\n 1. z = rotate ((n2 + n1) mod p) x", "using \\<open>length x=p\\<close>"], ["proof (prove)\nusing this:\n  z = rotate (n2 + n1) x\n  length x = p\n\ngoal (1 subgoal):\n 1. z = rotate ((n2 + n1) mod p) x", "by (metis rotate_conv_mod)"], ["proof (state)\nthis:\n  z = rotate ((n2 + n1) mod p) x\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "moreover"], ["proof (state)\nthis:\n  z = rotate ((n2 + n1) mod p) x\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "have \"(n2+n1) mod p < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n2 + n1) mod p < p", "by (metis \\<open>prime p\\<close> mod_less_divisor prime_gt_0_nat)"], ["proof (state)\nthis:\n  (n2 + n1) mod p < p\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  z = rotate ((n2 + n1) mod p) x\n  (n2 + n1) mod p < p", "show \"(x,z)\\<in>r\""], ["proof (prove)\nusing this:\n  z = rotate ((n2 + n1) mod p) x\n  (n2 + n1) mod p < p\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r", "using \\<open>x\\<in> C (p - 1)\\<close> r"], ["proof (prove)\nusing this:\n  z = rotate ((n2 + n1) mod p) x\n  (n2 + n1) mod p < p\n  x \\<in> C (p - 1)\n  r = {(x, y). x \\<in> C (p - 1) \\<and> (\\<exists>n<p. rotate n x = y)}\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trans r\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "moreover"], ["proof (state)\nthis:\n  trans r\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "have \"finite (C (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (C (p - 1))", "by (metis \\<open>card (C (p - 1)) mod p = 1\\<close> card_eq_0_iff mod_0 zero_neq_one)"], ["proof (state)\nthis:\n  finite (C (p - 1))\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>C (p - 1) // r. p dvd card X\n  refl_on (C (p - 1)) r\n  sym r\n  trans r\n  finite (C (p - 1))", "have \"p dvd card (C (p-(1::nat)))\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>C (p - 1) // r. p dvd card X\n  refl_on (C (p - 1)) r\n  sym r\n  trans r\n  finite (C (p - 1))\n\ngoal (1 subgoal):\n 1. p dvd card (C (p - 1))", "using equiv_imp_dvd_card equiv_def"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>C (p - 1) // r. p dvd card X\n  refl_on (C (p - 1)) r\n  sym r\n  trans r\n  finite (C (p - 1))\n  \\<lbrakk>finite ?A; equiv ?A ?r;\n   \\<And>X. X \\<in> ?A // ?r \\<Longrightarrow> ?k dvd card X\\<rbrakk>\n  \\<Longrightarrow> ?k dvd card ?A\n  equiv ?A ?r = (refl_on ?A ?r \\<and> sym ?r \\<and> trans ?r)\n\ngoal (1 subgoal):\n 1. p dvd card (C (p - 1))", "by fast"], ["proof (state)\nthis:\n  p dvd card (C (p - 1))\n\ngoal (1 subgoal):\n 1. C =\n    (\\<lambda>l.\n        {ps.\n         length ps = l + 1 \\<and>\n         adj_path (hd ps) (tl ps) \\<and>\n         adjacent (last ps) (hd ps)}) \\<Longrightarrow>\n    card (C (p - 1)) mod p = 0", "thus \"card (C (p-(1::nat))) mod p=0\""], ["proof (prove)\nusing this:\n  p dvd card (C (p - 1))\n\ngoal (1 subgoal):\n 1. card (C (p - 1)) mod p = 0", "by (metis dvd_eq_mod_eq_0)"], ["proof (state)\nthis:\n  card (C (p - 1)) mod p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (C (p - 1)) mod p = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>V. degree v G = 2) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  card (C (p - 1)) mod p = 1\n  card (C (p - 1)) mod p = 0", "show False"], ["proof (prove)\nusing this:\n  card (C (p - 1)) mod p = 1\n  card (C (p - 1)) mod p = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in valid_unSimpGraph) friendship_thm:\n  assumes friend_assm:\"\\<And>v u. v\\<in>V \\<Longrightarrow> u\\<in>V \\<Longrightarrow> v\\<noteq>u \\<Longrightarrow> \\<exists>! n. adjacent v n \\<and> adjacent u n\"\n      and \"finite V\" \n  shows \"\\<exists>v. \\<forall>n\\<in>V. n\\<noteq>v \\<longrightarrow> adjacent v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "have \"card V=0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 0 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "using \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. card V = 0 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "by (metis all_not_in_conv card_seteq empty_subsetI le0)"], ["proof (state)\nthis:\n  card V = 0 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "moreover"], ["proof (state)\nthis:\n  card V = 0 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "have \"card V=1 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "assume \"card V=1\""], ["proof (state)\nthis:\n  card V = 1\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "then"], ["proof (chain)\npicking this:\n  card V = 1", "obtain v where \"V={v}\""], ["proof (prove)\nusing this:\n  card V = 1\n\ngoal (1 subgoal):\n 1. (\\<And>v. V = {v} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using card_eq_SucD[of V 0]"], ["proof (prove)\nusing this:\n  card V = 1\n  card V = Suc 0 \\<Longrightarrow>\n  \\<exists>b B.\n     V = insert b B \\<and>\n     b \\<notin> B \\<and> card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. (\\<And>v. V = {v} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  V = {v}\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "hence \"\\<forall>n\\<in>V. n=v\""], ["proof (prove)\nusing this:\n  V = {v}\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>V. n = v", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<in>V. n = v\n\ngoal (1 subgoal):\n 1. card V = 1 \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "thus \"\\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>V. n = v\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "by auto"], ["proof (state)\nthis:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card V = 1 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "moreover"], ["proof (state)\nthis:\n  card V = 1 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "have \"card V\\<ge>2 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> card V \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> card V \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "assume \"card V\\<ge>2\""], ["proof (state)\nthis:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "hence \"\\<exists>v\\<in>V. degree v G = 2\""], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. degree v G = 2", "using exist_degree_two[OF friend_assm] \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u;\n   finite E; finite V; 2 \\<le> card V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<in>V. degree v G = 2\n  finite V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. degree v G = 2", "by auto"], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. degree v G = 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V \\<Longrightarrow>\n    \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. degree v G = 2\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "using degree_two_windmill[OF friend_assm] \\<open>card V\\<ge>2\\<close> \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. degree v G = 2\n  \\<lbrakk>\\<And>v u.\n              \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n              \\<Longrightarrow> v \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> u \\<in> V;\n   \\<And>v u.\n      \\<lbrakk>v \\<in> V; u \\<in> V; v \\<noteq> u\\<rbrakk>\n      \\<Longrightarrow> v \\<noteq> u;\n   finite E; 2 \\<le> card V\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>v\\<in>V. degree v G = 2) =\n                    (\\<exists>v.\n                        \\<forall>n\\<in>V.\n                           n \\<noteq> v \\<longrightarrow> adjacent v n)\n  2 \\<le> card V\n  finite V\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "by auto"], ["proof (state)\nthis:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 \\<le> card V \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "ultimately"], ["proof (chain)\npicking this:\n  card V = 0 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  card V = 1 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  2 \\<le> card V \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "show ?thesis"], ["proof (prove)\nusing this:\n  card V = 0 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  card V = 1 \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n  2 \\<le> card V \\<Longrightarrow>\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n", "by force"], ["proof (state)\nthis:\n  \\<exists>v. \\<forall>n\\<in>V. n \\<noteq> v \\<longrightarrow> adjacent v n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}