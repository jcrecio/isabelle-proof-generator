{"file_name": "/home/qj213/afp-2021-10-22/thys/Linear_Programming/LP_Preliminaries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Linear_Programming", "problem_names": ["lemma constraints_set_vars_geq_vec_def:\n  \"set (vars_from_index_geq_vec start b) = \n   {GEQ (lp_monom 1 (i+start)) (b$i) |i. i \\<in> {0..<dim_vec b}}\"", "lemma vars_from_index_geq_sat:\n  assumes \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (vars_from_index_geq_vec start b)\"\n  assumes \"i < dim_vec b\"\n  shows \"\\<langle>x\\<rangle> (i+start) \\<ge> b$i\"", "lemma mat_x_leq_vec_sol:\n  assumes \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\"\n  assumes \"i < dim_vec b\"\n  shows \"((matrix_to_lpolies A)!i) \\<lbrace>\\<langle>x\\<rangle>\\<rbrace> \\<le> b$i\"", "lemma x_mat_eq_vec_sol:\n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec b A)\"\n  assumes \"i < dim_vec b\"\n  shows \"((matrix_to_lpolies A)!i) \\<lbrace> x \\<rbrace> = b$i\"", "lemma split_two_block_non_interfering:\n  assumes \"split_block (two_block_non_interfering A B) (dim_row A) (dim_col A) = (Q1, Q2, Q3, Q4)\"\n  shows \"Q1 = A\" \"Q4 = B\"", "lemma two_block_non_interfering_dims: \n  \"dim_row (two_block_non_interfering A B) = dim_row A + dim_row B\"\n  \"dim_col (two_block_non_interfering A B) = dim_col A + dim_col B\"", "lemma two_block_non_interfering_zeros_are_0:\n  assumes \"i < dim_row A\"\n    and \"j \\<ge> dim_col A\"\n    and \"j < dim_col (two_block_non_interfering A B)\"\n  shows \"(two_block_non_interfering A B)$$(i,j) = 0\" \"(two_block_non_interfering A B)$$(i,j) = 0\"", "lemma two_block_non_interfering_row_comp1:\n  assumes \"i <dim_row A\"\n  shows \"row (two_block_non_interfering A B) i = row A i @\\<^sub>v (0\\<^sub>v (dim_col B))\"", "lemma two_block_non_interfering_row_comp2:\n  assumes \"i <dim_row (two_block_non_interfering A B)\"\n    and \"i \\<ge> dim_row A\"\n  shows \"row (two_block_non_interfering A B) i = (0\\<^sub>v (dim_col A)) @\\<^sub>v row B (i - dim_row A)\"", "lemma first_vec_two_block_non_inter_is_first_vec:\n  assumes \"dim_col A + dim_col B = dim_vec v\"\n  assumes \"dim_row A = n\"\n  shows \"vec_first (two_block_non_interfering A B *\\<^sub>v v) n = A *\\<^sub>v (vec_first v (dim_col A))\"", "lemma last_vec_two_block_non_inter_is_last_vec:\n  assumes \"dim_col A + dim_col B = dim_vec v\"\n  assumes \"dim_row B = n\"\n  shows \"vec_last ((two_block_non_interfering A B) *\\<^sub>v v) n = B *\\<^sub>v (vec_last v (dim_col B))\"", "lemma two_block_non_interfering_mult_decomposition:\n  assumes \"dim_col A + dim_col B = dim_vec v\"      \n  shows \"two_block_non_interfering A B *\\<^sub>v v =\n         A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v B *\\<^sub>v vec_last v (dim_col B)\"", "lemma mat_leqb_eqc_for_LEQ:\n  assumes \"i < dim_vec b\"\n  assumes \"i < dim_row A\"\n  shows \"(mat_leqb_eqc A b c)!i = LEQ ((matrix_to_lpolies A)!i) (b$i)\"", "lemma mat_leqb_eqc_for_EQ:\n  assumes \"dim_vec b \\<le> i\" and \"i < dim_vec (b@\\<^sub>vc)\"\n  assumes \"dim_row A = dim_vec b\" and \"dim_col A \\<ge> dim_vec c\"\n  shows \"(mat_leqb_eqc A b c)!i = \n    EQ (vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i-dim_vec b))) (c$(i-dim_vec b))\"", "lemma mat_leqb_eqc_satisfies1:\n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"i < dim_vec b\"\n    and \"i < dim_row A\"\n  shows \"(matrix_to_lpolies A!i) \\<lbrace>x\\<rbrace> \\<le> b$i\"", "lemma mat_leqb_eqc_satisfies2:\n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"dim_vec b \\<le> i\" and \"i < dim_vec (b@\\<^sub>vc)\"\n    and \"dim_row A = dim_vec b\" and \"dim_vec c \\<le> dim_col A\"\n  shows \"(matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i) \\<lbrace>x\\<rbrace> = (b @\\<^sub>v c) $ i\"", "lemma mat_leqb_eqc_simplex_satisfies2:\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat x\"\n  assumes \"dim_vec b \\<le> i\" and \"i < dim_vec (b@\\<^sub>vc)\"\n    and \"dim_row A = dim_vec b\" and \"dim_vec c \\<le> dim_col A\"\n  shows \"(matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i) \\<lbrace>\\<langle>x\\<rangle>\\<rbrace> = (b @\\<^sub>v c) $ i\"", "lemma index_geq_n_simplex: \n  assumes \"\\<langle>x\\<rangle>  \\<Turnstile>\\<^sub>c (index_geq_n i n)\"\n  shows \"\\<langle>x\\<rangle> i \\<ge> n\"", "lemma from_index_geq_vector_simplex: \n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector i v)\"\n  \"j < dim_vec v\"\n  shows \"x (i + j) \\<ge> v$j\"", "lemma from_index_geq0_vector_simplex2: \n  assumes \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector i v)\"\n  assumes \"i \\<le> j\" and \"j < (dim_vec v) + i\"\n  shows \"\\<langle>x\\<rangle> j \\<ge> v$(j - i)\"", "lemma x_times_c_geq_y_times_b_correct:\n  assumes \"simplex [x_times_c_geq_y_times_b c b] = Sat x\"\n  shows \"((vec_to_lpoly (c @\\<^sub>v 0\\<^sub>v (dim_vec b))) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>) \\<ge>\n         ((vec_to_lpoly (0\\<^sub>v (dim_vec c) @\\<^sub>v b)) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>)\"", "lemma split_vec_dims:\n  assumes \"split_i_j_x i j x = (a ,b)\"\n  shows \"dim_vec a = i\" \"dim_vec b = (j - i)\"", "lemma split_n_m_x_abbrev_dims: \n  assumes \"split_n_m_x n m x = (a, b)\"\n  shows \"dim_vec a = n\" \"dim_vec b = m\"", "lemma split_access_fst_1:\n  assumes \"k < i\"\n  assumes \"split_i_j_x i j x = (a, b)\"\n  shows \"a $ k = \\<langle>x\\<rangle> k\"", "lemma split_access_snd_1:\n  assumes \"i \\<le> k\" and \"k < j\"\n  assumes \"split_i_j_x i j x = (a, b)\"\n  shows \"b $ (k - i) = \\<langle>x\\<rangle> k\"", "lemma split_access_fst_2:\n  assumes \"(x, y) = split_i_j_x i j Z\"\n  assumes \"k < dim_vec x\"\n  shows \"x$k = \\<langle>Z\\<rangle> k\"", "lemma split_access_snd_2:\n  assumes \"(x, y) = split_i_j_x i j Z\"\n  assumes \"k < dim_vec y\"\n  shows \"y$k = \\<langle>Z\\<rangle> (k+dim_vec x)\"", "lemma from_index_geq0_vector_split_snd:\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector d v)\"\n  assumes \"(x, y) = split_n_m_x d m X\"\n  shows \"\\<And>i. i < dim_vec v \\<Longrightarrow> i < m \\<Longrightarrow> y$i \\<ge> v$i\"", "lemma split_coeff_vec_index_sum:\n  assumes \"(x,y) = split_i_j_x (dim_vec (lpoly_to_vec v)) l X\"\n  shows \"(\\<Sum>i = 0..<dim_vec x. Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) = \n         (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\"", "lemma scalar_prod_valuation_after_split_equiv1:\n  assumes \"(x,y) = split_i_j_x (dim_vec (lpoly_to_vec v)) l X\"\n  shows \"(lpoly_to_vec v) \\<bullet> x = (v \\<lbrace>\\<langle>X\\<rangle>\\<rbrace>)\"", "lemma mat_times_vec_leqI[intro]:\n  assumes \"dim_row A = dim_vec b\"\n  assumes \"dim_col A = dim_vec x\"\n  assumes \"\\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x)$i \\<le> b$i\"\n  shows \"[A *\\<^sub>v x]\\<le>b\"", "lemma mat_times_vec_leqD[dest]:\n  assumes \"[A *\\<^sub>v x]\\<le>b\"\n  shows \"dim_row A = dim_vec b\" \"dim_col A = dim_vec x\" \"\\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x)$i \\<le> b$i\"", "lemma vec_times_mat_eqD[dest]:\n  assumes \"[y \\<^sub>v* A]=c\"\n  shows \"(\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v y)$i = c$i)\" \"(dim_col A\\<^sup>T = dim_vec y)\" \"(dim_row A\\<^sup>T = dim_vec c)\"", "lemma vec_times_mat_leqD[dest]:\n  assumes \"[y \\<^sub>v* A]\\<le>c\"\n  shows \"(\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v y)$i \\<le> c$i)\" \"(dim_col A\\<^sup>T = dim_vec y)\" \"(dim_row A\\<^sup>T = dim_vec c)\"", "lemma mat_times_vec_eqI[intro]:  \n  assumes \"dim_col A\\<^sup>T = dim_vec x\"\n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"\\<And>i. i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x)$i = c$i\"\n  shows \"[x \\<^sub>v* A]=c\"", "lemma mat_leqb_eqc_split_correct1:\n  assumes \"dim_vec b = dim_row A\"\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"(x,y) = split_i_j_x (dim_col A) l X\"  \n  shows \"[A *\\<^sub>v x]\\<le>b\"", "lemma mat_leqb_eqc_split_simplex_correct1:\n  assumes \"dim_vec b = dim_row A\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  assumes \"(x,y) = split_i_j_x (dim_col A) l X\"  \n  shows \"[A *\\<^sub>v x]\\<le>b\"", "lemma sat_mono:\n  assumes \"set A \\<subseteq> set B\"\n  shows \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set B \\<Longrightarrow> \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set A\"", "lemma mat_leqb_eqc_split_subset_correct1:\n  assumes \"dim_vec b = dim_row A\"\n  assumes \"set (mat_leqb_eqc A b c) \\<subseteq> set S\"\n  assumes \"simplex S = Sat X\"\n  assumes \"(x,y) = split_i_j_x (dim_col A) l X\"  \n  shows \"[A *\\<^sub>v x]\\<le>b\"", "lemma mat_leqb_eqc_split_correct2:\n  assumes \"dim_vec c = dim_row A\\<^sup>T\"\n  assumes \"dim_vec b = dim_col A\\<^sup>T\"\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"(x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\"  \n  shows \"[y \\<^sub>v* A]=c\"", "lemma mat_leqb_eqc_split_simplex_correct2:\n  assumes \"dim_vec c = dim_row A\\<^sup>T\"\n  assumes \"dim_vec b = dim_col A\\<^sup>T\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  assumes \"(x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\"  \n  shows \"[y \\<^sub>v* A]=c\"", "lemma mat_leqb_eqc_correct:\n  assumes \"dim_vec c = dim_row A\\<^sup>T\"\n    and \"dim_vec b = dim_col A\\<^sup>T\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  assumes \"(x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\"\n  shows \"[y \\<^sub>v* A]=c\" \"[A *\\<^sub>v x]\\<le>b\"", "lemma eval_lpoly_eq_dot_prod_split1:\n  assumes \"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\"\n  shows\"(vec_to_lpoly c) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> =  c \\<bullet> x\"", "lemma eval_lpoly_eq_dot_prod_split2:\n  assumes \"(x, y) = split_n_m_x (dim_vec b) (dim_vec c) X\"\n  shows\"(vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> =  c \\<bullet> y\"", "lemma x_times_c_geq_y_times_b_split_dotP:\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c x_times_c_geq_y_times_b c b\"\n  assumes \"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\"\n  shows \"c \\<bullet> x \\<ge> b \\<bullet> y\"", "lemma mult_right_leq:\n  fixes A :: \"('a::{comm_semiring_1,ordered_semiring}) mat\"\n  assumes \"dim_vec y = dim_vec b\"\n    and \"\\<forall>i < dim_vec y. y$i \\<ge> 0\"\n    and \"[A *\\<^sub>v x]\\<le> b\"\n  shows \"(A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y\"", "lemma mult_right_eq:\n  assumes \"dim_vec x = dim_vec c\"\n    and \"[y \\<^sub>v* A]=c\"\n  shows \"(A\\<^sup>T *\\<^sub>v y) \\<bullet> x = c \\<bullet> x\"", "lemma soundness_mat_x_leq:\n  assumes \"dim_row A = dim_vec b\"\n  assumes \"simplex (mat_x_leq_vec A b) = Sat X\"\n  shows \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\"", "lemma completeness_mat_x_leq:\n  assumes \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\"\n  shows \"\\<exists>X. simplex (mat_x_leq_vec A b) = Sat X\"", "lemma soundness_mat_x_eq_vec:\n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"simplex (x_mat_eq_vec c A\\<^sup>T) = Sat X\"\n  shows  \"\\<exists>x. [x \\<^sub>v* A]=c\"", "lemma completeness_mat_x_eq_vec:\n  assumes \"\\<exists>x. [x \\<^sub>v* A]=c\"\n  shows \"\\<exists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Sat X\"", "lemma soundness_mat_leqb_eqc1:\n  assumes \"dim_row A = dim_vec b\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  shows \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\"", "lemma soundness_mat_leqb_eqc2:\n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"dim_col A\\<^sup>T = dim_vec b\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  shows \"\\<exists>y. [y \\<^sub>v* A]=c\"", "lemma completeness_mat_leqb_eqc:  \n  assumes \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\" \n    and \"\\<exists>y. [y \\<^sub>v* A]=c\"\n  shows \"\\<exists>X. simplex (mat_leqb_eqc A b c) = Sat X\"", "lemma sound_and_compltete_mat_leqb_eqc [iff]:  \n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"dim_col A\\<^sup>T = dim_vec b\"\n  shows \"(\\<exists>x. [A *\\<^sub>v x]\\<le>b) \\<and> (\\<exists>y. [y \\<^sub>v* A]=c) \\<longleftrightarrow> (\\<exists>X. simplex (mat_leqb_eqc A b c) = Sat X)\"", "lemma trans_constraint_creats_LEQ_only:\n  assumes \"transf_constraint x \\<noteq> []\"\n  shows \"(\\<forall>x \\<in> set (transf_constraint x). \\<exists>a b. x = LEQ a b)\"", "lemma trans_constraints_creats_LEQ_only:\n  assumes \"transf_constraints xs \\<noteq> []\"\n  assumes \"x \\<in> set (transf_constraints xs)\"\n  shows \"\\<exists>p r. LEQ p r = x\"", "lemma non_strict_constr_no_LT: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. LT a b = x)\"", "lemma non_strict_constr_no_GT: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. GT a b = x)\"", "lemma non_strict_constr_no_LTPP: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. LTPP a b = x)\"", "lemma non_strict_constr_no_GTPP: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. GTPP a b = x)\"", "lemma non_strict_consts_cond:\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. LT a b = x)\"\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. GT a b = x)\"\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. LTPP a b = x)\"\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. GTPP a b = x)\"\n  shows \"nonstrict_constrs cs\"", "lemma sat_constr_sat_transf_constrs:\n  assumes \"v \\<Turnstile>\\<^sub>c cs\" \n  shows \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)\"", "lemma sat_constrs_sat_transf_constrs:\n  assumes \"v \\<Turnstile>\\<^sub>c\\<^sub>s set cs\" \n  shows \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)\"", "lemma sat_transf_constrs_sat_constr: \n  assumes \"nonstrict_constr cs\"\n  assumes \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)\"\n  shows \"v \\<Turnstile>\\<^sub>c cs\"", "lemma sat_transf_constrs_sat_constrs:\n  assumes \"nonstrict_constrs cs\"\n  assumes \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)\"\n  shows \"v \\<Turnstile>\\<^sub>c\\<^sub>s set cs\""], "translations": [["", "lemma constraints_set_vars_geq_vec_def:\n  \"set (vars_from_index_geq_vec start b) = \n   {GEQ (lp_monom 1 (i+start)) (b$i) |i. i \\<in> {0..<dim_vec b}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (vars_from_index_geq_vec start b) =\n    {GEQ (lp_monom 1 (i + start)) (b $ i) |i. i \\<in> {0..<dim_vec b}}", "using set_comprehension_list_comprehension[of \n      \"(\\<lambda>i. GEQ (lp_monom 1 (i+start)) (b$i))\" \"dim_vec b\"]"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>i. GEQ (lp_monom 1 (i + start)) (b $ i))\n        [dim_vec b..<?a]) =\n  {GEQ (lp_monom 1 (i + start)) (b $ i) |i. i \\<in> {dim_vec b..<?a}}\n\ngoal (1 subgoal):\n 1. set (vars_from_index_geq_vec start b) =\n    {GEQ (lp_monom 1 (i + start)) (b $ i) |i. i \\<in> {0..<dim_vec b}}", "by auto"], ["", "lemma vars_from_index_geq_sat:\n  assumes \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (vars_from_index_geq_vec start b)\"\n  assumes \"i < dim_vec b\"\n  shows \"\\<langle>x\\<rangle> (i+start) \\<ge> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b $ i \\<le> \\<langle>x\\<rangle> (i + start)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b $ i \\<le> \\<langle>x\\<rangle> (i + start)", "have e_e:\"GEQ (lp_monom 1 (i+start)) (b$i) \\<in> set (vars_from_index_geq_vec start b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEQ (lp_monom 1 (i + start)) (b $ i)\n    \\<in> set (vars_from_index_geq_vec start b)", "using constraints_set_vars_geq_vec_def[of start b]"], ["proof (prove)\nusing this:\n  set (vars_from_index_geq_vec start b) =\n  {GEQ (lp_monom 1 (i + start)) (b $ i) |i. i \\<in> {0..<dim_vec b}}\n\ngoal (1 subgoal):\n 1. GEQ (lp_monom 1 (i + start)) (b $ i)\n    \\<in> set (vars_from_index_geq_vec start b)", "using assms(2)"], ["proof (prove)\nusing this:\n  set (vars_from_index_geq_vec start b) =\n  {GEQ (lp_monom 1 (i + start)) (b $ i) |i. i \\<in> {0..<dim_vec b}}\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. GEQ (lp_monom 1 (i + start)) (b $ i)\n    \\<in> set (vars_from_index_geq_vec start b)", "by auto"], ["proof (state)\nthis:\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n  \\<in> set (vars_from_index_geq_vec start b)\n\ngoal (1 subgoal):\n 1. b $ i \\<le> \\<langle>x\\<rangle> (i + start)", "then"], ["proof (chain)\npicking this:\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n  \\<in> set (vars_from_index_geq_vec start b)", "have \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i+start)) (b$i)\""], ["proof (prove)\nusing this:\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n  \\<in> set (vars_from_index_geq_vec start b)\n\ngoal (1 subgoal):\n 1. \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n    GEQ (lp_monom 1 (i + start)) (b $ i)", "using assms(1)"], ["proof (prove)\nusing this:\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n  \\<in> set (vars_from_index_geq_vec start b)\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (vars_from_index_geq_vec start b)\n\ngoal (1 subgoal):\n 1. \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n    GEQ (lp_monom 1 (i + start)) (b $ i)", "by blast"], ["proof (state)\nthis:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n\ngoal (1 subgoal):\n 1. b $ i \\<le> \\<langle>x\\<rangle> (i + start)", "then"], ["proof (chain)\npicking this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  GEQ (lp_monom 1 (i + start)) (b $ i)", "have \"(lp_monom 1 (i+start)) \\<lbrace>\\<langle>x\\<rangle>\\<rbrace> \\<ge> (b$i)\""], ["proof (prove)\nusing this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n\ngoal (1 subgoal):\n 1. b $ i\n    \\<le> lp_monom 1 (i + start) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>", "using satisfies_constraint.simps(4)[of \"\\<langle>x\\<rangle>\" \"lp_monom 1 (i + start)\" \"b$i\"]"], ["proof (prove)\nusing this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  GEQ (lp_monom 1 (i + start)) (b $ i)\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  GEQ (lp_monom 1 (i + start)) (b $ i) =\n  (b $ i *R 1\n   \\<le> lp_monom 1 (i + start) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>)\n\ngoal (1 subgoal):\n 1. b $ i\n    \\<le> lp_monom 1 (i + start) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>", "by simp"], ["proof (state)\nthis:\n  b $ i \\<le> lp_monom 1 (i + start) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. b $ i \\<le> \\<langle>x\\<rangle> (i + start)", "then"], ["proof (chain)\npicking this:\n  b $ i \\<le> lp_monom 1 (i + start) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  b $ i \\<le> lp_monom 1 (i + start) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. b $ i \\<le> \\<langle>x\\<rangle> (i + start)", "by simp"], ["proof (state)\nthis:\n  b $ i \\<le> \\<langle>x\\<rangle> (i + start)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Matrix A less equal vector b (A \\<le> b):\n           a1 b1 c1 d1 \\<bullet> X \\<le> b_1,\n           a2 b2 c2 d2 \\<bullet> X \\<le> b_2,\n           ...\n*)"], ["", "fun mat_x_leq_vec where\n    \"mat_x_leq_vec A b = [LEQ (matrix_to_lpolies A!i) (b$i) . i <- [0..<dim_vec b]]\""], ["", "lemma mat_x_leq_vec_sol:\n  assumes \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\"\n  assumes \"i < dim_vec b\"\n  shows \"((matrix_to_lpolies A)!i) \\<lbrace>\\<langle>x\\<rangle>\\<rbrace> \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> b $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> b $ i", "have e_e: \"LEQ ((matrix_to_lpolies A)!i) (b$i) \\<in> set (mat_x_leq_vec A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_x_leq_vec A b)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> b $ i", "then"], ["proof (chain)\npicking this:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_x_leq_vec A b)", "have \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c LEQ ((matrix_to_lpolies A)!i) (b$i)\""], ["proof (prove)\nusing this:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n    LEQ (matrix_to_lpolies A ! i) (b $ i)", "using assms(1)"], ["proof (prove)\nusing this:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_x_leq_vec A b)\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n    LEQ (matrix_to_lpolies A ! i) (b $ i)", "by blast"], ["proof (state)\nthis:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> b $ i", "then"], ["proof (chain)\npicking this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  LEQ (matrix_to_lpolies A ! i) (b $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> b $ i", "using satisfies_constraint.simps"], ["proof (prove)\nusing this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\n  LEQ (matrix_to_lpolies A ! i) (b $ i)\n  ?v \\<Turnstile>\\<^sub>c LT ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> < ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c GT ?l ?r =\n  (?r *R (1::?'a) < ?l \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c LEQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> \\<le> ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c GEQ ?l ?r =\n  (?r *R (1::?'a) \\<le> ?l \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c EQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> = ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c LTPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> < ?l2.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c GTPP ?l1.0 ?l2.0 =\n  (?l2.0 \\<lbrace> ?v \\<rbrace> < ?l1.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c LEQPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> \\<le> ?l2.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c GEQPP ?l1.0 ?l2.0 =\n  (?l2.0 \\<lbrace> ?v \\<rbrace> \\<le> ?l1.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c EQPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> = ?l2.0 \\<lbrace> ?v \\<rbrace>)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> b $ i", "by auto"], ["proof (state)\nthis:\n  matrix_to_lpolies A ! i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n  \\<le> b $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Matrix A less equal vector b (A = b):\n           a1 b1 c1 d1 \\<bullet> X = b_1,\n           a2 b2 c2 d2 \\<bullet> X = b_2,\n           ... \n*)"], ["", "fun x_mat_eq_vec where\n    \"x_mat_eq_vec b A = [EQ (matrix_to_lpolies A!i) (b$i) . i <- [0..<dim_vec b]]\""], ["", "lemma x_mat_eq_vec_sol:\n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec b A)\"\n  assumes \"i < dim_vec b\"\n  shows \"((matrix_to_lpolies A)!i) \\<lbrace> x \\<rbrace> = b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i", "have e_e: \"EQ ((matrix_to_lpolies A)!i) (b$i) \\<in> set (x_mat_eq_vec b A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (x_mat_eq_vec b A)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  EQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (x_mat_eq_vec b A)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i", "then"], ["proof (chain)\npicking this:\n  EQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (x_mat_eq_vec b A)", "have \"x \\<Turnstile>\\<^sub>c EQ ((matrix_to_lpolies A)!i) (b$i)\""], ["proof (prove)\nusing this:\n  EQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (x_mat_eq_vec b A)\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A ! i) (b $ i)", "using assms(1)"], ["proof (prove)\nusing this:\n  EQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (x_mat_eq_vec b A)\n  x \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec b A)\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A ! i) (b $ i)", "by blast"], ["proof (state)\nthis:\n  x \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i", "then"], ["proof (chain)\npicking this:\n  x \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A ! i) (b $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i", "using satisfies_constraint.simps"], ["proof (prove)\nusing this:\n  x \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A ! i) (b $ i)\n  ?v \\<Turnstile>\\<^sub>c LT ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> < ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c GT ?l ?r =\n  (?r *R (1::?'a) < ?l \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c LEQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> \\<le> ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c GEQ ?l ?r =\n  (?r *R (1::?'a) \\<le> ?l \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c EQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> = ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c LTPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> < ?l2.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c GTPP ?l1.0 ?l2.0 =\n  (?l2.0 \\<lbrace> ?v \\<rbrace> < ?l1.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c LEQPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> \\<le> ?l2.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c GEQPP ?l1.0 ?l2.0 =\n  (?l2.0 \\<lbrace> ?v \\<rbrace> \\<le> ?l1.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c EQPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> = ?l2.0 \\<lbrace> ?v \\<rbrace>)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i", "by auto"], ["proof (state)\nthis:\n  matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> = b $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open> Get different matrices into same space, without interference \\<close>"], ["", "(* Given matrix A and B create: \n               A 0\n               0 B  \n*)"], ["", "fun two_block_non_interfering where\n  \"two_block_non_interfering A B = (let z1 = 0\\<^sub>m (dim_row A) (dim_col B);\n                                        z2 = 0\\<^sub>m (dim_row B) (dim_col A) in\n                                    four_block_mat A z1 z2 B)\""], ["", "lemma split_two_block_non_interfering:\n  assumes \"split_block (two_block_non_interfering A B) (dim_row A) (dim_col A) = (Q1, Q2, Q3, Q4)\"\n  shows \"Q1 = A\" \"Q4 = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q1 = A &&& Q4 = B", "using split_four_block_dual_fst_lst[of A _ _ B Q1 Q2 Q3 Q4] \n    assms"], ["proof (prove)\nusing this:\n  split_block (four_block_mat A ?B ?C B) (dim_row A) (dim_col A) =\n  (Q1, Q2, Q3, Q4) \\<Longrightarrow>\n  Q1 = A\n  split_block (four_block_mat A ?B ?C B) (dim_row A) (dim_col A) =\n  (Q1, Q2, Q3, Q4) \\<Longrightarrow>\n  Q4 = B\n  split_block (two_block_non_interfering A B) (dim_row A) (dim_col A) =\n  (Q1, Q2, Q3, Q4)\n\ngoal (1 subgoal):\n 1. Q1 = A &&& Q4 = B", "by auto"], ["", "lemma two_block_non_interfering_dims: \n  \"dim_row (two_block_non_interfering A B) = dim_row A + dim_row B\"\n  \"dim_col (two_block_non_interfering A B) = dim_col A + dim_col B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (two_block_non_interfering A B) = dim_row A + dim_row B &&&\n    dim_col (two_block_non_interfering A B) = dim_col A + dim_col B", "by (simp)+"], ["", "lemma two_block_non_interfering_zeros_are_0:\n  assumes \"i < dim_row A\"\n    and \"j \\<ge> dim_col A\"\n    and \"j < dim_col (two_block_non_interfering A B)\"\n  shows \"(two_block_non_interfering A B)$$(i,j) = 0\" \"(two_block_non_interfering A B)$$(i,j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. two_block_non_interfering A B $$ (i, j) = (0::'a) &&&\n    two_block_non_interfering A B $$ (i, j) = (0::'a)", "using four_block_mat_def assms two_block_non_interfering_dims[of A B]"], ["proof (prove)\nusing this:\n  four_block_mat ?A ?B ?C ?D =\n  (let nra = dim_row ?A; nrd = dim_row ?D; nca = dim_col ?A;\n       ncd = dim_col ?D\n   in mat (nra + nrd) (nca + ncd)\n       (\\<lambda>(i, j).\n           if i < nra\n           then if j < nca then ?A $$ (i, j) else ?B $$ (i, j - nca)\n           else if j < nca then ?C $$ (i - nra, j)\n                else ?D $$ (i - nra, j - nca)))\n  i < dim_row A\n  dim_col A \\<le> j\n  j < dim_col (two_block_non_interfering A B)\n  dim_row (two_block_non_interfering A B) = dim_row A + dim_row B\n  dim_col (two_block_non_interfering A B) = dim_col A + dim_col B\n\ngoal (1 subgoal):\n 1. two_block_non_interfering A B $$ (i, j) = (0::'a) &&&\n    two_block_non_interfering A B $$ (i, j) = (0::'a)", "by auto"], ["", "lemma two_block_non_interfering_row_comp1:\n  assumes \"i <dim_row A\"\n  shows \"row (two_block_non_interfering A B) i = row A i @\\<^sub>v (0\\<^sub>v (dim_col B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B) i =\n    row A i @\\<^sub>v 0\\<^sub>v (dim_col B)", "using assms"], ["proof (prove)\nusing this:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B) i =\n    row A i @\\<^sub>v 0\\<^sub>v (dim_col B)", "by auto"], ["", "lemma two_block_non_interfering_row_comp2:\n  assumes \"i <dim_row (two_block_non_interfering A B)\"\n    and \"i \\<ge> dim_row A\"\n  shows \"row (two_block_non_interfering A B) i = (0\\<^sub>v (dim_col A)) @\\<^sub>v row B (i - dim_row A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B) i =\n    0\\<^sub>v (dim_col A) @\\<^sub>v row B (i - dim_row A)", "using assms"], ["proof (prove)\nusing this:\n  i < dim_row (two_block_non_interfering A B)\n  dim_row A \\<le> i\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B) i =\n    0\\<^sub>v (dim_col A) @\\<^sub>v row B (i - dim_row A)", "by (auto)"], ["", "lemma first_vec_two_block_non_inter_is_first_vec:\n  assumes \"dim_col A + dim_col B = dim_vec v\"\n  assumes \"dim_row A = n\"\n  shows \"vec_first (two_block_non_interfering A B *\\<^sub>v v) n = A *\\<^sub>v (vec_first v (dim_col A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first (two_block_non_interfering A B *\\<^sub>v v) n =\n    A *\\<^sub>v vec_first v (dim_col A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "assume a: \"i < dim_vec (A *\\<^sub>v vec_first v (dim_col A))\""], ["proof (state)\nthis:\n  i < dim_vec (A *\\<^sub>v vec_first v (dim_col A))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "let ?tb = \"two_block_non_interfering A B\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have i_n: \"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n", "using a assms(2)"], ["proof (prove)\nusing this:\n  i < dim_vec (A *\\<^sub>v vec_first v (dim_col A))\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have \"vec_first (?tb *\\<^sub>v v) n $ i = vec_first (vec (dim_row ?tb) (\\<lambda> i. row ?tb i \\<bullet> v)) n $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    vec_first\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i", "unfolding mult_mat_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i =\n    vec_first\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i", "by simp"], ["proof (state)\nthis:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  vec_first\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "also"], ["proof (state)\nthis:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  vec_first\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have \"... = (vec n  (\\<lambda> i. row ?tb i \\<bullet> v)) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i =\n    vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    i", "unfolding vec_first_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (($) (vec (dim_row (two_block_non_interfering A B))\n            (\\<lambda>i.\n                row (two_block_non_interfering A B) i \\<bullet> v))) $\n    i =\n    vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    i", "using trans_less_add1"], ["proof (prove)\nusing this:\n  ?i < ?j \\<Longrightarrow> ?i < ?j + ?m\n\ngoal (1 subgoal):\n 1. vec n\n     (($) (vec (dim_row (two_block_non_interfering A B))\n            (\\<lambda>i.\n                row (two_block_non_interfering A B) i \\<bullet> v))) $\n    i =\n    vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    i", "by (metis a assms(2) dim_mult_mat_vec index_vec  two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  vec_first\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i =\n  vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $ i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "also"], ["proof (state)\nthis:\n  vec_first\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i =\n  vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $ i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have \"... = row ?tb i \\<bullet> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    i =\n    row (two_block_non_interfering A B) i \\<bullet> v", "by (simp add: i_n)"], ["proof (state)\nthis:\n  vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n  i =\n  row (two_block_non_interfering A B) i \\<bullet> v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n  i =\n  row (two_block_non_interfering A B) i \\<bullet> v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have \"... = (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B) i \\<bullet> v =\n    (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v", "using assms(2) i_n two_block_non_interfering_row_comp1"], ["proof (prove)\nusing this:\n  dim_row A = n\n  i < n\n  ?i < dim_row ?A \\<Longrightarrow>\n  row (two_block_non_interfering ?A ?B) ?i =\n  row ?A ?i @\\<^sub>v 0\\<^sub>v (dim_col ?B)\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B) i \\<bullet> v =\n    (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v", "by fastforce"], ["proof (state)\nthis:\n  row (two_block_non_interfering A B) i \\<bullet> v =\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "also"], ["proof (state)\nthis:\n  row (two_block_non_interfering A B) i \\<bullet> v =\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have \"... = row A i \\<bullet> vec_first v (dim_vec (row A i)) + \n                   0\\<^sub>v (dim_col B) \\<bullet> vec_last v (dim_vec (0\\<^sub>v (dim_col B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n    row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n    0\\<^sub>v (dim_col B) \\<bullet>\n    vec_last v (dim_vec (0\\<^sub>v (dim_col B)))", "using append_split_vec_distrib_scalar_prod[of \"row A i\" \"0\\<^sub>v (dim_col B)\" v] assms(1)"], ["proof (prove)\nusing this:\n  dim_vec (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) =\n  dim_vec v \\<Longrightarrow>\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n  row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n  0\\<^sub>v (dim_col B) \\<bullet>\n  vec_last v (dim_vec (0\\<^sub>v (dim_col B)))\n  dim_col A + dim_col B = dim_vec v\n\ngoal (1 subgoal):\n 1. (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n    row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n    0\\<^sub>v (dim_col B) \\<bullet>\n    vec_last v (dim_vec (0\\<^sub>v (dim_col B)))", "by auto"], ["proof (state)\nthis:\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n  row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n  0\\<^sub>v (dim_col B) \\<bullet>\n  vec_last v (dim_vec (0\\<^sub>v (dim_col B)))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "then"], ["proof (chain)\npicking this:\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n  row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n  0\\<^sub>v (dim_col B) \\<bullet>\n  vec_last v (dim_vec (0\\<^sub>v (dim_col B)))", "have \"vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i = \n             row A i \\<bullet> vec_first v (dim_vec (row A i))\""], ["proof (prove)\nusing this:\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n  row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n  0\\<^sub>v (dim_col B) \\<bullet>\n  vec_last v (dim_vec (0\\<^sub>v (dim_col B)))\n\ngoal (1 subgoal):\n 1. vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    row A i \\<bullet> vec_first v (dim_vec (row A i))", "using calculation"], ["proof (prove)\nusing this:\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v =\n  row A i \\<bullet> vec_first v (dim_vec (row A i)) +\n  0\\<^sub>v (dim_col B) \\<bullet>\n  vec_last v (dim_vec (0\\<^sub>v (dim_col B)))\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  (row A i @\\<^sub>v 0\\<^sub>v (dim_col B)) \\<bullet> v\n\ngoal (1 subgoal):\n 1. vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    row A i \\<bullet> vec_first v (dim_vec (row A i))", "by auto"], ["proof (state)\nthis:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  row A i \\<bullet> vec_first v (dim_vec (row A i))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (A *\\<^sub>v vec_first v (dim_col A)) \\<Longrightarrow>\n       vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (A *\\<^sub>v vec_first v (dim_col A)) $ i\n 2. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "then"], ["proof (chain)\npicking this:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  row A i \\<bullet> vec_first v (dim_vec (row A i))", "show \"vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i = \n             (A *\\<^sub>v vec_first v (dim_col A)) $ i\""], ["proof (prove)\nusing this:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  row A i \\<bullet> vec_first v (dim_vec (row A i))\n\ngoal (1 subgoal):\n 1. vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    (A *\\<^sub>v vec_first v (dim_col A)) $ i", "by (simp add: assms(2) i_n)"], ["proof (state)\nthis:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  (A *\\<^sub>v vec_first v (dim_col A)) $ i\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "have \"dim_vec (A *\\<^sub>v v) = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (A *\\<^sub>v v) = dim_row A", "using dim_vec_def dim_mult_mat_vec[of A v]"], ["proof (prove)\nusing this:\n  dim_vec \\<equiv> map_fun Rep_vec id fst\n  dim_vec (A *\\<^sub>v v) = dim_row A\n\ngoal (1 subgoal):\n 1. dim_vec (A *\\<^sub>v v) = dim_row A", "by auto"], ["proof (state)\nthis:\n  dim_vec (A *\\<^sub>v v) = dim_row A\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "then"], ["proof (chain)\npicking this:\n  dim_vec (A *\\<^sub>v v) = dim_row A", "have \"dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) = n\""], ["proof (prove)\nusing this:\n  dim_vec (A *\\<^sub>v v) = dim_row A\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) = n\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "then"], ["proof (chain)\npicking this:\n  dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) = n", "show \"dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) = \n             dim_vec (A *\\<^sub>v vec_first v (dim_col A))\""], ["proof (prove)\nusing this:\n  dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) = n\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (A *\\<^sub>v vec_first v (dim_col A))", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  dim_vec (vec_first (two_block_non_interfering A B *\\<^sub>v v) n) =\n  dim_vec (A *\\<^sub>v vec_first v (dim_col A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_vec_two_block_non_inter_is_last_vec:\n  assumes \"dim_col A + dim_col B = dim_vec v\"\n  assumes \"dim_row B = n\"\n  shows \"vec_last ((two_block_non_interfering A B) *\\<^sub>v v) n = B *\\<^sub>v (vec_last v (dim_col B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_last (two_block_non_interfering A B *\\<^sub>v v) n =\n    B *\\<^sub>v vec_last v (dim_col B)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "assume a: \"i < dim_vec (B *\\<^sub>v vec_last v (dim_col B))\""], ["proof (state)\nthis:\n  i < dim_vec (B *\\<^sub>v vec_last v (dim_col B))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "let ?tb = \"two_block_non_interfering A B\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "let ?vl = \"(vec (dim_row ?tb) (\\<lambda> i. row ?tb i \\<bullet> v))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have i_n: \"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n", "using  assms(2)"], ["proof (prove)\nusing this:\n  dim_row B = n\n\ngoal (1 subgoal):\n 1. i < n", "using a"], ["proof (prove)\nusing this:\n  dim_row B = n\n  i < dim_vec (B *\\<^sub>v vec_last v (dim_col B))\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have in3: \"(dim_row ?tb) - n + i \\<ge> dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A \\<le> dim_row (two_block_non_interfering A B) - n + i", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  dim_row A \\<le> dim_row (two_block_non_interfering A B) - n + i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have in3': \"(dim_row ?tb) - n + i < dim_row ?tb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (two_block_non_interfering A B) - n + i\n    < dim_row (two_block_non_interfering A B)", "by (simp add: assms(2) i_n two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  dim_row (two_block_non_interfering A B) - n + i\n  < dim_row (two_block_non_interfering A B)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have \"dim_row A + n = dim_row (two_block_non_interfering A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A + n = dim_row (two_block_non_interfering A B)", "by (simp add: assms(2) two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  dim_row A + n = dim_row (two_block_non_interfering A B)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "then"], ["proof (chain)\npicking this:\n  dim_row A + n = dim_row (two_block_non_interfering A B)", "have dim_a: \"dim_row A = dim_row (two_block_non_interfering A B) - n\""], ["proof (prove)\nusing this:\n  dim_row A + n = dim_row (two_block_non_interfering A B)\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row (two_block_non_interfering A B) - n", "by (metis (no_types) diff_add_inverse2)"], ["proof (state)\nthis:\n  dim_row A = dim_row (two_block_non_interfering A B) - n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have \"vec_last (?tb *\\<^sub>v v) n $ i = vec_last (vec (dim_row ?tb) (\\<lambda> i. row ?tb i \\<bullet> v)) n $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    vec_last\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i", "unfolding mult_mat_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_last\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i =\n    vec_last\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i", "by auto"], ["proof (state)\nthis:\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  vec_last\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "also"], ["proof (state)\nthis:\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  vec_last\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have \"... = ?vl $ (dim_vec ?vl - n + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_last\n     (vec (dim_row (two_block_non_interfering A B))\n       (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n     n $\n    i =\n    vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    (dim_vec\n      (vec (dim_row (two_block_non_interfering A B))\n        (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n     n +\n     i)", "unfolding vec_last_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>i.\n         vec (dim_row (two_block_non_interfering A B))\n          (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n         (dim_vec\n           (vec (dim_row (two_block_non_interfering A B))\n             (\\<lambda>i.\n                 row (two_block_non_interfering A B) i \\<bullet> v)) -\n          n +\n          i)) $\n    i =\n    vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    (dim_vec\n      (vec (dim_row (two_block_non_interfering A B))\n        (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n     n +\n     i)", "using i_n index_vec"], ["proof (prove)\nusing this:\n  i < n\n  ?i < ?n \\<Longrightarrow> vec ?n ?f $ ?i = ?f ?i\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>i.\n         vec (dim_row (two_block_non_interfering A B))\n          (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n         (dim_vec\n           (vec (dim_row (two_block_non_interfering A B))\n             (\\<lambda>i.\n                 row (two_block_non_interfering A B) i \\<bullet> v)) -\n          n +\n          i)) $\n    i =\n    vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    (dim_vec\n      (vec (dim_row (two_block_non_interfering A B))\n        (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n     n +\n     i)", "by blast"], ["proof (state)\nthis:\n  vec_last\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i =\n  vec (dim_row (two_block_non_interfering A B))\n   (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n  (dim_vec\n    (vec (dim_row (two_block_non_interfering A B))\n      (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n   n +\n   i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "also"], ["proof (state)\nthis:\n  vec_last\n   (vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v))\n   n $\n  i =\n  vec (dim_row (two_block_non_interfering A B))\n   (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n  (dim_vec\n    (vec (dim_row (two_block_non_interfering A B))\n      (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n   n +\n   i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have \"... = row ?tb ((dim_row ?tb) - n + i) \\<bullet> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    (dim_vec\n      (vec (dim_row (two_block_non_interfering A B))\n        (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n     n +\n     i) =\n    row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v", "unfolding index_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_row (two_block_non_interfering A B))\n     (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n    (dim_vec\n      (vec (dim_row (two_block_non_interfering A B))\n        (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n     n +\n     i) =\n    row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v", "by (simp add: assms(2) i_n two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  vec (dim_row (two_block_non_interfering A B))\n   (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n  (dim_vec\n    (vec (dim_row (two_block_non_interfering A B))\n      (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n   n +\n   i) =\n  row (two_block_non_interfering A B)\n   (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n  v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "also"], ["proof (state)\nthis:\n  vec (dim_row (two_block_non_interfering A B))\n   (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v) $\n  (dim_vec\n    (vec (dim_row (two_block_non_interfering A B))\n      (\\<lambda>i. row (two_block_non_interfering A B) i \\<bullet> v)) -\n   n +\n   i) =\n  row (two_block_non_interfering A B)\n   (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n  v\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have \"... = row B i \\<bullet> vec_last v (dim_vec (row B i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v =\n    row B i \\<bullet> vec_last v (dim_vec (row B i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v =\n    row B i \\<bullet> vec_last v (dim_vec (row B i))", "have \"dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) = dim_vec v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) = dim_vec v", "by (simp add: \\<open>dim_col A + dim_col B = dim_vec v\\<close>)"], ["proof (state)\nthis:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) = dim_vec v\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v =\n    row B i \\<bullet> vec_last v (dim_vec (row B i))", "then"], ["proof (chain)\npicking this:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) = dim_vec v", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) = dim_vec v\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v =\n    row B i \\<bullet> vec_last v (dim_vec (row B i))", "using dim_a assms(1) in3' two_block_non_interfering_row_comp2\n        append_split_vec_distrib_scalar_prod[of \"0\\<^sub>v (dim_col A)\" \"row B i\" v]"], ["proof (prove)\nusing this:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) = dim_vec v\n  dim_row A = dim_row (two_block_non_interfering A B) - n\n  dim_col A + dim_col B = dim_vec v\n  dim_row (two_block_non_interfering A B) - n + i\n  < dim_row (two_block_non_interfering A B)\n  \\<lbrakk>?i < dim_row (two_block_non_interfering ?A ?B);\n   dim_row ?A \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> row (two_block_non_interfering ?A ?B) ?i =\n                    0\\<^sub>v (dim_col ?A) @\\<^sub>v\n                    row ?B (?i - dim_row ?A)\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) =\n  dim_vec v \\<Longrightarrow>\n  (0\\<^sub>v (dim_col A) @\\<^sub>v row B i) \\<bullet> v =\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first v (dim_vec (0\\<^sub>v (dim_col A))) +\n  row B i \\<bullet> vec_last v (dim_vec (row B i))\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A B)\n     (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n    v =\n    row B i \\<bullet> vec_last v (dim_vec (row B i))", "by (metis add.commute add.right_neutral diff_add_inverse\n          in3 index_zero_vec(2) scalar_prod_left_zero  vec_first_carrier)"], ["proof (state)\nthis:\n  row (two_block_non_interfering A B)\n   (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n  v =\n  row B i \\<bullet> vec_last v (dim_vec (row B i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (two_block_non_interfering A B)\n   (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n  v =\n  row B i \\<bullet> vec_last v (dim_vec (row B i))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "also"], ["proof (state)\nthis:\n  row (two_block_non_interfering A B)\n   (dim_row (two_block_non_interfering A B) - n + i) \\<bullet>\n  v =\n  row B i \\<bullet> vec_last v (dim_vec (row B i))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "have \"... = row B i \\<bullet> vec_last v (dim_col B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B i \\<bullet> vec_last v (dim_vec (row B i)) =\n    row B i \\<bullet> vec_last v (dim_col B)", "by simp"], ["proof (state)\nthis:\n  row B i \\<bullet> vec_last v (dim_vec (row B i)) =\n  row B i \\<bullet> vec_last v (dim_col B)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (B *\\<^sub>v vec_last v (dim_col B)) \\<Longrightarrow>\n       vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n       (B *\\<^sub>v vec_last v (dim_col B)) $ i\n 2. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "thus \"vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i = (B *\\<^sub>v vec_last v (dim_col B)) $ i\""], ["proof (prove)\nusing this:\n  row B i \\<bullet> vec_last v (dim_vec (row B i)) =\n  row B i \\<bullet> vec_last v (dim_col B)\n\ngoal (1 subgoal):\n 1. vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    (B *\\<^sub>v vec_last v (dim_col B)) $ i", "using assms(2) calculation i_n"], ["proof (prove)\nusing this:\n  row B i \\<bullet> vec_last v (dim_vec (row B i)) =\n  row B i \\<bullet> vec_last v (dim_col B)\n  dim_row B = n\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  row B i \\<bullet> vec_last v (dim_vec (row B i))\n  i < n\n\ngoal (1 subgoal):\n 1. vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n    (B *\\<^sub>v vec_last v (dim_col B)) $ i", "by auto"], ["proof (state)\nthis:\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) n $ i =\n  (B *\\<^sub>v vec_last v (dim_col B)) $ i\n\ngoal (1 subgoal):\n 1. dim_vec (vec_last (two_block_non_interfering A B *\\<^sub>v v) n) =\n    dim_vec (B *\\<^sub>v vec_last v (dim_col B))", "qed (simp add: assms(2))"], ["", "lemma two_block_non_interfering_mult_decomposition:\n  assumes \"dim_col A + dim_col B = dim_vec v\"      \n  shows \"two_block_non_interfering A B *\\<^sub>v v =\n         A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v B *\\<^sub>v vec_last v (dim_col B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "let ?tb = \"two_block_non_interfering A B\""], ["proof (state)\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "from first_vec_two_block_non_inter_is_first_vec[of A B v \"dim_row A\", OF assms]"], ["proof (chain)\npicking this:\n  dim_row A = dim_row A \\<Longrightarrow>\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)", "have \"vec_first (?tb *\\<^sub>v v) (dim_row A) = A *\\<^sub>v vec_first v (dim_col A)\""], ["proof (prove)\nusing this:\n  dim_row A = dim_row A \\<Longrightarrow>\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)\n\ngoal (1 subgoal):\n 1. vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n    A *\\<^sub>v vec_first v (dim_col A)", "by blast"], ["proof (state)\nthis:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)\n\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "moreover"], ["proof (state)\nthis:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)\n\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "from last_vec_two_block_non_inter_is_last_vec[of A B v \"dim_row B\", OF assms]"], ["proof (chain)\npicking this:\n  dim_row B = dim_row B \\<Longrightarrow>\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  B *\\<^sub>v vec_last v (dim_col B)", "have \"vec_last (?tb *\\<^sub>v v) (dim_row B) = B *\\<^sub>v vec_last v (dim_col B)\""], ["proof (prove)\nusing this:\n  dim_row B = dim_row B \\<Longrightarrow>\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  B *\\<^sub>v vec_last v (dim_col B)\n\ngoal (1 subgoal):\n 1. vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n    B *\\<^sub>v vec_last v (dim_col B)", "by blast"], ["proof (state)\nthis:\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  B *\\<^sub>v vec_last v (dim_col B)\n\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "ultimately"], ["proof (chain)\npicking this:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  B *\\<^sub>v vec_last v (dim_col B)", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  B *\\<^sub>v vec_last v (dim_col B)\n\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "using vec_first_last_append[of \"?tb *\\<^sub>v v\" \"(dim_row A)\" \"(dim_row B)\"]\n      dim_mult_mat_vec[of \"?tb\" v] two_block_non_interfering_dims(1)[of A B]"], ["proof (prove)\nusing this:\n  vec_first (two_block_non_interfering A B *\\<^sub>v v) (dim_row A) =\n  A *\\<^sub>v vec_first v (dim_col A)\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  B *\\<^sub>v vec_last v (dim_col B)\n  two_block_non_interfering A B *\\<^sub>v v\n  \\<in> carrier_vec (dim_row A + dim_row B) \\<Longrightarrow>\n  vec_first (two_block_non_interfering A B *\\<^sub>v v)\n   (dim_row A) @\\<^sub>v\n  vec_last (two_block_non_interfering A B *\\<^sub>v v) (dim_row B) =\n  two_block_non_interfering A B *\\<^sub>v v\n  dim_vec (two_block_non_interfering A B *\\<^sub>v v) =\n  dim_row (two_block_non_interfering A B)\n  dim_row (two_block_non_interfering A B) = dim_row A + dim_row B\n\ngoal (1 subgoal):\n 1. two_block_non_interfering A B *\\<^sub>v v =\n    A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n    B *\\<^sub>v vec_last v (dim_col B)", "by (metis carrier_vec_dim_vec)"], ["proof (state)\nthis:\n  two_block_non_interfering A B *\\<^sub>v v =\n  A *\\<^sub>v vec_first v (dim_col A) @\\<^sub>v\n  B *\\<^sub>v vec_last v (dim_col B)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* A \\<le> b   \n   A = c *)"], ["", "fun mat_leqb_eqc where\n    \"mat_leqb_eqc A b c = (let lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) in\n                         [LEQ (lst!i) (b$i) . i <- [0..<dim_vec b]] @\n                         [EQ  (lst!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)]])\""], ["", "lemma mat_leqb_eqc_for_LEQ:\n  assumes \"i < dim_vec b\"\n  assumes \"i < dim_row A\"\n  shows \"(mat_leqb_eqc A b c)!i = LEQ ((matrix_to_lpolies A)!i) (b$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "define lst where lst: \"lst = (mat_leqb_eqc A b c)\""], ["proof (state)\nthis:\n  lst = mat_leqb_eqc A b c\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "define l where l: \"l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\""], ["proof (state)\nthis:\n  l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "have ileqA: \"i < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row A", "using assms"], ["proof (prove)\nusing this:\n  i < dim_vec b\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. i < dim_row A", "by auto"], ["proof (state)\nthis:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "have \"l!i = vec_to_lpoly ((row A i)@\\<^sub>v 0\\<^sub>v (dim_row A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! i = vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i =\n    vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))", "using two_block_non_interfering_row_comp1[of i A \"A\\<^sup>T\", OF ileqA]"], ["proof (prove)\nusing this:\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i =\n    vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))", "by (metis ileqA lpoly_of_v_equals_v_append0 matrix_to_lp_vec_to_lpoly_row \n        trans_less_add1 two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  l ! i = vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "then"], ["proof (chain)\npicking this:\n  l ! i = vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))", "have leq: \"l!i = (matrix_to_lpolies A)!i\""], ["proof (prove)\nusing this:\n  l ! i = vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))\n\ngoal (1 subgoal):\n 1. l ! i = matrix_to_lpolies A ! i", "using lpoly_of_v_equals_v_append0[of \"row A i\" \"(dim_row A)\"] l"], ["proof (prove)\nusing this:\n  l ! i = vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))\n  vec_to_lpoly (row A i) =\n  vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_row A))\n  l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. l ! i = matrix_to_lpolies A ! i", "by (simp add: ileqA)"], ["proof (state)\nthis:\n  l ! i = matrix_to_lpolies A ! i\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "have *: \"lst = [LEQ (l!i) (b$i) . i <- [0..<dim_vec b]] @\n                         [EQ  (l!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)] ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lst =\n    map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n    map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)]", "unfolding l lst"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c =\n    map (\\<lambda>i.\n            LEQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n                 i)\n             (b $ i))\n     [0..<dim_vec b] @\n    map (\\<lambda>i.\n            EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n                i)\n             ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)]", "by (metis mat_leqb_eqc.simps)"], ["proof (state)\nthis:\n  lst =\n  map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "have \"([LEQ (l!i) (b$i). i <- [0..<dim_vec b]] @ \n         [EQ (l!i) ((b@\\<^sub>vc)$i). i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)]]) ! i = \n         [LEQ (l!i) (b$i). i <- [0..<dim_vec b]]!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i =\n    map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i", "using assms(2) lst"], ["proof (prove)\nusing this:\n  i < dim_row A\n  lst = mat_leqb_eqc A b c\n\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i =\n    map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i", "by (simp add: assms(1) nth_append)"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "also"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "have \"... = LEQ (l!i) (b$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i =\n    LEQ (l ! i) (b $ i)", "using l lst"], ["proof (prove)\nusing this:\n  l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n  lst = mat_leqb_eqc A b c\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i =\n    LEQ (l ! i) (b $ i)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] ! i =\n  LEQ (l ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "finally"], ["proof (chain)\npicking this:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  LEQ (l ! i) (b $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  LEQ (l ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "using \"*\" leq lst"], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  LEQ (l ! i) (b $ i)\n  lst =\n  map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n  l ! i = matrix_to_lpolies A ! i\n  lst = mat_leqb_eqc A b c\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "using mat_leqb_eqc.simps[of A b c]"], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  LEQ (l ! i) (b $ i)\n  lst =\n  map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n  l ! i = matrix_to_lpolies A ! i\n  lst = mat_leqb_eqc A b c\n  mat_leqb_eqc A b c =\n  (let lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n   in map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n      map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n       [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)", "by auto"], ["proof (state)\nthis:\n  mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_leqb_eqc_for_EQ:\n  assumes \"dim_vec b \\<le> i\" and \"i < dim_vec (b@\\<^sub>vc)\"\n  assumes \"dim_row A = dim_vec b\" and \"dim_col A \\<ge> dim_vec c\"\n  shows \"(mat_leqb_eqc A b c)!i = \n    EQ (vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i-dim_vec b))) (c$(i-dim_vec b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "define lst where lst: \"lst = (mat_leqb_eqc A b c)\""], ["proof (state)\nthis:\n  lst = mat_leqb_eqc A b c\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "define l where l: \"l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\""], ["proof (state)\nthis:\n  l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "have i_s: \"i < dim_row (two_block_non_interfering A A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row (two_block_non_interfering A A\\<^sup>T)", "using assms"], ["proof (prove)\nusing this:\n  dim_vec b \\<le> i\n  i < dim_vec (b @\\<^sub>v c)\n  dim_row A = dim_vec b\n  dim_vec c \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. i < dim_row (two_block_non_interfering A A\\<^sup>T)", "by (simp add: assms(2) assms(3) two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  i < dim_row (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "have l':\"l!i = vec_to_lpoly ((0\\<^sub>v (dim_col A)) @\\<^sub>v (row A\\<^sup>T (i - dim_vec b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! i =\n    vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))", "using l two_block_non_interfering_row_comp2[of i A \"A\\<^sup>T\", OF i_s]\n      assms(1) assms(3) i_s matrix_to_lp_vec_to_lpoly_row"], ["proof (prove)\nusing this:\n  l = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n  dim_row A \\<le> i \\<Longrightarrow>\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_row A)\n  dim_vec b \\<le> i\n  dim_row A = dim_vec b\n  i < dim_row (two_block_non_interfering A A\\<^sup>T)\n  ?i < dim_row ?A \\<Longrightarrow>\n  matrix_to_lpolies ?A ! ?i = vec_to_lpoly (row ?A ?i)\n\ngoal (1 subgoal):\n 1. l ! i =\n    vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))", "by presburger"], ["proof (state)\nthis:\n  l ! i =\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "have \"([LEQ (l!i) (b$i) . i <- [0..<dim_vec b]] @\n                         [EQ  (l!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)]])!i =\n        [EQ  (l!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b..< dim_vec (b@\\<^sub>vc)]] ! (i - dim_vec b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i =\n    map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n    (i - dim_vec b)", "by (simp add: assms(1) leD nth_append)"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "also"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (l ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "have \"... = EQ (l!i) ((b@\\<^sub>vc)$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n    (i - dim_vec b) =\n    EQ (l ! i) ((b @\\<^sub>v c) $ i)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  dim_vec b \\<le> i\n  i < dim_vec (b @\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n    (i - dim_vec b) =\n    EQ (l ! i) ((b @\\<^sub>v c) $ i)", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b) =\n  EQ (l ! i) ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. EQ (l ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b) =\n  EQ (l ! i) ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "have \"... = EQ (l!i) (c$(i-dim_vec b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EQ (l ! i) ((b @\\<^sub>v c) $ i) = EQ (l ! i) (c $ (i - dim_vec b))", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  dim_vec b \\<le> i\n  i < dim_vec (b @\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. EQ (l ! i) ((b @\\<^sub>v c) $ i) = EQ (l ! i) (c $ (i - dim_vec b))", "by auto"], ["proof (state)\nthis:\n  EQ (l ! i) ((b @\\<^sub>v c) $ i) = EQ (l ! i) (c $ (i - dim_vec b))\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "then"], ["proof (chain)\npicking this:\n  EQ (l ! i) ((b @\\<^sub>v c) $ i) = EQ (l ! i) (c $ (i - dim_vec b))", "show ?thesis"], ["proof (prove)\nusing this:\n  EQ (l ! i) ((b @\\<^sub>v c) $ i) = EQ (l ! i) (c $ (i - dim_vec b))\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "using mat_leqb_eqc.simps"], ["proof (prove)\nusing this:\n  EQ (l ! i) ((b @\\<^sub>v c) $ i) = EQ (l ! i) (c $ (i - dim_vec b))\n  mat_leqb_eqc ?A ?b ?c =\n  (let lst = matrix_to_lpolies (two_block_non_interfering ?A ?A\\<^sup>T)\n   in map (\\<lambda>i. LEQ (lst ! i) (?b $ i)) [0..<dim_vec ?b] @\n      map (\\<lambda>i. EQ (lst ! i) ((?b @\\<^sub>v ?c) $ i))\n       [dim_vec ?b..<dim_vec (?b @\\<^sub>v ?c)])\n\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c ! i =\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "by (metis (full_types) calculation l l')"], ["proof (state)\nthis:\n  mat_leqb_eqc A b c ! i =\n  EQ (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   (c $ (i - dim_vec b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_leqb_eqc_satisfies1:\n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"i < dim_vec b\"\n    and \"i < dim_row A\"\n  shows \"(matrix_to_lpolies A!i) \\<lbrace>x\\<rbrace> \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i", "have e_e: \"LEQ (matrix_to_lpolies A ! i) (b$i) \\<in> set (mat_leqb_eqc A b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_leqb_eqc A b c)", "using mat_leqb_eqc_for_LEQ[of i b A c, OF assms(2) assms(3)] \n      nth_mem[of i \"matrix_to_lpolies A\"] mat_leqb_eqc.simps"], ["proof (prove)\nusing this:\n  mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)\n  i < length (matrix_to_lpolies A) \\<Longrightarrow>\n  matrix_to_lpolies A ! i \\<in> set (matrix_to_lpolies A)\n  mat_leqb_eqc ?A ?b ?c =\n  (let lst = matrix_to_lpolies (two_block_non_interfering ?A ?A\\<^sup>T)\n   in map (\\<lambda>i. LEQ (lst ! i) (?b $ i)) [0..<dim_vec ?b] @\n      map (\\<lambda>i. EQ (lst ! i) ((?b @\\<^sub>v ?c) $ i))\n       [dim_vec ?b..<dim_vec (?b @\\<^sub>v ?c)])\n\ngoal (1 subgoal):\n 1. LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_leqb_eqc A b c)", "by (metis (no_types, lifting) assms(2) diff_zero in_set_conv_nth length_append length_map \n        length_upt trans_less_add1)"], ["proof (state)\nthis:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i", "then"], ["proof (chain)\npicking this:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_leqb_eqc A b c)", "have \"x \\<Turnstile>\\<^sub>c LEQ ((matrix_to_lpolies A)!i) (b$i)\""], ["proof (prove)\nusing this:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i)", "using assms"], ["proof (prove)\nusing this:\n  LEQ (matrix_to_lpolies A ! i) (b $ i) \\<in> set (mat_leqb_eqc A b c)\n  x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n  i < dim_vec b\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i)", "by blast"], ["proof (state)\nthis:\n  x \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i", "then"], ["proof (chain)\npicking this:\n  x \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i", "using satisfies_constraint.simps"], ["proof (prove)\nusing this:\n  x \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i)\n  ?v \\<Turnstile>\\<^sub>c LT ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> < ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c GT ?l ?r =\n  (?r *R (1::?'a) < ?l \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c LEQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> \\<le> ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c GEQ ?l ?r =\n  (?r *R (1::?'a) \\<le> ?l \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c EQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> = ?r *R (1::?'a))\n  ?v \\<Turnstile>\\<^sub>c LTPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> < ?l2.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c GTPP ?l1.0 ?l2.0 =\n  (?l2.0 \\<lbrace> ?v \\<rbrace> < ?l1.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c LEQPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> \\<le> ?l2.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c GEQPP ?l1.0 ?l2.0 =\n  (?l2.0 \\<lbrace> ?v \\<rbrace> \\<le> ?l1.0 \\<lbrace> ?v \\<rbrace>)\n  ?v \\<Turnstile>\\<^sub>c EQPP ?l1.0 ?l2.0 =\n  (?l1.0 \\<lbrace> ?v \\<rbrace> = ?l2.0 \\<lbrace> ?v \\<rbrace>)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i", "by auto"], ["proof (state)\nthis:\n  matrix_to_lpolies A ! i \\<lbrace> x \\<rbrace> \\<le> b $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_leqb_eqc_satisfies2:\n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"dim_vec b \\<le> i\" and \"i < dim_vec (b@\\<^sub>vc)\"\n    and \"dim_row A = dim_vec b\" and \"dim_vec c \\<le> dim_col A\"\n  shows \"(matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i) \\<lbrace>x\\<rbrace> = (b @\\<^sub>v c) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "have e_e: \"EQ (vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))) (c $ (i - dim_vec b))\n              \\<in> set (mat_leqb_eqc A b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))\n    \\<in> set (mat_leqb_eqc A b c)", "using assms(2) mat_leqb_eqc.simps[of A b c] \n      nth_mem[of i \"(mat_leqb_eqc A b c)\"]"], ["proof (prove)\nusing this:\n  dim_vec b \\<le> i\n  mat_leqb_eqc A b c =\n  (let lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n   in map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n      map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n       [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n  i < length (mat_leqb_eqc A b c) \\<Longrightarrow>\n  mat_leqb_eqc A b c ! i \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))\n    \\<in> set (mat_leqb_eqc A b c)", "using  mat_leqb_eqc_for_EQ[of b i c A, OF assms(2) assms(3) assms(4) assms(5)]"], ["proof (prove)\nusing this:\n  dim_vec b \\<le> i\n  mat_leqb_eqc A b c =\n  (let lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n   in map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n      map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n       [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n  i < length (mat_leqb_eqc A b c) \\<Longrightarrow>\n  mat_leqb_eqc A b c ! i \\<in> set (mat_leqb_eqc A b c)\n  mat_leqb_eqc A b c ! i =\n  EQ (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   (c $ (i - dim_vec b))\n\ngoal (1 subgoal):\n 1. EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))\n    \\<in> set (mat_leqb_eqc A b c)", "by (metis (mono_tags, lifting) add_diff_cancel_left' assms(3) diff_zero index_append_vec(2) \n        length_append length_map length_upt)"], ["proof (state)\nthis:\n  EQ (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   (c $ (i - dim_vec b))\n  \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "hence sateq: \"x \\<Turnstile>\\<^sub>c EQ (vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v \n                row A\\<^sup>T (i - dim_vec b))) (c $ (i - dim_vec b))\""], ["proof (prove)\nusing this:\n  EQ (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   (c $ (i - dim_vec b))\n  \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "using assms(1)"], ["proof (prove)\nusing this:\n  EQ (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   (c $ (i - dim_vec b))\n  \\<in> set (mat_leqb_eqc A b c)\n  x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c\n    EQ (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n     (c $ (i - dim_vec b))", "by blast"], ["proof (state)\nthis:\n  x \\<Turnstile>\\<^sub>c\n  EQ (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   (c $ (i - dim_vec b))\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "have *: \"i < dim_row (two_block_non_interfering A A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row (two_block_non_interfering A A\\<^sup>T)", "by (metis assms(3) assms(4) assms(5) dual_order.order_iff_strict dual_order.strict_trans \n        index_append_vec(2) index_transpose_mat(2) nat_add_left_cancel_less \n        two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  i < dim_row (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "have **: \"dim_row A \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A \\<le> i", "by (simp add: assms(2) assms(4))"], ["proof (state)\nthis:\n  dim_row A \\<le> i\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "then"], ["proof (chain)\npicking this:\n  dim_row A \\<le> i", "have \"x \\<Turnstile>\\<^sub>c EQ ((matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T))!i) ((b@\\<^sub>vc)$i)\""], ["proof (prove)\nusing this:\n  dim_row A \\<le> i\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c\n    EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i)\n     ((b @\\<^sub>v c) $ i)", "using two_block_non_interfering_row_comp2[of i A \"A\\<^sup>T\", OF * **]"], ["proof (prove)\nusing this:\n  dim_row A \\<le> i\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_row A)\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c\n    EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i)\n     ((b @\\<^sub>v c) $ i)", "by (metis \"*\" sateq assms(3) assms(4) index_append_vec(1) index_append_vec(2) leD\n        matrix_to_lp_vec_to_lpoly_row)"], ["proof (state)\nthis:\n  x \\<Turnstile>\\<^sub>c\n  EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i)\n   ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "then"], ["proof (chain)\npicking this:\n  x \\<Turnstile>\\<^sub>c\n  EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i)\n   ((b @\\<^sub>v c) $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<Turnstile>\\<^sub>c\n  EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i)\n   ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "using satisfies_constraint.simps(5)"], ["proof (prove)\nusing this:\n  x \\<Turnstile>\\<^sub>c\n  EQ (matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i)\n   ((b @\\<^sub>v c) $ i)\n  ?v \\<Turnstile>\\<^sub>c EQ ?l ?r =\n  (?l \\<lbrace> ?v \\<rbrace> = ?r *R (1::?'a))\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> x \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "by simp"], ["proof (state)\nthis:\n  matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n  i \\<lbrace> x \\<rbrace> =\n  (b @\\<^sub>v c) $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_leqb_eqc_simplex_satisfies2:\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat x\"\n  assumes \"dim_vec b \\<le> i\" and \"i < dim_vec (b@\\<^sub>vc)\"\n    and \"dim_row A = dim_vec b\" and \"dim_vec c \\<le> dim_col A\"\n  shows \"(matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) ! i) \\<lbrace>\\<langle>x\\<rangle>\\<rbrace> = (b @\\<^sub>v c) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "using mat_leqb_eqc_satisfies2 assms(1) assms(2) assms(3) assms(4) assms(5) simplex(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc ?A ?b ?c);\n   dim_vec ?b \\<le> ?i; ?i < dim_vec (?b @\\<^sub>v ?c);\n   dim_row ?A = dim_vec ?b; dim_vec ?c \\<le> dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies\n                     (two_block_non_interfering ?A ?A\\<^sup>T) !\n                    ?i \\<lbrace> ?x \\<rbrace> =\n                    (?b @\\<^sub>v ?c) $ ?i\n  simplex (mat_leqb_eqc A b c) = Inr x\n  dim_vec b \\<le> i\n  i < dim_vec (b @\\<^sub>v c)\n  dim_row A = dim_vec b\n  dim_vec c \\<le> dim_col A\n  simplex ?cs = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?cs\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T) !\n    i \\<lbrace> \\<langle>x\\<rangle> \\<rbrace> =\n    (b @\\<^sub>v c) $ i", "by blast"], ["", "fun index_geq_n where\n  \"index_geq_n i n = GEQ (lp_monom 1 i) n\""], ["", "lemma index_geq_n_simplex: \n  assumes \"\\<langle>x\\<rangle>  \\<Turnstile>\\<^sub>c (index_geq_n i n)\"\n  shows \"\\<langle>x\\<rangle> i \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> \\<langle>x\\<rangle> i", "using assms"], ["proof (prove)\nusing this:\n  \\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c index_geq_n i n\n\ngoal (1 subgoal):\n 1. n \\<le> \\<langle>x\\<rangle> i", "by simp"], ["", "(* In the variables x_i to x_i+(length v) we synthesise a vector that is pointwise\n       greater than v *)"], ["", "fun from_index_geq0_vector where\n  \"from_index_geq0_vector i v = [GEQ (lp_monom 1 (i+j)) (v$j) . j <-[0..<dim_vec v]]\""], ["", "lemma from_index_geq_vector_simplex: \n  assumes \"x \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector i v)\"\n  \"j < dim_vec v\"\n  shows \"x (i + j) \\<ge> v$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ j \\<le> x (i + j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v $ j \\<le> x (i + j)", "have \"GEQ (lp_monom 1 (i+j)) (v$j)\\<in> set (from_index_geq0_vector i v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEQ (lp_monom 1 (i + j)) (v $ j) \\<in> set (from_index_geq0_vector i v)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  GEQ (lp_monom 1 (i + j)) (v $ j) \\<in> set (from_index_geq0_vector i v)\n\ngoal (1 subgoal):\n 1. v $ j \\<le> x (i + j)", "moreover"], ["proof (state)\nthis:\n  GEQ (lp_monom 1 (i + j)) (v $ j) \\<in> set (from_index_geq0_vector i v)\n\ngoal (1 subgoal):\n 1. v $ j \\<le> x (i + j)", "have \"x \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i+j)) (v$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i + j)) (v $ j)", "using calculation(1) assms"], ["proof (prove)\nusing this:\n  GEQ (lp_monom 1 (i + j)) (v $ j) \\<in> set (from_index_geq0_vector i v)\n  x \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector i v)\n  j < dim_vec v\n\ngoal (1 subgoal):\n 1. x \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i + j)) (v $ j)", "by force"], ["proof (state)\nthis:\n  x \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i + j)) (v $ j)\n\ngoal (1 subgoal):\n 1. v $ j \\<le> x (i + j)", "ultimately"], ["proof (chain)\npicking this:\n  GEQ (lp_monom 1 (i + j)) (v $ j) \\<in> set (from_index_geq0_vector i v)\n  x \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i + j)) (v $ j)", "show ?thesis"], ["proof (prove)\nusing this:\n  GEQ (lp_monom 1 (i + j)) (v $ j) \\<in> set (from_index_geq0_vector i v)\n  x \\<Turnstile>\\<^sub>c GEQ (lp_monom 1 (i + j)) (v $ j)\n\ngoal (1 subgoal):\n 1. v $ j \\<le> x (i + j)", "by simp"], ["proof (state)\nthis:\n  v $ j \\<le> x (i + j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_index_geq0_vector_simplex2: \n  assumes \"\\<langle>x\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector i v)\"\n  assumes \"i \\<le> j\" and \"j < (dim_vec v) + i\"\n  shows \"\\<langle>x\\<rangle> j \\<ge> v$(j - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ (j - i) \\<le> \\<langle>x\\<rangle> j", "by (metis assms(1) assms(2) assms(3) from_index_geq_vector_simplex \n      le_add_diff_inverse less_diff_conv2)"], ["", "(* [c1, ... cm, 01, ... 0n] * X \\<ge> [01, ... 0m, b1,...,bn] * X *)"], ["", "fun x_times_c_geq_y_times_b where\n  \"x_times_c_geq_y_times_b c b = GEQPP (vec_to_lpoly (c @\\<^sub>v 0\\<^sub>v (dim_vec b)))\n                                       (vec_to_lpoly (0\\<^sub>v (dim_vec c) @\\<^sub>v b))\""], ["", "lemma x_times_c_geq_y_times_b_correct:\n  assumes \"simplex [x_times_c_geq_y_times_b c b] = Sat x\"\n  shows \"((vec_to_lpoly (c @\\<^sub>v 0\\<^sub>v (dim_vec b))) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>) \\<ge>\n         ((vec_to_lpoly (0\\<^sub>v (dim_vec c) @\\<^sub>v b)) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec c) @\\<^sub>v\n      b) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> vec_to_lpoly\n           (c @\\<^sub>v\n            0\\<^sub>v (dim_vec b)) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>", "using assms simplex(3)"], ["proof (prove)\nusing this:\n  simplex [x_times_c_geq_y_times_b c b] = Inr x\n  simplex ?cs = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?cs\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec c) @\\<^sub>v\n      b) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>\n    \\<le> vec_to_lpoly\n           (c @\\<^sub>v\n            0\\<^sub>v (dim_vec b)) \\<lbrace> \\<langle>x\\<rangle> \\<rbrace>", "by fastforce"], ["", "(* Splitting an assignment into two vectors *)\n\n(* The first [0...(i-1)] elements and [i...j] elements *)"], ["", "definition split_i_j_x where\n  \"split_i_j_x i j x = (vec i \\<langle>x\\<rangle>, vec (j - i) (\\<lambda>y. \\<langle>x\\<rangle> (y+i)))\""], ["", "abbreviation split_n_m_x where \n  \"split_n_m_x n m x \\<equiv> split_i_j_x n (n+m) x\""], ["", "lemma split_vec_dims:\n  assumes \"split_i_j_x i j x = (a ,b)\"\n  shows \"dim_vec a = i\" \"dim_vec b = (j - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec a = i &&& dim_vec b = j - i", "using assms(1)"], ["proof (prove)\nusing this:\n  split_i_j_x i j x = (a, b)\n\ngoal (1 subgoal):\n 1. dim_vec a = i &&& dim_vec b = j - i", "unfolding split_i_j_x_def"], ["proof (prove)\nusing this:\n  (vec i \\<langle>x\\<rangle>,\n   vec (j - i) (\\<lambda>y. \\<langle>x\\<rangle> (y + i))) =\n  (a, b)\n\ngoal (1 subgoal):\n 1. dim_vec a = i &&& dim_vec b = j - i", "by auto+"], ["", "lemma split_n_m_x_abbrev_dims: \n  assumes \"split_n_m_x n m x = (a, b)\"\n  shows \"dim_vec a = n\" \"dim_vec b = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec a = n &&& dim_vec b = m", "using split_vec_dims"], ["proof (prove)\nusing this:\n  split_i_j_x ?i ?j ?x = (?a, ?b) \\<Longrightarrow> dim_vec ?a = ?i\n  split_i_j_x ?i ?j ?x = (?a, ?b) \\<Longrightarrow> dim_vec ?b = ?j - ?i\n\ngoal (1 subgoal):\n 1. dim_vec a = n &&& dim_vec b = m", "using assms"], ["proof (prove)\nusing this:\n  split_i_j_x ?i ?j ?x = (?a, ?b) \\<Longrightarrow> dim_vec ?a = ?i\n  split_i_j_x ?i ?j ?x = (?a, ?b) \\<Longrightarrow> dim_vec ?b = ?j - ?i\n  split_n_m_x n m x = (a, b)\n\ngoal (1 subgoal):\n 1. dim_vec a = n &&& dim_vec b = m", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec b = m", "using assms split_vec_dims(2)"], ["proof (prove)\nusing this:\n  split_n_m_x n m x = (a, b)\n  split_i_j_x ?i ?j ?x = (?a, ?b) \\<Longrightarrow> dim_vec ?b = ?j - ?i\n\ngoal (1 subgoal):\n 1. dim_vec b = m", "by fastforce"], ["", "lemma split_access_fst_1:\n  assumes \"k < i\"\n  assumes \"split_i_j_x i j x = (a, b)\"\n  shows \"a $ k = \\<langle>x\\<rangle> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a $ k = \\<langle>x\\<rangle> k", "by (metis Pair_inject assms(1) assms(2) index_vec split_i_j_x_def)"], ["", "lemma split_access_snd_1:\n  assumes \"i \\<le> k\" and \"k < j\"\n  assumes \"split_i_j_x i j x = (a, b)\"\n  shows \"b $ (k - i) = \\<langle>x\\<rangle> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b $ (k - i) = \\<langle>x\\<rangle> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b $ (k - i) = \\<langle>x\\<rangle> k", "have \"vec (j - i) (\\<lambda>n. \\<langle>x\\<rangle> (n + i)) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (j - i) (\\<lambda>n. \\<langle>x\\<rangle> (n + i)) = b", "by (metis (no_types) assms(3) prod.sel(2) split_i_j_x_def)"], ["proof (state)\nthis:\n  vec (j - i) (\\<lambda>n. \\<langle>x\\<rangle> (n + i)) = b\n\ngoal (1 subgoal):\n 1. b $ (k - i) = \\<langle>x\\<rangle> k", "then"], ["proof (chain)\npicking this:\n  vec (j - i) (\\<lambda>n. \\<langle>x\\<rangle> (n + i)) = b", "show ?thesis"], ["proof (prove)\nusing this:\n  vec (j - i) (\\<lambda>n. \\<langle>x\\<rangle> (n + i)) = b\n\ngoal (1 subgoal):\n 1. b $ (k - i) = \\<langle>x\\<rangle> k", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  vec (j - i) (\\<lambda>n. \\<langle>x\\<rangle> (n + i)) = b\n  i \\<le> k\n  k < j\n\ngoal (1 subgoal):\n 1. b $ (k - i) = \\<langle>x\\<rangle> k", "by fastforce"], ["proof (state)\nthis:\n  b $ (k - i) = \\<langle>x\\<rangle> k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_access_fst_2:\n  assumes \"(x, y) = split_i_j_x i j Z\"\n  assumes \"k < dim_vec x\"\n  shows \"x$k = \\<langle>Z\\<rangle> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ k = \\<langle>Z\\<rangle> k", "by (metis assms(1) assms(2) split_access_fst_1 split_vec_dims(1))"], ["", "lemma split_access_snd_2:\n  assumes \"(x, y) = split_i_j_x i j Z\"\n  assumes \"k < dim_vec y\"\n  shows \"y$k = \\<langle>Z\\<rangle> (k+dim_vec x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y $ k = \\<langle>Z\\<rangle> (k + dim_vec x)", "using assms split_i_j_x_def[of i j Z]"], ["proof (prove)\nusing this:\n  (x, y) = split_i_j_x i j Z\n  k < dim_vec y\n  split_i_j_x i j Z =\n  (vec i \\<langle>Z\\<rangle>,\n   vec (j - i) (\\<lambda>y. \\<langle>Z\\<rangle> (y + i)))\n\ngoal (1 subgoal):\n 1. y $ k = \\<langle>Z\\<rangle> (k + dim_vec x)", "by auto"], ["", "lemma from_index_geq0_vector_split_snd:\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (from_index_geq0_vector d v)\"\n  assumes \"(x, y) = split_n_m_x d m X\"\n  shows \"\\<And>i. i < dim_vec v \\<Longrightarrow> i < m \\<Longrightarrow> y$i \\<ge> v$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_vec v; i < m\\<rbrakk>\n       \\<Longrightarrow> v $ i \\<le> y $ i", "using assms"], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (from_index_geq0_vector d v)\n  (x, y) = split_n_m_x d m X\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_vec v; i < m\\<rbrakk>\n       \\<Longrightarrow> v $ i \\<le> y $ i", "unfolding split_i_j_x_def"], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (from_index_geq0_vector d v)\n  (x, y) =\n  (vec d \\<langle>X\\<rangle>,\n   vec (d + m - d) (\\<lambda>y. \\<langle>X\\<rangle> (y + d)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_vec v; i < m\\<rbrakk>\n       \\<Longrightarrow> v $ i \\<le> y $ i", "using from_index_geq_vector_simplex[of d v \"\\<langle>X\\<rangle>\" _] index_vec"], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (from_index_geq0_vector d v)\n  (x, y) =\n  (vec d \\<langle>X\\<rangle>,\n   vec (d + m - d) (\\<lambda>y. \\<langle>X\\<rangle> (y + d)))\n  \\<lbrakk>\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (from_index_geq0_vector d v);\n   ?j < dim_vec v\\<rbrakk>\n  \\<Longrightarrow> v $ ?j \\<le> \\<langle>X\\<rangle> (d + ?j)\n  ?i < ?n \\<Longrightarrow> vec ?n ?f $ ?i = ?f ?i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_vec v; i < m\\<rbrakk>\n       \\<Longrightarrow> v $ i \\<le> y $ i", "by (simp add: add.commute)"], ["", "lemma split_coeff_vec_index_sum:\n  assumes \"(x,y) = split_i_j_x (dim_vec (lpoly_to_vec v)) l X\"\n  shows \"(\\<Sum>i = 0..<dim_vec x. Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) = \n         (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "from valuate_with_dim_poly[of v \"\\<langle>X\\<rangle>\", symmetric]"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<dim_poly v.\n      Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n  v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "have \"(\\<Sum>i = 0..<dim_vec x. (lpoly_to_vec v) $ i * \\<langle>X\\<rangle> i) = \n        (\\<Sum>i = 0..<dim_vec x. (lpoly_to_vec v) $ i * x $ i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<dim_poly v.\n      Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n  v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "by (metis (no_types, lifting) assms split_access_fst_1 split_vec_dims(1) sum.ivl_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "by (metis (no_types, lifting) assms dim_poly_dim_vec_equiv \n        lin_poly_to_vec_coeff_access split_vec_dims(1) sum.ivl_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec x.\n      Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_prod_valuation_after_split_equiv1:\n  assumes \"(x,y) = split_i_j_x (dim_vec (lpoly_to_vec v)) l X\"\n  shows \"(lpoly_to_vec v) \\<bullet> x = (v \\<lbrace>\\<langle>X\\<rangle>\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "from valuate_with_dim_poly[of v \"\\<langle>X\\<rangle>\", symmetric]"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<dim_poly v.\n      Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n  v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "have 1: \"(v \\<lbrace>\\<langle>X\\<rangle>\\<rbrace>) = (\\<Sum>i = 0..<dim_poly v. Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<dim_poly v.\n      Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i) =\n  v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>i = 0..<dim_poly v.\n        Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i)", "by simp"], ["proof (state)\nthis:\n  v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>i = 0..<dim_poly v.\n      Abstract_Linear_Poly.coeff v i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "have \"(\\<Sum>i = 0..<dim_vec x. (lpoly_to_vec v) $ i * \\<langle>X\\<rangle> i) = \n    (\\<Sum>i = 0..<dim_vec x. (lpoly_to_vec v) $ i * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "by (metis (no_types, lifting) assms split_access_fst_1 split_vec_dims(1) sum.ivl_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)\n\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "have \"... =  (lpoly_to_vec v) \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i) =\n    lpoly_to_vec v \\<bullet> x", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i) =\n    (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * x $ i) =\n  lpoly_to_vec v \\<bullet> x\n\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  lpoly_to_vec v \\<bullet> x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec v $ i * \\<langle>X\\<rangle> i) =\n  lpoly_to_vec v \\<bullet> x\n\ngoal (1 subgoal):\n 1. lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "by (metis (no_types, lifting) \"1\" dim_poly_dim_vec_equiv lin_poly_to_vec_coeff_access \n        split_vec_dims(1) sum.ivl_cong assms)"], ["proof (state)\nthis:\n  lpoly_to_vec v \\<bullet> x = v \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mat_times_vec_leq (\"[_*\\<^sub>v_]\\<le>_\" [1000,1000,100])\n  where\n    \"[A *\\<^sub>v x]\\<le>b \\<longleftrightarrow> (\\<forall>i < dim_vec b. (A *\\<^sub>v x)$i \\<le> b$i) \\<and>\n                    (dim_row A = dim_vec b) \\<and>\n                    (dim_col A = dim_vec x)\""], ["", "definition vec_times_mat_eq (\"[_\\<^sub>v*_]=_\" [1000,1000,100])\n  where\n    \"[y \\<^sub>v* A]=c \\<longleftrightarrow> (\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v y)$i = c$i) \\<and>\n                    (dim_col A\\<^sup>T = dim_vec y) \\<and>\n                    (dim_row A\\<^sup>T = dim_vec c)\""], ["", "definition vec_times_mat_leq (\"[_\\<^sub>v*_]\\<le>_\" [1000,1000,100])\n  where\n    \"[y \\<^sub>v* A]\\<le>c \\<longleftrightarrow> (\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v y)$i \\<le> c$i) \\<and>\n                    (dim_col A\\<^sup>T = dim_vec y) \\<and>\n                    (dim_row A\\<^sup>T = dim_vec c)\""], ["", "lemma mat_times_vec_leqI[intro]:\n  assumes \"dim_row A = dim_vec b\"\n  assumes \"dim_col A = dim_vec x\"\n  assumes \"\\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x)$i \\<le> b$i\"\n  shows \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "unfolding mat_times_vec_leq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i) \\<and>\n    dim_row A = dim_vec b \\<and> dim_col A = dim_vec x", "using assms"], ["proof (prove)\nusing this:\n  dim_row A = dim_vec b\n  dim_col A = dim_vec x\n  ?i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ ?i \\<le> b $ ?i\n\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i) \\<and>\n    dim_row A = dim_vec b \\<and> dim_col A = dim_vec x", "by auto"], ["", "lemma mat_times_vec_leqD[dest]:\n  assumes \"[A *\\<^sub>v x]\\<le>b\"\n  shows \"dim_row A = dim_vec b\" \"dim_col A = dim_vec x\" \"\\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x)$i \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = dim_vec b &&&\n    dim_col A = dim_vec x &&&\n    (\\<And>i.\n        i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i)", "using assms mat_times_vec_leq_def"], ["proof (prove)\nusing this:\n  [A*\\<^sub>vx]\\<le>b\n  [?A*\\<^sub>v?x]\\<le>?b =\n  ((\\<forall>i<dim_vec ?b. (?A *\\<^sub>v ?x) $ i \\<le> ?b $ i) \\<and>\n   dim_row ?A = dim_vec ?b \\<and> dim_col ?A = dim_vec ?x)\n\ngoal (1 subgoal):\n 1. dim_row A = dim_vec b &&&\n    dim_col A = dim_vec x &&&\n    (\\<And>i.\n        i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i)", "by blast+"], ["", "lemma vec_times_mat_eqD[dest]:\n  assumes \"[y \\<^sub>v* A]=c\"\n  shows \"(\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v y)$i = c$i)\" \"(dim_col A\\<^sup>T = dim_vec y)\" \"(dim_row A\\<^sup>T = dim_vec c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v y) $ i = c $ i &&&\n    dim_col A\\<^sup>T = dim_vec y &&& dim_row A\\<^sup>T = dim_vec c", "using assms vec_times_mat_eq_def"], ["proof (prove)\nusing this:\n  [y\\<^sub>v*A]=c\n  [?y\\<^sub>v*?A]=?c =\n  ((\\<forall>i<dim_vec ?c. (?A\\<^sup>T *\\<^sub>v ?y) $ i = ?c $ i) \\<and>\n   dim_col ?A\\<^sup>T = dim_vec ?y \\<and> dim_row ?A\\<^sup>T = dim_vec ?c)\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v y) $ i = c $ i &&&\n    dim_col A\\<^sup>T = dim_vec y &&& dim_row A\\<^sup>T = dim_vec c", "by blast+"], ["", "lemma vec_times_mat_leqD[dest]:\n  assumes \"[y \\<^sub>v* A]\\<le>c\"\n  shows \"(\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v y)$i \\<le> c$i)\" \"(dim_col A\\<^sup>T = dim_vec y)\" \"(dim_row A\\<^sup>T = dim_vec c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v y) $ i \\<le> c $ i &&&\n    dim_col A\\<^sup>T = dim_vec y &&& dim_row A\\<^sup>T = dim_vec c", "using assms vec_times_mat_leq_def"], ["proof (prove)\nusing this:\n  [y\\<^sub>v*A]\\<le>c\n  [?y\\<^sub>v*?A]\\<le>?c =\n  ((\\<forall>i<dim_vec ?c.\n       (?A\\<^sup>T *\\<^sub>v ?y) $ i \\<le> ?c $ i) \\<and>\n   dim_col ?A\\<^sup>T = dim_vec ?y \\<and> dim_row ?A\\<^sup>T = dim_vec ?c)\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v y) $ i \\<le> c $ i &&&\n    dim_col A\\<^sup>T = dim_vec y &&& dim_row A\\<^sup>T = dim_vec c", "by blast+"], ["", "lemma mat_times_vec_eqI[intro]:  \n  assumes \"dim_col A\\<^sup>T = dim_vec x\"\n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"\\<And>i. i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x)$i = c$i\"\n  shows \"[x \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x\\<^sub>v*A]=c", "unfolding vec_times_mat_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i) \\<and>\n    dim_col A\\<^sup>T = dim_vec x \\<and> dim_row A\\<^sup>T = dim_vec c", "using assms"], ["proof (prove)\nusing this:\n  dim_col A\\<^sup>T = dim_vec x\n  dim_row A\\<^sup>T = dim_vec c\n  ?i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x) $ ?i = c $ ?i\n\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i) \\<and>\n    dim_col A\\<^sup>T = dim_vec x \\<and> dim_row A\\<^sup>T = dim_vec c", "by blast"], ["", "lemma mat_leqb_eqc_split_correct1:\n  assumes \"dim_vec b = dim_row A\"\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"(x,y) = split_i_j_x (dim_col A) l X\"  \n  shows \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_row A = dim_vec b\n 2. dim_col A = dim_vec x\n 3. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. dim_row A = dim_vec b\n 2. dim_col A = dim_vec x\n 3. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = dim_vec b", "using assms(1)[symmetric]"], ["proof (prove)\nusing this:\n  dim_row A = dim_vec b\n\ngoal (1 subgoal):\n 1. dim_row A = dim_vec b", "."], ["proof (state)\nthis:\n  dim_row A = dim_vec b\n\ngoal (2 subgoals):\n 1. dim_col A = dim_vec x\n 2. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. dim_col A = dim_vec x\n 2. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = dim_vec x", "using assms(3)"], ["proof (prove)\nusing this:\n  (x, y) = split_i_j_x (dim_col A) l X\n\ngoal (1 subgoal):\n 1. dim_col A = dim_vec x", "unfolding split_i_j_x_def"], ["proof (prove)\nusing this:\n  (x, y) =\n  (vec (dim_col A) \\<langle>X\\<rangle>,\n   vec (l - dim_col A) (\\<lambda>y. \\<langle>X\\<rangle> (y + dim_col A)))\n\ngoal (1 subgoal):\n 1. dim_col A = dim_vec x", "using split_vec_dims[of  0 \"dim_col A\" X x y]"], ["proof (prove)\nusing this:\n  (x, y) =\n  (vec (dim_col A) \\<langle>X\\<rangle>,\n   vec (l - dim_col A) (\\<lambda>y. \\<langle>X\\<rangle> (y + dim_col A)))\n  split_i_j_x 0 (dim_col A) X = (x, y) \\<Longrightarrow> dim_vec x = 0\n  split_i_j_x 0 (dim_col A) X = (x, y) \\<Longrightarrow>\n  dim_vec y = dim_col A - 0\n\ngoal (1 subgoal):\n 1. dim_col A = dim_vec x", "by auto"], ["proof (state)\nthis:\n  dim_col A = dim_vec x\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "case (3 i)"], ["proof (state)\nthis:\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "with mat_leqb_eqc_satisfies1[of A b c \"\\<langle>X\\<rangle>\" i]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (mat_leqb_eqc A b c);\n   i < dim_vec b; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A !\n                    i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n                    \\<le> b $ i\n  i < dim_vec b", "have m: \"(matrix_to_lpolies A ! i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> \\<le> b $ i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (mat_leqb_eqc A b c);\n   i < dim_vec b; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A !\n                    i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n                    \\<le> b $ i\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n    \\<le> b $ i", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (mat_leqb_eqc A b c);\n   i < dim_vec b; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A !\n                    i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n                    \\<le> b $ i\n  i < dim_vec b\n  dim_vec b = dim_row A\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n    \\<le> b $ i", "by linarith"], ["proof (state)\nthis:\n  matrix_to_lpolies A ! i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n  \\<le> b $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have leq: \"dim_poly (vec_to_lpoly (row A i)) \\<le> dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_poly (vec_to_lpoly (row A i)) \\<le> dim_col A", "using vec_to_poly_dim_less[of \"row A i\"]"], ["proof (prove)\nusing this:\n  dim_poly (vec_to_lpoly (row A i)) \\<le> dim_vec (row A i)\n\ngoal (1 subgoal):\n 1. dim_poly (vec_to_lpoly (row A i)) \\<le> dim_col A", "by simp"], ["proof (state)\nthis:\n  dim_poly (vec_to_lpoly (row A i)) \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have i: \"i < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row A", "using \"3\" assms(1)"], ["proof (prove)\nusing this:\n  i < dim_vec b\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. i < dim_row A", "by linarith"], ["proof (state)\nthis:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "from two_block_non_interfering_row_comp1[of i A \"A\\<^sup>T\"]"], ["proof (chain)\npicking this:\n  i < dim_row A \\<Longrightarrow>\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)", "have \"row (two_block_non_interfering A A\\<^sup>T) i = row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)\""], ["proof (prove)\nusing this:\n  i < dim_row A \\<Longrightarrow>\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A A\\<^sup>T) i =\n    row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)", "using \"3\" assms(1)"], ["proof (prove)\nusing this:\n  i < dim_row A \\<Longrightarrow>\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)\n  i < dim_vec b\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A A\\<^sup>T) i =\n    row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)", "by linarith"], ["proof (state)\nthis:\n  row (two_block_non_interfering A A\\<^sup>T) i =\n  row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have \"(vec_to_lpoly (row A i @\\<^sub>v 0\\<^sub>v (dim_col A\\<^sup>T))) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> = ((vec_to_lpoly (row A i)) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (row A i @\\<^sub>v\n      0\\<^sub>v\n       (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "using lpoly_of_v_equals_v_append0"], ["proof (prove)\nusing this:\n  vec_to_lpoly ?v = vec_to_lpoly (?v @\\<^sub>v 0\\<^sub>v ?a)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (row A i @\\<^sub>v\n      0\\<^sub>v\n       (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>", "by auto"], ["proof (state)\nthis:\n  vec_to_lpoly\n   (row A i @\\<^sub>v\n    0\\<^sub>v (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "also"], ["proof (state)\nthis:\n  vec_to_lpoly\n   (row A i @\\<^sub>v\n    0\\<^sub>v (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have \"... = (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)). \n                      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a * \\<langle>X\\<rangle> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a)", "using valuate_with_dim_poly[of \"vec_to_lpoly (row A i)\" \"\\<langle>X\\<rangle>\"]"], ["proof (prove)\nusing this:\n  vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>ia = 0..<dim_poly (vec_to_lpoly (row A i)).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) ia *\n      \\<langle>X\\<rangle> ia)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a)", "by blast"], ["proof (state)\nthis:\n  vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "also"], ["proof (state)\nthis:\n  vec_to_lpoly (row A i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have \"... = (\\<Sum>a = 0..<dim_col A. Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a * \\<langle>X\\<rangle> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a) =\n    (\\<Sum>a = 0..<dim_col A.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a)", "using split_coeff_vec_index_sum[of x y]\n      sum_dim_vec_equals_sum_dim_poly[of \"row A i\" \"\\<langle>X\\<rangle>\"]"], ["proof (prove)\nusing this:\n  (x, y) = split_i_j_x (dim_vec (lpoly_to_vec ?v)) ?l ?X \\<Longrightarrow>\n  (\\<Sum>i = 0..<dim_vec x.\n      Abstract_Linear_Poly.coeff ?v i * \\<langle>?X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec x. lpoly_to_vec ?v $ i * x $ i)\n  (\\<Sum>a = 0..<dim_vec (row A i).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a) =\n  (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a) =\n    (\\<Sum>a = 0..<dim_col A.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a) =\n  (\\<Sum>a = 0..<dim_col A.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>a = 0..<dim_poly (vec_to_lpoly (row A i)).\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a) =\n  (\\<Sum>a = 0..<dim_col A.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have \"... = row A i \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<dim_col A.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a) =\n    row A i \\<bullet> x", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<dim_col A.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a) =\n    (\\<Sum>ia = 0..<dim_vec x. row A i $ ia * x $ ia)", "using \\<open>dim_col A = dim_vec x\\<close> i assms(3)"], ["proof (prove)\nusing this:\n  dim_col A = dim_vec x\n  i < dim_row A\n  (x, y) = split_i_j_x (dim_col A) l X\n\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<dim_col A.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a) =\n    (\\<Sum>ia = 0..<dim_vec x. row A i $ ia * x $ ia)", "using matrix_to_lpolies_coeff_access[of i A] matrix_to_lp_vec_to_lpoly_row[of i A] \n      split_access_fst_1[of _ \"(dim_col A)\" l X x y]"], ["proof (prove)\nusing this:\n  dim_col A = dim_vec x\n  i < dim_row A\n  (x, y) = split_i_j_x (dim_col A) l X\n  \\<lbrakk>i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> Abstract_Linear_Poly.coeff (matrix_to_lpolies A ! i)\n                     ?j =\n                    A $$ (i, ?j)\n  i < dim_row A \\<Longrightarrow>\n  matrix_to_lpolies A ! i = vec_to_lpoly (row A i)\n  \\<lbrakk>?k < dim_col A; split_i_j_x (dim_col A) l X = (x, y)\\<rbrakk>\n  \\<Longrightarrow> x $ ?k = \\<langle>X\\<rangle> ?k\n\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<dim_col A.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n        \\<langle>X\\<rangle> a) =\n    (\\<Sum>ia = 0..<dim_vec x. row A i $ ia * x $ ia)", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>a = 0..<dim_col A.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) a *\n      \\<langle>X\\<rangle> a) =\n  row A i \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "finally"], ["proof (chain)\npicking this:\n  vec_to_lpoly\n   (row A i @\\<^sub>v\n    0\\<^sub>v (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  row A i \\<bullet> x", "show ?case"], ["proof (prove)\nusing this:\n  vec_to_lpoly\n   (row A i @\\<^sub>v\n    0\\<^sub>v (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  row A i \\<bullet> x\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) $ i \\<le> b $ i", "using m i lpoly_of_v_equals_v_append0"], ["proof (prove)\nusing this:\n  vec_to_lpoly\n   (row A i @\\<^sub>v\n    0\\<^sub>v (dim_col A\\<^sup>T)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  row A i \\<bullet> x\n  matrix_to_lpolies A ! i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n  \\<le> b $ i\n  i < dim_row A\n  vec_to_lpoly ?v = vec_to_lpoly (?v @\\<^sub>v 0\\<^sub>v ?a)\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) $ i \\<le> b $ i", "by auto"], ["proof (state)\nthis:\n  (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_leqb_eqc_split_simplex_correct1:\n  assumes \"dim_vec b = dim_row A\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  assumes \"(x,y) = split_i_j_x (dim_col A) l X\"  \n  shows \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "using mat_leqb_eqc_split_correct1[of b A c X x y] assms(1) assms(2) assms(3) simplex(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_vec b = dim_row A;\n   \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n   set (mat_leqb_eqc A b c);\n   (x, y) = split_i_j_x (dim_col A) ?l X\\<rbrakk>\n  \\<Longrightarrow> [A*\\<^sub>vx]\\<le>b\n  dim_vec b = dim_row A\n  simplex (mat_leqb_eqc A b c) = Inr X\n  (x, y) = split_i_j_x (dim_col A) l X\n  simplex ?cs = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?cs\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "by blast"], ["", "lemma sat_mono:\n  assumes \"set A \\<subseteq> set B\"\n  shows \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set B \\<Longrightarrow> \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set B \\<Longrightarrow>\n    \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set A", "using assms(1) assms"], ["proof (prove)\nusing this:\n  set A \\<subseteq> set B\n  set A \\<subseteq> set B\n\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set B \\<Longrightarrow>\n    \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set A", "by blast"], ["", "lemma mat_leqb_eqc_split_subset_correct1:\n  assumes \"dim_vec b = dim_row A\"\n  assumes \"set (mat_leqb_eqc A b c) \\<subseteq> set S\"\n  assumes \"simplex S = Sat X\"\n  assumes \"(x,y) = split_i_j_x (dim_col A) l X\"  \n  shows \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "using sat_mono assms(1) assms(2) assms(3) assms(4) \n    mat_leqb_eqc_split_correct1 simplex(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?A \\<subseteq> set ?B;\n   \\<langle>?X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?B\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?A\n  dim_vec b = dim_row A\n  set (mat_leqb_eqc A b c) \\<subseteq> set S\n  simplex S = Inr X\n  (x, y) = split_i_j_x (dim_col A) l X\n  \\<lbrakk>dim_vec ?b = dim_row ?A;\n   \\<langle>?X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n   set (mat_leqb_eqc ?A ?b ?c);\n   (?x, ?y) = split_i_j_x (dim_col ?A) ?l ?X\\<rbrakk>\n  \\<Longrightarrow> [?A*\\<^sub>v?x]\\<le>?b\n  simplex ?cs = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?cs\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "by blast"], ["", "lemma mat_leqb_eqc_split_correct2:\n  assumes \"dim_vec c = dim_row A\\<^sup>T\"\n  assumes \"dim_vec b = dim_col A\\<^sup>T\"\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\"\n  assumes \"(x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\"  \n  shows \"[y \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_col A\\<^sup>T = dim_vec y\n 2. dim_row A\\<^sup>T = dim_vec c\n 3. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. dim_col A\\<^sup>T = dim_vec y\n 2. dim_row A\\<^sup>T = dim_vec c\n 3. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A\\<^sup>T = dim_vec y", "using assms split_n_m_x_abbrev_dims(2)[OF assms(4)[symmetric]]"], ["proof (prove)\nusing this:\n  dim_vec c = dim_row A\\<^sup>T\n  dim_vec b = dim_col A\\<^sup>T\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n  (x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\n  dim_vec y = dim_col A\\<^sup>T\n\ngoal (1 subgoal):\n 1. dim_col A\\<^sup>T = dim_vec y", "by linarith"], ["proof (state)\nthis:\n  dim_col A\\<^sup>T = dim_vec y\n\ngoal (2 subgoals):\n 1. dim_row A\\<^sup>T = dim_vec c\n 2. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. dim_row A\\<^sup>T = dim_vec c\n 2. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A\\<^sup>T = dim_vec c", "using assms(1)[symmetric]"], ["proof (prove)\nusing this:\n  dim_row A\\<^sup>T = dim_vec c\n\ngoal (1 subgoal):\n 1. dim_row A\\<^sup>T = dim_vec c", "."], ["proof (state)\nthis:\n  dim_row A\\<^sup>T = dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "case (3 i)"], ["proof (state)\nthis:\n  i < dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "define lst where lst: \"lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\""], ["proof (state)\nthis:\n  lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "define db where db: \"db = dim_vec b\""], ["proof (state)\nthis:\n  db = dim_vec b\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "define dc where dc: \"dc = dim_vec c\""], ["proof (state)\nthis:\n  dc = dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have cA: \"dim_vec c \\<le> dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec c \\<le> dim_col A", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  dim_vec c \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have dbi_dim: \"db+i < dim_vec (b @\\<^sub>v c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. db + i < dim_vec (b @\\<^sub>v c)", "by (simp add: \"3\" db)"], ["proof (state)\nthis:\n  db + i < dim_vec (b @\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have *: \"dim_vec b \\<le> db+i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec b \\<le> db + i", "by (simp add: db)"], ["proof (state)\nthis:\n  dim_vec b \\<le> db + i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"([LEQ (lst!i) (b$i) . i <- [0..<dim_vec b]] @\n        [EQ  (lst!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)]]) ! (db + i) =\n         EQ (lst!(db+i)) ((b@\\<^sub>vc)$(db+i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    (db + i) =\n    EQ (lst ! (db + i)) ((b @\\<^sub>v c) $ (db + i))", "using mat_leqb_eqc_for_EQ[of b \"db+i\" c A]\n    nth_append[of \"[LEQ (lst!i) (b$i) . i <- [0..<dim_vec b]]\" \n      \"[EQ  (lst!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)]]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_vec b \\<le> db + i; db + i < dim_vec (b @\\<^sub>v c);\n   dim_row A = dim_vec b; dim_vec c \\<le> dim_col A\\<rbrakk>\n  \\<Longrightarrow> mat_leqb_eqc A b c ! (db + i) =\n                    EQ (vec_to_lpoly\n                         (0\\<^sub>v (dim_col A) @\\<^sub>v\n                          row A\\<^sup>T (db + i - dim_vec b)))\n                     (c $ (db + i - dim_vec b))\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  ?n =\n  (if ?n < length (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b])\n   then map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] ! ?n\n   else map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n         [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n        (?n -\n         length (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b])))\n\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    (db + i) =\n    EQ (lst ! (db + i)) ((b @\\<^sub>v c) $ (db + i))", "by (simp add: \"3\" db)"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  (db + i) =\n  EQ (lst ! (db + i)) ((b @\\<^sub>v c) $ (db + i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have rowA: \"dim_vec b = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec b = dim_row A", "using assms index_transpose_mat(3)[of A]"], ["proof (prove)\nusing this:\n  dim_vec c = dim_row A\\<^sup>T\n  dim_vec b = dim_col A\\<^sup>T\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n  (x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\n  dim_col A\\<^sup>T = dim_row A\n\ngoal (1 subgoal):\n 1. dim_vec b = dim_row A", "by linarith"], ["proof (state)\nthis:\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst!(db+i)) (c$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "have \"db + i - dim_vec b = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. db + i - dim_vec b = i", "using db diff_add_inverse"], ["proof (prove)\nusing this:\n  db = dim_vec b\n  ?n + ?m - ?n = ?m\n\ngoal (1 subgoal):\n 1. db + i - dim_vec b = i", "by blast"], ["proof (state)\nthis:\n  db + i - dim_vec b = i\n\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "then"], ["proof (chain)\npicking this:\n  db + i - dim_vec b = i", "have \"(lst ! (db + i)) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i\""], ["proof (prove)\nusing this:\n  db + i - dim_vec b = i\n\ngoal (1 subgoal):\n 1. lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i", "by (metis dbi_dim rowA * cA assms(3) index_append_vec(1)\n          index_append_vec(2) leD lst mat_leqb_eqc_satisfies2)"], ["proof (state)\nthis:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i\n\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "then"], ["proof (chain)\npicking this:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i\n\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "using satisfies_constraint.simps(5)[of \"\\<langle>X\\<rangle>\" \"(lst ! (db + i))\" \"(c $ i)\"]"], ["proof (prove)\nusing this:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i) =\n  (lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i *R 1)\n\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "by simp"], ["proof (state)\nthis:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "then"], ["proof (chain)\npicking this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)", "have sat: \"(lst!(db+i)) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> = c$i\""], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c EQ (lst ! (db + i)) (c $ i)\n\ngoal (1 subgoal):\n 1. lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i", "by simp"], ["proof (state)\nthis:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "define V where V: \"V = vec (db+dc) (\\<lambda>i. \\<langle>X\\<rangle> i)\""], ["proof (state)\nthis:\n  V = vec (db + dc) \\<langle>X\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have vdim: \"dim_vec V = dim_vec (b@\\<^sub>vc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec V = dim_vec (b @\\<^sub>v c)", "using V db dc"], ["proof (prove)\nusing this:\n  V = vec (db + dc) \\<langle>X\\<rangle>\n  db = dim_vec b\n  dc = dim_vec c\n\ngoal (1 subgoal):\n 1. dim_vec V = dim_vec (b @\\<^sub>v c)", "by simp"], ["proof (state)\nthis:\n  dim_vec V = dim_vec (b @\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have *: \"db + i < dim_row (two_block_non_interfering A A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. db + i < dim_row (two_block_non_interfering A A\\<^sup>T)", "by (metis dbi_dim assms(1) index_append_vec(2) rowA two_block_non_interfering_dims(1))"], ["proof (state)\nthis:\n  db + i < dim_row (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have **: \"dim_row A \\<le> db + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A \\<le> db + i", "by (simp add: assms(2) db)"], ["proof (state)\nthis:\n  dim_row A \\<le> db + i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "from two_block_non_interfering_row_comp2[of \"db+i\" A \"A\\<^sup>T\", OF * **]"], ["proof (chain)\npicking this:\n  row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (db + i - dim_row A)", "have eql: \"row (two_block_non_interfering A A\\<^sup>T) (db + i) = 0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i\""], ["proof (prove)\nusing this:\n  row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (db + i - dim_row A)\n\ngoal (1 subgoal):\n 1. row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n    0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i", "by (simp add: assms(2) db)"], ["proof (state)\nthis:\n  row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "with matrix_to_lp_vec_to_lpoly_row[of i \"A\\<^sup>T\"]"], ["proof (chain)\npicking this:\n  i < dim_row A\\<^sup>T \\<Longrightarrow>\n  matrix_to_lpolies A\\<^sup>T ! i = vec_to_lpoly (row A\\<^sup>T i)\n  row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i", "have eqv: \"lst!(db+i) = vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)\""], ["proof (prove)\nusing this:\n  i < dim_row A\\<^sup>T \\<Longrightarrow>\n  matrix_to_lpolies A\\<^sup>T ! i = vec_to_lpoly (row A\\<^sup>T i)\n  row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i\n\ngoal (1 subgoal):\n 1. lst ! (db + i) =\n    vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)", "using \"*\" lst matrix_to_lp_vec_to_lpoly_row"], ["proof (prove)\nusing this:\n  i < dim_row A\\<^sup>T \\<Longrightarrow>\n  matrix_to_lpolies A\\<^sup>T ! i = vec_to_lpoly (row A\\<^sup>T i)\n  row (two_block_non_interfering A A\\<^sup>T) (db + i) =\n  0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i\n  db + i < dim_row (two_block_non_interfering A A\\<^sup>T)\n  lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n  ?i < dim_row ?A \\<Longrightarrow>\n  matrix_to_lpolies ?A ! ?i = vec_to_lpoly (row ?A ?i)\n\ngoal (1 subgoal):\n 1. lst ! (db + i) =\n    vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)", "by presburger"], ["proof (state)\nthis:\n  lst ! (db + i) =\n  vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "then"], ["proof (chain)\npicking this:\n  lst ! (db + i) =\n  vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)", "have \"\\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst!(db+i)) j = 0\""], ["proof (prove)\nusing this:\n  lst ! (db + i) =\n  vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)\n\ngoal (1 subgoal):\n 1. \\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0", "by (metis index_append_vec(1) index_append_vec(2) index_zero_vec(1) index_zero_vec(2) \n        vec_to_lin_poly_coeff_access trans_less_add1)"], ["proof (state)\nthis:\n  \\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "moreover"], ["proof (state)\nthis:\n  \\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"\\<forall>j\\<ge>db+dc. Abstract_Linear_Poly.coeff (lst!(db+i)) j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>db + dc.\n       Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0", "by (metis (mono_tags, lifting) eqv index_transpose_mat(3) index_zero_vec(2) leD\n        add.commute assms(1) assms(2) coeff_nonzero_dim_vec_non_zero(2) index_append_vec(2) \n        index_row(2) index_transpose_mat(2) db dc)"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>db + dc. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "moreover"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>db + dc. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"vars (lst!(db+i)) \\<subseteq> {dim_col A..<db+dc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (lst ! (db + i)) \\<subseteq> {dim_col A..<db + dc}", "by (meson atLeastLessThan_iff calculation(1) calculation(2) coeff_zero not_le subsetI)"], ["proof (state)\nthis:\n  vars (lst ! (db + i)) \\<subseteq> {dim_col A..<db + dc}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n  \\<forall>j\\<ge>db + dc. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n  vars (lst ! (db + i)) \\<subseteq> {dim_col A..<db + dc}", "have \"(lst!(db+i))\\<lbrace>\\<langle>X\\<rangle>\\<rbrace> = (\\<Sum>j\\<in>{dim_col A..<db+dc}. Abstract_Linear_Poly.coeff (lst!(db+i)) j * \\<langle>X\\<rangle> j)\""], ["proof (prove)\nusing this:\n  \\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n  \\<forall>j\\<ge>db + dc. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n  vars (lst ! (db + i)) \\<subseteq> {dim_col A..<db + dc}\n\ngoal (1 subgoal):\n 1. lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j *\n        \\<langle>X\\<rangle> j)", "using eval_poly_with_sum_superset[of \"{dim_col A..<db+dc}\" \"lst!(db+i)\" \"\\<langle>X\\<rangle>\"]"], ["proof (prove)\nusing this:\n  \\<forall>j<dim_col A. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n  \\<forall>j\\<ge>db + dc. Abstract_Linear_Poly.coeff (lst ! (db + i)) j = 0\n  vars (lst ! (db + i)) \\<subseteq> {dim_col A..<db + dc}\n  \\<lbrakk>finite {dim_col A..<db + dc};\n   vars (lst ! (db + i)) \\<subseteq> {dim_col A..<db + dc}\\<rbrakk>\n  \\<Longrightarrow> lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n                    (\\<Sum>x = dim_col A..<db + dc.\n                        Abstract_Linear_Poly.coeff (lst ! (db + i)) x *\n                        \\<langle>X\\<rangle> x)\n\ngoal (1 subgoal):\n 1. lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j *\n        \\<langle>X\\<rangle> j)", "by blast"], ["proof (state)\nthis:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * \\<langle>X\\<rangle> j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  lst ! (db + i) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * \\<langle>X\\<rangle> j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"... = (\\<Sum>j\\<in>{dim_col A..<db+dc}. Abstract_Linear_Poly.coeff (lst!(db+i)) j * V$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j *\n        \\<langle>X\\<rangle> j) =\n    (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j)", "using V"], ["proof (prove)\nusing this:\n  V = vec (db + dc) \\<langle>X\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j *\n        \\<langle>X\\<rangle> j) =\n    (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j *\n      \\<langle>X\\<rangle> j) =\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j *\n      \\<langle>X\\<rangle> j) =\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"... = (\\<Sum>j\\<in>{dim_col A..<db+dc}. (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)$j * V$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n    (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n    (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)", "have \"\\<forall>j\\<in>{dim_col A..<db+dc}. Abstract_Linear_Poly.coeff (lst!(db+i)) j = (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{dim_col A..<db + dc}.\n       Abstract_Linear_Poly.coeff (lst ! (db + i)) j =\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j", "by (metis \\<open>V \\<equiv> vec (db + dc) \\<langle>X\\<rangle>\\<close> vdim assms(1) assms(2) index_transpose_mat(2)\n          atLeastLessThan_iff dim_vec eql eqv index_append_vec(2) index_row(2) \n          vec_to_lin_poly_coeff_access semiring_normalization_rules(24) \n          two_block_non_interfering_dims(2))"], ["proof (state)\nthis:\n  \\<forall>j\\<in>{dim_col A..<db + dc}.\n     Abstract_Linear_Poly.coeff (lst ! (db + i)) j =\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n    (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>j\\<in>{dim_col A..<db + dc}.\n     Abstract_Linear_Poly.coeff (lst ! (db + i)) j =\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>{dim_col A..<db + dc}.\n     Abstract_Linear_Poly.coeff (lst ! (db + i)) j =\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n    (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)", "by (metis (mono_tags, lifting) sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      Abstract_Linear_Poly.coeff (lst ! (db + i)) j * V $ j) =\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"... = (\\<Sum>j\\<in>{0..<dim_col A}. (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)$j * V$j) + \n                   (\\<Sum>j\\<in>{dim_col A..<db+dc}. (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)$j * V$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n    (\\<Sum>j = 0..<dim_col A.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) +\n    (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)", "by (metis (no_types, lifting) add_cancel_left_left atLeastLessThan_iff mult_eq_0_iff\n        class_semiring.add.finprod_all1 index_append_vec(1) index_zero_vec(1)\n        index_zero_vec(2) trans_less_add1)"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n  (\\<Sum>j = 0..<dim_col A.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) +\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n  (\\<Sum>j = 0..<dim_col A.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) +\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"... = (\\<Sum>j\\<in>{0..<db+dc}. (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i)$j * V$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_col A.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) +\n    (\\<Sum>j = dim_col A..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n    (\\<Sum>j = 0..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)", "by (metis (no_types, lifting) add.commute assms(1) dc index_transpose_mat(2) \n        le_add1 le_add_same_cancel1 sum.atLeastLessThan_concat)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_col A.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) +\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n  (\\<Sum>j = 0..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_col A.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) +\n  (\\<Sum>j = dim_col A..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n  (\\<Sum>j = 0..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"... = (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n    (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<db + dc.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n    (\\<Sum>ia = 0..<dim_vec V.\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ ia * V $ ia)", "by (simp add: V)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n  (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<db + dc.\n      (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) $ j * V $ j) =\n  (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"... = 0\\<^sub>v (dim_col A) \\<bullet> vec_first V (dim_vec (0\\<^sub>v (dim_col A))) + \n                   row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V =\n    0\\<^sub>v (dim_col A) \\<bullet>\n    vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n    row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i))", "using append_split_vec_distrib_scalar_prod[of \"0\\<^sub>v (dim_col A)\" \"row A\\<^sup>T i\" V]"], ["proof (prove)\nusing this:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) =\n  dim_vec V \\<Longrightarrow>\n  (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V =\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i))\n\ngoal (1 subgoal):\n 1. (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V =\n    0\\<^sub>v (dim_col A) \\<bullet>\n    vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n    row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i))", "by (metis (no_types, lifting) \\<open>dim_vec V = dim_vec (b @\\<^sub>v c)\\<close> add.commute assms(1) \n        assms(2) index_append_vec(2) index_row(2) index_transpose_mat(2) \n        index_transpose_mat(3) index_zero_vec(2))"], ["proof (state)\nthis:\n  (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V =\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "also"], ["proof (state)\nthis:\n  (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T i) \\<bullet> V =\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have  \"0\\<^sub>v (dim_col A) \\<bullet> vec_first V (dim_vec (0\\<^sub>v (dim_col A))) + \n                   row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) = (row A\\<^sup>T i) \\<bullet> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_col A) \\<bullet>\n    vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n    row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n    row A\\<^sup>T i \\<bullet> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_col A) \\<bullet>\n    vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n    row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n    row A\\<^sup>T i \\<bullet> y", "have \"vec_last V (dim_vec (row A\\<^sup>T i)) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_last V (dim_vec (row A\\<^sup>T i)) = y", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec y \\<Longrightarrow>\n       vec_last V (dim_vec (row A\\<^sup>T i)) $ ia = y $ ia\n 2. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i))) = dim_vec y", "case (1 i)"], ["proof (state)\nthis:\n  i < dim_vec y\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec y \\<Longrightarrow>\n       vec_last V (dim_vec (row A\\<^sup>T i__)) $ ia = y $ ia\n 2. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i__))) = dim_vec y", "then"], ["proof (chain)\npicking this:\n  i < dim_vec y", "show ?case"], ["proof (prove)\nusing this:\n  i < dim_vec y\n\ngoal (1 subgoal):\n 1. vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < dim_vec y \\<Longrightarrow>\n    vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i", "have f1: \"dim_col A\\<^sup>T = db\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A\\<^sup>T = db", "by (simp add: assms(2) db)"], ["proof (state)\nthis:\n  dim_col A\\<^sup>T = db\n\ngoal (1 subgoal):\n 1. i < dim_vec y \\<Longrightarrow>\n    vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i", "then"], ["proof (chain)\npicking this:\n  dim_col A\\<^sup>T = db", "have \"\\<forall>v va. vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or> (x, y) \\<noteq> (va, v)\""], ["proof (prove)\nusing this:\n  dim_col A\\<^sup>T = db\n\ngoal (1 subgoal):\n 1. \\<forall>v va.\n       vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or>\n       (x, y) \\<noteq> (va, v)", "by (metis Pair_inject add_diff_cancel_left' assms(1) assms(4) dc split_i_j_x_def)"], ["proof (state)\nthis:\n  \\<forall>v va.\n     vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or>\n     (x, y) \\<noteq> (va, v)\n\ngoal (1 subgoal):\n 1. i < dim_vec y \\<Longrightarrow>\n    vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i", "then"], ["proof (chain)\npicking this:\n  \\<forall>v va.\n     vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or>\n     (x, y) \\<noteq> (va, v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v va.\n     vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or>\n     (x, y) \\<noteq> (va, v)\n\ngoal (1 subgoal):\n 1. vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i", "unfolding V vec_last_def"], ["proof (prove)\nusing this:\n  \\<forall>v va.\n     vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or>\n     (x, y) \\<noteq> (va, v)\n\ngoal (1 subgoal):\n 1. vec (dim_vec (row A\\<^sup>T i__))\n     (\\<lambda>ia.\n         vec (db + dc) \\<langle>X\\<rangle> $\n         (dim_vec (vec (db + dc) \\<langle>X\\<rangle>) -\n          dim_vec (row A\\<^sup>T i__) +\n          ia)) $\n    i =\n    y $ i", "using split_access_fst_1[of \"(dim_row A\\<^sup>T)\"  i \"(dim_col A\\<^sup>T)\" X x y]"], ["proof (prove)\nusing this:\n  \\<forall>v va.\n     vec db (\\<lambda>n. \\<langle>X\\<rangle> (n + dc)) = v \\<or>\n     (x, y) \\<noteq> (va, v)\n  \\<lbrakk>dim_row A\\<^sup>T < i;\n   split_i_j_x i (dim_col A\\<^sup>T) X = (x, y)\\<rbrakk>\n  \\<Longrightarrow> x $ dim_row A\\<^sup>T =\n                    \\<langle>X\\<rangle> (dim_row A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. vec (dim_vec (row A\\<^sup>T i__))\n     (\\<lambda>ia.\n         vec (db + dc) \\<langle>X\\<rangle> $\n         (dim_vec (vec (db + dc) \\<langle>X\\<rangle>) -\n          dim_vec (row A\\<^sup>T i__) +\n          ia)) $\n    i =\n    y $ i", "by (metis \"1\" add.commute add_diff_cancel_left' add_less_cancel_left \n              dim_vec f1 index_row(2) index_vec)"], ["proof (state)\nthis:\n  vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_last V (dim_vec (row A\\<^sup>T i__)) $ i = y $ i\n\ngoal (1 subgoal):\n 1. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i__))) = dim_vec y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i))) = dim_vec y", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i))) = dim_vec y", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i))) = dim_vec y", "using \\<open>dim_col A\\<^sup>T = dim_vec y\\<close>"], ["proof (prove)\nusing this:\n  dim_col A\\<^sup>T = dim_vec y\n\ngoal (1 subgoal):\n 1. dim_vec (vec_last V (dim_vec (row A\\<^sup>T i))) = dim_vec y", "by auto"], ["proof (state)\nthis:\n  dim_vec (vec_last V (dim_vec (row A\\<^sup>T i))) = dim_vec y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_last V (dim_vec (row A\\<^sup>T i)) = y\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_col A) \\<bullet>\n    vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n    row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n    row A\\<^sup>T i \\<bullet> y", "then"], ["proof (chain)\npicking this:\n  vec_last V (dim_vec (row A\\<^sup>T i)) = y", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_last V (dim_vec (row A\\<^sup>T i)) = y\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_col A) \\<bullet>\n    vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n    row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n    row A\\<^sup>T i \\<bullet> y", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n  row A\\<^sup>T i \\<bullet> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n  row A\\<^sup>T i \\<bullet> y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "then"], ["proof (chain)\npicking this:\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n  row A\\<^sup>T i \\<bullet> y", "show ?case"], ["proof (prove)\nusing this:\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n  row A\\<^sup>T i \\<bullet> y\n\ngoal (1 subgoal):\n 1. (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "unfolding mult_mat_vec_def"], ["proof (prove)\nusing this:\n  0\\<^sub>v (dim_col A) \\<bullet>\n  vec_first V (dim_vec (0\\<^sub>v (dim_col A))) +\n  row A\\<^sup>T i \\<bullet> vec_last V (dim_vec (row A\\<^sup>T i)) =\n  row A\\<^sup>T i \\<bullet> y\n\ngoal (1 subgoal):\n 1. vec (dim_row A\\<^sup>T) (\\<lambda>i. row A\\<^sup>T i \\<bullet> y) $ i =\n    c $ i", "by (metis \"3\" assms(1) calculation index_vec sat)"], ["proof (state)\nthis:\n  (A\\<^sup>T *\\<^sub>v y) $ i = c $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_leqb_eqc_split_simplex_correct2:\n  assumes \"dim_vec c = dim_row A\\<^sup>T\"\n  assumes \"dim_vec b = dim_col A\\<^sup>T\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  assumes \"(x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\"  \n  shows \"[y \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c", "using assms(1) assms(2) assms(3) assms(4) mat_leqb_eqc_split_correct2 simplex(3)"], ["proof (prove)\nusing this:\n  dim_vec c = dim_row A\\<^sup>T\n  dim_vec b = dim_col A\\<^sup>T\n  simplex (mat_leqb_eqc A b c) = Inr X\n  (x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\n  \\<lbrakk>dim_vec ?c = dim_row ?A\\<^sup>T; dim_vec ?b = dim_col ?A\\<^sup>T;\n   \\<langle>?X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n   set (mat_leqb_eqc ?A ?b ?c);\n   (?x, ?y) =\n   split_n_m_x (dim_row ?A\\<^sup>T) (dim_col ?A\\<^sup>T) ?X\\<rbrakk>\n  \\<Longrightarrow> [?y\\<^sub>v*?A]=?c\n  simplex ?cs = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?cs\n\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c", "by blast"], ["", "lemma mat_leqb_eqc_correct:\n  assumes \"dim_vec c = dim_row A\\<^sup>T\"\n    and \"dim_vec b = dim_col A\\<^sup>T\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  assumes \"(x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\"\n  shows \"[y \\<^sub>v* A]=c\" \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c &&& [A*\\<^sub>vx]\\<le>b", "using mat_leqb_eqc_split_simplex_correct1[of b A c X x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_vec b = dim_row A; simplex (mat_leqb_eqc A b c) = Inr X;\n   (x, y) = split_i_j_x (dim_col A) ?l X\\<rbrakk>\n  \\<Longrightarrow> [A*\\<^sub>vx]\\<le>b\n\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c &&& [A*\\<^sub>vx]\\<le>b", "using assms(1) assms(2) assms(3) assms(4) mat_leqb_eqc_split_simplex_correct2"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_vec b = dim_row A; simplex (mat_leqb_eqc A b c) = Inr X;\n   (x, y) = split_i_j_x (dim_col A) ?l X\\<rbrakk>\n  \\<Longrightarrow> [A*\\<^sub>vx]\\<le>b\n  dim_vec c = dim_row A\\<^sup>T\n  dim_vec b = dim_col A\\<^sup>T\n  simplex (mat_leqb_eqc A b c) = Inr X\n  (x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\n  \\<lbrakk>dim_vec ?c = dim_row ?A\\<^sup>T; dim_vec ?b = dim_col ?A\\<^sup>T;\n   simplex (mat_leqb_eqc ?A ?b ?c) = Inr ?X;\n   (?x, ?y) =\n   split_n_m_x (dim_row ?A\\<^sup>T) (dim_col ?A\\<^sup>T) ?X\\<rbrakk>\n  \\<Longrightarrow> [?y\\<^sub>v*?A]=?c\n\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c &&& [A*\\<^sub>vx]\\<le>b", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "using mat_leqb_eqc_split_correct2[of b A c X x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_vec b = dim_row A\\<^sup>T; dim_vec c = dim_col A\\<^sup>T;\n   \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n   set (mat_leqb_eqc A c b);\n   (x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) X\\<rbrakk>\n  \\<Longrightarrow> [y\\<^sub>v*A]=b\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "by (metis (no_types) Matrix.transpose_transpose assms(2) assms(3) assms(4) index_transpose_mat(3)\n      mat_leqb_eqc_split_simplex_correct1[of b A c X x y])"], ["", "lemma eval_lpoly_eq_dot_prod_split1:\n  assumes \"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\"\n  shows\"(vec_to_lpoly c) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> =  c \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "have *: \"(vec_to_lpoly c) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> =\n           (\\<Sum>i\\<in>vars (vec_to_lpoly c). Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n       Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n       \\<langle>X\\<rangle> i)", "using linear_poly_sum sum.cong eval_poly_with_sum"], ["proof (prove)\nusing this:\n  ?p \\<lbrace> ?v \\<rbrace> =\n  (\\<Sum>x\\<in>vars ?p. Abstract_Linear_Poly.coeff ?p x *R ?v x)\n  \\<lbrakk>?A = ?B;\n   \\<And>x. x \\<in> ?B \\<Longrightarrow> ?g x = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n  ?v \\<lbrace> ?X \\<rbrace> =\n  (\\<Sum>x\\<in>vars ?v. Abstract_Linear_Poly.coeff ?v x * ?X x)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n       Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n       \\<langle>X\\<rangle> i)", "by auto"], ["proof (state)\nthis:\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n     Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "also"], ["proof (state)\nthis:\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n     Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec c}. Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n       Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n       \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n        \\<langle>X\\<rangle> i)", "using vars_subset_dim_vec_to_lpoly_dim[of c] linear_poly_sum[of \"vec_to_lpoly c\" \"\\<langle>X\\<rangle>\"] \n      eval_poly_with_sum_superset[of \"{0..<dim_vec c}\" \"vec_to_lpoly c\" \"\\<langle>X\\<rangle>\"]"], ["proof (prove)\nusing this:\n  vars (vec_to_lpoly c) \\<subseteq> {0..<dim_vec c}\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>x\\<in>vars (vec_to_lpoly c).\n     Abstract_Linear_Poly.coeff (vec_to_lpoly c) x *R \\<langle>X\\<rangle> x)\n  \\<lbrakk>finite {0..<dim_vec c};\n   vars (vec_to_lpoly c) \\<subseteq> {0..<dim_vec c}\\<rbrakk>\n  \\<Longrightarrow> vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n                    (\\<Sum>x = 0..<dim_vec c.\n                        Abstract_Linear_Poly.coeff (vec_to_lpoly c) x *\n                        \\<langle>X\\<rangle> x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n       Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n       \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n        \\<langle>X\\<rangle> i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n     Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n     \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>vars (vec_to_lpoly c).\n     Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n     \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly c) i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec c}. c$i * x$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i)", "using split_access_fst_1[of _ \"dim_vec c\" \"(dim_vec c) + (dim_vec b)\" X x y]\n      split_access_snd_1[of \"dim_vec c\" _ \"((dim_vec c) + (dim_vec b))\" X x y]\n      vec_to_lin_poly_coeff_access[of _ c]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < dim_vec c;\n   split_n_m_x (dim_vec c) (dim_vec b) X = (x, y)\\<rbrakk>\n  \\<Longrightarrow> x $ ?k = \\<langle>X\\<rangle> ?k\n  \\<lbrakk>dim_vec c \\<le> ?k; ?k < dim_vec c + dim_vec b;\n   split_n_m_x (dim_vec c) (dim_vec b) X = (x, y)\\<rbrakk>\n  \\<Longrightarrow> y $ (?k - dim_vec c) = \\<langle>X\\<rangle> ?k\n  ?x < dim_vec c \\<Longrightarrow>\n  c $ ?x = Abstract_Linear_Poly.coeff (vec_to_lpoly c) ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < dim_vec c;\n   split_n_m_x (dim_vec c) (dim_vec b) X = (x, y)\\<rbrakk>\n  \\<Longrightarrow> x $ ?k = \\<langle>X\\<rangle> ?k\n  \\<lbrakk>dim_vec c \\<le> ?k; ?k < dim_vec c + dim_vec b;\n   split_n_m_x (dim_vec c) (dim_vec b) X = (x, y)\\<rbrakk>\n  \\<Longrightarrow> y $ (?k - dim_vec c) = \\<langle>X\\<rangle> ?k\n  ?x < dim_vec c \\<Longrightarrow>\n  c $ ?x = Abstract_Linear_Poly.coeff (vec_to_lpoly c) ?x\n  (x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c.\n        Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c.\n      Abstract_Linear_Poly.coeff (vec_to_lpoly c) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "have \"... = c \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i) = c \\<bullet> x", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i) =\n    (\\<Sum>i = 0..<dim_vec x. c $ i * x $ i)", "using split_vec_dims(1)[of \"dim_vec c\" \"(dim_vec c) + (dim_vec b)\" X x y] assms"], ["proof (prove)\nusing this:\n  split_n_m_x (dim_vec c) (dim_vec b) X = (x, y) \\<Longrightarrow>\n  dim_vec x = dim_vec c\n  (x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i) =\n    (\\<Sum>i = 0..<dim_vec x. c $ i * x $ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c. c $ i * x $ i) = c \\<bullet> x\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "finally"], ["proof (chain)\npicking this:\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x\n\ngoal (1 subgoal):\n 1. vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x", "."], ["proof (state)\nthis:\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_lpoly_eq_dot_prod_split2:\n  assumes \"(x, y) = split_n_m_x (dim_vec b) (dim_vec c) X\"\n  shows\"(vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> =  c \\<bullet> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "let ?p = \"(vec_to_lpoly ((0\\<^sub>v (dim_vec b) @\\<^sub>v c)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "let ?v0 = \"(0\\<^sub>v (dim_vec b) @\\<^sub>v c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have *: \"\\<forall>i<dim_vec b. Abstract_Linear_Poly.coeff ?p i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec b.\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i =\n       0", "using coeff_nonzero_dim_vec_non_zero(1)"], ["proof (prove)\nusing this:\n  Abstract_Linear_Poly.coeff (vec_to_lpoly ?v) ?i \\<noteq>\n  0 \\<Longrightarrow>\n  ?v $ ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec b.\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i =\n       0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec b.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i =\n     0\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have **: \"dim_vec ?v0 = dim_vec b + dim_vec c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c) = dim_vec b + dim_vec c", "by simp"], ["proof (state)\nthis:\n  dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c) = dim_vec b + dim_vec c\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"?p \\<lbrace>\\<langle>X\\<rangle>\\<rbrace> = (\\<Sum>i\\<in>vars ?p. Abstract_Linear_Poly.coeff ?p i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n       \\<langle>X\\<rangle> i)", "using eval_poly_with_sum"], ["proof (prove)\nusing this:\n  ?v \\<lbrace> ?X \\<rbrace> =\n  (\\<Sum>x\\<in>vars ?v. Abstract_Linear_Poly.coeff ?v x * ?X x)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n       \\<langle>X\\<rangle> i)", "by blast"], ["proof (state)\nthis:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec b) @\\<^sub>v\n    c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n     \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec b) @\\<^sub>v\n    c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n     \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec ?v0}. Abstract_Linear_Poly.coeff ?p i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n       \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i)", "using eval_poly_with_sum_superset[of \"{0..<dim_vec ?v0}\" ?p \"\\<langle>X\\<rangle>\"] calculation\n      vars_subset_dim_vec_to_lpoly_dim[of ?v0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c)};\n   vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c))\n   \\<subseteq> {0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c)}\\<rbrakk>\n  \\<Longrightarrow> vec_to_lpoly\n                     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n                      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n                    (\\<Sum>x = 0..<dim_vec\n                                    (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n                        Abstract_Linear_Poly.coeff\n                         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c))\n                         x *\n                        \\<langle>X\\<rangle> x)\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec b) @\\<^sub>v\n    c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n     \\<langle>X\\<rangle> i)\n  vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c))\n  \\<subseteq> {0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n       \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i)", "by force"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n     \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>vars (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n     \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec b}. Abstract_Linear_Poly.coeff ?p i * \\<langle>X\\<rangle> i) + \n                   (\\<Sum>i\\<in>{(dim_vec b)..<dim_vec ?v0}. Abstract_Linear_Poly.coeff ?p i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec b.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) +\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i)", "by (simp add: sum.atLeastLessThan_concat)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec b.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) +\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec b.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) +\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{(dim_vec b)..<dim_vec ?v0}. Abstract_Linear_Poly.coeff ?p i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec b.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) +\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i)", "using *"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec b.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i =\n     0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec b.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) +\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec b.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) +\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec b.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) +\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{(dim_vec b)..<dim_vec ?v0}. ?v0$i * \\<langle>X\\<rangle> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i)", "using vec_to_lin_poly_coeff_access"], ["proof (prove)\nusing this:\n  ?x < dim_vec ?y \\<Longrightarrow>\n  ?y $ ?x = Abstract_Linear_Poly.coeff (vec_to_lpoly ?y) ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n        \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i *\n      \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec c}. ?v0$(i+dim_vec b) * \\<langle>X\\<rangle> (i+dim_vec b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c.\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n        \\<langle>X\\<rangle> (i + dim_vec b))", "using index_zero_vec(2)[of \"dim_vec b\"] index_append_vec(2)[of \"0\\<^sub>v (dim_vec b)\" c] ** *\n       sum.shift_bounds_nat_ivl[of \"(\\<lambda>i. ?v0$i * \\<langle>X\\<rangle> i)\" 0 \"dim_vec b\" \"dim_vec c\"]"], ["proof (prove)\nusing this:\n  dim_vec (0\\<^sub>v (dim_vec b)) = dim_vec b\n  dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c) =\n  dim_vec (0\\<^sub>v (dim_vec b)) + dim_vec c\n  dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c) = dim_vec b + dim_vec c\n  \\<forall>i<dim_vec b.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly (0\\<^sub>v (dim_vec b) @\\<^sub>v c)) i =\n     0\n  (\\<Sum>i = 0 + dim_vec b..<dim_vec c + dim_vec b.\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c.\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n      \\<langle>X\\<rangle> (i + dim_vec b))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i) =\n    (\\<Sum>i = 0..<dim_vec c.\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n        \\<langle>X\\<rangle> (i + dim_vec b))", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c.\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n      \\<langle>X\\<rangle> (i + dim_vec b))\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = dim_vec b..<dim_vec (0\\<^sub>v (dim_vec b) @\\<^sub>v c).\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ i * \\<langle>X\\<rangle> i) =\n  (\\<Sum>i = 0..<dim_vec c.\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n      \\<langle>X\\<rangle> (i + dim_vec b))\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec c}. c$i * \\<langle>X\\<rangle> (i+dim_vec b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c.\n        (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n        \\<langle>X\\<rangle> (i + dim_vec b)) =\n    (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c.\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n      \\<langle>X\\<rangle> (i + dim_vec b)) =\n  (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b))\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c.\n      (0\\<^sub>v (dim_vec b) @\\<^sub>v c) $ (i + dim_vec b) *\n      \\<langle>X\\<rangle> (i + dim_vec b)) =\n  (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b))\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = (\\<Sum>i\\<in>{0..<dim_vec c}. c$i * y$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b)) =\n    (\\<Sum>i = 0..<dim_vec c. c $ i * y $ i)", "using split_access_snd_2[of x y \"(dim_vec b)\" \"(dim_vec c)\" X] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y) = split_i_j_x (dim_vec b) (dim_vec c) X;\n   ?k < dim_vec y\\<rbrakk>\n  \\<Longrightarrow> y $ ?k = \\<langle>X\\<rangle> (?k + dim_vec x)\n  (x, y) = split_n_m_x (dim_vec b) (dim_vec c) X\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b)) =\n    (\\<Sum>i = 0..<dim_vec c. c $ i * y $ i)", "by (metis (mono_tags, lifting) atLeastLessThan_iff split_access_snd_2 \n        split_n_m_x_abbrev_dims(2) split_vec_dims(1) sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b)) =\n  (\\<Sum>i = 0..<dim_vec c. c $ i * y $ i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c. c $ i * \\<langle>X\\<rangle> (i + dim_vec b)) =\n  (\\<Sum>i = 0..<dim_vec c. c $ i * y $ i)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "have \"... = c \\<bullet> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec c. c $ i * y $ i) = c \\<bullet> y", "by (metis assms scalar_prod_def split_n_m_x_abbrev_dims(2))"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec c. c $ i * y $ i) = c \\<bullet> y\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "finally"], ["proof (chain)\npicking this:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec b) @\\<^sub>v\n    c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  c \\<bullet> y", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec b) @\\<^sub>v\n    c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  c \\<bullet> y\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_vec b) @\\<^sub>v\n      c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n    c \\<bullet> y", "."], ["proof (state)\nthis:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec b) @\\<^sub>v\n    c) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  c \\<bullet> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma x_times_c_geq_y_times_b_split_dotP:\n  assumes \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c x_times_c_geq_y_times_b c b\"\n  assumes \"(x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\"\n  shows \"c \\<bullet> x \\<ge> b \\<bullet> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<bullet> y \\<le> c \\<bullet> x", "using assms lpoly_of_v_equals_v_append0 eval_lpoly_eq_dot_prod_split2[of x y c b X]\n   eval_lpoly_eq_dot_prod_split1[of x y c b X]"], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c x_times_c_geq_y_times_b c b\n  (x, y) = split_n_m_x (dim_vec c) (dim_vec b) X\n  vec_to_lpoly ?v = vec_to_lpoly (?v @\\<^sub>v 0\\<^sub>v ?a)\n  (x, y) = split_n_m_x (dim_vec c) (dim_vec b) X \\<Longrightarrow>\n  vec_to_lpoly\n   (0\\<^sub>v (dim_vec c) @\\<^sub>v\n    b) \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  b \\<bullet> y\n  (x, y) = split_n_m_x (dim_vec c) (dim_vec b) X \\<Longrightarrow>\n  vec_to_lpoly c \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> = c \\<bullet> x\n\ngoal (1 subgoal):\n 1. b \\<bullet> y \\<le> c \\<bullet> x", "by auto"], ["", "lemma mult_right_leq:\n  fixes A :: \"('a::{comm_semiring_1,ordered_semiring}) mat\"\n  assumes \"dim_vec y = dim_vec b\"\n    and \"\\<forall>i < dim_vec y. y$i \\<ge> 0\"\n    and \"[A *\\<^sub>v x]\\<le> b\"\n  shows \"(A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y", "have \"(\\<Sum>n<dim_vec b. (A *\\<^sub>v x) $ n * y $ n) \\<le> (\\<Sum>n<dim_vec b. b $ n * y $ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<dim_vec b. (A *\\<^sub>v x) $ n * y $ n)\n    \\<le> (\\<Sum>n<dim_vec b. b $ n * y $ n)", "by (metis (no_types, lifting) assms(1) assms(2) assms(3) lessThan_iff \n        mat_times_vec_leq_def mult_right_mono sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>n<dim_vec b. (A *\\<^sub>v x) $ n * y $ n)\n  \\<le> (\\<Sum>n<dim_vec b. b $ n * y $ n)\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>n<dim_vec b. (A *\\<^sub>v x) $ n * y $ n)\n  \\<le> (\\<Sum>n<dim_vec b. b $ n * y $ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>n<dim_vec b. (A *\\<^sub>v x) $ n * y $ n)\n  \\<le> (\\<Sum>n<dim_vec b. b $ n * y $ n)\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y", "by (metis (no_types) assms(1) atLeast0LessThan scalar_prod_def)"], ["proof (state)\nthis:\n  (A *\\<^sub>v x) \\<bullet> y \\<le> b \\<bullet> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_right_eq:\n  assumes \"dim_vec x = dim_vec c\"\n    and \"[y \\<^sub>v* A]=c\"\n  shows \"(A\\<^sup>T *\\<^sub>v y) \\<bullet> x = c \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A\\<^sup>T *\\<^sub>v y) \\<bullet> x = c \\<bullet> x", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x. (A\\<^sup>T *\\<^sub>v y) $ i * x $ i) =\n    (\\<Sum>i = 0..<dim_vec x. c $ i * x $ i)", "using atLeastLessThan_iff[of _ 0 \"dim_vec x\"] vec_times_mat_eq_def[of y A c] \n    sum.cong[of _ _ \"\\<lambda>i. (A\\<^sup>T *\\<^sub>v y) $ i * x $ i\" \"\\<lambda>i. c $ i * x $ i\"]"], ["proof (prove)\nusing this:\n  (?i \\<in> {0..<dim_vec x}) = (0 \\<le> ?i \\<and> ?i < dim_vec x)\n  [y\\<^sub>v*A]=c =\n  ((\\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v y) $ i = c $ i) \\<and>\n   dim_col A\\<^sup>T = dim_vec y \\<and> dim_row A\\<^sup>T = dim_vec c)\n  \\<lbrakk>?A = ?B;\n   \\<And>xa.\n      xa \\<in> ?B \\<Longrightarrow>\n      (A\\<^sup>T *\\<^sub>v y) $ xa * x $ xa = c $ xa * x $ xa\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>?A. (A\\<^sup>T *\\<^sub>v y) $ i * x $ i) =\n                    (\\<Sum>i\\<in>?B. c $ i * x $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec x. (A\\<^sup>T *\\<^sub>v y) $ i * x $ i) =\n    (\\<Sum>i = 0..<dim_vec x. c $ i * x $ i)", "by (metis (mono_tags, lifting) assms(1) assms(2))"], ["", "lemma soundness_mat_x_leq:\n  assumes \"dim_row A = dim_vec b\"\n  assumes \"simplex (mat_x_leq_vec A b) = Sat X\"\n  shows \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [A*\\<^sub>vx]\\<le>b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "define x where x: \"x = fst (split_n_m_x (dim_col A) (dim_row A) X)\""], ["proof (state)\nthis:\n  x = fst (split_n_m_x (dim_col A) (dim_row A) X)\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "have *: \"dim_vec x = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A", "by (simp add: split_i_j_x_def x)"], ["proof (state)\nthis:\n  dim_vec x = dim_col A\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "have \"\\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i", "proof (standard, standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "assume \"i < dim_vec b\""], ["proof (state)\nthis:\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have \"row A i \\<bullet> x \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> x \\<le> b $ i", "using mat_x_leq_vec_sol[of A b X i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (mat_x_leq_vec A b);\n   i < dim_vec b\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A !\n                    i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n                    \\<le> b $ i\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> x \\<le> b $ i", "by (metis \\<open>i < dim_vec b\\<close> assms(1) assms(2) eval_lpoly_eq_dot_prod_split1 \n          fst_conv index_row(2) matrix_to_lp_vec_to_lpoly_row simplex(3) split_i_j_x_def x)"], ["proof (state)\nthis:\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "then"], ["proof (chain)\npicking this:\n  row A i \\<bullet> x \\<le> b $ i", "show \"(A *\\<^sub>v x) $ i \\<le> b $ i\""], ["proof (prove)\nusing this:\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) $ i \\<le> b $ i", "by (simp add: \\<open>i < dim_vec b\\<close> assms(1))"], ["proof (state)\nthis:\n  (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i", "show \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "using mat_times_vec_leqI[of A b x, OF assms(1) *[symmetric]]"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\n  (\\<And>i.\n      i < dim_vec b \\<Longrightarrow>\n      (A *\\<^sub>v x) $ i \\<le> b $ i) \\<Longrightarrow>\n  [A*\\<^sub>vx]\\<le>b\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "by auto"], ["proof (state)\nthis:\n  [A*\\<^sub>vx]\\<le>b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma completeness_mat_x_leq:\n  assumes \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\"\n  shows \"\\<exists>X. simplex (mat_x_leq_vec A b) = Sat X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. simplex (mat_x_leq_vec A b) = Inr X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "assume 1: \"\\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X\""], ["proof (state)\nthis:\n  \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "have *: \"\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)", "using simplex(1)[of \"mat_x_leq_vec A b\"]"], ["proof (prove)\nusing this:\n  simplex (mat_x_leq_vec A b) = Inl ?I \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)", "using \"1\" sum.exhaust_sel"], ["proof (prove)\nusing this:\n  simplex (mat_x_leq_vec A b) = Inl ?I \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n  \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)", "by blast"], ["proof (state)\nthis:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)", "have \"dim_vec b = dim_row A\""], ["proof (prove)\nusing this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. dim_vec b = dim_row A", "using assms mat_times_vec_leqD(1)[of A _ b]"], ["proof (prove)\nusing this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n  \\<exists>x. [A*\\<^sub>vx]\\<le>b\n  [A*\\<^sub>v?x]\\<le>b \\<Longrightarrow> dim_row A = dim_vec b\n\ngoal (1 subgoal):\n 1. dim_vec b = dim_row A", "by auto"], ["proof (state)\nthis:\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  dim_vec b = dim_row A", "obtain x where x: \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\nusing this:\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        [A*\\<^sub>vx]\\<le>b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  dim_vec b = dim_row A\n  \\<exists>x. [A*\\<^sub>vx]\\<le>b\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        [A*\\<^sub>vx]\\<le>b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [A*\\<^sub>vx]\\<le>b\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "have x_A: \"dim_vec x = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A", "using x"], ["proof (prove)\nusing this:\n  [A*\\<^sub>vx]\\<le>b\n\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A", "by auto"], ["proof (state)\nthis:\n  dim_vec x = dim_col A\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "define v where v: \"v = (\\<lambda>i. (if i < dim_vec x then x$i else 0))\""], ["proof (state)\nthis:\n  v = (\\<lambda>i. if i < dim_vec x then x $ i else 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "have v_d: \"\\<forall>i < dim_vec x. x$i = v i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec x. x $ i = v i", "by (simp add: v)"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec x. x $ i = v i\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "have \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "assume \"c \\<in> set (mat_x_leq_vec A b)\""], ["proof (state)\nthis:\n  c \\<in> set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "then"], ["proof (chain)\npicking this:\n  c \\<in> set (mat_x_leq_vec A b)", "obtain i where i: \"c = LEQ (matrix_to_lpolies A!i) (b$i)\" \"i < dim_vec b\""], ["proof (prove)\nusing this:\n  c \\<in> set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>c = LEQ (matrix_to_lpolies A ! i) (b $ i);\n         i < dim_vec b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = LEQ (matrix_to_lpolies A ! i) (b $ i)\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "let ?p = \"matrix_to_lpolies A!i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "have 2: \"?p\\<lbrace> v \\<rbrace> = (row A i) \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> = row A i \\<bullet> x", "using matrix_to_lpolies_lambda_valuate_scalarP[of i A x] v"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < dim_row A; dim_col A = dim_vec x\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A !\n                    i \\<lbrace> \\<lambda>i.\n                                   if i < dim_vec x then x $ i\n                                   else 0 \\<rbrace> =\n                    row A i \\<bullet> x\n  v = (\\<lambda>i. if i < dim_vec x then x $ i else 0)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> = row A i \\<bullet> x", "by (metis \\<open>dim_vec b = dim_row A\\<close> i(2) x_A)"], ["proof (state)\nthis:\n  matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> = row A i \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "also"], ["proof (state)\nthis:\n  matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> = row A i \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "have \"... \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> x \\<le> b $ i", "by (metis i(2) index_mult_mat_vec mat_times_vec_leq_def x)"], ["proof (state)\nthis:\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set (mat_x_leq_vec A b) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c c", "finally"], ["proof (chain)\npicking this:\n  matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> \\<le> b $ i", "show \"v \\<Turnstile>\\<^sub>c c\""], ["proof (prove)\nusing this:\n  matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> \\<le> b $ i\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c c", "using i(1) satisfies_constraint.simps(3)[of v \"(matrix_to_lpolies A ! i)\" \"b $ i\"] \n        2 \\<open>row A i \\<bullet> x \\<le> b $ i\\<close>"], ["proof (prove)\nusing this:\n  matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> \\<le> b $ i\n  c = LEQ (matrix_to_lpolies A ! i) (b $ i)\n  v \\<Turnstile>\\<^sub>c LEQ (matrix_to_lpolies A ! i) (b $ i) =\n  (matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> \\<le> b $ i *R 1)\n  matrix_to_lpolies A ! i \\<lbrace> v \\<rbrace> = row A i \\<bullet> x\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c c", "by simp"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_x_leq_vec A b) = Inr X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)", "show False"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_x_leq_vec A b)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma soundness_mat_x_eq_vec:\n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"simplex (x_mat_eq_vec c A\\<^sup>T) = Sat X\"\n  shows  \"\\<exists>x. [x \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [x\\<^sub>v*A]=c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. [?x\\<^sub>v*A]=c", "define x where x: \"x = fst (split_n_m_x (dim_col A\\<^sup>T) (dim_row A\\<^sup>T) X)\""], ["proof (state)\nthis:\n  x = fst (split_n_m_x (dim_col A\\<^sup>T) (dim_row A\\<^sup>T) X)\n\ngoal (1 subgoal):\n 1. [?x\\<^sub>v*A]=c", "have \"dim_vec x = dim_col A\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A\\<^sup>T", "unfolding split_i_j_x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A\\<^sup>T", "using split_vec_dims(1)[of \"(dim_col A\\<^sup>T)\" _ X x] fst_conv[of x]"], ["proof (prove)\nusing this:\n  split_i_j_x (dim_col A\\<^sup>T) ?j X = (x, ?b) \\<Longrightarrow>\n  dim_vec x = dim_col A\\<^sup>T\n  fst (x, ?x2.0) = x\n\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A\\<^sup>T", "by (simp add: split_i_j_x_def x)"], ["proof (state)\nthis:\n  dim_vec x = dim_col A\\<^sup>T\n\ngoal (1 subgoal):\n 1. [?x\\<^sub>v*A]=c", "have \"\\<forall>i < dim_vec c. (A\\<^sup>T *\\<^sub>v x)$i = c$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "proof (standard, standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "assume a: \"i < dim_vec c\""], ["proof (state)\nthis:\n  i < dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "have *: \"\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n    set (x_mat_eq_vec c A\\<^sup>T)", "using assms(2) simplex(3)"], ["proof (prove)\nusing this:\n  simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\n  simplex ?cs = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set ?cs\n\ngoal (1 subgoal):\n 1. \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n    set (x_mat_eq_vec c A\\<^sup>T)", "by blast"], ["proof (state)\nthis:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "then"], ["proof (chain)\npicking this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (x_mat_eq_vec c A\\<^sup>T)", "have \"row A\\<^sup>T i \\<bullet> x = c$i\""], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T i \\<bullet> x = c $ i", "using x_mat_eq_vec_sol[of c \"A\\<^sup>T\" \"\\<langle>X\\<rangle>\" i, OF * a] eval_lpoly_eq_dot_prod_split1 fstI"], ["proof (prove)\nusing this:\n  \\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  set (x_mat_eq_vec c A\\<^sup>T)\n  matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace> =\n  c $ i\n  (?x, ?y) = split_n_m_x (dim_vec ?c) (dim_vec ?b) ?X \\<Longrightarrow>\n  vec_to_lpoly ?c \\<lbrace> \\<langle>?X\\<rangle> \\<rbrace> = ?c \\<bullet> ?x\n  ?x = (?y, ?z) \\<Longrightarrow> fst ?x = ?y\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T i \\<bullet> x = c $ i", "by (metis a assms(1) index_row(2) matrix_to_lpolies_vec_of_row split_i_j_x_def x)"], ["proof (state)\nthis:\n  row A\\<^sup>T i \\<bullet> x = c $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "then"], ["proof (chain)\npicking this:\n  row A\\<^sup>T i \\<bullet> x = c $ i", "show \"(A\\<^sup>T *\\<^sub>v x) $ i = c $ i\""], ["proof (prove)\nusing this:\n  row A\\<^sup>T i \\<bullet> x = c $ i\n\ngoal (1 subgoal):\n 1. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "unfolding mult_mat_vec_def"], ["proof (prove)\nusing this:\n  row A\\<^sup>T i \\<bullet> x = c $ i\n\ngoal (1 subgoal):\n 1. vec (dim_row A\\<^sup>T) (\\<lambda>i. row A\\<^sup>T i \\<bullet> x) $ i =\n    c $ i", "using a assms(1)"], ["proof (prove)\nusing this:\n  row A\\<^sup>T i \\<bullet> x = c $ i\n  i < dim_vec c\n  dim_row A\\<^sup>T = dim_vec c\n\ngoal (1 subgoal):\n 1. vec (dim_row A\\<^sup>T) (\\<lambda>i. row A\\<^sup>T i \\<bullet> x) $ i =\n    c $ i", "by auto"], ["proof (state)\nthis:\n  (A\\<^sup>T *\\<^sub>v x) $ i = c $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i\n\ngoal (1 subgoal):\n 1. [?x\\<^sub>v*A]=c", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i", "show \"[x \\<^sub>v* A]=c\""], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i\n\ngoal (1 subgoal):\n 1. [x\\<^sub>v*A]=c", "using mat_times_vec_eqI[of A x c, OF \\<open>dim_vec x = dim_col A\\<^sup>T\\<close>[symmetric] assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v x) $ i = c $ i\n  (\\<And>i.\n      i < dim_vec c \\<Longrightarrow>\n      (A\\<^sup>T *\\<^sub>v x) $ i = c $ i) \\<Longrightarrow>\n  [x\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. [x\\<^sub>v*A]=c", "by auto"], ["proof (state)\nthis:\n  [x\\<^sub>v*A]=c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma completeness_mat_x_eq_vec:\n  assumes \"\\<exists>x. [x \\<^sub>v* A]=c\"\n  shows \"\\<exists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Sat X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "assume 1: \"\\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\""], ["proof (state)\nthis:\n  \\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X", "have *: \"\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\""], ["proof (prove)\nusing this:\n  \\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)", "using simplex(1)[of \"x_mat_eq_vec c A\\<^sup>T\"]"], ["proof (prove)\nusing this:\n  \\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\n  simplex (x_mat_eq_vec c A\\<^sup>T) = Inl ?I \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)", "using sum.exhaust_sel 1"], ["proof (prove)\nusing this:\n  \\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\n  simplex (x_mat_eq_vec c A\\<^sup>T) = Inl ?I \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<nexists>X. simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)", "by blast"], ["proof (state)\nthis:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)", "have \"dim_vec c = dim_col A\""], ["proof (prove)\nusing this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. dim_vec c = dim_col A", "using assms"], ["proof (prove)\nusing this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n  \\<exists>x. [x\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. dim_vec c = dim_col A", "by (metis index_transpose_mat(2) vec_times_mat_eqD(3))"], ["proof (state)\nthis:\n  dim_vec c = dim_col A\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "obtain x where \" [x \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. [x\\<^sub>v*A]=c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x. [x\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. (\\<And>x. [x\\<^sub>v*A]=c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [x\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  [x\\<^sub>v*A]=c", "have \"dim_vec x = dim_col A\\<^sup>T\""], ["proof (prove)\nusing this:\n  [x\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A\\<^sup>T", "using assms"], ["proof (prove)\nusing this:\n  [x\\<^sub>v*A]=c\n  \\<exists>x. [x\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A\\<^sup>T", "by (metis \\<open>[x \\<^sub>v* A]=c\\<close> vec_times_mat_eq_def)"], ["proof (state)\nthis:\n  dim_vec x = dim_col A\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "define v where v: \"v = (\\<lambda>i. (if i < dim_vec x then x$i else 0))\""], ["proof (state)\nthis:\n  v = (\\<lambda>i. if i < dim_vec x then x $ i else 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "have v_d: \"\\<forall>i < dim_vec x. x$i = v i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec x. x $ i = v i", "by (simp add: v)"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec x. x $ i = v i\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "have \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "assume \"a \\<in> set (x_mat_eq_vec c A\\<^sup>T)\""], ["proof (state)\nthis:\n  a \\<in> set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "then"], ["proof (chain)\npicking this:\n  a \\<in> set (x_mat_eq_vec c A\\<^sup>T)", "obtain i where i: \"a = EQ (matrix_to_lpolies A\\<^sup>T!i) (c$i)\" \"i < dim_vec c\""], ["proof (prove)\nusing this:\n  a \\<in> set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>a = EQ (matrix_to_lpolies A\\<^sup>T ! i) (c $ i);\n         i < dim_vec c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) add_cancel_right_left diff_zero in_set_conv_nth length_map length_upt nth_map_upt x_mat_eq_vec.simps)"], ["proof (state)\nthis:\n  a = EQ (matrix_to_lpolies A\\<^sup>T ! i) (c $ i)\n  i < dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "let ?p = \"matrix_to_lpolies A\\<^sup>T!i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "have 2: \"?p\\<lbrace> v \\<rbrace> = (row A\\<^sup>T i) \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> =\n    row A\\<^sup>T i \\<bullet> x", "using matrix_to_lpolies_lambda_valuate_scalarP[of i \"A\\<^sup>T\" x] v"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < dim_row A\\<^sup>T; dim_col A\\<^sup>T = dim_vec x\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A\\<^sup>T !\n                    i \\<lbrace> \\<lambda>i.\n                                   if i < dim_vec x then x $ i\n                                   else 0 \\<rbrace> =\n                    row A\\<^sup>T i \\<bullet> x\n  v = (\\<lambda>i. if i < dim_vec x then x $ i else 0)\n\ngoal (1 subgoal):\n 1. matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> =\n    row A\\<^sup>T i \\<bullet> x", "by (metis \\<open>dim_vec c = dim_col A\\<close> \\<open>dim_vec x = dim_col A\\<^sup>T\\<close> i(2) index_transpose_mat(2))"], ["proof (state)\nthis:\n  matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> =\n  row A\\<^sup>T i \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "also"], ["proof (state)\nthis:\n  matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> =\n  row A\\<^sup>T i \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "have \"... = c$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A\\<^sup>T i \\<bullet> x = c $ i", "by (metis \\<open>[x \\<^sub>v* A]=c\\<close> \\<open>dim_vec c = dim_col A\\<close> i(2) index_mult_mat_vec index_transpose_mat(2) vec_times_mat_eqD(1))"], ["proof (state)\nthis:\n  row A\\<^sup>T i \\<bullet> x = c $ i\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (x_mat_eq_vec c A\\<^sup>T) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "finally"], ["proof (chain)\npicking this:\n  matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> = c $ i", "show \"v \\<Turnstile>\\<^sub>c a\""], ["proof (prove)\nusing this:\n  matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> = c $ i\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c a", "using i(1) satisfies_constraint.simps(5)[of v \"(matrix_to_lpolies A\\<^sup>T ! i)\" \"(c $ i)\"]"], ["proof (prove)\nusing this:\n  matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> = c $ i\n  a = EQ (matrix_to_lpolies A\\<^sup>T ! i) (c $ i)\n  v \\<Turnstile>\\<^sub>c EQ (matrix_to_lpolies A\\<^sup>T ! i) (c $ i) =\n  (matrix_to_lpolies A\\<^sup>T ! i \\<lbrace> v \\<rbrace> = c $ i *R 1)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c a", "by simp"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<nexists>X.\n       simplex (x_mat_eq_vec c A\\<^sup>T) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)", "show False"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. False", "using \"*\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (x_mat_eq_vec c A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma soundness_mat_leqb_eqc1:\n  assumes \"dim_row A = dim_vec b\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  shows \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. [A*\\<^sub>vx]\\<le>b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "define x where x: \"x = fst (split_n_m_x (dim_col A) (dim_row A) X)\""], ["proof (state)\nthis:\n  x = fst (split_n_m_x (dim_col A) (dim_row A) X)\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "have *: \"dim_vec x = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A", "by (simp add: split_i_j_x_def x)"], ["proof (state)\nthis:\n  dim_vec x = dim_col A\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "have \"\\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i", "proof (standard, standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "assume \"i < dim_vec b\""], ["proof (state)\nthis:\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "have \"row A i \\<bullet> x \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> x \\<le> b $ i", "using mat_x_leq_vec_sol[of A b X i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (mat_x_leq_vec A b);\n   i < dim_vec b\\<rbrakk>\n  \\<Longrightarrow> matrix_to_lpolies A !\n                    i \\<lbrace> \\<langle>X\\<rangle> \\<rbrace>\n                    \\<le> b $ i\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> x \\<le> b $ i", "by (metis \\<open>i < dim_vec b\\<close> assms(1) assms(2) fst_conv split_i_j_x_def x\n          index_mult_mat_vec mat_leqb_eqc_split_simplex_correct1 mat_times_vec_leqD(3))"], ["proof (state)\nthis:\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < dim_vec b \\<Longrightarrow> (A *\\<^sub>v x) $ i \\<le> b $ i", "then"], ["proof (chain)\npicking this:\n  row A i \\<bullet> x \\<le> b $ i", "show \"(A *\\<^sub>v x) $ i \\<le> b $ i\""], ["proof (prove)\nusing this:\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x) $ i \\<le> b $ i", "by (simp add: \\<open>i < dim_vec b\\<close> assms(1))"], ["proof (state)\nthis:\n  (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>v?x]\\<le>b", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i", "show \"[A *\\<^sub>v x]\\<le>b\""], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "using mat_times_vec_leqI[of A b x, OF assms(1) *[symmetric]]"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec b. (A *\\<^sub>v x) $ i \\<le> b $ i\n  (\\<And>i.\n      i < dim_vec b \\<Longrightarrow>\n      (A *\\<^sub>v x) $ i \\<le> b $ i) \\<Longrightarrow>\n  [A*\\<^sub>vx]\\<le>b\n\ngoal (1 subgoal):\n 1. [A*\\<^sub>vx]\\<le>b", "by auto"], ["proof (state)\nthis:\n  [A*\\<^sub>vx]\\<le>b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma soundness_mat_leqb_eqc2:\n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"dim_col A\\<^sup>T = dim_vec b\"\n  assumes \"simplex (mat_leqb_eqc A b c) = Sat X\"\n  shows \"\\<exists>y. [y \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. [y\\<^sub>v*A]=c", "proof (standard, intro mat_times_vec_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. dim_col A\\<^sup>T = dim_vec ?y\n 2. dim_row A\\<^sup>T = dim_vec c\n 3. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v ?y) $ i = c $ i", "define y where x: \"y = snd (split_n_m_x (dim_col A) (dim_row A) X)\""], ["proof (state)\nthis:\n  y = snd (split_n_m_x (dim_col A) (dim_row A) X)\n\ngoal (3 subgoals):\n 1. dim_col A\\<^sup>T = dim_vec ?y\n 2. dim_row A\\<^sup>T = dim_vec c\n 3. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v ?y) $ i = c $ i", "have *: \"dim_vec y = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec y = dim_row A", "by (simp add: split_i_j_x_def x)"], ["proof (state)\nthis:\n  dim_vec y = dim_row A\n\ngoal (3 subgoals):\n 1. dim_col A\\<^sup>T = dim_vec ?y\n 2. dim_row A\\<^sup>T = dim_vec c\n 3. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v ?y) $ i = c $ i", "show \"dim_col A\\<^sup>T = dim_vec y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A\\<^sup>T = dim_vec y", "by (simp add: \"*\")"], ["proof (state)\nthis:\n  dim_col A\\<^sup>T = dim_vec y\n\ngoal (2 subgoals):\n 1. dim_row A\\<^sup>T = dim_vec c\n 2. \\<And>i.\n       i < dim_vec c \\<Longrightarrow>\n       (A\\<^sup>T *\\<^sub>v snd (split_n_m_x (dim_col A) (dim_row A) X)) $\n       i =\n       c $ i", "show \"dim_row A\\<^sup>T = dim_vec c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A\\<^sup>T = dim_vec c", "using assms(1)"], ["proof (prove)\nusing this:\n  dim_row A\\<^sup>T = dim_vec c\n\ngoal (1 subgoal):\n 1. dim_row A\\<^sup>T = dim_vec c", "by blast"], ["proof (state)\nthis:\n  dim_row A\\<^sup>T = dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow>\n       (A\\<^sup>T *\\<^sub>v snd (split_n_m_x (dim_col A) (dim_row A) X)) $\n       i =\n       c $ i", "show \"\\<And>i. i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "assume a: \"i < dim_vec c\""], ["proof (state)\nthis:\n  i < dim_vec c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "have \"[y \\<^sub>v* A]=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c", "using mat_leqb_eqc_split_correct2[of c A b _ _ y, OF assms(1)[symmetric] assms(2)[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>?X\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n           set (mat_leqb_eqc A b c);\n   (?x, y) = split_n_m_x (dim_row A\\<^sup>T) (dim_col A\\<^sup>T) ?X\\<rbrakk>\n  \\<Longrightarrow> [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. [y\\<^sub>v*A]=c", "by (metis Matrix.transpose_transpose assms(3) index_transpose_mat(2) \n          simplex(3) snd_conv split_i_j_x_def x)"], ["proof (state)\nthis:\n  [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "then"], ["proof (chain)\npicking this:\n  [y\\<^sub>v*A]=c", "show \"(A\\<^sup>T *\\<^sub>v y) $ i = c $ i\""], ["proof (prove)\nusing this:\n  [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. (A\\<^sup>T *\\<^sub>v y) $ i = c $ i", "by (metis a vec_times_mat_eq_def)"], ["proof (state)\nthis:\n  (A\\<^sup>T *\\<^sub>v y) $ i = c $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < dim_vec c \\<Longrightarrow> (A\\<^sup>T *\\<^sub>v y) $ ?i = c $ ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma completeness_mat_leqb_eqc:  \n  assumes \"\\<exists>x. [A *\\<^sub>v x]\\<le>b\" \n    and \"\\<exists>y. [y \\<^sub>v* A]=c\"\n  shows \"\\<exists>X. simplex (mat_leqb_eqc A b c) = Sat X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. simplex (mat_leqb_eqc A b c) = Inr X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "assume 1: \"\\<nexists>X. simplex (mat_leqb_eqc A b c) = Sat X\""], ["proof (state)\nthis:\n  \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "have *: \"\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)", "using simplex(1)[of \"mat_leqb_eqc A b c\"]"], ["proof (prove)\nusing this:\n  simplex (mat_leqb_eqc A b c) = Inl ?I \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)", "using \"1\" sum.exhaust_sel"], ["proof (prove)\nusing this:\n  simplex (mat_leqb_eqc A b c) = Inl ?I \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n  \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)", "by blast"], ["proof (state)\nthis:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)", "have \"dim_vec b = dim_row A\""], ["proof (prove)\nusing this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. dim_vec b = dim_row A", "using assms mat_times_vec_leqD(1)[of A _ b]"], ["proof (prove)\nusing this:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n  \\<exists>x. [A*\\<^sub>vx]\\<le>b\n  \\<exists>y. [y\\<^sub>v*A]=c\n  [A*\\<^sub>v?x]\\<le>b \\<Longrightarrow> dim_row A = dim_vec b\n\ngoal (1 subgoal):\n 1. dim_vec b = dim_row A", "by presburger"], ["proof (state)\nthis:\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  dim_vec b = dim_row A", "obtain x y where x: \"[A *\\<^sub>v x]\\<le>b\" \"[y \\<^sub>v* A]=c\""], ["proof (prove)\nusing this:\n  dim_vec b = dim_row A\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>[A*\\<^sub>vx]\\<le>b; [y\\<^sub>v*A]=c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  dim_vec b = dim_row A\n  \\<exists>x. [A*\\<^sub>vx]\\<le>b\n  \\<exists>y. [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>[A*\\<^sub>vx]\\<le>b; [y\\<^sub>v*A]=c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [A*\\<^sub>vx]\\<le>b\n  [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "have x_A: \"dim_vec x = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A", "using x"], ["proof (prove)\nusing this:\n  [A*\\<^sub>vx]\\<le>b\n  [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. dim_vec x = dim_col A", "by auto"], ["proof (state)\nthis:\n  dim_vec x = dim_col A\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "have yr: \"dim_vec y = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec y = dim_row A", "using vec_times_mat_eq_def x(2)"], ["proof (prove)\nusing this:\n  [?y\\<^sub>v*?A]=?c =\n  ((\\<forall>i<dim_vec ?c. (?A\\<^sup>T *\\<^sub>v ?y) $ i = ?c $ i) \\<and>\n   dim_col ?A\\<^sup>T = dim_vec ?y \\<and> dim_row ?A\\<^sup>T = dim_vec ?c)\n  [y\\<^sub>v*A]=c\n\ngoal (1 subgoal):\n 1. dim_vec y = dim_row A", "by force"], ["proof (state)\nthis:\n  dim_vec y = dim_row A\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "define v where v: \"v = (\\<lambda>i. (if i < dim_vec (x@\\<^sub>vy) then (x@\\<^sub>vy)$i else 0))\""], ["proof (state)\nthis:\n  v =\n  (\\<lambda>i.\n      if i < dim_vec (x @\\<^sub>v y) then (x @\\<^sub>v y) $ i else 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "have v_d: \"\\<forall>i < dim_vec (x@\\<^sub>vy). (x@\\<^sub>vy)$i = v i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_vec (x @\\<^sub>v y). (x @\\<^sub>v y) $ i = v i", "by (simp add: v)"], ["proof (state)\nthis:\n  \\<forall>i<dim_vec (x @\\<^sub>v y). (x @\\<^sub>v y) $ i = v i\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "have i_in: \"\\<forall>i \\<in> {0..< dim_vec y}. y$i = v (i+dim_vec x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<dim_vec y}. y $ i = v (i + dim_vec x)", "by (simp add: v)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..<dim_vec y}. y $ i = v (i + dim_vec x)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "have \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "assume asm: \"e \\<in> set (mat_leqb_eqc A b c)\""], ["proof (state)\nthis:\n  e \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "define lst where lst: \"lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\""], ["proof (state)\nthis:\n  lst = matrix_to_lpolies (two_block_non_interfering A A\\<^sup>T)\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "let ?L = \"[LEQ (lst!i) (b$i) . i <- [0..<dim_vec b]] @\n              [EQ  (lst!i) ((b@\\<^sub>vc)$i) . i <- [dim_vec b ..< dim_vec (b@\\<^sub>vc)]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "have L: \"mat_leqb_eqc A b c = ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_leqb_eqc A b c =\n    map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)]", "by (metis (full_types) lst mat_leqb_eqc.simps)"], ["proof (state)\nthis:\n  mat_leqb_eqc A b c =\n  map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "then"], ["proof (chain)\npicking this:\n  mat_leqb_eqc A b c =\n  map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]", "obtain i where i: \"e = ?L!i\" \"i \\<in>{0..<length ?L}\""], ["proof (prove)\nusing this:\n  mat_leqb_eqc A b c =\n  map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>e =\n                 (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                   [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n                 i;\n         i \\<in> {0..<length\n                       (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                         [0..<dim_vec b] @\n                        map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                         [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using asm"], ["proof (prove)\nusing this:\n  mat_leqb_eqc A b c =\n  map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n  e \\<in> set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>e =\n                 (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                   [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n                 i;\n         i \\<in> {0..<length\n                       (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                         [0..<dim_vec b] @\n                        map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                         [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis atLeastLessThan_iff in_set_conv_nth not_le not_less0)"], ["proof (state)\nthis:\n  e =\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n  i \\<in> {0..<length\n                (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                 map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                  [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "have ldimbc: \"length ?L = dim_vec (b@\\<^sub>vc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n      map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n       [dim_vec b..<dim_vec (b @\\<^sub>v c)]) =\n    dim_vec (b @\\<^sub>v c)", "using i(2)"], ["proof (prove)\nusing this:\n  i \\<in> {0..<length\n                (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                 map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                  [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\n\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n      map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n       [dim_vec b..<dim_vec (b @\\<^sub>v c)]) =\n    dim_vec (b @\\<^sub>v c)", "by auto"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)]) =\n  dim_vec (b @\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "consider (leqb) \"i \\<in> {0..<dim_vec b}\" | (eqc) \"i \\<in> {dim_vec b..<length ?L}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> {0..<dim_vec b} \\<Longrightarrow> thesis;\n     i \\<in> {dim_vec\n               b..<length\n                    (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                      [0..<dim_vec b] @\n                     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                      [dim_vec b..<\n                       dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using i(2) leI"], ["proof (prove)\nusing this:\n  i \\<in> {0..<length\n                (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                 map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                  [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> {0..<dim_vec b} \\<Longrightarrow> thesis;\n     i \\<in> {dim_vec\n               b..<length\n                    (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                      [0..<dim_vec b] @\n                     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                      [dim_vec b..<\n                       dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<in> {0..<dim_vec b} \\<Longrightarrow> ?thesis;\n   i \\<in> {dim_vec\n             b..<length\n                  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                    [dim_vec b..<\n                     dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>ca.\n       ca \\<in> set (mat_leqb_eqc A b c) \\<Longrightarrow>\n       v \\<Turnstile>\\<^sub>c ca", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<in> {0..<dim_vec b} \\<Longrightarrow> ?thesis;\n   i \\<in> {dim_vec\n             b..<length\n                  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                    [dim_vec b..<\n                     dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"v \\<Turnstile>\\<^sub>c e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<in> {0..<dim_vec b} \\<Longrightarrow> ?thesis;\n   i \\<in> {dim_vec\n             b..<length\n                  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                    [dim_vec b..<\n                     dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c e", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "case leqb"], ["proof (state)\nthis:\n  i \\<in> {0..<dim_vec b}\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have il: \"i < dim_vec b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec b", "using atLeastLessThan_iff leqb"], ["proof (prove)\nusing this:\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  i \\<in> {0..<dim_vec b}\n\ngoal (1 subgoal):\n 1. i < dim_vec b", "by blast"], ["proof (state)\nthis:\n  i < dim_vec b\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have iA: \"i < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row A", "using \\<open>dim_vec b = dim_row A\\<close> \\<open>i < dim_vec b\\<close>"], ["proof (prove)\nusing this:\n  dim_vec b = dim_row A\n  i < dim_vec b\n\ngoal (1 subgoal):\n 1. i < dim_row A", "by linarith"], ["proof (state)\nthis:\n  i < dim_row A\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  i < dim_row A", "have *: \"e = LEQ (lst!i) (b$i)\""], ["proof (prove)\nusing this:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. e = LEQ (lst ! i) (b $ i)", "by (simp add: i(1) nth_append il)"], ["proof (state)\nthis:\n  e = LEQ (lst ! i) (b $ i)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  e = LEQ (lst ! i) (b $ i)", "have \"... = LEQ ((matrix_to_lpolies A)!i) (b$i)\""], ["proof (prove)\nusing this:\n  e = LEQ (lst ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. LEQ (lst ! i) (b $ i) = LEQ (matrix_to_lpolies A ! i) (b $ i)", "using mat_leqb_eqc_for_LEQ[of i b A c, OF il \\<open>i < dim_row A\\<close>] L i(1)"], ["proof (prove)\nusing this:\n  e = LEQ (lst ! i) (b $ i)\n  mat_leqb_eqc A b c ! i = LEQ (matrix_to_lpolies A ! i) (b $ i)\n  mat_leqb_eqc A b c =\n  map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n  e =\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n\ngoal (1 subgoal):\n 1. LEQ (lst ! i) (b $ i) = LEQ (matrix_to_lpolies A ! i) (b $ i)", "by simp"], ["proof (state)\nthis:\n  LEQ (lst ! i) (b $ i) = LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  LEQ (lst ! i) (b $ i) = LEQ (matrix_to_lpolies A ! i) (b $ i)", "have eqmp: \"lst!i = ((matrix_to_lpolies A)!i)\""], ["proof (prove)\nusing this:\n  LEQ (lst ! i) (b $ i) = LEQ (matrix_to_lpolies A ! i) (b $ i)\n\ngoal (1 subgoal):\n 1. lst ! i = matrix_to_lpolies A ! i", "by blast"], ["proof (state)\nthis:\n  lst ! i = matrix_to_lpolies A ! i\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have sset: \"vars (lst!i) \\<subseteq> {0..<dim_vec x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (lst ! i) \\<subseteq> {0..<dim_vec x}", "using matrix_to_lpolies_vec_of_row"], ["proof (prove)\nusing this:\n  ?i < dim_row ?A \\<Longrightarrow>\n  matrix_to_lpolies ?A ! ?i = vec_to_lpoly (row ?A ?i)\n\ngoal (1 subgoal):\n 1. vars (lst ! i) \\<subseteq> {0..<dim_vec x}", "by (metis \\<open>i < dim_row A\\<close> eqmp index_row(2)  \n            vars_subset_dim_vec_to_lpoly_dim x_A)"], ["proof (state)\nthis:\n  vars (lst ! i) \\<subseteq> {0..<dim_vec x}\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have **: \"((lst!i) \\<lbrace> v \\<rbrace>) = ((vec_to_lpoly (row A i)) \\<lbrace> v \\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lst ! i \\<lbrace> v \\<rbrace> =\n    vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace>", "by (simp add: \\<open>i < dim_row A\\<close> eqmp)"], ["proof (state)\nthis:\n  lst ! i \\<lbrace> v \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace>\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  lst ! i \\<lbrace> v \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace>\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>vars(lst!i). Abstract_Linear_Poly.coeff (lst!i) j * v j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace> =\n    (\\<Sum>j\\<in>vars (lst ! i).\n       Abstract_Linear_Poly.coeff (lst ! i) j * v j)", "using ** eval_poly_with_sum"], ["proof (prove)\nusing this:\n  lst ! i \\<lbrace> v \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace>\n  ?v \\<lbrace> ?X \\<rbrace> =\n  (\\<Sum>x\\<in>vars ?v. Abstract_Linear_Poly.coeff ?v x * ?X x)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace> =\n    (\\<Sum>j\\<in>vars (lst ! i).\n       Abstract_Linear_Poly.coeff (lst ! i) j * v j)", "by auto"], ["proof (state)\nthis:\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace> =\n  (\\<Sum>j\\<in>vars (lst ! i). Abstract_Linear_Poly.coeff (lst ! i) j * v j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace> =\n  (\\<Sum>j\\<in>vars (lst ! i). Abstract_Linear_Poly.coeff (lst ! i) j * v j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{0..<dim_vec x}. Abstract_Linear_Poly.coeff (lst!i) j * v j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>vars (lst ! i).\n       Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n    (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j)", "using sset eval_poly_with_sum_superset[of \"{0..<dim_vec x}\" \"lst!i\" v, \n            OF finite_atLeastLessThan sset] \"**\""], ["proof (prove)\nusing this:\n  vars (lst ! i) \\<subseteq> {0..<dim_vec x}\n  lst ! i \\<lbrace> v \\<rbrace> =\n  (\\<Sum>x = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) x * v x)\n  lst ! i \\<lbrace> v \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace>\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>vars (lst ! i).\n       Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n    (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j)", "using calculation"], ["proof (prove)\nusing this:\n  vars (lst ! i) \\<subseteq> {0..<dim_vec x}\n  lst ! i \\<lbrace> v \\<rbrace> =\n  (\\<Sum>x = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) x * v x)\n  lst ! i \\<lbrace> v \\<rbrace> =\n  vec_to_lpoly (row A i) \\<lbrace> v \\<rbrace>\n  lst ! i \\<lbrace> v \\<rbrace> =\n  (\\<Sum>j\\<in>vars (lst ! i). Abstract_Linear_Poly.coeff (lst ! i) j * v j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>vars (lst ! i).\n       Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n    (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j)", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>vars (lst ! i).\n     Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n  (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>vars (lst ! i).\n     Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n  (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{0..<dim_vec x}. Abstract_Linear_Poly.coeff (lst!i) j * x$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n    (\\<Sum>j = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff (lst ! i) j * x $ j)", "using v"], ["proof (prove)\nusing this:\n  v =\n  (\\<lambda>i.\n      if i < dim_vec (x @\\<^sub>v y) then (x @\\<^sub>v y) $ i else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n    (\\<Sum>j = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff (lst ! i) j * x $ j)", "by (auto split: if_split)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n  (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * x $ j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * v j) =\n  (\\<Sum>j = 0..<dim_vec x. Abstract_Linear_Poly.coeff (lst ! i) j * x $ j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{0..<dim_vec x}. (row A i)$j * x$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff (lst ! i) j * x $ j) =\n    (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j)", "using matrix_to_lpolies_vec_of_row[of i A, OF iA] \n          vec_to_lin_poly_coeff_access[of _ \"row A i\"] index_row(2)[of A i] \n          atLeastLessThan_iff"], ["proof (prove)\nusing this:\n  matrix_to_lpolies A ! i = vec_to_lpoly (row A i)\n  ?x < dim_vec (row A i) \\<Longrightarrow>\n  row A i $ ?x = Abstract_Linear_Poly.coeff (vec_to_lpoly (row A i)) ?x\n  dim_vec (row A i) = dim_col A\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec x.\n        Abstract_Linear_Poly.coeff (lst ! i) j * x $ j) =\n    (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j)", "by (metis (no_types, lifting) eqmp sum.cong x_A)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec x.\n      Abstract_Linear_Poly.coeff (lst ! i) j * x $ j) =\n  (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec x.\n      Abstract_Linear_Poly.coeff (lst ! i) j * x $ j) =\n  (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j)\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have  \"... = row A i \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j) = row A i \\<bullet> x", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j) =\n    (\\<Sum>ia = 0..<dim_vec x. row A i $ ia * x $ ia)", "by (simp)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j) = row A i \\<bullet> x\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec x. row A i $ j * x $ j) = row A i \\<bullet> x\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... \\<le> b$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> x \\<le> b $ i", "by (metis \\<open>i < dim_vec b\\<close> index_mult_mat_vec mat_times_vec_leq_def x(1))"], ["proof (state)\nthis:\n  row A i \\<bullet> x \\<le> b $ i\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<dim_vec b} \\<Longrightarrow> v \\<Turnstile>\\<^sub>c e\n 2. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "finally"], ["proof (chain)\npicking this:\n  lst ! i \\<lbrace> v \\<rbrace> \\<le> b $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  lst ! i \\<lbrace> v \\<rbrace> \\<le> b $ i\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c e", "by (simp add: \"*\")"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c e\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "case eqc"], ["proof (state)\nthis:\n  i \\<in> {dim_vec\n            b..<length\n                 (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                   [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have igeq: \"i \\<ge> dim_vec b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec b \\<le> i", "using atLeastLessThan_iff eqc"], ["proof (prove)\nusing this:\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  i \\<in> {dim_vec\n            b..<length\n                 (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                   [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\n\ngoal (1 subgoal):\n 1. dim_vec b \\<le> i", "by blast"], ["proof (state)\nthis:\n  dim_vec b \\<le> i\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have *: \"i < length ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length\n         (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n          map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n           [dim_vec b..<dim_vec (b @\\<^sub>v c)])", "using atLeastLessThan_iff eqc"], ["proof (prove)\nusing this:\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  i \\<in> {dim_vec\n            b..<length\n                 (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n                  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                   [dim_vec b..<dim_vec (b @\\<^sub>v c)])}\n\ngoal (1 subgoal):\n 1. i < length\n         (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n          map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n           [dim_vec b..<dim_vec (b @\\<^sub>v c)])", "by blast"], ["proof (state)\nthis:\n  i < length\n       (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n        map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n         [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"e =?L!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e =\n    (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i", "using L i(1)"], ["proof (prove)\nusing this:\n  mat_leqb_eqc A b c =\n  map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)]\n  e =\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n\ngoal (1 subgoal):\n 1. e =\n    (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i", "by presburger"], ["proof (state)\nthis:\n  e =\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"?L!i \\<in> set [EQ  (lst!i) ((b@\\<^sub>vc)$i). i <- [dim_vec b..< dim_vec (b@\\<^sub>vc)]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i\n    \\<in> set (map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                [dim_vec b..<dim_vec (b @\\<^sub>v c)])", "using in_second_append_list length_map"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?a \\<le> ?i; ?i < length (?a @ ?b)\\<rbrakk>\n  \\<Longrightarrow> (?a @ ?b) ! ?i \\<in> set ?b\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i\n    \\<in> set (map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                [dim_vec b..<dim_vec (b @\\<^sub>v c)])", "by (metis (no_types, lifting) igeq *  length_upt minus_nat.diff_0)"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n  \\<in> set (map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n              [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n  \\<in> set (map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n              [dim_vec b..<dim_vec (b @\\<^sub>v c)])", "have \"?L!i = [EQ  (lst!i) ((b@\\<^sub>vc)$i). i <- [dim_vec b..< dim_vec (b@\\<^sub>vc)]]!(i-dim_vec b)\""], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n  \\<in> set (map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n              [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i =\n    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n     [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n    (i - dim_vec b)", "by (metis (no_types, lifting) \\<open>dim_vec b \\<le> i\\<close> diff_zero leD \n            length_map length_upt nth_append)"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b)", "have \"?L!i = EQ (lst!i) ((b@\\<^sub>vc)$i)\""], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b)\n\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i =\n    EQ (lst ! i) ((b @\\<^sub>v c) $ i)", "using add_diff_inverse_nat diff_less_mono"], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n   [dim_vec b..<dim_vec (b @\\<^sub>v c)] !\n  (i - dim_vec b)\n  \\<not> ?m < ?n \\<Longrightarrow> ?n + (?m - ?n) = ?m\n  \\<lbrakk>?a < ?b; ?c \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a - ?c < ?b - ?c\n\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n     map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n      [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n    i =\n    EQ (lst ! i) ((b @\\<^sub>v c) $ i)", "by (metis (no_types, lifting) \\<open>dim_vec b \\<le> i\\<close> * ldimbc  leD nth_map_upt)"], ["proof (state)\nthis:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  EQ (lst ! i) ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  EQ (lst ! i) ((b @\\<^sub>v c) $ i)", "have e: \"e = EQ (lst!i) ((b@\\<^sub>vc)$i)\""], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  EQ (lst ! i) ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. e = EQ (lst ! i) ((b @\\<^sub>v c) $ i)", "using i(1)"], ["proof (prove)\nusing this:\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i =\n  EQ (lst ! i) ((b @\\<^sub>v c) $ i)\n  e =\n  (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n   map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n    [dim_vec b..<dim_vec (b @\\<^sub>v c)]) !\n  i\n\ngoal (1 subgoal):\n 1. e = EQ (lst ! i) ((b @\\<^sub>v c) $ i)", "by blast"], ["proof (state)\nthis:\n  e = EQ (lst ! i) ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "with mat_leqb_eqc_for_EQ[of b i c A, OF igeq]"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < dim_vec (b @\\<^sub>v c); dim_row A = dim_vec b;\n   dim_vec c \\<le> dim_col A\\<rbrakk>\n  \\<Longrightarrow> mat_leqb_eqc A b c ! i =\n                    EQ (vec_to_lpoly\n                         (0\\<^sub>v (dim_col A) @\\<^sub>v\n                          row A\\<^sup>T (i - dim_vec b)))\n                     (c $ (i - dim_vec b))\n  e = EQ (lst ! i) ((b @\\<^sub>v c) $ i)", "have lsta: \"(lst!i) = (vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < dim_vec (b @\\<^sub>v c); dim_row A = dim_vec b;\n   dim_vec c \\<le> dim_col A\\<rbrakk>\n  \\<Longrightarrow> mat_leqb_eqc A b c ! i =\n                    EQ (vec_to_lpoly\n                         (0\\<^sub>v (dim_col A) @\\<^sub>v\n                          row A\\<^sup>T (i - dim_vec b)))\n                     (c $ (i - dim_vec b))\n  e = EQ (lst ! i) ((b @\\<^sub>v c) $ i)\n\ngoal (1 subgoal):\n 1. lst ! i =\n    vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))", "by (metis (no_types, lifting) \\<open>dim_vec b = dim_row A\\<close> * ldimbc assms(2) igeq \n            index_append_vec(2) lst matrix_to_lpolies_vec_of_row vec_times_mat_eq_def\n            two_block_non_interfering_dims(1) two_block_non_interfering_row_comp2 )"], ["proof (state)\nthis:\n  lst ! i =\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "let ?p = \"(vec_to_lpoly (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"dim_poly ?p \\<le> dim_col A + dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_poly\n     (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n    \\<le> dim_col A + dim_row A", "using dim_poly_of_append_vec[of \"0\\<^sub>v (dim_col A)\" \"row A\\<^sup>T (i - dim_vec b)\"]\n          index_zero_vec(2)[of \"dim_col A\"]"], ["proof (prove)\nusing this:\n  dim_poly\n   (vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n  \\<le> dim_vec (0\\<^sub>v (dim_col A)) +\n        dim_vec (row A\\<^sup>T (i - dim_vec b))\n  dim_vec (0\\<^sub>v (dim_col A)) = dim_col A\n\ngoal (1 subgoal):\n 1. dim_poly\n     (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n    \\<le> dim_col A + dim_row A", "by (metis \\<open>dim_vec (0\\<^sub>v (dim_col A)) = dim_col A\\<close> index_row(2) index_transpose_mat(3))"], ["proof (state)\nthis:\n  dim_poly\n   (vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n  \\<le> dim_col A + dim_row A\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"\\<forall>i < dim_col A. Abstract_Linear_Poly.coeff ?p i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia<dim_col A.\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly\n          (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n        ia =\n       0", "using vec_coeff_append1[of _ \"0\\<^sub>v (dim_col A)\" \"row A\\<^sup>T (i - dim_vec b)\"]"], ["proof (prove)\nusing this:\n  ?i \\<in> {0..<dim_vec (0\\<^sub>v (dim_col A))} \\<Longrightarrow>\n  Abstract_Linear_Poly.coeff\n   (vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n   ?i =\n  0\\<^sub>v (dim_col A) $ ?i\n\ngoal (1 subgoal):\n 1. \\<forall>ia<dim_col A.\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly\n          (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n        ia =\n       0", "by (metis atLeastLessThan_iff index_zero_vec(1) index_zero_vec(2) zero_le)"], ["proof (state)\nthis:\n  \\<forall>ia<dim_col A.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      ia =\n     0\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  \\<forall>ia<dim_col A.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      ia =\n     0", "have \"dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)) = dim_col A + dim_row A\""], ["proof (prove)\nusing this:\n  \\<forall>ia<dim_col A.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      ia =\n     0\n\ngoal (1 subgoal):\n 1. dim_vec\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)) =\n    dim_col A + dim_row A", "by (metis index_append_vec(2) index_row(2) index_transpose_mat(3) index_zero_vec(2))"], ["proof (state)\nthis:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)) =\n  dim_col A + dim_row A\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "then"], ["proof (chain)\npicking this:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)) =\n  dim_col A + dim_row A", "have allcr: \"\\<forall>j\\<in>{0..<dim_row A}. Abstract_Linear_Poly.coeff ?p (j+dim_col A) = (row A\\<^sup>T (i - dim_vec b))$j\""], ["proof (prove)\nusing this:\n  dim_vec (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)) =\n  dim_col A + dim_row A\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{0..<dim_row A}.\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly\n          (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n        (j + dim_col A) =\n       row A\\<^sup>T (i - dim_vec b) $ j", "by (metis add_diff_cancel_right' atLeastLessThan_iff diff_add_inverse index_zero_vec(2) \n            le_add_same_cancel2 less_diff_conv vec_coeff_append2)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>{0..<dim_row A}.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      (j + dim_col A) =\n     row A\\<^sup>T (i - dim_vec b) $ j\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have vs: \"vars ?p \\<subseteq> {dim_col A..<dim_col A + dim_row A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n    \\<subseteq> {dim_col A..<dim_col A + dim_row A}", "using vars_vec_append_subset"], ["proof (prove)\nusing this:\n  vars (vec_to_lpoly (0\\<^sub>v ?n @\\<^sub>v ?v))\n  \\<subseteq> {?n..<?n + dim_vec ?v}\n\ngoal (1 subgoal):\n 1. vars\n     (vec_to_lpoly\n       (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n    \\<subseteq> {dim_col A..<dim_col A + dim_row A}", "by (metis index_row(2) index_transpose_mat(3))"], ["proof (state)\nthis:\n  vars\n   (vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n  \\<subseteq> {dim_col A..<dim_col A + dim_row A}\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"?p \\<lbrace> v \\<rbrace> = (\\<Sum>j\\<in>vars ?p. Abstract_Linear_Poly.coeff ?p j * v j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v\n      row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n    (\\<Sum>j\\<in>vars\n                  (vec_to_lpoly\n                    (0\\<^sub>v (dim_col A) @\\<^sub>v\n                     row A\\<^sup>T (i - dim_vec b))).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly\n          (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n        j *\n       v j)", "using eval_poly_with_sum"], ["proof (prove)\nusing this:\n  ?v \\<lbrace> ?X \\<rbrace> =\n  (\\<Sum>x\\<in>vars ?v. Abstract_Linear_Poly.coeff ?v x * ?X x)\n\ngoal (1 subgoal):\n 1. vec_to_lpoly\n     (0\\<^sub>v (dim_col A) @\\<^sub>v\n      row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n    (\\<Sum>j\\<in>vars\n                  (vec_to_lpoly\n                    (0\\<^sub>v (dim_col A) @\\<^sub>v\n                     row A\\<^sup>T (i - dim_vec b))).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly\n          (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n        j *\n       v j)", "by blast"], ["proof (state)\nthis:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v\n    row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n  (\\<Sum>j\\<in>vars\n                (vec_to_lpoly\n                  (0\\<^sub>v (dim_col A) @\\<^sub>v\n                   row A\\<^sup>T (i - dim_vec b))).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      j *\n     v j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v\n    row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n  (\\<Sum>j\\<in>vars\n                (vec_to_lpoly\n                  (0\\<^sub>v (dim_col A) @\\<^sub>v\n                   row A\\<^sup>T (i - dim_vec b))).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      j *\n     v j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{dim_col A..<dim_col A + dim_row A}. Abstract_Linear_Poly.coeff ?p j * v j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>vars\n                  (vec_to_lpoly\n                    (0\\<^sub>v (dim_col A) @\\<^sub>v\n                     row A\\<^sup>T (i - dim_vec b))).\n       Abstract_Linear_Poly.coeff\n        (vec_to_lpoly\n          (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n        j *\n       v j) =\n    (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         j *\n        v j)", "by (metis (mono_tags, lifting) DiffD2 vs coeff_zero finite_atLeastLessThan\n            mult_not_zero sum.mono_neutral_left)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>vars\n                (vec_to_lpoly\n                  (0\\<^sub>v (dim_col A) @\\<^sub>v\n                   row A\\<^sup>T (i - dim_vec b))).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      j *\n     v j) =\n  (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       j *\n      v j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>vars\n                (vec_to_lpoly\n                  (0\\<^sub>v (dim_col A) @\\<^sub>v\n                   row A\\<^sup>T (i - dim_vec b))).\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      j *\n     v j) =\n  (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       j *\n      v j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{0..<dim_row A}. Abstract_Linear_Poly.coeff ?p (j+dim_col A) * v (j+dim_col A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         j *\n        v j) =\n    (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        v (j + dim_col A))", "using sum.shift_bounds_nat_ivl[of \"\\<lambda>j. Abstract_Linear_Poly.coeff ?p j * v j\" 0 \"dim_col A\" \"dim_row A\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0 + dim_col A..<dim_row A + dim_col A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       j *\n      v j) =\n  (\\<Sum>ia = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (ia + dim_col A) *\n      v (ia + dim_col A))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         j *\n        v j) =\n    (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        v (j + dim_col A))", "by (metis (no_types, lifting) add.commute add_cancel_left_left)"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       j *\n      v j) =\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      v (j + dim_col A))\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = dim_col A..<dim_col A + dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       j *\n      v j) =\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      v (j + dim_col A))\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{0..<dim_row A}. Abstract_Linear_Poly.coeff ?p (j+dim_col A) * y$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        v (j + dim_col A)) =\n    (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        y $ j)", "using v i_in yr"], ["proof (prove)\nusing this:\n  v =\n  (\\<lambda>i.\n      if i < dim_vec (x @\\<^sub>v y) then (x @\\<^sub>v y) $ i else 0)\n  \\<forall>i\\<in>{0..<dim_vec y}. y $ i = v (i + dim_vec x)\n  dim_vec y = dim_row A\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        v (j + dim_col A)) =\n    (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        y $ j)", "by (metis (no_types, lifting) sum.cong x_A)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      v (j + dim_col A)) =\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      y $ j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      v (j + dim_col A)) =\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      y $ j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (\\<Sum>j\\<in>{0..<dim_row A}. (row A\\<^sup>T (i - dim_vec b))$j * y$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        y $ j) =\n    (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j)", "using allcr"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>{0..<dim_row A}.\n     Abstract_Linear_Poly.coeff\n      (vec_to_lpoly\n        (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n      (j + dim_col A) =\n     row A\\<^sup>T (i - dim_vec b) $ j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_row A.\n        Abstract_Linear_Poly.coeff\n         (vec_to_lpoly\n           (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n         (j + dim_col A) *\n        y $ j) =\n    (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j)", "by (metis (no_types, lifting) sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      y $ j) =\n  (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_row A.\n      Abstract_Linear_Poly.coeff\n       (vec_to_lpoly\n         (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b)))\n       (j + dim_col A) *\n      y $ j) =\n  (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j)\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (row A\\<^sup>T (i - dim_vec b)) \\<bullet> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j) =\n    row A\\<^sup>T (i - dim_vec b) \\<bullet> y", "by (metis \\<open>dim_vec y = dim_row A\\<close> scalar_prod_def)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j) =\n  row A\\<^sup>T (i - dim_vec b) \\<bullet> y\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_row A. row A\\<^sup>T (i - dim_vec b) $ j * y $ j) =\n  row A\\<^sup>T (i - dim_vec b) \\<bullet> y\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "have \"... = (b@\\<^sub>vc)$i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A\\<^sup>T (i - dim_vec b) \\<bullet> y = (b @\\<^sub>v c) $ i", "using vec_times_mat_eqD[OF x(2)] * igeq"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_vec c. (A\\<^sup>T *\\<^sub>v y) $ i = c $ i\n  dim_col A\\<^sup>T = dim_vec y\n  dim_row A\\<^sup>T = dim_vec c\n  i < length\n       (map (\\<lambda>i. LEQ (lst ! i) (b $ i)) [0..<dim_vec b] @\n        map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n         [dim_vec b..<dim_vec (b @\\<^sub>v c)])\n  dim_vec b \\<le> i\n\ngoal (1 subgoal):\n 1. row A\\<^sup>T (i - dim_vec b) \\<bullet> y = (b @\\<^sub>v c) $ i", "by auto"], ["proof (state)\nthis:\n  row A\\<^sup>T (i - dim_vec b) \\<bullet> y = (b @\\<^sub>v c) $ i\n\ngoal (1 subgoal):\n 1. i \\<in> {dim_vec\n              b..<length\n                   (map (\\<lambda>i. LEQ (lst ! i) (b $ i))\n                     [0..<dim_vec b] @\n                    map (\\<lambda>i. EQ (lst ! i) ((b @\\<^sub>v c) $ i))\n                     [dim_vec b..<\n                      dim_vec (b @\\<^sub>v c)])} \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>c e", "finally"], ["proof (chain)\npicking this:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v\n    row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n  (b @\\<^sub>v c) $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v\n    row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n  (b @\\<^sub>v c) $ i\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c e", "using e lsta satisfies_constraint.simps(5)[of _ \"(lst ! i)\" \"((b @\\<^sub>v c) $ i)\"]"], ["proof (prove)\nusing this:\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v\n    row A\\<^sup>T (i - dim_vec b)) \\<lbrace> v \\<rbrace> =\n  (b @\\<^sub>v c) $ i\n  e = EQ (lst ! i) ((b @\\<^sub>v c) $ i)\n  lst ! i =\n  vec_to_lpoly\n   (0\\<^sub>v (dim_col A) @\\<^sub>v row A\\<^sup>T (i - dim_vec b))\n  ?v \\<Turnstile>\\<^sub>c EQ (lst ! i) ((b @\\<^sub>v c) $ i) =\n  (lst ! i \\<lbrace> ?v \\<rbrace> = (b @\\<^sub>v c) $ i *R (1::?'a))\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c e", "by simp"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. \\<nexists>X. simplex (mat_leqb_eqc A b c) = Inr X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)", "show False"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s set (mat_leqb_eqc A b c)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sound_and_compltete_mat_leqb_eqc [iff]:  \n  assumes \"dim_row A\\<^sup>T = dim_vec c\"\n  assumes \"dim_col A\\<^sup>T = dim_vec b\"\n  shows \"(\\<exists>x. [A *\\<^sub>v x]\\<le>b) \\<and> (\\<exists>y. [y \\<^sub>v* A]=c) \\<longleftrightarrow> (\\<exists>X. simplex (mat_leqb_eqc A b c) = Sat X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>x. [A*\\<^sub>vx]\\<le>b) \\<and>\n     (\\<exists>y. [y\\<^sub>v*A]=c)) =\n    (\\<exists>X. simplex (mat_leqb_eqc A b c) = Inr X)", "by (metis assms(1) assms(2) completeness_mat_leqb_eqc index_transpose_mat(3) \n      soundness_mat_leqb_eqc1 soundness_mat_leqb_eqc2)"], ["", "section \\<open> Translate Inequalities to Matrix Form \\<close>"], ["", "(* We (obviously) cannot use strict inequalities hence we use the option type *)"], ["", "fun nonstrict_constr where \n  \"nonstrict_constr (LEQ p r) = True\" |\n  \"nonstrict_constr (GEQ p r) = True\" |\n  \"nonstrict_constr (EQ p r) = True\" |\n  \"nonstrict_constr (LEQPP p q) = True\" |\n  \"nonstrict_constr (GEQPP p q) = True\" |\n  \"nonstrict_constr (EQPP p q) = True\" |\n  \"nonstrict_constr _ = False\""], ["", "abbreviation \"nonstrict_constrs cs \\<equiv> (\\<forall>a \\<in> set cs. nonstrict_constr a)\""], ["", "fun transf_constraint where\n  \"transf_constraint (LEQ p r) = [LEQ p r]\" |\n  \"transf_constraint (GEQ p r) = [LEQ (-p) (-r)]\" |\n  \"transf_constraint (EQ p r) = [LEQ p r, LEQ (-p) (-r)]\" |\n  \"transf_constraint (LEQPP p q) = [LEQ (p - q) 0]\" |\n  \"transf_constraint (GEQPP p q) = [LEQ (-(p - q)) 0]\" |\n  \"transf_constraint (EQPP p q) = [LEQ (p - q) 0, LEQ (-(p - q)) 0]\" |\n  \"transf_constraint _ = []\""], ["", "fun transf_constraints where\n\"transf_constraints [] = []\" |\n\"transf_constraints (x#xs) = transf_constraint x @ (transf_constraints xs)\""], ["", "lemma trans_constraint_creats_LEQ_only:\n  assumes \"transf_constraint x \\<noteq> []\"\n  shows \"(\\<forall>x \\<in> set (transf_constraint x). \\<exists>a b. x = LEQ a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (transf_constraint x). \\<exists>a b. x = LEQ a b", "using assms"], ["proof (prove)\nusing this:\n  transf_constraint x \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (transf_constraint x). \\<exists>a b. x = LEQ a b", "by (cases x, auto+)"], ["", "lemma trans_constraints_creats_LEQ_only:\n  assumes \"transf_constraints xs \\<noteq> []\"\n  assumes \"x \\<in> set (transf_constraints xs)\"\n  shows \"\\<exists>p r. LEQ p r = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p r. LEQ p r = x", "using assms"], ["proof (prove)\nusing this:\n  transf_constraints xs \\<noteq> []\n  x \\<in> set (transf_constraints xs)\n\ngoal (1 subgoal):\n 1. \\<exists>p r. LEQ p r = x", "apply(induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>transf_constraints [] \\<noteq> [];\n     x \\<in> set (transf_constraints [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p r. LEQ p r = x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>transf_constraints xs \\<noteq> [];\n                 x \\<in> set (transf_constraints xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>p r. LEQ p r = x;\n        transf_constraints (a # xs) \\<noteq> [];\n        x \\<in> set (transf_constraints (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x", "using trans_constraint_creats_LEQ_only"], ["proof (prove)\nusing this:\n  transf_constraint ?x \\<noteq> [] \\<Longrightarrow>\n  \\<forall>x\\<in>set (transf_constraint ?x). \\<exists>a b. x = LEQ a b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>transf_constraints [] \\<noteq> [];\n     x \\<in> set (transf_constraints [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p r. LEQ p r = x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>transf_constraints xs \\<noteq> [];\n                 x \\<in> set (transf_constraints xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>p r. LEQ p r = x;\n        transf_constraints (a # xs) \\<noteq> [];\n        x \\<in> set (transf_constraints (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x", "apply(auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>transf_constraints xs \\<noteq> [];\n                 x \\<in> set (transf_constraints xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>p r. LEQ p r = x;\n        \\<And>x.\n           transf_constraint x \\<noteq> [] \\<Longrightarrow>\n           \\<forall>x\\<in>set (transf_constraint x).\n              \\<exists>a b. x = LEQ a b;\n        x \\<in> set (transf_constraint a);\n        transf_constraint a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x\n 2. \\<And>a xs.\n       \\<lbrakk>x \\<in> set (transf_constraints xs) \\<Longrightarrow>\n                \\<exists>p r. LEQ p r = x;\n        \\<And>x.\n           transf_constraint x \\<noteq> [] \\<Longrightarrow>\n           \\<forall>x\\<in>set (transf_constraint x).\n              \\<exists>a b. x = LEQ a b;\n        x \\<in> set (transf_constraint a);\n        transf_constraints xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x\n 3. \\<And>a xs.\n       \\<lbrakk>transf_constraints xs \\<noteq> [] \\<Longrightarrow>\n                \\<exists>p r. LEQ p r = x;\n        \\<And>x.\n           transf_constraint x \\<noteq> [] \\<Longrightarrow>\n           \\<forall>x\\<in>set (transf_constraint x).\n              \\<exists>a b. x = LEQ a b;\n        x \\<in> set (transf_constraints xs);\n        transf_constraint a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>x \\<in> set (transf_constraints xs) \\<Longrightarrow>\n                \\<exists>p r. LEQ p r = x;\n        \\<And>x.\n           transf_constraint x \\<noteq> [] \\<Longrightarrow>\n           \\<forall>x\\<in>set (transf_constraint x).\n              \\<exists>a b. x = LEQ a b;\n        x \\<in> set (transf_constraint a);\n        transf_constraints xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x\n 2. \\<And>a xs.\n       \\<lbrakk>transf_constraints xs \\<noteq> [] \\<Longrightarrow>\n                \\<exists>p r. LEQ p r = x;\n        \\<And>x.\n           transf_constraint x \\<noteq> [] \\<Longrightarrow>\n           \\<forall>x\\<in>set (transf_constraint x).\n              \\<exists>a b. x = LEQ a b;\n        x \\<in> set (transf_constraints xs);\n        transf_constraint a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x", "apply (metis in_set_simps(3) trans_constraint_creats_LEQ_only)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>transf_constraints xs \\<noteq> [] \\<Longrightarrow>\n                \\<exists>p r. LEQ p r = x;\n        \\<And>x.\n           transf_constraint x \\<noteq> [] \\<Longrightarrow>\n           \\<forall>x\\<in>set (transf_constraint x).\n              \\<exists>a b. x = LEQ a b;\n        x \\<in> set (transf_constraints xs);\n        transf_constraint a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p r. LEQ p r = x", "by fastforce"], ["", "lemma non_strict_constr_no_LT: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. LT a b = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. LT a b = x", "using assms nonstrict_constr.simps(7)"], ["proof (prove)\nusing this:\n  nonstrict_constrs cs\n  nonstrict_constr (LT ?v ?va) = False\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. LT a b = x", "by blast"], ["", "lemma non_strict_constr_no_GT: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. GT a b = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. GT a b = x", "using assms nonstrict_constr.simps(8)"], ["proof (prove)\nusing this:\n  nonstrict_constrs cs\n  nonstrict_constr (GT ?v ?va) = False\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. GT a b = x", "by blast"], ["", "lemma non_strict_constr_no_LTPP: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. LTPP a b = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. LTPP a b = x", "using assms nonstrict_constr.simps(9)"], ["proof (prove)\nusing this:\n  nonstrict_constrs cs\n  nonstrict_constr (LTPP ?v ?va) = False\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. LTPP a b = x", "by blast"], ["", "lemma non_strict_constr_no_GTPP: \n  assumes \"nonstrict_constrs cs\"\n  shows \"\\<forall>x \\<in> set cs. \\<not>(\\<exists>a b. GTPP a b = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. GTPP a b = x", "using assms nonstrict_constr.simps(10)"], ["proof (prove)\nusing this:\n  nonstrict_constrs cs\n  nonstrict_constr (GTPP ?v ?va) = False\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs. \\<nexists>a b. GTPP a b = x", "by blast"], ["", "lemma non_strict_consts_cond:\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. LT a b = x)\"\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. GT a b = x)\"\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. LTPP a b = x)\"\n  assumes \"\\<And>x. x \\<in> set cs \\<Longrightarrow> \\<not>(\\<exists>a b. GTPP a b = x)\"\n  shows \"nonstrict_constrs cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonstrict_constrs cs", "by (metis assms(1) assms(2) assms(3) assms(4) nonstrict_constr.elims(3))"], ["", "lemma sat_constr_sat_transf_constrs:\n  assumes \"v \\<Turnstile>\\<^sub>c cs\" \n  shows \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)", "using assms"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c cs\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)", "by (cases cs) (simp add: valuate_uminus valuate_minus)+"], ["", "lemma sat_constrs_sat_transf_constrs:\n  assumes \"v \\<Turnstile>\\<^sub>c\\<^sub>s set cs\" \n  shows \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)", "using assms"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set cs\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)", "by(induction cs, simp) (metis UnE list.set_intros(1) \n      list.set_intros(2) sat_constr_sat_transf_constrs set_append transf_constraints.simps(2))"], ["", "lemma sat_transf_constrs_sat_constr: \n  assumes \"nonstrict_constr cs\"\n  assumes \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)\"\n  shows \"v \\<Turnstile>\\<^sub>c cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c cs", "using assms"], ["proof (prove)\nusing this:\n  nonstrict_constr cs\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraint cs)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c cs", "by (cases cs) (simp add: valuate_uminus valuate_minus)+"], ["", "lemma sat_transf_constrs_sat_constrs:\n  assumes \"nonstrict_constrs cs\"\n  assumes \"v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)\"\n  shows \"v \\<Turnstile>\\<^sub>c\\<^sub>s set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set cs", "using assms"], ["proof (prove)\nusing this:\n  nonstrict_constrs cs\n  v \\<Turnstile>\\<^sub>c\\<^sub>s set (transf_constraints cs)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s set cs", "by (induction cs, auto) (simp add: sat_transf_constrs_sat_constr)"], ["", "end"]]}