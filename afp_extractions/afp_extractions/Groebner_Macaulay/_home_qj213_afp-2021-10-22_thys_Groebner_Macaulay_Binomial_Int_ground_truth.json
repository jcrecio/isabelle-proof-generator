{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay/Binomial_Int.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay", "problem_names": ["lemma upper_le_binomial:\n  assumes \"0 < k\" and \"k < n\"\n  shows \"n \\<le> n choose k\"", "lemma gbinomial_0_left: \"0 gchoose k = (if k = 0 then 1 else 0)\"", "lemma gbinomial_eq_0_int:\n  assumes \"n < k\"\n  shows \"(int n) gchoose k = 0\"", "lemma int_binomial: \"int (n choose k) = (int n) gchoose k\"", "lemma falling_fact_pochhammer: \"prod (\\<lambda>i. a - int i) {0..<k} = (- 1) ^ k * pochhammer (- a) k\"", "lemma falling_fact_pochhammer': \"prod (\\<lambda>i. a - int i) {0..<k} = pochhammer (a - int k + 1) k\"", "lemma gbinomial_int_pochhammer: \"(a::int) gchoose k = (- 1) ^ k * pochhammer (- a) k div fact k\"", "lemma gbinomial_int_pochhammer': \"a gchoose k = pochhammer (a - int k + 1) k div fact k\"", "lemma fact_dvd_pochhammer: \"fact k dvd pochhammer (a::int) k\"", "lemma gbinomial_int_negated_upper: \"(a gchoose k) = (-1) ^ k * ((int k - a - 1) gchoose k)\"", "lemma gbinomial_int_mult_fact: \"fact k * (a gchoose k) = (\\<Prod>i = 0..<k. a - int i)\"", "lemma gbinomial_int_binomial:\n  \"a gchoose k = (if 0 \\<le> a then int ((nat a) choose k) else (-1::int)^k * int ((k + (nat (- a)) - 1) choose k))\"", "lemma of_int_gbinomial: \"of_int (a gchoose k) = (of_int a :: 'a::field_char_0) gchoose k\"", "lemma uminus_one_gbinomial [simp]: \"(- 1::int) gchoose k = (- 1) ^ k\"", "lemma gbinomial_int_Suc_Suc: \"(x + 1::int) gchoose (Suc k) = (x gchoose k) + (x gchoose (Suc k))\"", "lemma gbinomial_int_n_n [simp]: \"(int n) gchoose n = 1\"", "lemma gbinomial_int_Suc_n [simp]: \"(1 + int n) gchoose n = 1 + int n\"", "lemma zbinomial_eq_0_iff [simp]: \"a gchoose k = 0 \\<longleftrightarrow> (0 \\<le> a \\<and> a < int k)\"", "lemma gchoose_rising_sum_nat: \"(\\<Sum>j\\<le>n. int j + int k gchoose k) = (int n + int k + 1) gchoose (Suc k)\"", "lemma gchoose_rising_sum:\n  assumes \"0 \\<le> n\"   \\<comment>\\<open>Necessary condition.\\<close>\n  shows \"(\\<Sum>j=0..n. j + int k gchoose k) = (n + int k + 1) gchoose (Suc k)\"", "lemma binomial_mono:\n  assumes \"m \\<le> n\"\n  shows \"m choose k \\<le> n choose k\"", "lemma binomial_plus_le:\n  assumes \"0 < k\"\n  shows \"(m choose k) + (n choose k) \\<le> (m + n) choose k\"", "lemma binomial_ineq_1: \"2 * ((n + i) choose k) \\<le> n choose k + ((n + 2 * i) choose k)\"", "lemma gbinomial_int_nonneg:\n  assumes \"0 \\<le> (x::int)\"\n  shows \"0 \\<le> x gchoose k\"", "lemma gbinomial_int_mono:\n  assumes \"0 \\<le> x\" and \"x \\<le> (y::int)\"\n  shows \"x gchoose k \\<le> y gchoose k\"", "lemma gbinomial_int_plus_le:\n  assumes \"0 < k\" and \"0 \\<le> x\" and \"0 \\<le> (y::int)\"\n  shows \"(x gchoose k) + (y gchoose k) \\<le> (x + y) gchoose k\"", "lemma binomial_int_ineq_1:\n  assumes \"0 \\<le> x\" and \"0 \\<le> (y::int)\"\n  shows \"2 * (x + y gchoose k) \\<le> x gchoose k + ((x + 2 * y) gchoose k)\"", "lemma bw_diff_const [simp]: \"bw_diff (\\<lambda>_. c) = (\\<lambda>_. 0)\"", "lemma bw_diff_id [simp]: \"bw_diff (\\<lambda>x. x) = (\\<lambda>_. 1)\"", "lemma bw_diff_plus [simp]: \"bw_diff (\\<lambda>x. f x + g x) = (\\<lambda>x. bw_diff f x + bw_diff g x)\"", "lemma bw_diff_uminus [simp]: \"bw_diff (\\<lambda>x. - f x) = (\\<lambda>x. - bw_diff f x)\"", "lemma bw_diff_minus [simp]: \"bw_diff (\\<lambda>x. f x - g x) = (\\<lambda>x. bw_diff f x - bw_diff g x)\"", "lemma bw_diff_const_pow: \"(bw_diff ^^ k) (\\<lambda>_. c) = (if k = 0 then \\<lambda>_. c else (\\<lambda>_. 0))\"", "lemma bw_diff_id_pow:\n  \"(bw_diff ^^ k) (\\<lambda>x. x) = (if k = 0 then (\\<lambda>x. x) else if k = 1 then (\\<lambda>_. 1) else (\\<lambda>_. 0))\"", "lemma bw_diff_plus_pow [simp]:\n  \"(bw_diff ^^ k) (\\<lambda>x. f x + g x) = (\\<lambda>x. (bw_diff ^^ k) f x + (bw_diff ^^ k) g x)\"", "lemma bw_diff_uminus_pow [simp]: \"(bw_diff ^^ k) (\\<lambda>x. - f x) = (\\<lambda>x. - (bw_diff ^^ k) f x)\"", "lemma bw_diff_minus_pow [simp]:\n  \"(bw_diff ^^ k) (\\<lambda>x. f x - g x) = (\\<lambda>x. (bw_diff ^^ k) f x - (bw_diff ^^ k) g x)\"", "lemma bw_diff_sum_pow [simp]:\n  \"(bw_diff ^^ k) (\\<lambda>x. (\\<Sum>i\\<in>I. f i x)) = (\\<lambda>x. (\\<Sum>i\\<in>I. (bw_diff ^^ k) (f i) x))\"", "lemma bw_diff_gbinomial:\n  assumes \"0 < k\"\n  shows \"bw_diff (\\<lambda>x::int. (x + n) gchoose k) = (\\<lambda>x. (x + n - 1) gchoose (k - 1))\"", "lemma bw_diff_gbinomial_pow:\n  \"(bw_diff ^^ l) (\\<lambda>x::int. (x + n) gchoose k) =\n      (if l \\<le> k then (\\<lambda>x. (x + n - int l) gchoose (k - l)) else (\\<lambda>_. 0))\""], "translations": [["", "lemma upper_le_binomial:\n  assumes \"0 < k\" and \"k < n\"\n  shows \"n \\<le> n choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "from assms"], ["proof (chain)\npicking this:\n  0 < k\n  k < n", "have \"1 \\<le> n\""], ["proof (prove)\nusing this:\n  0 < k\n  k < n\n\ngoal (1 subgoal):\n 1. 1 \\<le> n", "by simp"], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "define k' where \"k' = (if n div 2 \\<le> k then k else n - k)\""], ["proof (state)\nthis:\n  k' = (if n div 2 \\<le> k then k else n - k)\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "from assms"], ["proof (chain)\npicking this:\n  0 < k\n  k < n", "have 1: \"k' \\<le> n - 1\" and 2: \"n div 2 \\<le> k'\""], ["proof (prove)\nusing this:\n  0 < k\n  k < n\n\ngoal (1 subgoal):\n 1. k' \\<le> n - 1 &&& n div 2 \\<le> k'", "by (auto simp: k'_def)"], ["proof (state)\nthis:\n  k' \\<le> n - 1\n  n div 2 \\<le> k'\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "from assms(2)"], ["proof (chain)\npicking this:\n  k < n", "have \"k \\<le> n\""], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. k \\<le> n", "by simp"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "have \"n choose k = n choose k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n choose k = n choose k'", "by (simp add: k'_def binomial_symmetric[OF \\<open>k \\<le> n\\<close>])"], ["proof (state)\nthis:\n  n choose k = n choose k'\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "have \"n = n choose 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n choose 1", "by (simp only: choose_one)"], ["proof (state)\nthis:\n  n = n choose 1\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "also"], ["proof (state)\nthis:\n  n = n choose 1\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "from \\<open>1 \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> n", "have \"\\<dots> = n choose (n - 1)\""], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. n choose 1 = n choose (n - 1)", "by (rule binomial_symmetric)"], ["proof (state)\nthis:\n  n choose 1 = n choose (n - 1)\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "also"], ["proof (state)\nthis:\n  n choose 1 = n choose (n - 1)\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "from 1 2"], ["proof (chain)\npicking this:\n  k' \\<le> n - 1\n  n div 2 \\<le> k'", "have \"\\<dots> \\<le> n choose k'\""], ["proof (prove)\nusing this:\n  k' \\<le> n - 1\n  n div 2 \\<le> k'\n\ngoal (1 subgoal):\n 1. n choose (n - 1) \\<le> n choose k'", "by (rule binomial_antimono) simp"], ["proof (state)\nthis:\n  n choose (n - 1) \\<le> n choose k'\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "also"], ["proof (state)\nthis:\n  n choose (n - 1) \\<le> n choose k'\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "have \"\\<dots> = n choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n choose k' = n choose k", "by (simp add: k'_def binomial_symmetric[OF \\<open>k \\<le> n\\<close>])"], ["proof (state)\nthis:\n  n choose k' = n choose k\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "finally"], ["proof (chain)\npicking this:\n  n \\<le> n choose k", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> n choose k\n\ngoal (1 subgoal):\n 1. n \\<le> n choose k", "."], ["proof (state)\nthis:\n  n \\<le> n choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Restore original sort constraints:\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (@{const_name gbinomial}, SOME @{typ \"'a::{semidom_divide,semiring_char_0} \\<Rightarrow> nat \\<Rightarrow> 'a\"})\\<close>"], ["", "lemma gbinomial_0_left: \"0 gchoose k = (if k = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) gchoose k = (if k = 0 then 1::'a else (0::'a))", "by (cases k) simp_all"], ["", "lemma gbinomial_eq_0_int:\n  assumes \"n < k\"\n  shows \"(int n) gchoose k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n gchoose k = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int n gchoose k = 0", "have \"\\<exists>a\\<in>{0..<k}. int n - int a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>{0..<k}. int n - int a = 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. int n - int ?a = 0\n 2. ?a \\<in> {0..<k}", "show \"int n - int n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n - int n = 0", "by simp"], ["proof (state)\nthis:\n  int n - int n = 0\n\ngoal (1 subgoal):\n 1. n \\<in> {0..<k}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> {0..<k}", "from assms"], ["proof (chain)\npicking this:\n  n < k", "show \"n \\<in> {0..<k}\""], ["proof (prove)\nusing this:\n  n < k\n\ngoal (1 subgoal):\n 1. n \\<in> {0..<k}", "by simp"], ["proof (state)\nthis:\n  n \\<in> {0..<k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>{0..<k}. int n - int a = 0\n\ngoal (1 subgoal):\n 1. int n gchoose k = 0", "with finite_atLeastLessThan"], ["proof (chain)\npicking this:\n  finite {?l..<?u}\n  \\<exists>a\\<in>{0..<k}. int n - int a = 0", "have eq: \"prod (\\<lambda>i. int n - int i) {0..<k} = 0\""], ["proof (prove)\nusing this:\n  finite {?l..<?u}\n  \\<exists>a\\<in>{0..<k}. int n - int a = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. int n - int i) = 0", "by (rule prod_zero)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<k. int n - int i) = 0\n\ngoal (1 subgoal):\n 1. int n gchoose k = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int n gchoose k = 0", "by (simp add: gbinomial_prod_rev eq)"], ["proof (state)\nthis:\n  int n gchoose k = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary gbinomial_eq_0: \"0 \\<le> a \\<Longrightarrow> a < int k \\<Longrightarrow> a gchoose k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; a < int k\\<rbrakk> \\<Longrightarrow> a gchoose k = 0", "by (metis nat_eq_iff2 nat_less_iff gbinomial_eq_0_int)"], ["", "lemma int_binomial: \"int (n choose k) = (int n) gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n choose k) = int n gchoose k", "proof (cases \"k \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k\n 2. \\<not> k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k", "case True"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (2 subgoals):\n 1. k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k\n 2. \\<not> k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have eq: \"(\\<Prod>i = 0..<k. int (n - i)) = (\\<Prod>i = 0..<k. int n - int i)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. int (n - i)) = (\\<Prod>i = 0..<k. int n - int i)", "proof (rule prod.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..<k} \\<Longrightarrow> int (n - x) = int n - int x", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..<k} \\<Longrightarrow> int (n - x) = int n - int x", "assume \"i \\<in> {0..<k}\""], ["proof (state)\nthis:\n  i \\<in> {0..<k}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..<k} \\<Longrightarrow> int (n - x) = int n - int x", "with True"], ["proof (chain)\npicking this:\n  k \\<le> n\n  i \\<in> {0..<k}", "show \"int (n - i) = int n - int i\""], ["proof (prove)\nusing this:\n  k \\<le> n\n  i \\<in> {0..<k}\n\ngoal (1 subgoal):\n 1. int (n - i) = int n - int i", "by simp"], ["proof (state)\nthis:\n  int (n - i) = int n - int i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<k. int (n - i)) = (\\<Prod>i = 0..<k. int n - int i)\n\ngoal (2 subgoals):\n 1. k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k\n 2. \\<not> k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n choose k) = int n gchoose k", "by (simp add: gbinomial_binomial[symmetric] gbinomial_prod_rev zdiv_int eq)"], ["proof (state)\nthis:\n  int (n choose k) = int n gchoose k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> n \\<Longrightarrow> int (n choose k) = int n gchoose k", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> k \\<le> n\n\ngoal (1 subgoal):\n 1. int (n choose k) = int n gchoose k", "by (simp add: gbinomial_eq_0_int)"], ["proof (state)\nthis:\n  int (n choose k) = int n gchoose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma falling_fact_pochhammer: \"prod (\\<lambda>i. a - int i) {0..<k} = (- 1) ^ k * pochhammer (- a) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "have eq: \"z ^ Suc n * prod f {0..n} = prod (\\<lambda>x. z * f x) {0..n}\" for z::int and n f"], ["proof (prove)\ngoal (1 subgoal):\n 1. z ^ Suc n * prod f {0..n} = (\\<Prod>x = 0..n. z * f x)", "by (induct n) (simp_all add: ac_simps)"], ["proof (state)\nthis:\n  ?z ^ Suc ?n * prod ?f {0..?n} = (\\<Prod>x = 0..?n. ?z * ?f x)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "by (simp add: pochhammer_minus)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "case (Suc n)"], ["proof (state)\nthis:\n  k = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = Suc n\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k", "by (simp only: pochhammer_prod atLeastLessThanSuc_atLeastAtMost\n          prod.atLeast_Suc_atMost_Suc_shift eq flip: power_mult_distrib) (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<k. a - int i) = (- 1) ^ k * pochhammer (- a) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma falling_fact_pochhammer': \"prod (\\<lambda>i. a - int i) {0..<k} = pochhammer (a - int k + 1) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<k. a - int i) = pochhammer (a - int k + 1) k", "by (simp add: falling_fact_pochhammer pochhammer_minus')"], ["", "lemma gbinomial_int_pochhammer: \"(a::int) gchoose k = (- 1) ^ k * pochhammer (- a) k div fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a gchoose k = (- 1) ^ k * pochhammer (- a) k div fact k", "by (simp only: gbinomial_prod_rev falling_fact_pochhammer)"], ["", "lemma gbinomial_int_pochhammer': \"a gchoose k = pochhammer (a - int k + 1) k div fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a gchoose k = pochhammer (a - int k + 1) k div fact k", "by (simp only: gbinomial_prod_rev falling_fact_pochhammer')"], ["", "lemma fact_dvd_pochhammer: \"fact k dvd pochhammer (a::int) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact k dvd pochhammer a k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact k dvd pochhammer a k", "have dvd: \"y \\<noteq> 0 \\<Longrightarrow> ((of_int (x div y))::'a::field_char_0) = of_int x / of_int y \\<Longrightarrow> y dvd x\"\n    for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> 0; of_int (x div y) = of_int x / of_int y\\<rbrakk>\n    \\<Longrightarrow> y dvd x", "by (smt dvd_triv_left mult.commute nonzero_eq_divide_eq of_int_eq_0_iff of_int_eq_iff of_int_mult)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<noteq> 0;\n   of_int (?x div ?y) = of_int ?x / of_int ?y\\<rbrakk>\n  \\<Longrightarrow> ?y dvd ?x\n\ngoal (1 subgoal):\n 1. fact k dvd pochhammer a k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact k dvd pochhammer a k", "proof (cases \"0 < a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> fact k dvd pochhammer a k\n 2. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "case True"], ["proof (state)\nthis:\n  0 < a\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> fact k dvd pochhammer a k\n 2. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "moreover"], ["proof (state)\nthis:\n  0 < a\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> fact k dvd pochhammer a k\n 2. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "define n where \"n = nat (a - 1) + k\""], ["proof (state)\nthis:\n  n = nat (a - 1) + k\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> fact k dvd pochhammer a k\n 2. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "ultimately"], ["proof (chain)\npicking this:\n  0 < a\n  n = nat (a - 1) + k", "have a: \"a = int n - int k + 1\""], ["proof (prove)\nusing this:\n  0 < a\n  n = nat (a - 1) + k\n\ngoal (1 subgoal):\n 1. a = int n - int k + 1", "by simp"], ["proof (state)\nthis:\n  a = int n - int k + 1\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> fact k dvd pochhammer a k\n 2. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "from fact_nonzero"], ["proof (chain)\npicking this:\n  fact ?n \\<noteq> (0::?'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  fact ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. fact k dvd pochhammer a k", "unfolding a"], ["proof (prove)\nusing this:\n  fact ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. fact k dvd pochhammer (int n - int k + 1) k", "proof (rule dvd)"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"of_int (pochhammer (int n - int k + 1) k div fact k) = (of_int (int n gchoose k)::rat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n    rat_of_int (int n gchoose k)", "by (simp only: gbinomial_int_pochhammer')"], ["proof (state)\nthis:\n  rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n  rat_of_int (int n gchoose k)\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n  rat_of_int (int n gchoose k)\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"\\<dots> = of_int (int (n choose k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int n gchoose k) = rat_of_int (int (n choose k))", "by (simp only: int_binomial)"], ["proof (state)\nthis:\n  rat_of_int (int n gchoose k) = rat_of_int (int (n choose k))\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_int (int n gchoose k) = rat_of_int (int (n choose k))\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"\\<dots> = of_nat (n choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int (n choose k)) = rat_of_nat (n choose k)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (int (n choose k)) = rat_of_nat (n choose k)\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_int (int (n choose k)) = rat_of_nat (n choose k)\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"\\<dots> = (of_nat n) gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (n choose k) = rat_of_nat n gchoose k", "by (fact binomial_gbinomial)"], ["proof (state)\nthis:\n  rat_of_nat (n choose k) = rat_of_nat n gchoose k\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_nat (n choose k) = rat_of_nat n gchoose k\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"\\<dots> = pochhammer (of_nat n - of_nat k + 1) k / fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat n gchoose k =\n    pochhammer (rat_of_nat n - rat_of_nat k + 1) k / fact k", "by (fact gbinomial_pochhammer')"], ["proof (state)\nthis:\n  rat_of_nat n gchoose k =\n  pochhammer (rat_of_nat n - rat_of_nat k + 1) k / fact k\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_nat n gchoose k =\n  pochhammer (rat_of_nat n - rat_of_nat k + 1) k / fact k\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"\\<dots> = pochhammer (of_int (int n - int k + 1)) k / fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pochhammer (rat_of_nat n - rat_of_nat k + 1) k / fact k =\n    pochhammer (rat_of_int (int n - int k + 1)) k / fact k", "by simp"], ["proof (state)\nthis:\n  pochhammer (rat_of_nat n - rat_of_nat k + 1) k / fact k =\n  pochhammer (rat_of_int (int n - int k + 1)) k / fact k\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  pochhammer (rat_of_nat n - rat_of_nat k + 1) k / fact k =\n  pochhammer (rat_of_int (int n - int k + 1)) k / fact k\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "have \"\\<dots> = (of_int (pochhammer (int n - int k + 1) k)) / (of_int (fact k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pochhammer (rat_of_int (int n - int k + 1)) k / fact k =\n    rat_of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)", "by (simp only: of_int_fact pochhammer_of_int)"], ["proof (state)\nthis:\n  pochhammer (rat_of_int (int n - int k + 1)) k / fact k =\n  rat_of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)\n\ngoal (1 subgoal):\n 1. of_int (pochhammer (int n - int k + 1) k div fact k) =\n    of_int (pochhammer (int n - int k + 1) k) / of_int (fact k)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n  rat_of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)", "show \"of_int (pochhammer (int n - int k + 1) k div fact k) =\n                      of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)\""], ["proof (prove)\nusing this:\n  rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n  rat_of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)\n\ngoal (1 subgoal):\n 1. rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n    rat_of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)", "."], ["proof (state)\nthis:\n  rat_of_int (pochhammer (int n - int k + 1) k div fact k) =\n  rat_of_int (pochhammer (int n - int k + 1) k) / rat_of_int (fact k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact k dvd pochhammer a k\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "moreover"], ["proof (state)\nthis:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "define n where \"n = nat (- a)\""], ["proof (state)\nthis:\n  n = nat (- a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> 0 < a\n  n = nat (- a)", "have a: \"a = - int n\""], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n  n = nat (- a)\n\ngoal (1 subgoal):\n 1. a = - int n", "by simp"], ["proof (state)\nthis:\n  a = - int n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "from fact_nonzero"], ["proof (chain)\npicking this:\n  fact ?n \\<noteq> (0::?'a)", "have \"fact k dvd (-1)^k * pochhammer (- int n) k\""], ["proof (prove)\nusing this:\n  fact ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. fact k dvd (- 1) ^ k * pochhammer (- int n) k", "proof (rule dvd)"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"of_int ((-1)^k * pochhammer (- int n) k div fact k) = (of_int (int n gchoose k)::rat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    rat_of_int (int n gchoose k)", "by (simp only: gbinomial_int_pochhammer)"], ["proof (state)\nthis:\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n  rat_of_int (int n gchoose k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n  rat_of_int (int n gchoose k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = of_int (int (n choose k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int n gchoose k) = rat_of_int (int (n choose k))", "by (simp only: int_binomial)"], ["proof (state)\nthis:\n  rat_of_int (int n gchoose k) = rat_of_int (int (n choose k))\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_int (int n gchoose k) = rat_of_int (int (n choose k))\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = of_nat (n choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int (n choose k)) = rat_of_nat (n choose k)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (int (n choose k)) = rat_of_nat (n choose k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_int (int (n choose k)) = rat_of_nat (n choose k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = (of_nat n) gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (n choose k) = rat_of_nat n gchoose k", "by (fact binomial_gbinomial)"], ["proof (state)\nthis:\n  rat_of_nat (n choose k) = rat_of_nat n gchoose k\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_nat (n choose k) = rat_of_nat n gchoose k\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = (-1)^k * pochhammer (- of_nat n) k / fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat n gchoose k =\n    (- 1) ^ k * pochhammer (- rat_of_nat n) k / fact k", "by (fact gbinomial_pochhammer)"], ["proof (state)\nthis:\n  rat_of_nat n gchoose k =\n  (- 1) ^ k * pochhammer (- rat_of_nat n) k / fact k\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  rat_of_nat n gchoose k =\n  (- 1) ^ k * pochhammer (- rat_of_nat n) k / fact k\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = (-1)^k * pochhammer (of_int (- int n)) k / fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * pochhammer (- rat_of_nat n) k / fact k =\n    (- 1) ^ k * pochhammer (rat_of_int (- int n)) k / fact k", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ k * pochhammer (- rat_of_nat n) k / fact k =\n  (- 1) ^ k * pochhammer (rat_of_int (- int n)) k / fact k\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  (- 1) ^ k * pochhammer (- rat_of_nat n) k / fact k =\n  (- 1) ^ k * pochhammer (rat_of_int (- int n)) k / fact k\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = (-1)^k * (of_int (pochhammer (- int n) k)) / (of_int (fact k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * pochhammer (rat_of_int (- int n)) k / fact k =\n    (- 1) ^ k * rat_of_int (pochhammer (- int n) k) / rat_of_int (fact k)", "by (simp only: of_int_fact pochhammer_of_int)"], ["proof (state)\nthis:\n  (- 1) ^ k * pochhammer (rat_of_int (- int n)) k / fact k =\n  (- 1) ^ k * rat_of_int (pochhammer (- int n) k) / rat_of_int (fact k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "also"], ["proof (state)\nthis:\n  (- 1) ^ k * pochhammer (rat_of_int (- int n)) k / fact k =\n  (- 1) ^ k * rat_of_int (pochhammer (- int n) k) / rat_of_int (fact k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "have \"\\<dots> = (of_int ((-1)^k * pochhammer (- int n) k)) / (of_int (fact k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * rat_of_int (pochhammer (- int n) k) / rat_of_int (fact k) =\n    rat_of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ k * rat_of_int (pochhammer (- int n) k) / rat_of_int (fact k) =\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)\n\ngoal (1 subgoal):\n 1. of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    of_int ((- 1) ^ k * pochhammer (- int n) k) / of_int (fact k)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)", "show \"of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n                    of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)\""], ["proof (prove)\nusing this:\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)\n\ngoal (1 subgoal):\n 1. rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n    rat_of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)", "."], ["proof (state)\nthis:\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k div fact k) =\n  rat_of_int ((- 1) ^ k * pochhammer (- int n) k) / rat_of_int (fact k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact k dvd (- 1) ^ k * pochhammer (- int n) k\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> fact k dvd pochhammer a k", "thus ?thesis"], ["proof (prove)\nusing this:\n  fact k dvd (- 1) ^ k * pochhammer (- int n) k\n\ngoal (1 subgoal):\n 1. fact k dvd pochhammer a k", "unfolding a"], ["proof (prove)\nusing this:\n  fact k dvd (- 1) ^ k * pochhammer (- int n) k\n\ngoal (1 subgoal):\n 1. fact k dvd pochhammer (- int n) k", "by (metis dvdI dvd_mult_unit_iff' minus_one_mult_self)"], ["proof (state)\nthis:\n  fact k dvd pochhammer a k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact k dvd pochhammer a k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbinomial_int_negated_upper: \"(a gchoose k) = (-1) ^ k * ((int k - a - 1) gchoose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a gchoose k = (- 1) ^ k * (int k - a - 1 gchoose k)", "by (simp add: gbinomial_int_pochhammer pochhammer_minus algebra_simps fact_dvd_pochhammer div_mult_swap)"], ["", "lemma gbinomial_int_mult_fact: \"fact k * (a gchoose k) = (\\<Prod>i = 0..<k. a - int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact k * (a gchoose k) = (\\<Prod>i = 0..<k. a - int i)", "by (simp only: gbinomial_int_pochhammer' fact_dvd_pochhammer dvd_mult_div_cancel falling_fact_pochhammer')"], ["", "corollary gbinomial_int_mult_fact': \"(a gchoose k) * fact k = (\\<Prod>i = 0..<k. a - int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a gchoose k) * fact k = (\\<Prod>i = 0..<k. a - int i)", "using gbinomial_int_mult_fact[of k a]"], ["proof (prove)\nusing this:\n  fact k * (a gchoose k) = (\\<Prod>i = 0..<k. a - int i)\n\ngoal (1 subgoal):\n 1. (a gchoose k) * fact k = (\\<Prod>i = 0..<k. a - int i)", "by (simp add: ac_simps)"], ["", "lemma gbinomial_int_binomial:\n  \"a gchoose k = (if 0 \\<le> a then int ((nat a) choose k) else (-1::int)^k * int ((k + (nat (- a)) - 1) choose k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a gchoose k =\n    (if 0 \\<le> a then int (nat a choose k)\n     else (- 1) ^ k * int (k + nat (- a) - 1 choose k))", "by (auto simp: int_binomial gbinomial_int_negated_upper[of a] int_ops(6))"], ["", "corollary gbinomial_nneg: \"0 \\<le> a \\<Longrightarrow> a gchoose k = int ((nat a) choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<Longrightarrow> a gchoose k = int (nat a choose k)", "by (simp add: gbinomial_int_binomial)"], ["", "corollary gbinomial_neg: \"a < 0 \\<Longrightarrow> a gchoose k = (-1::int)^k * int ((k + (nat (- a)) - 1) choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    a gchoose k = (- 1) ^ k * int (k + nat (- a) - 1 choose k)", "by (simp add: gbinomial_int_binomial)"], ["", "lemma of_int_gbinomial: \"of_int (a gchoose k) = (of_int a :: 'a::field_char_0) gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (a gchoose k) = of_int a gchoose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int (a gchoose k) = of_int a gchoose k", "have of_int_div: \"y dvd x \\<Longrightarrow> of_int (x div y) = of_int x / (of_int y :: 'a)\" for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. y dvd x \\<Longrightarrow> of_int (x div y) = of_int x / of_int y", "by auto"], ["proof (state)\nthis:\n  ?y dvd ?x \\<Longrightarrow> of_int (?x div ?y) = of_int ?x / of_int ?y\n\ngoal (1 subgoal):\n 1. of_int (a gchoose k) = of_int a gchoose k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (a gchoose k) = of_int a gchoose k", "by (simp add: gbinomial_int_pochhammer' gbinomial_pochhammer' of_int_div fact_dvd_pochhammer\n        pochhammer_of_int[symmetric])"], ["proof (state)\nthis:\n  of_int (a gchoose k) = of_int a gchoose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uminus_one_gbinomial [simp]: \"(- 1::int) gchoose k = (- 1) ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 gchoose k = (- 1) ^ k", "by (simp add: gbinomial_int_binomial)"], ["", "lemma gbinomial_int_Suc_Suc: \"(x + 1::int) gchoose (Suc k) = (x gchoose k) + (x gchoose (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "proof (rule linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. ?x = ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 3. ?y < ?x \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "assume 1: \"x + 1 < 0\""], ["proof (state)\nthis:\n  x + 1 < 0\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. ?x = ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 3. ?y < ?x \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "hence 2: \"x < 0\""], ["proof (prove)\nusing this:\n  x + 1 < 0\n\ngoal (1 subgoal):\n 1. x < 0", "by simp"], ["proof (state)\nthis:\n  x < 0\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. ?x = ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 3. ?y < ?x \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "then"], ["proof (chain)\npicking this:\n  x < 0", "obtain n where 3: \"nat (- x) = Suc n\""], ["proof (prove)\nusing this:\n  x < 0\n\ngoal (1 subgoal):\n 1. (\\<And>n. nat (- x) = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not0_implies_Suc"], ["proof (prove)\nusing this:\n  x < 0\n  ?n \\<noteq> 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>n. nat (- x) = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  nat (- x) = Suc n\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. ?x = ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 3. ?y < ?x \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "hence 4: \"nat (- x - 1) = n\""], ["proof (prove)\nusing this:\n  nat (- x) = Suc n\n\ngoal (1 subgoal):\n 1. nat (- x - 1) = n", "by simp"], ["proof (state)\nthis:\n  nat (- x - 1) = n\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. ?x = ?y \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 3. ?y < ?x \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "by (simp add: \\<open>k = 0\\<close>)"], ["proof (state)\nthis:\n  x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "from 1 2 3 4"], ["proof (chain)\npicking this:\n  x + 1 < 0\n  x < 0\n  nat (- x) = Suc n\n  nat (- x - 1) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  x + 1 < 0\n  x < 0\n  nat (- x) = Suc n\n  nat (- x - 1) = n\n\ngoal (1 subgoal):\n 1. x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "by (simp add: \\<open>k = Suc k'\\<close> gbinomial_int_binomial int_distrib(2))"], ["proof (state)\nthis:\n  x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n\ngoal (2 subgoals):\n 1. x + 1 = 0 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x + 1 = 0 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "assume \"x + 1 = 0\""], ["proof (state)\nthis:\n  x + 1 = 0\n\ngoal (2 subgoals):\n 1. x + 1 = 0 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "hence \"x = - 1\""], ["proof (prove)\nusing this:\n  x + 1 = 0\n\ngoal (1 subgoal):\n 1. x = - 1", "by simp"], ["proof (state)\nthis:\n  x = - 1\n\ngoal (2 subgoals):\n 1. x + 1 = 0 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n 2. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = - 1\n\ngoal (1 subgoal):\n 1. x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "by simp"], ["proof (state)\nthis:\n  x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n\ngoal (1 subgoal):\n 1. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "assume \"0 < x + 1\""], ["proof (state)\nthis:\n  0 < x + 1\n\ngoal (1 subgoal):\n 1. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "hence \"0 \\<le> x + 1\" and \"0 \\<le> x\" and \"nat (x + 1) = Suc (nat x)\""], ["proof (prove)\nusing this:\n  0 < x + 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> x + 1 &&& 0 \\<le> x &&& nat (x + 1) = Suc (nat x)", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le> x + 1\n  0 \\<le> x\n  nat (x + 1) = Suc (nat x)\n\ngoal (1 subgoal):\n 1. 0 < x + 1 \\<Longrightarrow>\n    x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x + 1\n  0 \\<le> x\n  nat (x + 1) = Suc (nat x)\n\ngoal (1 subgoal):\n 1. x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)", "by (simp add: gbinomial_int_binomial)"], ["proof (state)\nthis:\n  x + 1 gchoose Suc k = x gchoose k + (x gchoose Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary plus_Suc_gbinomial:\n  \"(x + (1 + int k)) gchoose (Suc k) = ((x + int k) gchoose k) + ((x + int k) gchoose (Suc k))\"\n    (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "have \"?l = (x + int k + 1) gchoose (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k = x + int k + 1 gchoose Suc k", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  x + (1 + int k) gchoose Suc k = x + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "also"], ["proof (state)\nthis:\n  x + (1 + int k) gchoose Suc k = x + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + int k + 1 gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "by (fact gbinomial_int_Suc_Suc)"], ["proof (state)\nthis:\n  x + int k + 1 gchoose Suc k =\n  x + int k gchoose k + (x + int k gchoose Suc k)\n\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "finally"], ["proof (chain)\npicking this:\n  x + (1 + int k) gchoose Suc k =\n  x + int k gchoose k + (x + int k gchoose Suc k)", "show ?thesis"], ["proof (prove)\nusing this:\n  x + (1 + int k) gchoose Suc k =\n  x + int k gchoose k + (x + int k gchoose Suc k)\n\ngoal (1 subgoal):\n 1. x + (1 + int k) gchoose Suc k =\n    x + int k gchoose k + (x + int k gchoose Suc k)", "."], ["proof (state)\nthis:\n  x + (1 + int k) gchoose Suc k =\n  x + int k gchoose k + (x + int k gchoose Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbinomial_int_n_n [simp]: \"(int n) gchoose n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n gchoose n = 1", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. int 0 gchoose 0 = 1\n 2. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. int 0 gchoose 0 = 1\n 2. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int 0 gchoose 0 = 1", "by simp"], ["proof (state)\nthis:\n  int 0 gchoose 0 = 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "case (Suc n)"], ["proof (state)\nthis:\n  int n gchoose n = 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "have \"int (Suc n) gchoose Suc n = (int n + 1) gchoose Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc n) gchoose Suc n = int n + 1 gchoose Suc n", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  int (Suc n) gchoose Suc n = int n + 1 gchoose Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "also"], ["proof (state)\nthis:\n  int (Suc n) gchoose Suc n = int n + 1 gchoose Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "have \"\\<dots> = (int n gchoose n) + (int n gchoose (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n + 1 gchoose Suc n = int n gchoose n + (int n gchoose Suc n)", "by (fact gbinomial_int_Suc_Suc)"], ["proof (state)\nthis:\n  int n + 1 gchoose Suc n = int n gchoose n + (int n gchoose Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       int n gchoose n = 1 \\<Longrightarrow> int (Suc n) gchoose Suc n = 1", "finally"], ["proof (chain)\npicking this:\n  int (Suc n) gchoose Suc n = int n gchoose n + (int n gchoose Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  int (Suc n) gchoose Suc n = int n gchoose n + (int n gchoose Suc n)\n\ngoal (1 subgoal):\n 1. int (Suc n) gchoose Suc n = 1", "by (simp add: Suc gbinomial_eq_0)"], ["proof (state)\nthis:\n  int (Suc n) gchoose Suc n = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbinomial_int_Suc_n [simp]: \"(1 + int n) gchoose n = 1 + int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int n gchoose n = 1 + int n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 + int 0 gchoose 0 = 1 + int 0\n 2. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 1 + int 0 gchoose 0 = 1 + int 0\n 2. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int 0 gchoose 0 = 1 + int 0", "by simp"], ["proof (state)\nthis:\n  1 + int 0 gchoose 0 = 1 + int 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  1 + int n gchoose n = 1 + int n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "have \"1 + int (Suc n) gchoose Suc n = (1 + int n) + 1 gchoose Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int (Suc n) gchoose Suc n = 1 + int n + 1 gchoose Suc n", "by simp"], ["proof (state)\nthis:\n  1 + int (Suc n) gchoose Suc n = 1 + int n + 1 gchoose Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "also"], ["proof (state)\nthis:\n  1 + int (Suc n) gchoose Suc n = 1 + int n + 1 gchoose Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "have \"\\<dots> = (1 + int n gchoose n) + (1 + int n gchoose (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int n + 1 gchoose Suc n =\n    1 + int n gchoose n + (1 + int n gchoose Suc n)", "by (fact gbinomial_int_Suc_Suc)"], ["proof (state)\nthis:\n  1 + int n + 1 gchoose Suc n =\n  1 + int n gchoose n + (1 + int n gchoose Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "also"], ["proof (state)\nthis:\n  1 + int n + 1 gchoose Suc n =\n  1 + int n gchoose n + (1 + int n gchoose Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "have \"\\<dots> = 1 + int n + (int (Suc n) gchoose (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int n gchoose n + (1 + int n gchoose Suc n) =\n    1 + int n + (int (Suc n) gchoose Suc n)", "by (simp add: Suc)"], ["proof (state)\nthis:\n  1 + int n gchoose n + (1 + int n gchoose Suc n) =\n  1 + int n + (int (Suc n) gchoose Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "also"], ["proof (state)\nthis:\n  1 + int n gchoose n + (1 + int n gchoose Suc n) =\n  1 + int n + (int (Suc n) gchoose Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "have \"\\<dots> = 1 + int (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int n + (int (Suc n) gchoose Suc n) = 1 + int (Suc n)", "by (simp only: gbinomial_int_n_n)"], ["proof (state)\nthis:\n  1 + int n + (int (Suc n) gchoose Suc n) = 1 + int (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 + int n gchoose n = 1 + int n \\<Longrightarrow>\n       1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "finally"], ["proof (chain)\npicking this:\n  1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)\n\ngoal (1 subgoal):\n 1. 1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)", "."], ["proof (state)\nthis:\n  1 + int (Suc n) gchoose Suc n = 1 + int (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zbinomial_eq_0_iff [simp]: \"a gchoose k = 0 \\<longleftrightarrow> (0 \\<le> a \\<and> a < int k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a gchoose k = 0) = (0 \\<le> a \\<and> a < int k)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a gchoose k = 0 \\<Longrightarrow> 0 \\<le> a \\<and> a < int k\n 2. 0 \\<le> a \\<and> a < int k \\<Longrightarrow> a gchoose k = 0", "assume a: \"a gchoose k = 0\""], ["proof (state)\nthis:\n  a gchoose k = 0\n\ngoal (2 subgoals):\n 1. a gchoose k = 0 \\<Longrightarrow> 0 \\<le> a \\<and> a < int k\n 2. 0 \\<le> a \\<and> a < int k \\<Longrightarrow> a gchoose k = 0", "have 1: \"b < int k\" if \"b gchoose k = 0\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. b < int k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b < int k \\<Longrightarrow> False", "assume \"\\<not> b < int k\""], ["proof (state)\nthis:\n  \\<not> b < int k\n\ngoal (1 subgoal):\n 1. \\<not> b < int k \\<Longrightarrow> False", "hence \"0 \\<le> b\" and \"k \\<le> nat b\""], ["proof (prove)\nusing this:\n  \\<not> b < int k\n\ngoal (1 subgoal):\n 1. 0 \\<le> b &&& k \\<le> nat b", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le> b\n  k \\<le> nat b\n\ngoal (1 subgoal):\n 1. \\<not> b < int k \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  0 \\<le> b", "have \"int ((nat b) choose k) = b gchoose k\""], ["proof (prove)\nusing this:\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. int (nat b choose k) = b gchoose k", "by (simp add: gbinomial_int_binomial)"], ["proof (state)\nthis:\n  int (nat b choose k) = b gchoose k\n\ngoal (1 subgoal):\n 1. \\<not> b < int k \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int (nat b choose k) = b gchoose k\n\ngoal (1 subgoal):\n 1. \\<not> b < int k \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b gchoose k = 0", "by (fact that)"], ["proof (state)\nthis:\n  b gchoose k = 0\n\ngoal (1 subgoal):\n 1. \\<not> b < int k \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  int (nat b choose k) = 0", "show False"], ["proof (prove)\nusing this:\n  int (nat b choose k) = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>k \\<le> nat b\\<close>"], ["proof (prove)\nusing this:\n  int (nat b choose k) = 0\n  k \\<le> nat b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?b gchoose k = 0 \\<Longrightarrow> ?b < int k\n\ngoal (2 subgoals):\n 1. a gchoose k = 0 \\<Longrightarrow> 0 \\<le> a \\<and> a < int k\n 2. 0 \\<le> a \\<and> a < int k \\<Longrightarrow> a gchoose k = 0", "show \"0 \\<le> a \\<and> a < int k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and> a < int k", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> a\n 2. a < int k", "show \"0 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "assume \"\\<not> 0 \\<le> a\""], ["proof (state)\nthis:\n  \\<not> 0 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "hence \"(-1) ^ k * ((int k - a - 1) gchoose k) = a gchoose k\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> a\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * (int k - a - 1 gchoose k) = a gchoose k", "by (simp add: gbinomial_int_negated_upper[of a])"], ["proof (state)\nthis:\n  (- 1) ^ k * (int k - a - 1 gchoose k) = a gchoose k\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (- 1) ^ k * (int k - a - 1 gchoose k) = a gchoose k\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a gchoose k = 0", "by (fact a)"], ["proof (state)\nthis:\n  a gchoose k = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ k * (int k - a - 1 gchoose k) = 0", "have \"(int k - a - 1) gchoose k = 0\""], ["proof (prove)\nusing this:\n  (- 1) ^ k * (int k - a - 1 gchoose k) = 0\n\ngoal (1 subgoal):\n 1. int k - a - 1 gchoose k = 0", "by simp"], ["proof (state)\nthis:\n  int k - a - 1 gchoose k = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "hence \"int k - a - 1 < int k\""], ["proof (prove)\nusing this:\n  int k - a - 1 gchoose k = 0\n\ngoal (1 subgoal):\n 1. int k - a - 1 < int k", "by (rule 1)"], ["proof (state)\nthis:\n  int k - a - 1 < int k\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> a \\<Longrightarrow> False", "with \\<open>\\<not> 0 \\<le> a\\<close>"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> a\n  int k - a - 1 < int k", "show False"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> a\n  int k - a - 1 < int k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. a < int k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a < int k", "from a"], ["proof (chain)\npicking this:\n  a gchoose k = 0", "show \"a < int k\""], ["proof (prove)\nusing this:\n  a gchoose k = 0\n\ngoal (1 subgoal):\n 1. a < int k", "by (rule 1)"], ["proof (state)\nthis:\n  a < int k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> a \\<and> a < int k\n\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and> a < int k \\<Longrightarrow> a gchoose k = 0", "qed (auto intro: gbinomial_eq_0)"], ["", "subsection \\<open>Sums\\<close>"], ["", "lemma gchoose_rising_sum_nat: \"(\\<Sum>j\\<le>n. int j + int k gchoose k) = (int n + int k + 1) gchoose (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "have \"(\\<Sum>j\\<le>n. int j + int k gchoose k) = int (\\<Sum>j\\<le>n. k + j choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int (\\<Sum>j\\<le>n. k + j choose k)", "by (simp add: int_binomial add.commute)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n  int (\\<Sum>j\\<le>n. k + j choose k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n  int (\\<Sum>j\\<le>n. k + j choose k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "have \"(\\<Sum>j\\<le>n. k + j choose k) = (k + n + 1) choose (k + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. k + j choose k) = k + n + 1 choose (k + 1)", "by (fact choose_rising_sum(1))"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>n. k + j choose k) = k + n + 1 choose (k + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>n. k + j choose k) = k + n + 1 choose (k + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "have \"int \\<dots> = (int n + int k + 1) gchoose (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (k + n + 1 choose (k + 1)) = int n + int k + 1 gchoose Suc k", "by (simp add: int_binomial ac_simps del: binomial_Suc_Suc)"], ["proof (state)\nthis:\n  int (k + n + 1 choose (k + 1)) = int n + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<le>n. int j + int k gchoose k) = int n + int k + 1 gchoose Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<le>n. int j + int k gchoose k) = int n + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>n. int j + int k gchoose k) =\n    int n + int k + 1 gchoose Suc k", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>n. int j + int k gchoose k) = int n + int k + 1 gchoose Suc k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gchoose_rising_sum:\n  assumes \"0 \\<le> n\"   \\<comment>\\<open>Necessary condition.\\<close>\n  shows \"(\\<Sum>j=0..n. j + int k gchoose k) = (n + int k + 1) gchoose (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "from _ refl"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?t = ?t", "have \"(\\<Sum>j=0..n. j + int k gchoose k) = (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) =\n    (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. {0..n} = int ` {0..nat n}", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> n", "show \"{0..n} = int ` {0..nat n}\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. {0..n} = int ` {0..nat n}", "by (simp add: image_int_atLeastAtMost)"], ["proof (state)\nthis:\n  {0..n} = int ` {0..nat n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n. j + int k gchoose k) =\n  (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n. j + int k gchoose k) =\n  (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "have \"\\<dots> = (\\<Sum>j\\<le>nat n. int j + int k gchoose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k) =\n    (\\<Sum>j\\<le>nat n. int j + int k gchoose k)", "by (simp add: sum.reindex atMost_atLeast0)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k) =\n  (\\<Sum>j\\<le>nat n. int j + int k gchoose k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>int ` {0..nat n}. j + int k gchoose k) =\n  (\\<Sum>j\\<le>nat n. int j + int k gchoose k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "have \"\\<dots> = (int (nat n) + int k + 1) gchoose (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>nat n. int j + int k gchoose k) =\n    int (nat n) + int k + 1 gchoose Suc k", "by (fact gchoose_rising_sum_nat)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>nat n. int j + int k gchoose k) =\n  int (nat n) + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>nat n. int j + int k gchoose k) =\n  int (nat n) + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> n", "have \"\\<dots> = (n + int k + 1) gchoose (Suc k)\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. int (nat n) + int k + 1 gchoose Suc k = n + int k + 1 gchoose Suc k", "by (simp add: add.assoc add.commute)"], ["proof (state)\nthis:\n  int (nat n) + int k + 1 gchoose Suc k = n + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k", "."], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n. j + int k gchoose k) = n + int k + 1 gchoose Suc k\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Inequalities\\<close>"], ["", "lemma binomial_mono:\n  assumes \"m \\<le> n\"\n  shows \"m choose k \\<le> n choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose k \\<le> n choose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m choose k \\<le> n choose k", "define l where \"l = n - m\""], ["proof (state)\nthis:\n  l = n - m\n\ngoal (1 subgoal):\n 1. m choose k \\<le> n choose k", "with assms"], ["proof (chain)\npicking this:\n  m \\<le> n\n  l = n - m", "have n: \"n = m + l\""], ["proof (prove)\nusing this:\n  m \\<le> n\n  l = n - m\n\ngoal (1 subgoal):\n 1. n = m + l", "by simp"], ["proof (state)\nthis:\n  n = m + l\n\ngoal (1 subgoal):\n 1. m choose k \\<le> n choose k", "have \"m choose k \\<le> (m + l) choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose k \\<le> m + l choose k", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. m choose k \\<le> m + 0 choose k\n 2. \\<And>l.\n       m choose k \\<le> m + l choose k \\<Longrightarrow>\n       m choose k \\<le> m + Suc l choose k", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. m choose k \\<le> m + 0 choose k\n 2. \\<And>l.\n       m choose k \\<le> m + l choose k \\<Longrightarrow>\n       m choose k \\<le> m + Suc l choose k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose k \\<le> m + 0 choose k", "by simp"], ["proof (state)\nthis:\n  m choose k \\<le> m + 0 choose k\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       m choose k \\<le> m + l choose k \\<Longrightarrow>\n       m choose k \\<le> m + Suc l choose k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       m choose k \\<le> m + l choose k \\<Longrightarrow>\n       m choose k \\<le> m + Suc l choose k", "case *: (Suc l)"], ["proof (state)\nthis:\n  m choose k \\<le> m + l choose k\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       m choose k \\<le> m + l choose k \\<Longrightarrow>\n       m choose k \\<le> m + Suc l choose k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose k \\<le> m + Suc l choose k", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> m choose k \\<le> m + Suc l choose k\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> m choose k \\<le> m + Suc l choose k\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. m choose k \\<le> m + Suc l choose k", "by simp"], ["proof (state)\nthis:\n  m choose k \\<le> m + Suc l choose k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "case k: (Suc k0)"], ["proof (state)\nthis:\n  k = Suc k0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "note *"], ["proof (state)\nthis:\n  m choose k \\<le> m + l choose k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "also"], ["proof (state)\nthis:\n  m choose k \\<le> m + l choose k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "have \"m + l choose k \\<le> m + l choose k + (m + l choose k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + l choose k \\<le> m + l choose k + (m + l choose k0)", "by simp"], ["proof (state)\nthis:\n  m + l choose k \\<le> m + l choose k + (m + l choose k0)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "also"], ["proof (state)\nthis:\n  m + l choose k \\<le> m + l choose k + (m + l choose k0)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "have \"\\<dots> = m + Suc l choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + l choose k + (m + l choose k0) = m + Suc l choose k", "by (simp add: k)"], ["proof (state)\nthis:\n  m + l choose k + (m + l choose k0) = m + Suc l choose k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow> m choose k \\<le> m + Suc l choose k", "finally"], ["proof (chain)\npicking this:\n  m choose k \\<le> m + Suc l choose k", "show ?thesis"], ["proof (prove)\nusing this:\n  m choose k \\<le> m + Suc l choose k\n\ngoal (1 subgoal):\n 1. m choose k \\<le> m + Suc l choose k", "."], ["proof (state)\nthis:\n  m choose k \\<le> m + Suc l choose k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m choose k \\<le> m + Suc l choose k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m choose k \\<le> m + l choose k\n\ngoal (1 subgoal):\n 1. m choose k \\<le> n choose k", "thus ?thesis"], ["proof (prove)\nusing this:\n  m choose k \\<le> m + l choose k\n\ngoal (1 subgoal):\n 1. m choose k \\<le> n choose k", "by (simp only: n)"], ["proof (state)\nthis:\n  m choose k \\<le> n choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma binomial_plus_le:\n  assumes \"0 < k\"\n  shows \"(m choose k) + (n choose k) \\<le> (m + n) choose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose k + (n choose k) \\<le> m + n choose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m choose k + (n choose k) \\<le> m + n choose k", "define k0 where \"k0 = k - 1\""], ["proof (state)\nthis:\n  k0 = k - 1\n\ngoal (1 subgoal):\n 1. m choose k + (n choose k) \\<le> m + n choose k", "with assms"], ["proof (chain)\npicking this:\n  0 < k\n  k0 = k - 1", "have k: \"k = Suc k0\""], ["proof (prove)\nusing this:\n  0 < k\n  k0 = k - 1\n\ngoal (1 subgoal):\n 1. k = Suc k0", "by simp"], ["proof (state)\nthis:\n  k = Suc k0\n\ngoal (1 subgoal):\n 1. m choose k + (n choose k) \\<le> m + n choose k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose k + (n choose k) \\<le> m + n choose k", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose Suc k0 + (n choose Suc k0) \\<le> m + n choose Suc k0", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. m choose Suc k0 + (0 choose Suc k0) \\<le> m + 0 choose Suc k0\n 2. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. m choose Suc k0 + (0 choose Suc k0) \\<le> m + 0 choose Suc k0\n 2. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose Suc k0 + (0 choose Suc k0) \\<le> m + 0 choose Suc k0", "by simp"], ["proof (state)\nthis:\n  m choose Suc k0 + (0 choose Suc k0) \\<le> m + 0 choose Suc k0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "case (Suc n)"], ["proof (state)\nthis:\n  m choose Suc k0 + (n choose Suc k0) \\<le> m + n choose Suc k0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "have \"m choose Suc k0 + (Suc n choose Suc k0) = m choose Suc k0 + (n choose Suc k0) + (n choose k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m choose Suc k0 + (Suc n choose Suc k0) =\n    m choose Suc k0 + (n choose Suc k0) + (n choose k0)", "by (simp only: binomial_Suc_Suc)"], ["proof (state)\nthis:\n  m choose Suc k0 + (Suc n choose Suc k0) =\n  m choose Suc k0 + (n choose Suc k0) + (n choose k0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "also"], ["proof (state)\nthis:\n  m choose Suc k0 + (Suc n choose Suc k0) =\n  m choose Suc k0 + (n choose Suc k0) + (n choose k0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "from Suc"], ["proof (chain)\npicking this:\n  m choose Suc k0 + (n choose Suc k0) \\<le> m + n choose Suc k0", "have \"\\<dots> \\<le> (m + n) choose Suc k0 + ((m + n) choose k0)\""], ["proof (prove)\nusing this:\n  m choose Suc k0 + (n choose Suc k0) \\<le> m + n choose Suc k0\n\ngoal (1 subgoal):\n 1. m choose Suc k0 + (n choose Suc k0) + (n choose k0)\n    \\<le> m + n choose Suc k0 + (m + n choose k0)", "proof (rule add_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. n choose k0 \\<le> m + n choose k0", "have \"n \\<le> m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m + n", "by simp"], ["proof (state)\nthis:\n  n \\<le> m + n\n\ngoal (1 subgoal):\n 1. n choose k0 \\<le> m + n choose k0", "thus \"n choose k0 \\<le> m + n choose k0\""], ["proof (prove)\nusing this:\n  n \\<le> m + n\n\ngoal (1 subgoal):\n 1. n choose k0 \\<le> m + n choose k0", "by (rule binomial_mono)"], ["proof (state)\nthis:\n  n choose k0 \\<le> m + n choose k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m choose Suc k0 + (n choose Suc k0) + (n choose k0)\n  \\<le> m + n choose Suc k0 + (m + n choose k0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "also"], ["proof (state)\nthis:\n  m choose Suc k0 + (n choose Suc k0) + (n choose k0)\n  \\<le> m + n choose Suc k0 + (m + n choose k0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "have \"\\<dots> = m + Suc n choose Suc k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + n choose Suc k0 + (m + n choose k0) = m + Suc n choose Suc k0", "by simp"], ["proof (state)\nthis:\n  m + n choose Suc k0 + (m + n choose k0) = m + Suc n choose Suc k0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       m choose Suc k0 + (n choose Suc k0)\n       \\<le> m + n choose Suc k0 \\<Longrightarrow>\n       m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "finally"], ["proof (chain)\npicking this:\n  m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "show ?case"], ["proof (prove)\nusing this:\n  m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0\n\ngoal (1 subgoal):\n 1. m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0", "."], ["proof (state)\nthis:\n  m choose Suc k0 + (Suc n choose Suc k0) \\<le> m + Suc n choose Suc k0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m choose k + (n choose k) \\<le> m + n choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma binomial_ineq_1: \"2 * ((n + i) choose k) \\<le> n choose k + ((n + 2 * i) choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)\n 2. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. 2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "by simp"], ["proof (state)\nthis:\n  2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "case k: (Suc k0)"], ["proof (state)\nthis:\n  k = Suc k0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       k = Suc nat \\<Longrightarrow>\n       2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n + i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 * (n + 0 choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * 0 choose Suc k0)\n 2. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 2 * (n + 0 choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * 0 choose Suc k0)\n 2. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n + 0 choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * 0 choose Suc k0)", "by simp"], ["proof (state)\nthis:\n  2 * (n + 0 choose Suc k0)\n  \\<le> n choose Suc k0 + (n + 2 * 0 choose Suc k0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "case (Suc i)"], ["proof (state)\nthis:\n  2 * (n + i choose Suc k0)\n  \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "have \"2 * (n + Suc i choose Suc k0) = 2 * (n + i choose k0) + 2 * (n + i choose Suc k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n + Suc i choose Suc k0) =\n    2 * (n + i choose k0) + 2 * (n + i choose Suc k0)", "by simp"], ["proof (state)\nthis:\n  2 * (n + Suc i choose Suc k0) =\n  2 * (n + i choose k0) + 2 * (n + i choose Suc k0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "also"], ["proof (state)\nthis:\n  2 * (n + Suc i choose Suc k0) =\n  2 * (n + i choose k0) + 2 * (n + i choose Suc k0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "have \"\\<dots> \\<le> (n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)) + (n choose Suc k0 + (n + 2 * i choose Suc k0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (n + i choose k0) + 2 * (n + i choose Suc k0)\n    \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0) +\n          (n choose Suc k0 + (n + 2 * i choose Suc k0))", "proof (rule add_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 * (n + i choose k0)\n    \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)\n 2. 2 * (n + i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)", "have \"n + i choose k0 \\<le> n + 2 * i choose k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + i choose k0 \\<le> n + 2 * i choose k0", "by (rule binomial_mono) simp"], ["proof (state)\nthis:\n  n + i choose k0 \\<le> n + 2 * i choose k0\n\ngoal (2 subgoals):\n 1. 2 * (n + i choose k0)\n    \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)\n 2. 2 * (n + i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)", "moreover"], ["proof (state)\nthis:\n  n + i choose k0 \\<le> n + 2 * i choose k0\n\ngoal (2 subgoals):\n 1. 2 * (n + i choose k0)\n    \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)\n 2. 2 * (n + i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)", "have \"n + 2 * i choose k0 \\<le> Suc (n + 2 * i) choose k0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 2 * i choose k0 \\<le> Suc (n + 2 * i) choose k0", "by (rule binomial_mono) simp"], ["proof (state)\nthis:\n  n + 2 * i choose k0 \\<le> Suc (n + 2 * i) choose k0\n\ngoal (2 subgoals):\n 1. 2 * (n + i choose k0)\n    \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)\n 2. 2 * (n + i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)", "ultimately"], ["proof (chain)\npicking this:\n  n + i choose k0 \\<le> n + 2 * i choose k0\n  n + 2 * i choose k0 \\<le> Suc (n + 2 * i) choose k0", "show \"2 * (n + i choose k0) \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)\""], ["proof (prove)\nusing this:\n  n + i choose k0 \\<le> n + 2 * i choose k0\n  n + 2 * i choose k0 \\<le> Suc (n + 2 * i) choose k0\n\ngoal (1 subgoal):\n 1. 2 * (n + i choose k0)\n    \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)", "by simp"], ["proof (state)\nthis:\n  2 * (n + i choose k0)\n  \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0)\n\ngoal (1 subgoal):\n 1. 2 * (n + i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0)", "qed (fact Suc)"], ["proof (state)\nthis:\n  2 * (n + i choose k0) + 2 * (n + i choose Suc k0)\n  \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0) +\n        (n choose Suc k0 + (n + 2 * i choose Suc k0))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "also"], ["proof (state)\nthis:\n  2 * (n + i choose k0) + 2 * (n + i choose Suc k0)\n  \\<le> n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0) +\n        (n choose Suc k0 + (n + 2 * i choose Suc k0))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "have \"\\<dots> = n choose Suc k0 + (n + 2 * Suc i choose Suc k0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0) +\n    (n choose Suc k0 + (n + 2 * i choose Suc k0)) =\n    n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "by simp"], ["proof (state)\nthis:\n  n + 2 * i choose k0 + (Suc (n + 2 * i) choose k0) +\n  (n choose Suc k0 + (n + 2 * i choose Suc k0)) =\n  n choose Suc k0 + (n + 2 * Suc i choose Suc k0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       2 * (n + i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * i choose Suc k0) \\<Longrightarrow>\n       2 * (n + Suc i choose Suc k0)\n       \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "finally"], ["proof (chain)\npicking this:\n  2 * (n + Suc i choose Suc k0)\n  \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "show ?case"], ["proof (prove)\nusing this:\n  2 * (n + Suc i choose Suc k0)\n  \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)\n\ngoal (1 subgoal):\n 1. 2 * (n + Suc i choose Suc k0)\n    \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)", "."], ["proof (state)\nthis:\n  2 * (n + Suc i choose Suc k0)\n  \\<le> n choose Suc k0 + (n + 2 * Suc i choose Suc k0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * (n + i choose k) \\<le> n choose k + (n + 2 * i choose k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbinomial_int_nonneg:\n  assumes \"0 \\<le> (x::int)\"\n  shows \"0 \\<le> x gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x gchoose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> x gchoose k", "have \"0 \\<le> int (nat x choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int (nat x choose k)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> int (nat x choose k)\n\ngoal (1 subgoal):\n 1. 0 \\<le> x gchoose k", "also"], ["proof (state)\nthis:\n  0 \\<le> int (nat x choose k)\n\ngoal (1 subgoal):\n 1. 0 \\<le> x gchoose k", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have \"\\<dots> = x gchoose k\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. int (nat x choose k) = x gchoose k", "by (simp add: int_binomial)"], ["proof (state)\nthis:\n  int (nat x choose k) = x gchoose k\n\ngoal (1 subgoal):\n 1. 0 \\<le> x gchoose k", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> x gchoose k", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x gchoose k\n\ngoal (1 subgoal):\n 1. 0 \\<le> x gchoose k", "."], ["proof (state)\nthis:\n  0 \\<le> x gchoose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbinomial_int_mono:\n  assumes \"0 \\<le> x\" and \"x \\<le> (y::int)\"\n  shows \"x gchoose k \\<le> y gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  x \\<le> y", "have \"nat x \\<le> nat y\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. nat x \\<le> nat y", "by simp"], ["proof (state)\nthis:\n  nat x \\<le> nat y\n\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "hence \"nat x choose k \\<le> nat y choose k\""], ["proof (prove)\nusing this:\n  nat x \\<le> nat y\n\ngoal (1 subgoal):\n 1. nat x choose k \\<le> nat y choose k", "by (rule binomial_mono)"], ["proof (state)\nthis:\n  nat x choose k \\<le> nat y choose k\n\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "hence \"int (nat x choose k) \\<le> int (nat y choose k)\""], ["proof (prove)\nusing this:\n  nat x choose k \\<le> nat y choose k\n\ngoal (1 subgoal):\n 1. int (nat x choose k) \\<le> int (nat y choose k)", "by (simp only: zle_int)"], ["proof (state)\nthis:\n  int (nat x choose k) \\<le> int (nat y choose k)\n\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "hence \"int (nat x) gchoose k \\<le> int (nat y) gchoose k\""], ["proof (prove)\nusing this:\n  int (nat x choose k) \\<le> int (nat y choose k)\n\ngoal (1 subgoal):\n 1. int (nat x) gchoose k \\<le> int (nat y) gchoose k", "by (simp only: int_binomial)"], ["proof (state)\nthis:\n  int (nat x) gchoose k \\<le> int (nat y) gchoose k\n\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  x \\<le> y\n  int (nat x) gchoose k \\<le> int (nat y) gchoose k", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> y\n  int (nat x) gchoose k \\<le> int (nat y) gchoose k\n\ngoal (1 subgoal):\n 1. x gchoose k \\<le> y gchoose k", "by simp"], ["proof (state)\nthis:\n  x gchoose k \\<le> y gchoose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbinomial_int_plus_le:\n  assumes \"0 < k\" and \"0 \\<le> x\" and \"0 \\<le> (y::int)\"\n  shows \"(x gchoose k) + (y gchoose k) \\<le> (x + y) gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x gchoose k + (y gchoose k) \\<le> x + y gchoose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x gchoose k + (y gchoose k) \\<le> x + y gchoose k", "from assms(1)"], ["proof (chain)\npicking this:\n  0 < k", "have \"nat x choose k + (nat y choose k) \\<le> nat x + nat y choose k\""], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. nat x choose k + (nat y choose k) \\<le> nat x + nat y choose k", "by (rule binomial_plus_le)"], ["proof (state)\nthis:\n  nat x choose k + (nat y choose k) \\<le> nat x + nat y choose k\n\ngoal (1 subgoal):\n 1. x gchoose k + (y gchoose k) \\<le> x + y gchoose k", "hence \"int (nat x choose k + (nat y choose k)) \\<le> int (nat x + nat y choose k)\""], ["proof (prove)\nusing this:\n  nat x choose k + (nat y choose k) \\<le> nat x + nat y choose k\n\ngoal (1 subgoal):\n 1. int (nat x choose k + (nat y choose k))\n    \\<le> int (nat x + nat y choose k)", "by (simp only: zle_int)"], ["proof (state)\nthis:\n  int (nat x choose k + (nat y choose k)) \\<le> int (nat x + nat y choose k)\n\ngoal (1 subgoal):\n 1. x gchoose k + (y gchoose k) \\<le> x + y gchoose k", "hence \"int (nat x) gchoose k + (int (nat y) gchoose k) \\<le> int (nat x) + int (nat y) gchoose k\""], ["proof (prove)\nusing this:\n  int (nat x choose k + (nat y choose k)) \\<le> int (nat x + nat y choose k)\n\ngoal (1 subgoal):\n 1. int (nat x) gchoose k + (int (nat y) gchoose k)\n    \\<le> int (nat x) + int (nat y) gchoose k", "by (simp only: int_plus int_binomial)"], ["proof (state)\nthis:\n  int (nat x) gchoose k + (int (nat y) gchoose k)\n  \\<le> int (nat x) + int (nat y) gchoose k\n\ngoal (1 subgoal):\n 1. x gchoose k + (y gchoose k) \\<le> x + y gchoose k", "with assms(2, 3)"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  0 \\<le> y\n  int (nat x) gchoose k + (int (nat y) gchoose k)\n  \\<le> int (nat x) + int (nat y) gchoose k", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  0 \\<le> y\n  int (nat x) gchoose k + (int (nat y) gchoose k)\n  \\<le> int (nat x) + int (nat y) gchoose k\n\ngoal (1 subgoal):\n 1. x gchoose k + (y gchoose k) \\<le> x + y gchoose k", "by simp"], ["proof (state)\nthis:\n  x gchoose k + (y gchoose k) \\<le> x + y gchoose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma binomial_int_ineq_1:\n  assumes \"0 \\<le> x\" and \"0 \\<le> (y::int)\"\n  shows \"2 * (x + y gchoose k) \\<le> x gchoose k + ((x + 2 * y) gchoose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (x + y gchoose k) \\<le> x gchoose k + (x + 2 * y gchoose k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * (x + y gchoose k) \\<le> x gchoose k + (x + 2 * y gchoose k)", "from binomial_ineq_1[of \"nat x\" \"nat y\" k]"], ["proof (chain)\npicking this:\n  2 * (nat x + nat y choose k)\n  \\<le> nat x choose k + (nat x + 2 * nat y choose k)", "have \"int (2 * (nat x + nat y choose k)) \\<le> int (nat x choose k + (nat x + 2 * nat y choose k))\""], ["proof (prove)\nusing this:\n  2 * (nat x + nat y choose k)\n  \\<le> nat x choose k + (nat x + 2 * nat y choose k)\n\ngoal (1 subgoal):\n 1. int (2 * (nat x + nat y choose k))\n    \\<le> int (nat x choose k + (nat x + 2 * nat y choose k))", "by (simp only: zle_int)"], ["proof (state)\nthis:\n  int (2 * (nat x + nat y choose k))\n  \\<le> int (nat x choose k + (nat x + 2 * nat y choose k))\n\ngoal (1 subgoal):\n 1. 2 * (x + y gchoose k) \\<le> x gchoose k + (x + 2 * y gchoose k)", "hence \"2 * (int (nat x) + int (nat y) gchoose k) \\<le> int (nat x) gchoose k + (int (nat x) + 2 * int (nat y) gchoose k)\""], ["proof (prove)\nusing this:\n  int (2 * (nat x + nat y choose k))\n  \\<le> int (nat x choose k + (nat x + 2 * nat y choose k))\n\ngoal (1 subgoal):\n 1. 2 * (int (nat x) + int (nat y) gchoose k)\n    \\<le> int (nat x) gchoose k + (int (nat x) + 2 * int (nat y) gchoose k)", "by (simp only: int_binomial int_plus int_ops(7)) simp"], ["proof (state)\nthis:\n  2 * (int (nat x) + int (nat y) gchoose k)\n  \\<le> int (nat x) gchoose k + (int (nat x) + 2 * int (nat y) gchoose k)\n\ngoal (1 subgoal):\n 1. 2 * (x + y gchoose k) \\<le> x gchoose k + (x + 2 * y gchoose k)", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  0 \\<le> y\n  2 * (int (nat x) + int (nat y) gchoose k)\n  \\<le> int (nat x) gchoose k + (int (nat x) + 2 * int (nat y) gchoose k)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  0 \\<le> y\n  2 * (int (nat x) + int (nat y) gchoose k)\n  \\<le> int (nat x) gchoose k + (int (nat x) + 2 * int (nat y) gchoose k)\n\ngoal (1 subgoal):\n 1. 2 * (x + y gchoose k) \\<le> x gchoose k + (x + 2 * y gchoose k)", "by simp"], ["proof (state)\nthis:\n  2 * (x + y gchoose k) \\<le> x gchoose k + (x + 2 * y gchoose k)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary binomial_int_ineq_2:\n  assumes \"0 \\<le> y\" and \"y \\<le> (x::int)\"\n  shows \"2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)", "from assms(2)"], ["proof (chain)\npicking this:\n  y \\<le> x", "have \"0 \\<le> x - y\""], ["proof (prove)\nusing this:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> x - y", "by simp"], ["proof (state)\nthis:\n  0 \\<le> x - y\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)", "hence \"2 * ((x - y) + y gchoose k) \\<le> x - y gchoose k + ((x - y + 2 * y) gchoose k)\""], ["proof (prove)\nusing this:\n  0 \\<le> x - y\n\ngoal (1 subgoal):\n 1. 2 * (x - y + y gchoose k)\n    \\<le> x - y gchoose k + (x - y + 2 * y gchoose k)", "using assms(1)"], ["proof (prove)\nusing this:\n  0 \\<le> x - y\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 2 * (x - y + y gchoose k)\n    \\<le> x - y gchoose k + (x - y + 2 * y gchoose k)", "by (rule binomial_int_ineq_1)"], ["proof (state)\nthis:\n  2 * (x - y + y gchoose k)\n  \\<le> x - y gchoose k + (x - y + 2 * y gchoose k)\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 * (x - y + y gchoose k)\n  \\<le> x - y gchoose k + (x - y + 2 * y gchoose k)\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)", "by smt"], ["proof (state)\nthis:\n  2 * (x gchoose k) \\<le> x - y gchoose k + (x + y gchoose k)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary binomial_int_ineq_3:\n  assumes \"0 \\<le> y\" and \"y \\<le> 2 * (x::int)\"\n  shows \"2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "proof (cases \"y \\<le> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n 2. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "case True"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (2 subgoals):\n 1. y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n 2. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "hence \"0 \\<le> x - y\""], ["proof (prove)\nusing this:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> x - y", "by simp"], ["proof (state)\nthis:\n  0 \\<le> x - y\n\ngoal (2 subgoals):\n 1. y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n 2. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "moreover"], ["proof (state)\nthis:\n  0 \\<le> x - y\n\ngoal (2 subgoals):\n 1. y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n 2. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "from assms(1)"], ["proof (chain)\npicking this:\n  0 \\<le> y", "have \"x - y \\<le> x\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. x - y \\<le> x", "by simp"], ["proof (state)\nthis:\n  x - y \\<le> x\n\ngoal (2 subgoals):\n 1. y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n 2. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> x - y\n  x - y \\<le> x", "have \"2 * (x gchoose k) \\<le> x - (x - y) gchoose k + (x + (x - y) gchoose k)\""], ["proof (prove)\nusing this:\n  0 \\<le> x - y\n  x - y \\<le> x\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - (x - y) gchoose k + (x + (x - y) gchoose k)", "by (rule binomial_int_ineq_2)"], ["proof (state)\nthis:\n  2 * (x gchoose k) \\<le> x - (x - y) gchoose k + (x + (x - y) gchoose k)\n\ngoal (2 subgoals):\n 1. y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n 2. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 * (x gchoose k) \\<le> x - (x - y) gchoose k + (x + (x - y) gchoose k)\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "by simp"], ["proof (state)\nthis:\n  2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "case False"], ["proof (state)\nthis:\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "hence \"0 \\<le> y - x\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> y - x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> y - x\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "moreover"], ["proof (state)\nthis:\n  0 \\<le> y - x\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "from assms(2)"], ["proof (chain)\npicking this:\n  y \\<le> 2 * x", "have \"y - x \\<le> x\""], ["proof (prove)\nusing this:\n  y \\<le> 2 * x\n\ngoal (1 subgoal):\n 1. y - x \\<le> x", "by simp"], ["proof (state)\nthis:\n  y - x \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> y - x\n  y - x \\<le> x", "have \"2 * (x gchoose k) \\<le> x - (y - x) gchoose k + (x + (y - x) gchoose k)\""], ["proof (prove)\nusing this:\n  0 \\<le> y - x\n  y - x \\<le> x\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> x - (y - x) gchoose k + (x + (y - x) gchoose k)", "by (rule binomial_int_ineq_2)"], ["proof (state)\nthis:\n  2 * (x gchoose k) \\<le> x - (y - x) gchoose k + (x + (y - x) gchoose k)\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x \\<Longrightarrow>\n    2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 * (x gchoose k) \\<le> x - (y - x) gchoose k + (x + (y - x) gchoose k)\n\ngoal (1 subgoal):\n 1. 2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)", "by simp"], ["proof (state)\nthis:\n  2 * (x gchoose k) \\<le> y gchoose k + (2 * x - y gchoose k)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Backward Difference Operator\\<close>"], ["", "definition bw_diff :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a::{ab_group_add,one}\"\n  where \"bw_diff f x = f x - f (x - 1)\""], ["", "lemma bw_diff_const [simp]: \"bw_diff (\\<lambda>_. c) = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>_. c) = (\\<lambda>_. 0::'a)", "by (rule ext) (simp add: bw_diff_def)"], ["", "lemma bw_diff_id [simp]: \"bw_diff (\\<lambda>x. x) = (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. x) = (\\<lambda>_. 1::'a)", "by (rule ext) (simp add: bw_diff_def)"], ["", "lemma bw_diff_plus [simp]: \"bw_diff (\\<lambda>x. f x + g x) = (\\<lambda>x. bw_diff f x + bw_diff g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. f x + g x) =\n    (\\<lambda>x. bw_diff f x + bw_diff g x)", "by (rule ext) (simp add: bw_diff_def)"], ["", "lemma bw_diff_uminus [simp]: \"bw_diff (\\<lambda>x. - f x) = (\\<lambda>x. - bw_diff f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. - f x) = (\\<lambda>x. - bw_diff f x)", "by (rule ext) (simp add: bw_diff_def)"], ["", "lemma bw_diff_minus [simp]: \"bw_diff (\\<lambda>x. f x - g x) = (\\<lambda>x. bw_diff f x - bw_diff g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. f x - g x) =\n    (\\<lambda>x. bw_diff f x - bw_diff g x)", "by (rule ext) (simp add: bw_diff_def)"], ["", "lemma bw_diff_const_pow: \"(bw_diff ^^ k) (\\<lambda>_. c) = (if k = 0 then \\<lambda>_. c else (\\<lambda>_. 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ k) (\\<lambda>_. c) =\n    (if k = 0 then \\<lambda>_. c else (\\<lambda>_. 0::'a))", "by (induct k, simp_all)"], ["", "lemma bw_diff_id_pow:\n  \"(bw_diff ^^ k) (\\<lambda>x. x) = (if k = 0 then (\\<lambda>x. x) else if k = 1 then (\\<lambda>_. 1) else (\\<lambda>_. 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ k) (\\<lambda>x. x) =\n    (if k = 0 then \\<lambda>x. x\n     else if k = 1 then \\<lambda>_. 1::'a else (\\<lambda>_. 0::'a))", "by (induct k, simp_all)"], ["", "lemma bw_diff_plus_pow [simp]:\n  \"(bw_diff ^^ k) (\\<lambda>x. f x + g x) = (\\<lambda>x. (bw_diff ^^ k) f x + (bw_diff ^^ k) g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ k) (\\<lambda>x. f x + g x) =\n    (\\<lambda>x. (bw_diff ^^ k) f x + (bw_diff ^^ k) g x)", "by (induct k, simp_all)"], ["", "lemma bw_diff_uminus_pow [simp]: \"(bw_diff ^^ k) (\\<lambda>x. - f x) = (\\<lambda>x. - (bw_diff ^^ k) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ k) (\\<lambda>x. - f x) = (\\<lambda>x. - (bw_diff ^^ k) f x)", "by (induct k, simp_all)"], ["", "lemma bw_diff_minus_pow [simp]:\n  \"(bw_diff ^^ k) (\\<lambda>x. f x - g x) = (\\<lambda>x. (bw_diff ^^ k) f x - (bw_diff ^^ k) g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ k) (\\<lambda>x. f x - g x) =\n    (\\<lambda>x. (bw_diff ^^ k) f x - (bw_diff ^^ k) g x)", "by (induct k, simp_all)"], ["", "lemma bw_diff_sum_pow [simp]:\n  \"(bw_diff ^^ k) (\\<lambda>x. (\\<Sum>i\\<in>I. f i x)) = (\\<lambda>x. (\\<Sum>i\\<in>I. (bw_diff ^^ k) (f i) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ k) (\\<lambda>x. \\<Sum>i\\<in>I. f i x) =\n    (\\<lambda>x. \\<Sum>i\\<in>I. (bw_diff ^^ k) (f i) x)", "by (induct I rule: infinite_finite_induct, simp_all add: bw_diff_const_pow)"], ["", "lemma bw_diff_gbinomial:\n  assumes \"0 < k\"\n  shows \"bw_diff (\\<lambda>x::int. (x + n) gchoose k) = (\\<lambda>x. (x + n - 1) gchoose (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - 1 gchoose (k - 1))", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "fix x::int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "from assms"], ["proof (chain)\npicking this:\n  0 < k", "have eq: \"Suc (k - Suc 0) = k\""], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. Suc (k - Suc 0) = k", "by simp"], ["proof (state)\nthis:\n  Suc (k - Suc 0) = k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "have \"x + n gchoose k = (x + n - 1) + 1 gchoose (Suc (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + n gchoose k = x + n - 1 + 1 gchoose Suc (k - 1)", "by (simp add: eq)"], ["proof (state)\nthis:\n  x + n gchoose k = x + n - 1 + 1 gchoose Suc (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "also"], ["proof (state)\nthis:\n  x + n gchoose k = x + n - 1 + 1 gchoose Suc (k - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "have \"\\<dots> = (x + n - 1) gchoose (k - 1) + ((x + n - 1) gchoose (Suc (k - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + n - 1 + 1 gchoose Suc (k - 1) =\n    x + n - 1 gchoose (k - 1) + (x + n - 1 gchoose Suc (k - 1))", "by (fact gbinomial_int_Suc_Suc)"], ["proof (state)\nthis:\n  x + n - 1 + 1 gchoose Suc (k - 1) =\n  x + n - 1 gchoose (k - 1) + (x + n - 1 gchoose Suc (k - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "finally"], ["proof (chain)\npicking this:\n  x + n gchoose k =\n  x + n - 1 gchoose (k - 1) + (x + n - 1 gchoose Suc (k - 1))", "show \"bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)\""], ["proof (prove)\nusing this:\n  x + n gchoose k =\n  x + n - 1 gchoose (k - 1) + (x + n - 1 gchoose Suc (k - 1))\n\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)", "by (simp add: eq bw_diff_def algebra_simps)"], ["proof (state)\nthis:\n  bw_diff (\\<lambda>x. x + n gchoose k) x = x + n - 1 gchoose (k - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bw_diff_gbinomial_pow:\n  \"(bw_diff ^^ l) (\\<lambda>x::int. (x + n) gchoose k) =\n      (if l \\<le> k then (\\<lambda>x. (x + n - int l) gchoose (k - l)) else (\\<lambda>_. 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n    (if l \\<le> k then \\<lambda>x. x + n - int l gchoose (k - l)\n     else (\\<lambda>_. 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n    (if l \\<le> k then \\<lambda>x. x + n - int l gchoose (k - l)\n     else (\\<lambda>_. 0))", "have *: \"l0 \\<le> k \\<Longrightarrow> (bw_diff ^^ l0) (\\<lambda>x::int. (x + n) gchoose k) = (\\<lambda>x. (x + n - int l0) gchoose (k - l0))\"\n    for l0"], ["proof (prove)\ngoal (1 subgoal):\n 1. l0 \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - int l0 gchoose (k - l0))", "proof (induct l0)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ 0) (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - int 0 gchoose (k - 0))\n 2. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> k\n\ngoal (2 subgoals):\n 1. 0 \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ 0) (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - int 0 gchoose (k - 0))\n 2. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ 0) (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - int 0 gchoose (k - 0))", "by simp"], ["proof (state)\nthis:\n  (bw_diff ^^ 0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int 0 gchoose (k - 0))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "case (Suc l0)"], ["proof (state)\nthis:\n  l0 \\<le> k \\<Longrightarrow>\n  (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int l0 gchoose (k - l0))\n  Suc l0 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "from Suc.prems"], ["proof (chain)\npicking this:\n  Suc l0 \\<le> k", "have \"0 < k - l0\" and \"l0 \\<le> k\""], ["proof (prove)\nusing this:\n  Suc l0 \\<le> k\n\ngoal (1 subgoal):\n 1. 0 < k - l0 &&& l0 \\<le> k", "by simp_all"], ["proof (state)\nthis:\n  0 < k - l0\n  l0 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "from this(2)"], ["proof (chain)\npicking this:\n  l0 \\<le> k", "have eq: \"(bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) = (\\<lambda>x. x + n - int l0 gchoose (k - l0))\""], ["proof (prove)\nusing this:\n  l0 \\<le> k\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - int l0 gchoose (k - l0))", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int l0 gchoose (k - l0))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "have \"(bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) = bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n    bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0))", "by (simp add: eq algebra_simps)"], ["proof (state)\nthis:\n  (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n  bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n  bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "from \\<open>0 < k - l0\\<close>"], ["proof (chain)\npicking this:\n  0 < k - l0", "have \"\\<dots> = (\\<lambda>x. (x + (n - int l0) - 1) gchoose (k - l0 - 1))\""], ["proof (prove)\nusing this:\n  0 < k - l0\n\ngoal (1 subgoal):\n 1. bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0)) =\n    (\\<lambda>x. x + (n - int l0) - 1 gchoose (k - l0 - 1))", "by (rule bw_diff_gbinomial)"], ["proof (state)\nthis:\n  bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0)) =\n  (\\<lambda>x. x + (n - int l0) - 1 gchoose (k - l0 - 1))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "also"], ["proof (state)\nthis:\n  bw_diff (\\<lambda>x. x + (n - int l0) gchoose (k - l0)) =\n  (\\<lambda>x. x + (n - int l0) - 1 gchoose (k - l0 - 1))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "have \"\\<dots> = (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + (n - int l0) - 1 gchoose (k - l0 - 1)) =\n    (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>x. x + (n - int l0) - 1 gchoose (k - l0 - 1)) =\n  (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))\n\ngoal (1 subgoal):\n 1. \\<And>l0.\n       \\<lbrakk>l0 \\<le> k \\<Longrightarrow>\n                (bw_diff ^^ l0) (\\<lambda>x. x + n gchoose k) =\n                (\\<lambda>x. x + n - int l0 gchoose (k - l0));\n        Suc l0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n                         (\\<lambda>x.\n                             x + n - int (Suc l0) gchoose (k - Suc l0))", "finally"], ["proof (chain)\npicking this:\n  (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))", "show ?case"], ["proof (prove)\nusing this:\n  (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n    (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))", "."], ["proof (state)\nthis:\n  (bw_diff ^^ Suc l0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int (Suc l0) gchoose (k - Suc l0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?l0.0 \\<le> k \\<Longrightarrow>\n  (bw_diff ^^ ?l0.0) (\\<lambda>x. x + n gchoose k) =\n  (\\<lambda>x. x + n - int ?l0.0 gchoose (k - ?l0.0))\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n    (if l \\<le> k then \\<lambda>x. x + n - int l gchoose (k - l)\n     else (\\<lambda>_. 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n    (if l \\<le> k then \\<lambda>x. x + n - int l gchoose (k - l)\n     else (\\<lambda>_. 0))", "proof (simp add: * split: if_split, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "assume \"\\<not> l \\<le> k\""], ["proof (state)\nthis:\n  \\<not> l \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "hence \"(l - k) + k = l\" and \"l - k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> l \\<le> k\n\ngoal (1 subgoal):\n 1. l - k + k = l &&& l - k \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  l - k + k = l\n  l - k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "hence \"(bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (bw_diff ^^ ((l - k) + k)) (\\<lambda>x. x + n gchoose k)\""], ["proof (prove)\nusing this:\n  l - k + k = l\n  l - k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n    (bw_diff ^^ (l - k + k)) (\\<lambda>x. x + n gchoose k)", "by (simp only:)"], ["proof (state)\nthis:\n  (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n  (bw_diff ^^ (l - k + k)) (\\<lambda>x. x + n gchoose k)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n  (bw_diff ^^ (l - k + k)) (\\<lambda>x. x + n gchoose k)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "have \"\\<dots> = (bw_diff ^^ (l - k)) (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ (l - k + k)) (\\<lambda>x. x + n gchoose k) =\n    (bw_diff ^^ (l - k)) (\\<lambda>_. 1)", "by (simp add: * funpow_add)"], ["proof (state)\nthis:\n  (bw_diff ^^ (l - k + k)) (\\<lambda>x. x + n gchoose k) =\n  (bw_diff ^^ (l - k)) (\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ (l - k + k)) (\\<lambda>x. x + n gchoose k) =\n  (bw_diff ^^ (l - k)) (\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "from \\<open>l - k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  l - k \\<noteq> 0", "have \"\\<dots> = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  l - k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ (l - k)) (\\<lambda>_. 1) = (\\<lambda>_. 0)", "by (simp add: bw_diff_const_pow)"], ["proof (state)\nthis:\n  (bw_diff ^^ (l - k)) (\\<lambda>_. 1) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> k \\<Longrightarrow>\n    (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "finally"], ["proof (chain)\npicking this:\n  (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "show \"(bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)", "."], ["proof (state)\nthis:\n  (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) = (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bw_diff ^^ l) (\\<lambda>x. x + n gchoose k) =\n  (if l \\<le> k then \\<lambda>x. x + n - int l gchoose (k - l)\n   else (\\<lambda>_. 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* theory *)"]]}