{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay/Poly_Fun.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay", "problem_names": ["lemma poly_funI: \"(\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow> poly_fun f\"", "lemma poly_funE:\n  assumes \"poly_fun f\"\n  obtains p where \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\"", "lemma poly_fun_eqI:\n  assumes \"poly_fun f\" and \"poly_fun g\" and \"infinite {a. f a = g a}\"\n  shows \"f = g\"", "lemma poly_fun_const [simp]: \"poly_fun (\\<lambda>_. c)\"", "lemma poly_fun_id [simp]: \"poly_fun (\\<lambda>x. x)\" \"poly_fun id\"", "lemma poly_fun_uminus:\n  assumes \"poly_fun f\"\n  shows \"poly_fun (\\<lambda>x. - f x)\" and \"poly_fun (- f)\"", "lemma poly_fun_uminus_iff [simp]:\n  \"poly_fun (\\<lambda>x. - f x) \\<longleftrightarrow> poly_fun f\" \"poly_fun (- f) \\<longleftrightarrow> poly_fun f\"", "lemma poly_fun_plus [simp]:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f x + g x)\"", "lemma poly_fun_minus [simp]:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f x - g x)\"", "lemma poly_fun_times [simp]:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f x * g x)\"", "lemma poly_fun_divide:\n  assumes \"poly_fun f\" and \"\\<And>a. c dvd f a\"\n  shows \"poly_fun (\\<lambda>x. f x div c)\"", "lemma poly_fun_pow [simp]:\n  assumes \"poly_fun f\"\n  shows \"poly_fun (\\<lambda>x. f x ^ k)\"", "lemma poly_fun_comp:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f (g x))\" and \"poly_fun (f \\<circ> g)\"", "lemma poly_fun_sum [simp]: \"(\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow> poly_fun (\\<lambda>x. (\\<Sum>i\\<in>I. f i x))\"", "lemma poly_fun_prod [simp]: \"(\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow> poly_fun (\\<lambda>x. (\\<Prod>i\\<in>I. f i x))\"", "lemma poly_fun_pochhammer [simp]: \"poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. pochhammer (f x) k)\"", "lemma poly_fun_gbinomial [simp]: \"poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. f x gchoose k)\""], "translations": [["", "lemma poly_funI: \"(\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow> poly_fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n    poly_fun f", "by (auto simp: poly_fun_def)"], ["", "lemma poly_funE:\n  assumes \"poly_fun f\"\n  obtains p where \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: poly_fun_def)"], ["", "lemma poly_fun_eqI:\n  assumes \"poly_fun f\" and \"poly_fun g\" and \"infinite {a. f a = g a}\"\n  shows \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "from assms(2)"], ["proof (chain)\npicking this:\n  poly_fun g", "obtain q where q: \"\\<And>a. rat_of_int (g a) = poly q (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun g\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (\\<And>a.\n            rat_of_int (g a) = poly q (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (g ?a) = poly q (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "have \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "let ?A = \"{a. poly p (rat_of_int a) = poly q (rat_of_int a)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "assume \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"p - q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p - q \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  p - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence fin: \"finite {x. poly (p - q) x = 0}\""], ["proof (prove)\nusing this:\n  p - q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly (p - q) x = 0}", "by (rule poly_roots_finite)"], ["proof (state)\nthis:\n  finite {x. poly (p - q) x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"rat_of_int ` ?A \\<subseteq> {x. poly (p - q) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n    \\<subseteq> {x. poly (p - q) x = 0}", "by (simp add: image_Collect_subsetI)"], ["proof (state)\nthis:\n  rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n  \\<subseteq> {x. poly (p - q) x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "hence \"finite (rat_of_int ` ?A)\""], ["proof (prove)\nusing this:\n  rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n  \\<subseteq> {x. poly (p - q) x = 0}\n\ngoal (1 subgoal):\n 1. finite (rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)})", "using fin"], ["proof (prove)\nusing this:\n  rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n  \\<subseteq> {x. poly (p - q) x = 0}\n  finite {x. poly (p - q) x = 0}\n\ngoal (1 subgoal):\n 1. finite (rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)})", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)})\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  finite (rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)})\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"inj_on rat_of_int ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on rat_of_int {a. poly p (rat_of_int a) = poly q (rat_of_int a)}", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj_on rat_of_int {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  finite (rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)})\n  inj_on rat_of_int {a. poly p (rat_of_int a) = poly q (rat_of_int a)}", "have \"finite ?A\""], ["proof (prove)\nusing this:\n  finite (rat_of_int ` {a. poly p (rat_of_int a) = poly q (rat_of_int a)})\n  inj_on rat_of_int {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n\ngoal (1 subgoal):\n 1. finite {a. poly p (rat_of_int a) = poly q (rat_of_int a)}", "by (simp only: finite_image_iff)"], ["proof (state)\nthis:\n  finite {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  finite {a. poly p (rat_of_int a) = poly q (rat_of_int a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"?A = {a. f a = g a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. poly p (rat_of_int a) = poly q (rat_of_int a)} = {a. f a = g a}", "by (simp flip: p q)"], ["proof (state)\nthis:\n  {a. poly p (rat_of_int a) = poly q (rat_of_int a)} = {a. f a = g a}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  finite {a. f a = g a}", "show False"], ["proof (prove)\nusing this:\n  finite {a. f a = g a}\n\ngoal (1 subgoal):\n 1. False", "using assms(3)"], ["proof (prove)\nusing this:\n  finite {a. f a = g a}\n  infinite {a. f a = g a}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "hence \"rat_of_int (f a) = rat_of_int (g a)\""], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. rat_of_int (f a) = rat_of_int (g a)", "by (simp add: p q)"], ["proof (state)\nthis:\n  rat_of_int (f a) = rat_of_int (g a)\n\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "thus \"f a = g a\""], ["proof (prove)\nusing this:\n  rat_of_int (f a) = rat_of_int (g a)\n\ngoal (1 subgoal):\n 1. f a = g a", "by simp"], ["proof (state)\nthis:\n  f a = g a\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_fun_eqI_ge:\n  assumes \"poly_fun f\" and \"poly_fun g\" and \"\\<And>a. b \\<le> a \\<Longrightarrow> f a = g a\"\n  shows \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  poly_fun f\n  poly_fun g\n\ngoal (1 subgoal):\n 1. f = g", "proof (rule poly_fun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "have \"{b..} \\<subseteq> {a. f a = g a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b..} \\<subseteq> {a. f a = g a}", "by (auto intro: assms(3))"], ["proof (state)\nthis:\n  {b..} \\<subseteq> {a. f a = g a}\n\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "thus \"infinite {a. f a = g a}\""], ["proof (prove)\nusing this:\n  {b..} \\<subseteq> {a. f a = g a}\n\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "using infinite_Ici"], ["proof (prove)\nusing this:\n  {b..} \\<subseteq> {a. f a = g a}\n  infinite {?a..}\n\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "by (rule infinite_super)"], ["proof (state)\nthis:\n  infinite {a. f a = g a}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_fun_eqI_gr:\n  assumes \"poly_fun f\" and \"poly_fun g\" and \"\\<And>a. b < a \\<Longrightarrow> f a = g a\"\n  shows \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  poly_fun f\n  poly_fun g\n\ngoal (1 subgoal):\n 1. f = g", "proof (rule poly_fun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "have \"{b<..} \\<subseteq> {a. f a = g a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b<..} \\<subseteq> {a. f a = g a}", "by (auto intro: assms(3))"], ["proof (state)\nthis:\n  {b<..} \\<subseteq> {a. f a = g a}\n\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "thus \"infinite {a. f a = g a}\""], ["proof (prove)\nusing this:\n  {b<..} \\<subseteq> {a. f a = g a}\n\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "using infinite_Ioi"], ["proof (prove)\nusing this:\n  {b<..} \\<subseteq> {a. f a = g a}\n  infinite {?a<..}\n\ngoal (1 subgoal):\n 1. infinite {a. f a = g a}", "by (rule infinite_super)"], ["proof (state)\nthis:\n  infinite {a. f a = g a}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure Properties\\<close>"], ["", "lemma poly_fun_const [simp]: \"poly_fun (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>_. c)", "by (rule poly_funI[where p=\"[:rat_of_int c:]\"]) simp"], ["", "lemma poly_fun_id [simp]: \"poly_fun (\\<lambda>x. x)\" \"poly_fun id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. x) &&& poly_fun id", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. x)\n 2. poly_fun id", "show \"poly_fun (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. x)", "by (rule poly_funI[where p=\"[:0, 1:]\"]) simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. poly_fun id", "thus \"poly_fun id\""], ["proof (prove)\nusing this:\n  poly_fun (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. poly_fun id", "by (simp only: id_def)"], ["proof (state)\nthis:\n  poly_fun id\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_uminus:\n  assumes \"poly_fun f\"\n  shows \"poly_fun (\\<lambda>x. - f x)\" and \"poly_fun (- f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. - f x) &&& poly_fun (- f)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. - f x)\n 2. poly_fun (- f)", "from assms"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. - f x)\n 2. poly_fun (- f)", "show \"poly_fun (\\<lambda>x. - f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. - f x)", "by (rule poly_funI[where p=\"- p\"]) (simp add: p)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. - f x)\n\ngoal (1 subgoal):\n 1. poly_fun (- f)", "thus \"poly_fun (- f)\""], ["proof (prove)\nusing this:\n  poly_fun (\\<lambda>x. - f x)\n\ngoal (1 subgoal):\n 1. poly_fun (- f)", "by (simp only: fun_Compl_def)"], ["proof (state)\nthis:\n  poly_fun (- f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_uminus_iff [simp]:\n  \"poly_fun (\\<lambda>x. - f x) \\<longleftrightarrow> poly_fun f\" \"poly_fun (- f) \\<longleftrightarrow> poly_fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. - f x) = poly_fun f &&&\n    poly_fun (- f) = poly_fun f", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. - f x) = poly_fun f\n 2. poly_fun (- f) = poly_fun f", "show \"poly_fun (\\<lambda>x. - f x) \\<longleftrightarrow> poly_fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. - f x) = poly_fun f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. - f x) \\<Longrightarrow> poly_fun f\n 2. poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. - f x)", "assume \"poly_fun (\\<lambda>x. - f x)\""], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. - f x)\n\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. - f x) \\<Longrightarrow> poly_fun f\n 2. poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. - f x)", "hence \"poly_fun (\\<lambda>x. - (- f x))\""], ["proof (prove)\nusing this:\n  poly_fun (\\<lambda>x. - f x)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. - (- f x))", "by (rule poly_fun_uminus)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. - (- f x))\n\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. - f x) \\<Longrightarrow> poly_fun f\n 2. poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. - f x)", "thus \"poly_fun f\""], ["proof (prove)\nusing this:\n  poly_fun (\\<lambda>x. - (- f x))\n\ngoal (1 subgoal):\n 1. poly_fun f", "by simp"], ["proof (state)\nthis:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. - f x)", "qed (rule poly_fun_uminus)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. - f x) = poly_fun f\n\ngoal (1 subgoal):\n 1. poly_fun (- f) = poly_fun f", "thus \"poly_fun (- f) \\<longleftrightarrow> poly_fun f\""], ["proof (prove)\nusing this:\n  poly_fun (\\<lambda>x. - f x) = poly_fun f\n\ngoal (1 subgoal):\n 1. poly_fun (- f) = poly_fun f", "by (simp only: fun_Compl_def)"], ["proof (state)\nthis:\n  poly_fun (- f) = poly_fun f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_plus [simp]:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f x + g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x + g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x + g x)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x + g x)", "from assms(2)"], ["proof (chain)\npicking this:\n  poly_fun g", "obtain q where q: \"\\<And>a. rat_of_int (g a) = poly q (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun g\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (\\<And>a.\n            rat_of_int (g a) = poly q (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (g ?a) = poly q (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x + g x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x + g x)", "by (rule poly_funI[where p=\"p + q\"]) (simp add: p q)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f x + g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_minus [simp]:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f x - g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x - g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x - g x)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x - g x)", "from assms(2)"], ["proof (chain)\npicking this:\n  poly_fun g", "obtain q where q: \"\\<And>a. rat_of_int (g a) = poly q (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun g\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (\\<And>a.\n            rat_of_int (g a) = poly q (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (g ?a) = poly q (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x - g x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x - g x)", "by (rule poly_funI[where p=\"p - q\"]) (simp add: p q)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f x - g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_times [simp]:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f x * g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x * g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x * g x)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x * g x)", "from assms(2)"], ["proof (chain)\npicking this:\n  poly_fun g", "obtain q where q: \"\\<And>a. rat_of_int (g a) = poly q (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun g\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (\\<And>a.\n            rat_of_int (g a) = poly q (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (g ?a) = poly q (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x * g x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x * g x)", "by (rule poly_funI[where p=\"p * q\"]) (simp add: p q)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f x * g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_divide:\n  assumes \"poly_fun f\" and \"\\<And>a. c dvd f a\"\n  shows \"poly_fun (\\<lambda>x. f x div c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x div c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x div c)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x div c)", "let ?p = \"p * [:1 / rat_of_int c:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x div c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x div c)", "proof (rule poly_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. rat_of_int (f a div c) = poly ?p (rat_of_int a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. rat_of_int (f a div c) = poly ?p (rat_of_int a)", "have \"c dvd f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c dvd f a", "by fact"], ["proof (state)\nthis:\n  c dvd f a\n\ngoal (1 subgoal):\n 1. \\<And>a. rat_of_int (f a div c) = poly ?p (rat_of_int a)", "hence \"rat_of_int (f a div c) = rat_of_int (f a) / rat_of_int c\""], ["proof (prove)\nusing this:\n  c dvd f a\n\ngoal (1 subgoal):\n 1. rat_of_int (f a div c) = rat_of_int (f a) / rat_of_int c", "by auto"], ["proof (state)\nthis:\n  rat_of_int (f a div c) = rat_of_int (f a) / rat_of_int c\n\ngoal (1 subgoal):\n 1. \\<And>a. rat_of_int (f a div c) = poly ?p (rat_of_int a)", "also"], ["proof (state)\nthis:\n  rat_of_int (f a div c) = rat_of_int (f a) / rat_of_int c\n\ngoal (1 subgoal):\n 1. \\<And>a. rat_of_int (f a div c) = poly ?p (rat_of_int a)", "have \"\\<dots> = poly ?p (rat_of_int a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (f a) / rat_of_int c =\n    poly (p * [:1 / rat_of_int c:]) (rat_of_int a)", "by (simp add: p)"], ["proof (state)\nthis:\n  rat_of_int (f a) / rat_of_int c =\n  poly (p * [:1 / rat_of_int c:]) (rat_of_int a)\n\ngoal (1 subgoal):\n 1. \\<And>a. rat_of_int (f a div c) = poly ?p (rat_of_int a)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (f a div c) = poly (p * [:1 / rat_of_int c:]) (rat_of_int a)", "show \"rat_of_int (f a div c) = poly ?p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  rat_of_int (f a div c) = poly (p * [:1 / rat_of_int c:]) (rat_of_int a)\n\ngoal (1 subgoal):\n 1. rat_of_int (f a div c) = poly (p * [:1 / rat_of_int c:]) (rat_of_int a)", "."], ["proof (state)\nthis:\n  rat_of_int (f a div c) = poly (p * [:1 / rat_of_int c:]) (rat_of_int a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f x div c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_pow [simp]:\n  assumes \"poly_fun f\"\n  shows \"poly_fun (\\<lambda>x. f x ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x ^ k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x ^ k)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x ^ k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f x ^ k)", "by (rule poly_funI[where p=\"p ^ k\"]) (simp add: p)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f x ^ k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_comp:\n  assumes \"poly_fun f\" and \"poly_fun g\"\n  shows \"poly_fun (\\<lambda>x. f (g x))\" and \"poly_fun (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f (g x)) &&& poly_fun (f \\<circ> g)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. f (g x))\n 2. poly_fun (f \\<circ> g)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly_fun f", "obtain p where p: \"\\<And>a. rat_of_int (f a) = poly p (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun f\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>a.\n            rat_of_int (f a) = poly p (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (f ?a) = poly p (rat_of_int ?a)\n\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. f (g x))\n 2. poly_fun (f \\<circ> g)", "from assms(2)"], ["proof (chain)\npicking this:\n  poly_fun g", "obtain q where q: \"\\<And>a. rat_of_int (g a) = poly q (rat_of_int a)\""], ["proof (prove)\nusing this:\n  poly_fun g\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        (\\<And>a.\n            rat_of_int (g a) = poly q (rat_of_int a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_funE, blast)"], ["proof (state)\nthis:\n  rat_of_int (g ?a) = poly q (rat_of_int ?a)\n\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>x. f (g x))\n 2. poly_fun (f \\<circ> g)", "show \"poly_fun (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f (g x))", "by (rule poly_funI[where p=\"p \\<circ>\\<^sub>p q\"]) (simp add: p q poly_pcompose)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. poly_fun (f \\<circ> g)", "thus \"poly_fun (f \\<circ> g)\""], ["proof (prove)\nusing this:\n  poly_fun (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. poly_fun (f \\<circ> g)", "by (simp only: comp_def)"], ["proof (state)\nthis:\n  poly_fun (f \\<circ> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_sum [simp]: \"(\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow> poly_fun (\\<lambda>x. (\\<Sum>i\\<in>I. f i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "proof (induct I rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun (\\<lambda>x. \\<Sum>i\\<in>A. f i x)\n 2. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "case (infinite I)"], ["proof (state)\nthis:\n  infinite I\n  ?i \\<in> I \\<Longrightarrow> poly_fun (f ?i)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun (\\<lambda>x. \\<Sum>i\\<in>A. f i x)\n 2. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "from infinite(1)"], ["proof (chain)\npicking this:\n  infinite I", "show ?case"], ["proof (prove)\nusing this:\n  infinite I\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "by simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "case empty"], ["proof (state)\nthis:\n  ?i \\<in> {} \\<Longrightarrow> poly_fun (f ?i)\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)", "by simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>{}. f i x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\n  ?i \\<in> insert i I \\<Longrightarrow> poly_fun (f ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "have \"i \\<in> insert i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> insert i I", "by simp"], ["proof (state)\nthis:\n  i \\<in> insert i I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "hence \"poly_fun (f i)\""], ["proof (prove)\nusing this:\n  i \\<in> insert i I\n\ngoal (1 subgoal):\n 1. poly_fun (f i)", "by (rule insert.prems)"], ["proof (state)\nthis:\n  poly_fun (f i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "moreover"], ["proof (state)\nthis:\n  poly_fun (f i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "have \"poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "proof (rule insert.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "assume \"j \\<in> I\""], ["proof (state)\nthis:\n  j \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "hence \"j \\<in> insert i I\""], ["proof (prove)\nusing this:\n  j \\<in> I\n\ngoal (1 subgoal):\n 1. j \\<in> insert i I", "by simp"], ["proof (state)\nthis:\n  j \\<in> insert i I\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "thus \"poly_fun (f j)\""], ["proof (prove)\nusing this:\n  j \\<in> insert i I\n\ngoal (1 subgoal):\n 1. poly_fun (f j)", "by (rule insert.prems)"], ["proof (state)\nthis:\n  poly_fun (f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "ultimately"], ["proof (chain)\npicking this:\n  poly_fun (f i)\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "have \"poly_fun (\\<lambda>x. f i x + (\\<Sum>i\\<in>I. f i x))\""], ["proof (prove)\nusing this:\n  poly_fun (f i)\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f i x + (\\<Sum>i\\<in>I. f i x))", "by (rule poly_fun_plus)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f i x + (\\<Sum>i\\<in>I. f i x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Sum>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Sum>i\\<in>insert x F. f i xa)", "with insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite I\n  i \\<notin> I\n  poly_fun (\\<lambda>x. f i x + (\\<Sum>i\\<in>I. f i x))", "show ?case"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  poly_fun (\\<lambda>x. f i x + (\\<Sum>i\\<in>I. f i x))\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Sum>i\\<in>insert i I. f i x)", "by simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Sum>i\\<in>insert i I. f i x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_prod [simp]: \"(\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow> poly_fun (\\<lambda>x. (\\<Prod>i\\<in>I. f i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)", "proof (induct I rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun (\\<lambda>x. \\<Prod>i\\<in>A. f i x)\n 2. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "case (infinite I)"], ["proof (state)\nthis:\n  infinite I\n  ?i \\<in> I \\<Longrightarrow> poly_fun (f ?i)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun (\\<lambda>x. \\<Prod>i\\<in>A. f i x)\n 2. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "from infinite(1)"], ["proof (chain)\npicking this:\n  infinite I", "show ?case"], ["proof (prove)\nusing this:\n  infinite I\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)", "by simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "case empty"], ["proof (state)\nthis:\n  ?i \\<in> {} \\<Longrightarrow> poly_fun (f ?i)\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n    poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)", "by simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>{}. f i x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\n  ?i \\<in> insert i I \\<Longrightarrow> poly_fun (f ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "have \"i \\<in> insert i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> insert i I", "by simp"], ["proof (state)\nthis:\n  i \\<in> insert i I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "hence \"poly_fun (f i)\""], ["proof (prove)\nusing this:\n  i \\<in> insert i I\n\ngoal (1 subgoal):\n 1. poly_fun (f i)", "by (rule insert.prems)"], ["proof (state)\nthis:\n  poly_fun (f i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "moreover"], ["proof (state)\nthis:\n  poly_fun (f i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "have \"poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)", "proof (rule insert.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "assume \"j \\<in> I\""], ["proof (state)\nthis:\n  j \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "hence \"j \\<in> insert i I\""], ["proof (prove)\nusing this:\n  j \\<in> I\n\ngoal (1 subgoal):\n 1. j \\<in> insert i I", "by simp"], ["proof (state)\nthis:\n  j \\<in> insert i I\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> poly_fun (f i)", "thus \"poly_fun (f j)\""], ["proof (prove)\nusing this:\n  j \\<in> insert i I\n\ngoal (1 subgoal):\n 1. poly_fun (f j)", "by (rule insert.prems)"], ["proof (state)\nthis:\n  poly_fun (f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "ultimately"], ["proof (chain)\npicking this:\n  poly_fun (f i)\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)", "have \"poly_fun (\\<lambda>x. f i x * (\\<Prod>i\\<in>I. f i x))\""], ["proof (prove)\nusing this:\n  poly_fun (f i)\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>I. f i x)\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. f i x * (\\<Prod>i\\<in>I. f i x))", "by (rule poly_fun_times)"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. f i x * (\\<Prod>i\\<in>I. f i x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> poly_fun (f i)) \\<Longrightarrow>\n        poly_fun (\\<lambda>x. \\<Prod>i\\<in>F. f i x);\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> poly_fun (f i)\\<rbrakk>\n       \\<Longrightarrow> poly_fun\n                          (\\<lambda>xa. \\<Prod>i\\<in>insert x F. f i xa)", "with insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite I\n  i \\<notin> I\n  poly_fun (\\<lambda>x. f i x * (\\<Prod>i\\<in>I. f i x))", "show ?case"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  poly_fun (\\<lambda>x. f i x * (\\<Prod>i\\<in>I. f i x))\n\ngoal (1 subgoal):\n 1. poly_fun (\\<lambda>x. \\<Prod>i\\<in>insert i I. f i x)", "by simp"], ["proof (state)\nthis:\n  poly_fun (\\<lambda>x. \\<Prod>i\\<in>insert i I. f i x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_fun_pochhammer [simp]: \"poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. pochhammer (f x) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. pochhammer (f x) k)", "by (simp add: pochhammer_prod)"], ["", "lemma poly_fun_gbinomial [simp]: \"poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. f x gchoose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun f \\<Longrightarrow> poly_fun (\\<lambda>x. f x gchoose k)", "by (simp add: gbinomial_int_pochhammer' poly_fun_divide fact_dvd_pochhammer)"], ["", "end"], ["", "(* theory *)"]]}