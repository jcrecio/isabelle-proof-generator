{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay/Dube_Bound.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay", "problem_names": ["lemma Dube_aux_ge_d: \"d \\<le> Dube_aux j\"", "theorem \"rat_of_nat Dube \\<le> 2 * ((rat_of_nat d)\\<^sup>2 / 2 + (rat_of_nat d)) ^ (2 ^ (n - 2))\"", "lemma Hilbert_fun_cone_aux:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\" and \"homogeneous (h::_ \\<Rightarrow>\\<^sub>0 'a::field)\"\n  shows \"Hilbert_fun (cone (h, U)) z = card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\"", "lemma Hilbert_fun_cone_empty:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"homogeneous (h::_ \\<Rightarrow>\\<^sub>0 'a::field)\"\n  shows \"Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)\"", "lemma Hilbert_fun_cone_nonempty:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\" and \"homogeneous (h::_ \\<Rightarrow>\\<^sub>0 'a::field)\" and \"U \\<noteq> {}\"\n  shows \"Hilbert_fun (cone (h, U)) z =\n          (if poly_deg h \\<le> z then ((z - poly_deg h) + (card U - 1)) choose (card U - 1) else 0)\"", "lemma Hilbert_fun_cone_decomp:\n  assumes \"cone_decomp T ps\" and \"valid_decomp X ps\" and \"hom_decomp ps\"\n  shows \"Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)\"", "lemma poly_fun_Hilbert_poly: \"poly_fun (Hilbert_poly b)\"", "lemma Hilbert_fun_eq_Hilbert_poly_plus_card:\n  assumes \"X \\<noteq> {}\" and \"valid_decomp X ps\" and \"hom_decomp ps\" and \"cone_decomp T ps\"\n    and \"standard_decomp k ps\" and \"exact_decomp X 0 ps\" and \"\\<b> ps (Suc 0) \\<le> d\"\n  shows \"int (Hilbert_fun T d) = card {h::_ \\<Rightarrow>\\<^sub>0 'a::field. (h, {}) \\<in> set ps \\<and> poly_deg h = d} + Hilbert_poly (\\<b> ps) d\"", "lemma f_in_Polys: \"f \\<in> P[X]\"", "lemma hom_f: \"homogeneous f\"", "lemma f_not_0: \"f \\<noteq> 0\"", "lemma X_not_empty: \"X \\<noteq> {}\"", "lemma n_gr_0: \"0 < n\"", "lemma int_n_minus_2 [simp]: \"int (n - Suc (Suc 0)) = int n - 2\"", "lemma cone_f_X_sub: \"cone (f, X) \\<subseteq> P[X]\"", "lemma ideal_Int_Polys_eq_cone: \"ideal {f} \\<inter> P[X] = cone (f, X)\"", "lemma\n  shows valid_ps: \"valid_decomp X ps\" (is ?thesis1)\n    and std_ps: \"standard_decomp d ps\" (is ?thesis2)\n    and ext_ps: \"exact_decomp X 0 ps\" (is ?thesis3)\n    and cn_ps: \"cone_decomp P ps\" (is ?thesis4)\n    and hom_ps: \"hom_decomp ps\" (is ?thesis5)\n    and decomp_F: \"direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\" (is ?thesis6)", "lemma P_sub: \"P \\<subseteq> P[X]\"", "lemma ps_not_Nil: \"ps\\<^sub>+ \\<noteq> []\"", "lemma\n  shows valid_qs: \"valid_decomp X qs\" (is ?thesis1)\n    and std_qs: \"standard_decomp 0 qs\" (is ?thesis2)\n    and mon_qs: \"monomial_decomp qs\" (is ?thesis3)\n    and hom_qs: \"hom_decomp qs\" (is ?thesis6)\n    and cn_qs: \"cone_decomp N qs\" (is ?thesis4)\n    and ext_qs: \"exact_decomp X 0 qs\" (is ?thesis5)\n    and deg_RGB: \"g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0\"", "lemma N_sub: \"N \\<subseteq> P[X]\"", "lemma decomp_Polys: \"direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\"", "lemma aa_Suc_n [simp]: \"aa (Suc n) = d\"", "lemma bb_Suc_n [simp]: \"bb (Suc n) = 0\"", "lemma Hilbert_fun_X:\n  assumes \"d \\<le> z\"\n  shows \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) z =\n            ((z - d) + (n - 1)) choose (n - 1) + Hilbert_fun P z + Hilbert_fun N z\"", "lemma dube_eq_0:\n  \"(\\<lambda>z::int. (z + int n - 1) gchoose (n - 1)) =\n    (\\<lambda>z::int. ((z - d + n - 1) gchoose (n - 1)) + Hilbert_poly aa z + Hilbert_poly bb z)\"\n    (is \"?f = ?g\")", "lemma dube_eq_2:\n  assumes \"j < n\"\n  shows \"(\\<lambda>z::int. (z + int n - int j - 1) gchoose (n - j - 1)) =\n          (\\<lambda>z::int. ((z - d + n - int j - 1) gchoose (n - j - 1)) + ((z - d + n - j) gchoose (n - j)) +\n                    ((z + n - j) gchoose (n - j)) - 2 -\n                    (\\<Sum>i=Suc j..n. ((z - aa i + i - j - 1) gchoose (i - j)) + ((z - bb i + i - j - 1) gchoose (i - j))))\"\n    (is \"?f = ?g\")", "lemma dube_eq_3:\n  assumes \"j < n\"\n  shows \"(1::int) = (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - j) * ((int d - 1) gchoose (n - j)) - 1 -\n                    (\\<Sum>i=Suc j..n. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\"", "lemma dube_aux_1:\n  assumes \"(h, {}) \\<in> set ps \\<union> set qs\"\n  shows \"poly_deg h < max (aa 1) (bb 1)\"", "lemma\n  shows aa_n: \"aa n = d\" and bb_n: \"bb n = 0\" and bb_0: \"bb 0 \\<le> max (aa 1) (bb 1)\"", "lemma dube_eq_4:\n  assumes \"j < n\"\n  shows \"(1::int) = 2 * (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) - 1 -\n                    (\\<Sum>i=Suc j..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\"", "lemma cc_Suc:\n  assumes \"j < n - 1\"\n  shows \"int (cc (Suc j)) = 2 + 2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) +\n                   (\\<Sum>i=j+2..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\"", "lemma cc_n_minus_1: \"cc (n - 1) = 2 * d\"", "lemma cc_n_minus_2: \"cc (n - 2) \\<le> d\\<^sup>2 + 2 * d\"", "lemma cc_Suc_le:\n  assumes \"j < n - 3\"\n  shows \"int (cc (Suc j)) \\<le> 2 + (int (cc (j + 2)) gchoose 2) + (\\<Sum>i=j+4..n-1. int (cc i) gchoose (i - j))\"\n            \\<comment>\\<open>Could be proved without coercing to @{typ int}, because everything is non-negative.\\<close>", "lemma Dube_aux:\n  assumes \"g \\<in> punit.reduced_GB F\"\n  shows \"poly_deg g \\<le> Dube_aux n d 1\"", "theorem Dube:\n  assumes \"finite F\" and \"F \\<subseteq> P[X]\" and \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"g \\<in> punit.reduced_GB F\"\n  shows \"poly_deg g \\<le> Dube (card X) (maxdeg F)\"", "lemma Dube_is_GB_cofactor_bound:\n  assumes \"finite X\" and \"finite F\" and \"F \\<subseteq> P[X]\"\n  shows \"is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\"", "lemma Dube_is_GB_cofactor_bound_explicit:\n  assumes \"finite X\" and \"finite F\" and \"F \\<subseteq> P[X]\"\n  obtains G where \"punit.is_Groebner_basis G\" and \"ideal G = ideal F\" and \"G \\<subseteq> P[X]\"\n    and \"\\<And>g. g \\<in> G \\<Longrightarrow> \\<exists>q. g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n                            (\\<forall>f. q f \\<in> P[X] \\<and> poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                              (f \\<notin> F \\<longrightarrow> q f = 0))\""], "translations": [["", "lemma Dube_aux_ge_d: \"d \\<le> Dube_aux j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "proof (induct j rule: Dube_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j + 2 < n \\<Longrightarrow> d \\<le> local.Dube_aux (j + 1);\n        \\<And>x.\n           \\<lbrakk>j + 2 < n; x \\<in> {j + 3..n - 1}\\<rbrakk>\n           \\<Longrightarrow> d \\<le> local.Dube_aux x\\<rbrakk>\n       \\<Longrightarrow> d \\<le> local.Dube_aux j", "case step: (1 j)"], ["proof (state)\nthis:\n  j + 2 < n \\<Longrightarrow> d \\<le> local.Dube_aux (j + 1)\n  \\<lbrakk>j + 2 < n; ?x \\<in> {j + 3..n - 1}\\<rbrakk>\n  \\<Longrightarrow> d \\<le> local.Dube_aux ?x\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j + 2 < n \\<Longrightarrow> d \\<le> local.Dube_aux (j + 1);\n        \\<And>x.\n           \\<lbrakk>j + 2 < n; x \\<in> {j + 3..n - 1}\\<rbrakk>\n           \\<Longrightarrow> d \\<le> local.Dube_aux x\\<rbrakk>\n       \\<Longrightarrow> d \\<le> local.Dube_aux j", "have \"j + 2 < n \\<or> j + 2 = n \\<or> n < j + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j + 2 < n \\<or> j + 2 = n \\<or> n < j + 2", "by auto"], ["proof (state)\nthis:\n  j + 2 < n \\<or> j + 2 = n \\<or> n < j + 2\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j + 2 < n \\<Longrightarrow> d \\<le> local.Dube_aux (j + 1);\n        \\<And>x.\n           \\<lbrakk>j + 2 < n; x \\<in> {j + 3..n - 1}\\<rbrakk>\n           \\<Longrightarrow> d \\<le> local.Dube_aux x\\<rbrakk>\n       \\<Longrightarrow> d \\<le> local.Dube_aux j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "proof (rule linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. ?x = ?y \\<Longrightarrow> d \\<le> local.Dube_aux j\n 3. ?y < ?x \\<Longrightarrow> d \\<le> local.Dube_aux j", "assume *: \"j + 2 < n\""], ["proof (state)\nthis:\n  j + 2 < n\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. ?x = ?y \\<Longrightarrow> d \\<le> local.Dube_aux j\n 3. ?y < ?x \\<Longrightarrow> d \\<le> local.Dube_aux j", "hence 1: \"d \\<le> Dube_aux (j + 1)\""], ["proof (prove)\nusing this:\n  j + 2 < n\n\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux (j + 1)", "by (rule step.hyps)+"], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux (j + 1)\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. ?x = ?y \\<Longrightarrow> d \\<le> local.Dube_aux j\n 3. ?y < ?x \\<Longrightarrow> d \\<le> local.Dube_aux j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "proof (cases \"d \\<le> 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "case True"], ["proof (state)\nthis:\n  d \\<le> 2\n\ngoal (2 subgoals):\n 1. d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "also"], ["proof (state)\nthis:\n  d \\<le> 2\n\ngoal (2 subgoals):\n 1. d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "from *"], ["proof (chain)\npicking this:\n  j + 2 < n", "have \"2 \\<le> Dube_aux j\""], ["proof (prove)\nusing this:\n  j + 2 < n\n\ngoal (1 subgoal):\n 1. 2 \\<le> local.Dube_aux j", "by simp"], ["proof (state)\nthis:\n  2 \\<le> local.Dube_aux j\n\ngoal (2 subgoals):\n 1. d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "finally"], ["proof (chain)\npicking this:\n  d \\<le> local.Dube_aux j", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "."], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "case False"], ["proof (state)\nthis:\n  \\<not> d \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "hence \"2 < d\""], ["proof (prove)\nusing this:\n  \\<not> d \\<le> 2\n\ngoal (1 subgoal):\n 1. 2 < d", "by simp"], ["proof (state)\nthis:\n  2 < d\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "hence \"2 < Dube_aux (j + 1)\""], ["proof (prove)\nusing this:\n  2 < d\n\ngoal (1 subgoal):\n 1. 2 < local.Dube_aux (j + 1)", "using 1"], ["proof (prove)\nusing this:\n  2 < d\n  d \\<le> local.Dube_aux (j + 1)\n\ngoal (1 subgoal):\n 1. 2 < local.Dube_aux (j + 1)", "by (rule less_le_trans)"], ["proof (state)\nthis:\n  2 < local.Dube_aux (j + 1)\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  2 < local.Dube_aux (j + 1)", "have \"Dube_aux (j + 1) \\<le> Dube_aux (j + 1) choose 2\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  2 < local.Dube_aux (j + 1)\n\ngoal (1 subgoal):\n 1. local.Dube_aux (j + 1) \\<le> local.Dube_aux (j + 1) choose 2", "by (rule upper_le_binomial) simp"], ["proof (state)\nthis:\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux (j + 1) choose 2\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "also"], ["proof (state)\nthis:\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux (j + 1) choose 2\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "from *"], ["proof (chain)\npicking this:\n  j + 2 < n", "have \"\\<dots> \\<le> Dube_aux j\""], ["proof (prove)\nusing this:\n  j + 2 < n\n\ngoal (1 subgoal):\n 1. local.Dube_aux (j + 1) choose 2 \\<le> local.Dube_aux j", "by simp"], ["proof (state)\nthis:\n  local.Dube_aux (j + 1) choose 2 \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "finally"], ["proof (chain)\npicking this:\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux j", "have \"Dube_aux (j + 1) \\<le> Dube_aux j\""], ["proof (prove)\nusing this:\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. local.Dube_aux (j + 1) \\<le> local.Dube_aux j", "."], ["proof (state)\nthis:\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. \\<not> d \\<le> 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "with 1"], ["proof (chain)\npicking this:\n  d \\<le> local.Dube_aux (j + 1)\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux j", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> local.Dube_aux (j + 1)\n  local.Dube_aux (j + 1) \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "by (rule le_trans)"], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux j\n\ngoal (2 subgoals):\n 1. j + 2 = n \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. n < j + 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j + 2 = n \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. n < j + 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "assume \"j + 2 = n\""], ["proof (state)\nthis:\n  j + 2 = n\n\ngoal (2 subgoals):\n 1. j + 2 = n \\<Longrightarrow> d \\<le> local.Dube_aux j\n 2. n < j + 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j + 2 = n\n\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "by simp"], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux j\n\ngoal (1 subgoal):\n 1. n < j + 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n < j + 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "assume \"n < j + 2\""], ["proof (state)\nthis:\n  n < j + 2\n\ngoal (1 subgoal):\n 1. n < j + 2 \\<Longrightarrow> d \\<le> local.Dube_aux j", "thus ?thesis"], ["proof (prove)\nusing this:\n  n < j + 2\n\ngoal (1 subgoal):\n 1. d \\<le> local.Dube_aux j", "by simp"], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<le> local.Dube_aux j\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Dube_ge_d: \"d \\<le> Dube\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> local.Dube", "by (simp add: Dube_def Dube_aux_ge_d del: Dube_aux.simps)"], ["", "text \\<open>Dub\\'{e} in @{cite Dube1990} proves the following theorem, to obtain a short closed form for\n  the degree bound. However, the proof he gives is wrong: In the last-but-one proof step of Lemma 8.1\n  the sum on the right-hand-side of the inequality can be greater than 1/2 (e.g. for @{prop \"n = 7\"},\n  @{prop \"d = 2\"} and @{prop \"j = 1\"}), rendering the value inside the big brackets negative. This is\n  also true without the additional summand \\<open>2\\<close> we had to introduce in function @{const Dube_aux} to\n  correct another mistake found in @{cite Dube1990}.\n  Nonetheless, experiments carried out in Mathematica still suggest that the short closed form is a\n  valid upper bound for @{const Dube}, even with the additional summand \\<open>2\\<close>. So, with some effort it\n  might be possible to prove the theorem below; but in fact function @{const Dube} gives typically\n  much better (i.e. smaller) values for concrete values of \\<open>n\\<close> and \\<open>d\\<close>, so it is better to stick to\n  @{const Dube} instead of the closed form anyway. Asymptotically, as \\<open>n\\<close> tends to infinity,\n  @{const Dube} grows double exponentially, too.\\<close>"], ["", "theorem \"rat_of_nat Dube \\<le> 2 * ((rat_of_nat d)\\<^sup>2 / 2 + (rat_of_nat d)) ^ (2 ^ (n - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat local.Dube\n    \\<le> 2 * ((rat_of_nat d)\\<^sup>2 / 2 + rat_of_nat d) ^ 2 ^ (n - 2)", "oops"], ["", "end"], ["", "subsection \\<open>Hilbert Function and Hilbert Polynomial\\<close>"], ["", "context pm_powerprod\nbegin"], ["", "context\n  fixes X :: \"'x set\"\n  assumes fin_X: \"finite X\"\nbegin"], ["", "lemma Hilbert_fun_cone_aux:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\" and \"homogeneous (h::_ \\<Rightarrow>\\<^sub>0 'a::field)\"\n  shows \"Hilbert_fun (cone (h, U)) z = card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from assms(2)"], ["proof (chain)\npicking this:\n  h \\<noteq> 0", "have \"lpp h \\<in> keys h\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp h \\<in> keys h", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp h \\<in> keys h\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "with assms(4)"], ["proof (chain)\npicking this:\n  homogeneous h\n  lpp h \\<in> keys h", "have deg_h[symmetric]: \"deg_pm (lpp h) = poly_deg h\""], ["proof (prove)\nusing this:\n  homogeneous h\n  lpp h \\<in> keys h\n\ngoal (1 subgoal):\n 1. deg_pm (lpp h) = poly_deg h", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  poly_deg h = deg_pm (lpp h)\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from assms(1, 3)"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  U \\<subseteq> X", "have \"cone (h, U) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "by (rule cone_subset_PolysI)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "with fin_X"], ["proof (chain)\npicking this:\n  finite X\n  cone (h, U) \\<subseteq> P[X]", "have \"Hilbert_fun (cone (h, U)) z = card (lpp ` (hom_deg_set z (cone (h, U)) - {0}))\""], ["proof (prove)\nusing this:\n  finite X\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card (lpp ` (hom_deg_set z (cone (h, U)) - {0}))", "using subspace_cone[of \"(h, U)\"]"], ["proof (prove)\nusing this:\n  finite X\n  cone (h, U) \\<subseteq> P[X]\n  phull.subspace (cone (h, U))\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card (lpp ` (hom_deg_set z (cone (h, U)) - {0}))", "by (simp only: Hilbert_fun_alt)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card (lpp ` (hom_deg_set z (cone (h, U)) - {0}))\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "also"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card (lpp ` (hom_deg_set z (cone (h, U)) - {0}))\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from assms(4)"], ["proof (chain)\npicking this:\n  homogeneous h", "have \"lpp ` (hom_deg_set z (cone (h, U)) - {0}) =\n                            {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. lpp ` (hom_deg_set z (cone (h, U)) - {0}) =\n    {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "by (intro image_lt_hom_deg_set homogeneous_set_coneI)"], ["proof (state)\nthis:\n  lpp ` (hom_deg_set z (cone (h, U)) - {0}) =\n  {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "also"], ["proof (state)\nthis:\n  lpp ` (hom_deg_set z (cone (h, U)) - {0}) =\n  {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "have \"{t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z} =\n              (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\"  (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z} =\n    (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n    \\<subseteq> (\\<lambda>t. t + lpp h) `\n                {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n 2. (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n    \\<subseteq> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n    \\<subseteq> (\\<lambda>t. t + lpp h) `\n                {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "assume \"t \\<in> ?A\""], ["proof (state)\nthis:\n  t \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "hence \"t \\<in> lpp ` (cone (h, U) - {0})\" and \"deg_pm t = z\""], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n\ngoal (1 subgoal):\n 1. t \\<in> lpp ` (cone (h, U) - {0}) &&& deg_pm t = z", "by simp_all"], ["proof (state)\nthis:\n  t \\<in> lpp ` (cone (h, U) - {0})\n  deg_pm t = z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from this(1)"], ["proof (chain)\npicking this:\n  t \\<in> lpp ` (cone (h, U) - {0})", "obtain a where \"a \\<in> cone (h, U) - {0}\" and 2: \"t = lpp a\""], ["proof (prove)\nusing this:\n  t \\<in> lpp ` (cone (h, U) - {0})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> cone (h, U) - {0}; t = lpp a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  a \\<in> cone (h, U) - {0}\n  t = lpp a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from this(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U) - {0}", "have \"a \\<in> cone (h, U)\" and \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U) - {0}\n\ngoal (1 subgoal):\n 1. a \\<in> cone (h, U) &&& a \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from this(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain q where \"q \\<in> P[U]\" and a: \"a = q * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; a = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[U]\n  a = q * h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from \\<open>a \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "have \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by (auto simp: a)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "hence t: \"t = lpp q + lpp h\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t = lpp q + lpp h", "using assms(2)"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t = lpp q + lpp h", "unfolding 2 a"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (q * h) = lpp q + lpp h", "by (rule lp_times)"], ["proof (state)\nthis:\n  t = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "hence \"deg_pm (lpp q) + poly_deg h = deg_pm t\""], ["proof (prove)\nusing this:\n  t = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. deg_pm (lpp q) + poly_deg h = deg_pm t", "by (simp add: deg_pm_plus deg_h)"], ["proof (state)\nthis:\n  deg_pm (lpp q) + poly_deg h = deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "also"], ["proof (state)\nthis:\n  deg_pm (lpp q) + poly_deg h = deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "have \"\\<dots> = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = z", "by fact"], ["proof (state)\nthis:\n  deg_pm t = z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "finally"], ["proof (chain)\npicking this:\n  deg_pm (lpp q) + poly_deg h = z", "have \"deg_pm (lpp q) + poly_deg h = z\""], ["proof (prove)\nusing this:\n  deg_pm (lpp q) + poly_deg h = z\n\ngoal (1 subgoal):\n 1. deg_pm (lpp q) + poly_deg h = z", "."], ["proof (state)\nthis:\n  deg_pm (lpp q) + poly_deg h = z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "moreover"], ["proof (state)\nthis:\n  deg_pm (lpp q) + poly_deg h = z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "from \\<open>q \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[U]", "have \"lpp q \\<in> .[U]\""], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n\ngoal (1 subgoal):\n 1. lpp q \\<in> .[U]", "by (rule PPs_closed_lpp)"], ["proof (state)\nthis:\n  lpp q \\<in> .[U]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "ultimately"], ["proof (chain)\npicking this:\n  deg_pm (lpp q) + poly_deg h = z\n  lpp q \\<in> .[U]", "have \"lpp q \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\""], ["proof (prove)\nusing this:\n  deg_pm (lpp q) + poly_deg h = z\n  lpp q \\<in> .[U]\n\ngoal (1 subgoal):\n 1. lpp q \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "by simp"], ["proof (state)\nthis:\n  lpp q \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "moreover"], ["proof (state)\nthis:\n  lpp q \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "have \"t = lpp q + lpp h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = lpp q + lpp h", "by (simp only: t)"], ["proof (state)\nthis:\n  t = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}).\n                deg_pm t = z} \\<Longrightarrow>\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "ultimately"], ["proof (chain)\npicking this:\n  lpp q \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n  t = lpp q + lpp h", "show \"t \\<in> ?B\""], ["proof (prove)\nusing this:\n  lpp q \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n  t = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. t + lpp h) `\n            {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "by (rule rev_image_eqI)"], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>t. t + lpp h) `\n          {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n  \\<subseteq> (\\<lambda>t. t + lpp h) `\n              {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n    \\<subseteq> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n    \\<subseteq> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "show \"?B \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n    \\<subseteq> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "assume \"t \\<in> ?B\""], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>t. t + lpp h) `\n          {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "then"], ["proof (chain)\npicking this:\n  t \\<in> (\\<lambda>t. t + lpp h) `\n          {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "obtain s where \"s \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\"\n        and t1: \"t = s + lpp h\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. t + lpp h) `\n          {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z};\n         t = s + lpp h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n  t = s + lpp h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "have \"s \\<in> .[U]\" and 1: \"deg_pm s + poly_deg h = z\""], ["proof (prove)\nusing this:\n  s \\<in> {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. s \\<in> .[U] &&& deg_pm s + poly_deg h = z", "by simp_all"], ["proof (state)\nthis:\n  s \\<in> .[U]\n  deg_pm s + poly_deg h = z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "let ?q = \"monomial (1::'a) s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "have \"?q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<noteq> 0", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "hence \"?q * h \\<noteq> 0\" and \"lpp (?q * h) = lpp ?q + lpp h\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * h \\<noteq> 0 &&&\n    lpp (monomial (1::'a) s * h) = lpp (monomial (1::'a) s) + lpp h", "using \\<open>h \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  monomial (1::'a) s \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * h \\<noteq> 0 &&&\n    lpp (monomial (1::'a) s * h) = lpp (monomial (1::'a) s) + lpp h", "by (rule times_not_zero, rule lp_times)"], ["proof (state)\nthis:\n  monomial (1::'a) s * h \\<noteq> 0\n  lpp (monomial (1::'a) s * h) = lpp (monomial (1::'a) s) + lpp h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "hence t: \"t = lpp (?q * h)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s * h \\<noteq> 0\n  lpp (monomial (1::'a) s * h) = lpp (monomial (1::'a) s) + lpp h\n\ngoal (1 subgoal):\n 1. t = lpp (monomial (1::'a) s * h)", "by (simp add: t1 punit.lt_monomial)"], ["proof (state)\nthis:\n  t = lpp (monomial (1::'a) s * h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "from \\<open>s \\<in> .[U]\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> .[U]", "have \"?q \\<in> P[U]\""], ["proof (prove)\nusing this:\n  s \\<in> .[U]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> P[U]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "with refl"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[U]", "have \"?q * h \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * h \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (1::'a) s * h \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "moreover"], ["proof (state)\nthis:\n  monomial (1::'a) s * h \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "from _ assms(2)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  h \\<noteq> 0", "have \"?q * h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * h \\<noteq> 0", "by (rule times_not_zero) (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  monomial (1::'a) s * h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "ultimately"], ["proof (chain)\npicking this:\n  monomial (1::'a) s * h \\<in> cone (h, U)\n  monomial (1::'a) s * h \\<noteq> 0", "have \"?q * h \\<in> cone (h, U) - {0}\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s * h \\<in> cone (h, U)\n  monomial (1::'a) s * h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * h \\<in> cone (h, U) - {0}", "by simp"], ["proof (state)\nthis:\n  monomial (1::'a) s * h \\<in> cone (h, U) - {0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "hence \"t \\<in> lpp ` (cone (h, U) - {0})\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s * h \\<in> cone (h, U) - {0}\n\ngoal (1 subgoal):\n 1. t \\<in> lpp ` (cone (h, U) - {0})", "unfolding t"], ["proof (prove)\nusing this:\n  monomial (1::'a) s * h \\<in> cone (h, U) - {0}\n\ngoal (1 subgoal):\n 1. lpp (monomial (1::'a) s * h) \\<in> lpp ` (cone (h, U) - {0})", "by (rule imageI)"], ["proof (state)\nthis:\n  t \\<in> lpp ` (cone (h, U) - {0})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "moreover"], ["proof (state)\nthis:\n  t \\<in> lpp ` (cone (h, U) - {0})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "have \"deg_pm t = int z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (deg_pm t) = int z", "by (simp add: t1) (simp add: deg_pm_plus deg_h flip: 1)"], ["proof (state)\nthis:\n  int (deg_pm t) = int z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>t. t + lpp h) `\n               {t \\<in> .[U]. deg_pm t + poly_deg h = z} \\<Longrightarrow>\n       x \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> lpp ` (cone (h, U) - {0})\n  int (deg_pm t) = int z", "show \"t \\<in> ?A\""], ["proof (prove)\nusing this:\n  t \\<in> lpp ` (cone (h, U) - {0})\n  int (deg_pm t) = int z\n\ngoal (1 subgoal):\n 1. t \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}", "by simp"], ["proof (state)\nthis:\n  t \\<in> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n  \\<subseteq> {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z} =\n  (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "also"], ["proof (state)\nthis:\n  {t \\<in> lpp ` (cone (h, U) - {0}). deg_pm t = z} =\n  (\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "have \"card \\<dots> = card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}) =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "by (simp add: card_image)"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>t. t + lpp h) ` {t \\<in> .[U]. deg_pm t + poly_deg h = z}) =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "."], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hilbert_fun_cone_empty:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"homogeneous (h::_ \\<Rightarrow>\\<^sub>0 'a::field)\"\n  shows \"Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "have \"Hilbert_fun (cone (h, {})) z = card {t \\<in> .[{}::'x set]. deg_pm t + poly_deg h = z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z =\n    card {t \\<in> .[{}]. deg_pm t + poly_deg h = z}", "using assms(1, 2) empty_subsetI assms(3)"], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  {} \\<subseteq> ?A\n  homogeneous h\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z =\n    card {t \\<in> .[{}]. deg_pm t + poly_deg h = z}", "by (rule Hilbert_fun_cone_aux)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, {})) z =\n  card {t \\<in> .[{}]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "also"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, {})) z =\n  card {t \\<in> .[{}]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "have \"\\<dots> = (if poly_deg h = z then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {t \\<in> .[{}]. deg_pm t + poly_deg h = z} =\n    (if poly_deg h = z then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  card {t \\<in> .[{}]. deg_pm t + poly_deg h = z} =\n  (if poly_deg h = z then 1 else 0)\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)", "."], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, {})) z = (if poly_deg h = z then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hilbert_fun_cone_nonempty:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\" and \"homogeneous (h::_ \\<Rightarrow>\\<^sub>0 'a::field)\" and \"U \\<noteq> {}\"\n  shows \"Hilbert_fun (cone (h, U)) z =\n          (if poly_deg h \\<le> z then ((z - poly_deg h) + (card U - 1)) choose (card U - 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "proof (cases \"poly_deg h \\<le> z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "case True"], ["proof (state)\nthis:\n  poly_deg h \\<le> z\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "from assms(3) fin_X"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite X", "have \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "from assms(1-4)"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  homogeneous h", "have \"Hilbert_fun (cone (h, U)) z = card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  homogeneous h\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "by (rule Hilbert_fun_cone_aux)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "also"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "from True"], ["proof (chain)\npicking this:\n  poly_deg h \\<le> z", "have \"{t \\<in> .[U]. deg_pm t + poly_deg h = z} = deg_sect U (z - poly_deg h)\""], ["proof (prove)\nusing this:\n  poly_deg h \\<le> z\n\ngoal (1 subgoal):\n 1. {t \\<in> .[U]. deg_pm t + poly_deg h = z} = deg_sect U (z - poly_deg h)", "by (auto simp: deg_sect_def)"], ["proof (state)\nthis:\n  {t \\<in> .[U]. deg_pm t + poly_deg h = z} = deg_sect U (z - poly_deg h)\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "also"], ["proof (state)\nthis:\n  {t \\<in> .[U]. deg_pm t + poly_deg h = z} = deg_sect U (z - poly_deg h)\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "from \\<open>finite U\\<close> assms(5)"], ["proof (chain)\npicking this:\n  finite U\n  U \\<noteq> {}", "have \"card \\<dots> = (z - poly_deg h) + (card U - 1) choose (card U - 1)\""], ["proof (prove)\nusing this:\n  finite U\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (deg_sect U (z - poly_deg h)) =\n    z - poly_deg h + (card U - 1) choose (card U - 1)", "by (rule card_deg_sect)"], ["proof (state)\nthis:\n  card (deg_sect U (z - poly_deg h)) =\n  z - poly_deg h + (card U - 1) choose (card U - 1)\n\ngoal (2 subgoals):\n 1. poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n 2. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun (cone (h, U)) z =\n  z - poly_deg h + (card U - 1) choose (card U - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun (cone (h, U)) z =\n  z - poly_deg h + (card U - 1) choose (card U - 1)\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "by (simp add: True)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  (if poly_deg h \\<le> z\n   then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> poly_deg h \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "from assms(1-4)"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  homogeneous h", "have \"Hilbert_fun (cone (h, U)) z = card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  homogeneous h\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    card {t \\<in> .[U]. deg_pm t + poly_deg h = z}", "by (rule Hilbert_fun_cone_aux)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "also"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "from False"], ["proof (chain)\npicking this:\n  \\<not> poly_deg h \\<le> z", "have \"{t \\<in> .[U]. deg_pm t + poly_deg h = z} = {}\""], ["proof (prove)\nusing this:\n  \\<not> poly_deg h \\<le> z\n\ngoal (1 subgoal):\n 1. {t \\<in> .[U]. deg_pm t + poly_deg h = z} = {}", "by auto"], ["proof (state)\nthis:\n  {t \\<in> .[U]. deg_pm t + poly_deg h = z} = {}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "hence \"card {t \\<in> .[U]. deg_pm t + poly_deg h = z} = card ({}::('x \\<Rightarrow>\\<^sub>0 nat) set)\""], ["proof (prove)\nusing this:\n  {t \\<in> .[U]. deg_pm t + poly_deg h = z} = {}\n\ngoal (1 subgoal):\n 1. card {t \\<in> .[U]. deg_pm t + poly_deg h = z} = card {}", "by (rule arg_cong)"], ["proof (state)\nthis:\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z} = card {}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "also"], ["proof (state)\nthis:\n  card {t \\<in> .[U]. deg_pm t + poly_deg h = z} = card {}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {} = 0", "by simp"], ["proof (state)\nthis:\n  card {} = 0\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h \\<le> z \\<Longrightarrow>\n    Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun (cone (h, U)) z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun (cone (h, U)) z = 0\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) z =\n    (if poly_deg h \\<le> z\n     then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "by (simp add: False)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) z =\n  (if poly_deg h \\<le> z\n   then z - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Hilbert_fun_Polys:\n  assumes \"X \\<noteq> {}\"\n  shows \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a::field) set) z = (z + (card X - 1)) choose (card X - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "let ?one = \"1::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "have \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) z = Hilbert_fun (cone (?one, X)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = Hilbert_fun (cone (1, X)) z", "by simp"], ["proof (state)\nthis:\n  Hilbert_fun P[X] z = Hilbert_fun (cone (1, X)) z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "also"], ["proof (state)\nthis:\n  Hilbert_fun P[X] z = Hilbert_fun (cone (1, X)) z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "have \"\\<dots> = (if poly_deg ?one \\<le> z then ((z - poly_deg ?one) + (card X - 1)) choose (card X - 1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (1, X)) z =\n    (if poly_deg 1 \\<le> z\n     then z - poly_deg 1 + (card X - 1) choose (card X - 1) else 0)", "using one_in_Polys _ subset_refl _ assms"], ["proof (prove)\nusing this:\n  1 \\<in> P[?X]\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?A \\<subseteq> ?A\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (1, X)) z =\n    (if poly_deg 1 \\<le> z\n     then z - poly_deg 1 + (card X - 1) choose (card X - 1) else 0)", "by (rule Hilbert_fun_cone_nonempty) simp_all"], ["proof (state)\nthis:\n  Hilbert_fun (cone (1, X)) z =\n  (if poly_deg 1 \\<le> z\n   then z - poly_deg 1 + (card X - 1) choose (card X - 1) else 0)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "also"], ["proof (state)\nthis:\n  Hilbert_fun (cone (1, X)) z =\n  (if poly_deg 1 \\<le> z\n   then z - poly_deg 1 + (card X - 1) choose (card X - 1) else 0)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "have \"\\<dots> = (z + (card X - 1)) choose (card X - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if poly_deg 1 \\<le> z\n     then z - poly_deg 1 + (card X - 1) choose (card X - 1) else 0) =\n    z + (card X - 1) choose (card X - 1)", "by simp"], ["proof (state)\nthis:\n  (if poly_deg 1 \\<le> z\n   then z - poly_deg 1 + (card X - 1) choose (card X - 1) else 0) =\n  z + (card X - 1) choose (card X - 1)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)", "."], ["proof (state)\nthis:\n  Hilbert_fun P[X] z = z + (card X - 1) choose (card X - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hilbert_fun_cone_decomp:\n  assumes \"cone_decomp T ps\" and \"valid_decomp X ps\" and \"hom_decomp ps\"\n  shows \"Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "note fin_X"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "moreover"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "from assms(2, 1)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  cone_decomp T ps", "have \"T \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. T \\<subseteq> P[X]", "by (rule valid_cone_decomp_subset_Polys)"], ["proof (state)\nthis:\n  T \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "moreover"], ["proof (state)\nthis:\n  T \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "from assms(1)"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "have dd: \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  T \\<subseteq> P[X]\n  direct_decomp T (map cone ps)", "have \"Hilbert_fun T z = (\\<Sum>s\\<in>set (map cone ps). Hilbert_fun s z)\""], ["proof (prove)\nusing this:\n  finite X\n  T \\<subseteq> P[X]\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>s\\<in>set (map cone ps). Hilbert_fun s z)", "proof (rule Hilbert_fun_direct_decomp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "fix cn"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "assume \"cn \\<in> set (map cone ps)\""], ["proof (state)\nthis:\n  cn \\<in> set (map cone ps)\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "then"], ["proof (chain)\npicking this:\n  cn \\<in> set (map cone ps)", "obtain hU where \"hU \\<in> set ps\" and cn: \"cn = cone hU\""], ["proof (prove)\nusing this:\n  cn \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>hU.\n        \\<lbrakk>hU \\<in> set ps; cn = cone hU\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_map"], ["proof (prove)\nusing this:\n  cn \\<in> cone ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>hU.\n        \\<lbrakk>hU \\<in> set ps; cn = cone hU\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  hU \\<in> set ps\n  cn = cone hU\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "note this(1)"], ["proof (state)\nthis:\n  hU \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "moreover"], ["proof (state)\nthis:\n  hU \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "ultimately"], ["proof (chain)\npicking this:\n  hU \\<in> set ps\n  hU = (h, U)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "with assms(3)"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  (h, U) \\<in> set ps", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "thus \"homogeneous_set cn\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous_set cn", "unfolding cn hU"], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous_set (cone (h, U))", "by (rule homogeneous_set_coneI)"], ["proof (state)\nthis:\n  homogeneous_set cn\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "show \"phull.subspace cn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace cn", "unfolding cn"], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace (cone hU)", "by (fact subspace_cone)"], ["proof (state)\nthis:\n  phull.subspace cn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hilbert_fun T z = (\\<Sum>s\\<in>set (map cone ps). Hilbert_fun s z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "also"], ["proof (state)\nthis:\n  Hilbert_fun T z = (\\<Sum>s\\<in>set (map cone ps). Hilbert_fun s z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "have \"\\<dots> = (\\<Sum>hU\\<in>set ps. ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) hU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map cone ps). Hilbert_fun s z) =\n    sum ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) (set ps)", "unfolding set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>cone ` set ps. Hilbert_fun s z) =\n    sum ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) (set ps)", "using finite_set"], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>cone ` set ps. Hilbert_fun s z) =\n    sum ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) (set ps)", "proof (rule sum.reindex_nontrivial)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ps; y \\<in> set ps; x \\<noteq> y;\n        cone x = cone y\\<rbrakk>\n       \\<Longrightarrow> Hilbert_fun (cone x) z = 0", "fix hU1 hU2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ps; y \\<in> set ps; x \\<noteq> y;\n        cone x = cone y\\<rbrakk>\n       \\<Longrightarrow> Hilbert_fun (cone x) z = 0", "assume \"hU1 \\<in> set ps\" and \"hU2 \\<in> set ps\" and \"hU1 \\<noteq> hU2\""], ["proof (state)\nthis:\n  hU1 \\<in> set ps\n  hU2 \\<in> set ps\n  hU1 \\<noteq> hU2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ps; y \\<in> set ps; x \\<noteq> y;\n        cone x = cone y\\<rbrakk>\n       \\<Longrightarrow> Hilbert_fun (cone x) z = 0", "with dd"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)\n  hU1 \\<in> set ps\n  hU2 \\<in> set ps\n  hU1 \\<noteq> hU2", "have \"cone hU1 \\<inter> cone hU2 = {0}\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n  hU1 \\<in> set ps\n  hU2 \\<in> set ps\n  hU1 \\<noteq> hU2\n\ngoal (1 subgoal):\n 1. cone hU1 \\<inter> cone hU2 = {0}", "using zero_in_cone"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n  hU1 \\<in> set ps\n  hU2 \\<in> set ps\n  hU1 \\<noteq> hU2\n  0 \\<in> cone ?hU\n\ngoal (1 subgoal):\n 1. cone hU1 \\<inter> cone hU2 = {0}", "by (rule direct_decomp_map_Int_zero)"], ["proof (state)\nthis:\n  cone hU1 \\<inter> cone hU2 = {0}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ps; y \\<in> set ps; x \\<noteq> y;\n        cone x = cone y\\<rbrakk>\n       \\<Longrightarrow> Hilbert_fun (cone x) z = 0", "moreover"], ["proof (state)\nthis:\n  cone hU1 \\<inter> cone hU2 = {0}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ps; y \\<in> set ps; x \\<noteq> y;\n        cone x = cone y\\<rbrakk>\n       \\<Longrightarrow> Hilbert_fun (cone x) z = 0", "assume \"cone hU1 = cone hU2\""], ["proof (state)\nthis:\n  cone hU1 = cone hU2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ps; y \\<in> set ps; x \\<noteq> y;\n        cone x = cone y\\<rbrakk>\n       \\<Longrightarrow> Hilbert_fun (cone x) z = 0", "ultimately"], ["proof (chain)\npicking this:\n  cone hU1 \\<inter> cone hU2 = {0}\n  cone hU1 = cone hU2", "show \"Hilbert_fun (cone hU1) z = 0\""], ["proof (prove)\nusing this:\n  cone hU1 \\<inter> cone hU2 = {0}\n  cone hU1 = cone hU2\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone hU1) z = 0", "by simp"], ["proof (state)\nthis:\n  Hilbert_fun (cone hU1) z = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map cone ps). Hilbert_fun s z) =\n  sum ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) (set ps)\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun T z =\n  sum ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) (set ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun T z =\n  sum ((\\<lambda>s. Hilbert_fun s z) \\<circ> cone) (set ps)\n\ngoal (1 subgoal):\n 1. Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)", "by simp"], ["proof (state)\nthis:\n  Hilbert_fun T z = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Hilbert_poly :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> int \\<Rightarrow> int\"\n  where \"Hilbert_poly b =\n                (\\<lambda>z::int. let n = card X in\n                  ((z - b (Suc n) + n) gchoose n) - 1 - (\\<Sum>i=1..n. (z - b i + i - 1) gchoose i))\""], ["", "lemma poly_fun_Hilbert_poly: \"poly_fun (Hilbert_poly b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_fun (Hilbert_poly b)", "by (simp add: Hilbert_poly_def Let_def)"], ["", "lemma Hilbert_fun_eq_Hilbert_poly_plus_card:\n  assumes \"X \\<noteq> {}\" and \"valid_decomp X ps\" and \"hom_decomp ps\" and \"cone_decomp T ps\"\n    and \"standard_decomp k ps\" and \"exact_decomp X 0 ps\" and \"\\<b> ps (Suc 0) \\<le> d\"\n  shows \"int (Hilbert_fun T d) = card {h::_ \\<Rightarrow>\\<^sub>0 'a::field. (h, {}) \\<in> set ps \\<and> poly_deg h = d} + Hilbert_poly (\\<b> ps) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "define n where \"n = card X\""], ["proof (state)\nthis:\n  n = card X\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "with assms(1)"], ["proof (chain)\npicking this:\n  X \\<noteq> {}\n  n = card X", "have \"0 < n\""], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  n = card X\n\ngoal (1 subgoal):\n 1. 0 < n", "using fin_X"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  n = card X\n  finite X\n\ngoal (1 subgoal):\n 1. 0 < n", "by (simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "hence \"1 \\<le> n\" and \"Suc 0 \\<le> n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 \\<le> n &&& Suc 0 \\<le> n", "by simp_all"], ["proof (state)\nthis:\n  1 \\<le> n\n  Suc 0 \\<le> n\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "from pos_decomp_subset"], ["proof (chain)\npicking this:\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps", "have eq0: \"(set ps - set (ps\\<^sub>+)) \\<union> set (ps\\<^sub>+) = set ps\""], ["proof (prove)\nusing this:\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps\n\ngoal (1 subgoal):\n 1. set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+) = set ps", "by blast"], ["proof (state)\nthis:\n  set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+) = set ps\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"set ps - set (ps\\<^sub>+) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps - set (ps\\<^sub>+) \\<subseteq> set ps", "by blast"], ["proof (state)\nthis:\n  set ps - set (ps\\<^sub>+) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "hence fin2: \"finite (set ps - set (ps\\<^sub>+))\""], ["proof (prove)\nusing this:\n  set ps - set (ps\\<^sub>+) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. finite (set ps - set (ps\\<^sub>+))", "using finite_set"], ["proof (prove)\nusing this:\n  set ps - set (ps\\<^sub>+) \\<subseteq> set ps\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (set ps - set (ps\\<^sub>+))", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (set ps - set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"(\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n        (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+). if poly_deg h = d then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n    (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n       if poly_deg h = d then 1 else 0)", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n    (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n       if poly_deg h = d then 1 else 0)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "assume \"x \\<in> set ps - set (ps\\<^sub>+)\""], ["proof (state)\nthis:\n  x \\<in> set ps - set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  x \\<in> set ps - set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "obtain h U where x: \"x = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. x = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. x = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set ps - set (ps\\<^sub>+)\n  x = (h, U)", "have \"U = {}\" and \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  x \\<in> set ps - set (ps\\<^sub>+)\n  x = (h, U)\n\ngoal (1 subgoal):\n 1. U = {} &&& (h, U) \\<in> set ps", "by (simp_all add: pos_decomp_def)"], ["proof (state)\nthis:\n  U = {}\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "from assms(2) this(2)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"h \\<in> P[X]\" and \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "from assms(3) \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  (h, U) \\<in> set ps", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ps - set (ps\\<^sub>+) \\<Longrightarrow>\n       Hilbert_fun (cone x) d =\n       (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  homogeneous h", "show \"Hilbert_fun (cone x) d = (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  homogeneous h\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone x) d =\n    (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)", "by (simp add: x \\<open>U = {}\\<close> Hilbert_fun_cone_empty split del: if_split)"], ["proof (state)\nthis:\n  Hilbert_fun (cone x) d =\n  (case x of (h, U) \\<Rightarrow> if poly_deg h = d then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n     if poly_deg h = d then 1 else 0)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n     if poly_deg h = d then 1 else 0)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "from fin2"], ["proof (chain)\npicking this:\n  finite (set ps - set (ps\\<^sub>+))", "have \"\\<dots> = (\\<Sum>(h, U)\\<in>{(h', U') \\<in> set ps - set (ps\\<^sub>+). poly_deg h' = d}. 1)\""], ["proof (prove)\nusing this:\n  finite (set ps - set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n       if poly_deg h = d then 1 else 0) =\n    (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set ps - set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d}.\n       1)", "by (rule sum.mono_neutral_cong_right) (auto split: if_splits)"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n     if poly_deg h = d then 1 else 0) =\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set ps - set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d}.\n     1)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\\<in>set ps - set (ps\\<^sub>+).\n     if poly_deg h = d then 1 else 0) =\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set ps - set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d}.\n     1)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = card {(h, U) \\<in> set ps - set (ps\\<^sub>+). poly_deg h = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set ps - set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d}.\n       1) =\n    card\n     {(h, U). (h, U) \\<in> set ps - set (ps\\<^sub>+) \\<and> poly_deg h = d}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set ps - set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d}.\n     1) =\n  card\n   {(h, U). (h, U) \\<in> set ps - set (ps\\<^sub>+) \\<and> poly_deg h = d}\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set ps - set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d}.\n     1) =\n  card\n   {(h, U). (h, U) \\<in> set ps - set (ps\\<^sub>+) \\<and> poly_deg h = d}\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {(h, U).\n      (h, U) \\<in> set ps - set (ps\\<^sub>+) \\<and> poly_deg h = d} =\n    card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}", "by (fact card_Diff_pos_decomp)"], ["proof (state)\nthis:\n  card\n   {(h, U). (h, U) \\<in> set ps - set (ps\\<^sub>+) \\<and> poly_deg h = d} =\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}", "have eq1: \"(\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n                      card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}\""], ["proof (prove)\nusing this:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}\n\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n    card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}", "."], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "let ?f = \"\\<lambda>a b. (int d) - a + b gchoose b\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) = (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n    (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d))", "by (simp add: int_sum prod.case_distrib)"], ["proof (state)\nthis:\n  int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = (\\<Sum>(h, U)\\<in>(\\<Union>i\\<in>{1..n}. {(h, U) \\<in> set (ps\\<^sub>+). card U = i}). ?f (poly_deg h) (card U - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d)) =\n    (\\<Sum>(h, U)\n           \\<in>(\\<Union>i\\<in>{1..n}.\n                    {(h, U).\n                     (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}).\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (ps\\<^sub>+) =\n    (\\<Union>i\\<in>{1..n}.\n        {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "show \"set (ps\\<^sub>+) = (\\<Union>i\\<in>{1..n}. {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ps\\<^sub>+) =\n    (\\<Union>i\\<in>{1..n}.\n        {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})", "proof (rule Set.set_eqI, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "assume \"x \\<in> set (ps\\<^sub>+)\""], ["proof (state)\nthis:\n  x \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "obtain h U where x: \"x = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. x = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. x = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (h, U)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (ps\\<^sub>+)\n  x = (h, U)", "have \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  x \\<in> set (ps\\<^sub>+)\n  x = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+)", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "hence \"(h, U) \\<in> set ps\" and \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps &&& U \\<noteq> {}", "by (simp_all add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "from fin_X assms(6) this(1)"], ["proof (chain)\npicking this:\n  finite X\n  exact_decomp X 0 ps\n  (h, U) \\<in> set ps", "have \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  finite X\n  exact_decomp X 0 ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "hence \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. finite U", "using fin_X"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "with \\<open>U \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  U \\<noteq> {}\n  finite U", "have \"0 < card U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n  finite U\n\ngoal (1 subgoal):\n 1. 0 < card U", "by (simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card U\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "moreover"], ["proof (state)\nthis:\n  0 < card U\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "from fin_X \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X", "have \"card U \\<le> n\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. card U \\<le> n", "unfolding n_def"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. card U \\<le> card X", "by (rule card_mono)"], ["proof (state)\nthis:\n  card U \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "ultimately"], ["proof (chain)\npicking this:\n  0 < card U\n  card U \\<le> n", "have \"card U \\<in> {1..n}\""], ["proof (prove)\nusing this:\n  0 < card U\n  card U \\<le> n\n\ngoal (1 subgoal):\n 1. card U \\<in> {1..n}", "by simp"], ["proof (state)\nthis:\n  card U \\<in> {1..n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "moreover"], ["proof (state)\nthis:\n  card U \\<in> {1..n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "from \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"(h, U) \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = card U}\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = card U}", "by simp"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = card U}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n 2. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "ultimately"], ["proof (chain)\npicking this:\n  card U \\<in> {1..n}\n  (h, U)\n  \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = card U}", "show \"x \\<in> (\\<Union>i\\<in>{1..n}. {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\""], ["proof (prove)\nusing this:\n  card U \\<in> {1..n}\n  (h, U)\n  \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = card U}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>i\\<in>{1..n}.\n                {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})", "by (simp add: x)"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>i\\<in>{1..n}.\n              {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       x \\<in> set (ps\\<^sub>+)", "qed blast"], ["proof (state)\nthis:\n  set (ps\\<^sub>+) =\n  (\\<Union>i\\<in>{1..n}.\n      {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "assume \"x \\<in> (\\<Union>i\\<in>{1..n}. {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>i\\<in>{1..n}.\n              {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>i\\<in>{1..n}.\n              {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})", "obtain j where \"j \\<in> {1..n}\" and \"x \\<in> {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>i\\<in>{1..n}.\n              {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i})\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> {1..n};\n         x \\<in> {(h, U).\n                  (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j \\<in> {1..n}\n  x \\<in> {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from this(2)"], ["proof (chain)\npicking this:\n  x \\<in> {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}", "obtain h U where \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"card U = j\" and x: \"x = (h, U)\""], ["proof (prove)\nusing this:\n  x \\<in> {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); card U = j;\n         x = (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  card U = j\n  x = (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from fin_X assms(2, 5) this(1)"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"poly_deg h < \\<b> ps (Suc 0)\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "by (rule \\<b>_one_gr)"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "also"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "have \"\\<dots> \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) \\<le> d", "by fact"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "finally"], ["proof (chain)\npicking this:\n  poly_deg h < d", "have \"poly_deg h < d\""], ["proof (prove)\nusing this:\n  poly_deg h < d\n\ngoal (1 subgoal):\n 1. poly_deg h < d", "."], ["proof (state)\nthis:\n  poly_deg h < d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "hence int1: \"int (d - poly_deg h) = int d - int (poly_deg h)\""], ["proof (prove)\nusing this:\n  poly_deg h < d\n\ngoal (1 subgoal):\n 1. int (d - poly_deg h) = int d - int (poly_deg h)", "by simp"], ["proof (state)\nthis:\n  int (d - poly_deg h) = int d - int (poly_deg h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from \\<open>card U = j\\<close> \\<open>j \\<in> {1..n}\\<close>"], ["proof (chain)\npicking this:\n  card U = j\n  j \\<in> {1..n}", "have \"0 < card U\""], ["proof (prove)\nusing this:\n  card U = j\n  j \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. 0 < card U", "by simp"], ["proof (state)\nthis:\n  0 < card U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "hence int2: \"int (card U - Suc 0) = int (card U) - 1\""], ["proof (prove)\nusing this:\n  0 < card U\n\ngoal (1 subgoal):\n 1. int (card U - Suc 0) = int (card U) - 1", "by simp"], ["proof (state)\nthis:\n  int (card U - Suc 0) = int (card U) - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "using pos_decomp_subset"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", ".."], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "with assms(2)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "moreover"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from assms(3) \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  (h, U) \\<in> set ps", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "moreover"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from \\<open>0 < card U\\<close>"], ["proof (chain)\npicking this:\n  0 < card U", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "ultimately"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  homogeneous h\n  U \\<noteq> {}", "have \"Hilbert_fun (cone (h, U)) d =\n                (if poly_deg h \\<le> d then (d - poly_deg h + (card U - 1)) choose (card U - 1) else 0)\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  homogeneous h\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (h, U)) d =\n    (if poly_deg h \\<le> d\n     then d - poly_deg h + (card U - 1) choose (card U - 1) else 0)", "by (rule Hilbert_fun_cone_nonempty)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) d =\n  (if poly_deg h \\<le> d\n   then d - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "also"], ["proof (state)\nthis:\n  Hilbert_fun (cone (h, U)) d =\n  (if poly_deg h \\<le> d\n   then d - poly_deg h + (card U - 1) choose (card U - 1) else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "from \\<open>poly_deg h < d\\<close>"], ["proof (chain)\npicking this:\n  poly_deg h < d", "have \"\\<dots> = (d - poly_deg h + (card U - 1)) choose (card U - 1)\""], ["proof (prove)\nusing this:\n  poly_deg h < d\n\ngoal (1 subgoal):\n 1. (if poly_deg h \\<le> d\n     then d - poly_deg h + (card U - 1) choose (card U - 1) else 0) =\n    d - poly_deg h + (card U - 1) choose (card U - 1)", "by simp"], ["proof (state)\nthis:\n  (if poly_deg h \\<le> d\n   then d - poly_deg h + (card U - 1) choose (card U - 1) else 0) =\n  d - poly_deg h + (card U - 1) choose (card U - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun (cone (h, U)) d =\n  d - poly_deg h + (card U - 1) choose (card U - 1)", "have \"int (Hilbert_fun (cone (h, U)) d) = (int d - int (poly_deg h) + (int (card U - 1))) gchoose (card U - 1)\""], ["proof (prove)\nusing this:\n  Hilbert_fun (cone (h, U)) d =\n  d - poly_deg h + (card U - 1) choose (card U - 1)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun (cone (h, U)) d) =\n    int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)", "by (simp add: int_binomial int1 int2)"], ["proof (state)\nthis:\n  int (Hilbert_fun (cone (h, U)) d) =\n  int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>i\\<in>{1..n}.\n                   {(h, U).\n                    (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                    card U = i}) \\<Longrightarrow>\n       int (Hilbert_fun (cone x) d) =\n       (case x of\n        (h, U) \\<Rightarrow>\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "thus \"int (Hilbert_fun (cone x) d) =\n          (case x of (h, U) \\<Rightarrow> int d - int (poly_deg h) + (int (card U - 1)) gchoose (card U - 1))\""], ["proof (prove)\nusing this:\n  int (Hilbert_fun (cone (h, U)) d) =\n  int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun (cone x) d) =\n    (case x of\n     (h, U) \\<Rightarrow>\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "by (simp add: x)"], ["proof (state)\nthis:\n  int (Hilbert_fun (cone x) d) =\n  (case x of\n   (h, U) \\<Rightarrow>\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d)) =\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>i\\<in>{1..n}.\n                  {(h, U).\n                   (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). int (Hilbert_fun (cone hU) d)) =\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>i\\<in>{1..n}.\n                  {(h, U).\n                   (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = (\\<Sum>j=1..n. \\<Sum>(h, U)\\<in>{(h', U') \\<in> set (ps\\<^sub>+). card U' = j}. ?f (poly_deg h) (card U - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>(\\<Union>i\\<in>{1..n}.\n                    {(h, U).\n                     (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}).\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    (\\<Sum>j = 1..n.\n        \\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "proof (intro sum.UNION_disjoint ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {1..n}\n 2. \\<And>i.\n       i \\<in> {1..n} \\<Longrightarrow>\n       finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}\n 3. \\<And>i j.\n       \\<lbrakk>i \\<in> {1..n}; j \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> j \\<longrightarrow>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                          card U = i} \\<inter>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j} =\n                         {}", "fix j"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {1..n}\n 2. \\<And>i.\n       i \\<in> {1..n} \\<Longrightarrow>\n       finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}\n 3. \\<And>i j.\n       \\<lbrakk>i \\<in> {1..n}; j \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> j \\<longrightarrow>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                          card U = i} \\<inter>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j} =\n                         {}", "have \"{(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j} \\<subseteq> set (ps\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n    \\<subseteq> set (ps\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n  \\<subseteq> set (ps\\<^sub>+)\n\ngoal (3 subgoals):\n 1. finite {1..n}\n 2. \\<And>i.\n       i \\<in> {1..n} \\<Longrightarrow>\n       finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}\n 3. \\<And>i j.\n       \\<lbrakk>i \\<in> {1..n}; j \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> j \\<longrightarrow>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                          card U = i} \\<inter>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j} =\n                         {}", "thus \"finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\""], ["proof (prove)\nusing this:\n  {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n  \\<subseteq> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}", "using finite_set"], ["proof (prove)\nusing this:\n  {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n  \\<subseteq> set (ps\\<^sub>+)\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {(h, U). (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j}\n\ngoal (2 subgoals):\n 1. finite {1..n}\n 2. \\<And>i j.\n       \\<lbrakk>i \\<in> {1..n}; j \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> j \\<longrightarrow>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and>\n                          card U = i} \\<inter>\n                         {(h, U).\n                          (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = j} =\n                         {}", "qed blast+"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>i\\<in>{1..n}.\n                  {(h, U).\n                   (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>j = 1..n.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>i\\<in>{1..n}.\n                  {(h, U).\n                   (h, U) \\<in> set (ps\\<^sub>+) \\<and> card U = i}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>j = 1..n.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>j=1..n. ?f (\\<b> ps (Suc j)) j - ?f (\\<b> ps j) j)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 1..n.\n        \\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n    (\\<Sum>j = 1..n.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n        (int d - int (\\<b> ps j) + int j gchoose j))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "assume \"j \\<in> {1..n}\""], ["proof (state)\nthis:\n  j \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "hence \"Suc 0 \\<le> j\" and \"0 < j\" and \"j \\<le> n\""], ["proof (prove)\nusing this:\n  j \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> j &&& 0 < j &&& j \\<le> n", "by simp_all"], ["proof (state)\nthis:\n  Suc 0 \\<le> j\n  0 < j\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "from fin_X this(1)"], ["proof (chain)\npicking this:\n  finite X\n  Suc 0 \\<le> j", "have \"\\<b> ps j \\<le> \\<b> ps (Suc 0)\""], ["proof (prove)\nusing this:\n  finite X\n  Suc 0 \\<le> j\n\ngoal (1 subgoal):\n 1. \\<b> ps j \\<le> \\<b> ps (Suc 0)", "by (rule \\<b>_decreasing)"], ["proof (state)\nthis:\n  \\<b> ps j \\<le> \\<b> ps (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  \\<b> ps j \\<le> \\<b> ps (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "have \"\\<dots> \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) \\<le> d", "by fact"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "finally"], ["proof (chain)\npicking this:\n  \\<b> ps j \\<le> d", "have \"\\<b> ps j \\<le> d\""], ["proof (prove)\nusing this:\n  \\<b> ps j \\<le> d\n\ngoal (1 subgoal):\n 1. \\<b> ps j \\<le> d", "."], ["proof (state)\nthis:\n  \\<b> ps j \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "from fin_X"], ["proof (chain)\npicking this:\n  finite X", "have \"\\<b> ps (Suc j) \\<le> \\<b> ps j\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc j) \\<le> \\<b> ps j", "by (rule \\<b>_decreasing) simp"], ["proof (state)\nthis:\n  \\<b> ps (Suc j) \\<le> \\<b> ps j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "hence \"\\<b> ps (Suc j) \\<le> d\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc j) \\<le> \\<b> ps j\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc j) \\<le> d", "using \\<open>\\<b> ps j \\<le> d\\<close>"], ["proof (prove)\nusing this:\n  \\<b> ps (Suc j) \\<le> \\<b> ps j\n  \\<b> ps j \\<le> d\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc j) \\<le> d", "by (rule le_trans)"], ["proof (state)\nthis:\n  \\<b> ps (Suc j) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "from \\<open>0 < j\\<close>"], ["proof (chain)\npicking this:\n  0 < j", "have int_j: \"int (j - Suc 0) = int j - 1\""], ["proof (prove)\nusing this:\n  0 < j\n\ngoal (1 subgoal):\n 1. int (j - Suc 0) = int j - 1", "by simp"], ["proof (state)\nthis:\n  int (j - Suc 0) = int j - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "have \"(\\<Sum>(h, U)\\<in>{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}. ?f (poly_deg h) (card U - 1)) =\n         (\\<Sum>(h, U)\\<in>(\\<Union>d0\\<in>{\\<b> ps (Suc j)..int (\\<b> ps j) - 1}. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> int (poly_deg h') = d0 \\<and> card U' = j}).\n            ?f (poly_deg h) (card U - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    (\\<Sum>(h, U)\n           \\<in>(\\<Union>d0\\<in>{int (\\<b> ps\n (Suc j))..int (\\<b> ps j) - 1}.\n                    {(h', U').\n                     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                     int (poly_deg h') = d0 \\<and> card U' = j}).\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "using _ refl"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    (\\<Sum>(h, U)\n           \\<in>(\\<Union>d0\\<in>{int (\\<b> ps\n (Suc j))..int (\\<b> ps j) - 1}.\n                    {(h', U').\n                     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                     int (poly_deg h') = d0 \\<and> card U' = j}).\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j} =\n    (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         int (poly_deg h') = d0 \\<and> card U' = j})", "show \"{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j} =\n            (\\<Union>d0\\<in>{\\<b> ps (Suc j)..int (\\<b> ps j) - 1}. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> int (poly_deg h') = d0 \\<and> card U' = j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j} =\n    (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         int (poly_deg h') = d0 \\<and> card U' = j})", "proof (rule Set.set_eqI, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "assume \"x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}\""], ["proof (state)\nthis:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "moreover"], ["proof (state)\nthis:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "obtain h U where x: \"x = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. x = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. x = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (h, U)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}\n  x = (h, U)", "have \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"card U = j\""], ["proof (prove)\nusing this:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}\n  x = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+) &&& card U = j", "by simp_all"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  card U = j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "with fin_X assms(5, 6) \\<open>Suc 0 \\<le> j\\<close> \\<open>j \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  standard_decomp k ps\n  exact_decomp X 0 ps\n  Suc 0 \\<le> j\n  j \\<le> n\n  (h, U) \\<in> set (ps\\<^sub>+)\n  card U = j", "have \"\\<b> ps (Suc j) \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  finite X\n  standard_decomp k ps\n  exact_decomp X 0 ps\n  Suc 0 \\<le> j\n  j \\<le> n\n  (h, U) \\<in> set (ps\\<^sub>+)\n  card U = j\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc j) \\<le> poly_deg h", "unfolding n_def"], ["proof (prove)\nusing this:\n  finite X\n  standard_decomp k ps\n  exact_decomp X 0 ps\n  Suc 0 \\<le> j\n  j \\<le> card X\n  (h, U) \\<in> set (ps\\<^sub>+)\n  card U = j\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc j) \\<le> poly_deg h", "by (rule lem_6_1_3)"], ["proof (state)\nthis:\n  \\<b> ps (Suc j) \\<le> poly_deg h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "moreover"], ["proof (state)\nthis:\n  \\<b> ps (Suc j) \\<le> poly_deg h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "from fin_X"], ["proof (chain)\npicking this:\n  finite X", "have \"poly_deg h < \\<b> ps j\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps j", "proof (rule \\<b>)"], ["proof (state)\ngoal (2 subgoals):\n 1. (h, ?U) \\<in> set ps\n 2. j \\<le> card ?U", "from \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "show \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "using pos_decomp_subset"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", ".."], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. j \\<le> card U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<le> card U", "show \"j \\<le> card U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> card U", "by (simp add: \\<open>card U = j\\<close>)"], ["proof (state)\nthis:\n  j \\<le> card U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "ultimately"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc j) \\<le> poly_deg h\n  poly_deg h < \\<b> ps j", "have \"poly_deg h \\<in> {\\<b> ps (Suc j)..int (\\<b> ps j) - 1}\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc j) \\<le> poly_deg h\n  poly_deg h < \\<b> ps j\n\ngoal (1 subgoal):\n 1. int (poly_deg h) \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}", "by simp"], ["proof (state)\nthis:\n  int (poly_deg h) \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "moreover"], ["proof (state)\nthis:\n  int (poly_deg h) \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "have \"(h, U) \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h \\<and> card U' = card U}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n           poly_deg h' = poly_deg h \\<and> card U' = card U}", "using \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n           poly_deg h' = poly_deg h \\<and> card U' = card U}", "by simp"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         poly_deg h' = poly_deg h \\<and> card U' = card U}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                card U' = j} \\<Longrightarrow>\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j})\n 2. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "ultimately"], ["proof (chain)\npicking this:\n  int (poly_deg h) \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n  (h, U)\n  \\<in> {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         poly_deg h' = poly_deg h \\<and> card U' = card U}", "show \"x \\<in> (\\<Union>d0\\<in>{\\<b> ps (Suc j)..int (\\<b> ps j) - 1}.\n                                {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> int (poly_deg h') = d0 \\<and> card U' = j})\""], ["proof (prove)\nusing this:\n  int (poly_deg h) \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n  (h, U)\n  \\<in> {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         poly_deg h' = poly_deg h \\<and> card U' = card U}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j})", "by (simp add: x \\<open>card U = j\\<close>)"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n              {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                   {(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and>\n                    card U' = j}) \\<Longrightarrow>\n       x \\<in> {(h', U').\n                (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}", "qed blast"], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j} =\n  (\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n      {(h', U').\n       (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n       int (poly_deg h') = d0 \\<and> card U' = j})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                  {(h', U').\n                   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                   int (poly_deg h') = d0 \\<and> card U' = j}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                  {(h', U').\n                   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                   int (poly_deg h') = d0 \\<and> card U' = j}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "have \"\\<dots> = (\\<Sum>d0=\\<b> ps (Suc j)..int (\\<b> ps j) - 1.\n                        \\<Sum>(h, U)\\<in>{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d0 \\<and> card U' = j}.\n                            ?f (poly_deg h) (card U - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>(\\<Union>d0\\<in>{int (\\<b> ps\n (Suc j))..int (\\<b> ps j) - 1}.\n                    {(h', U').\n                     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                     int (poly_deg h') = d0 \\<and> card U' = j}).\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        \\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))", "proof (intro sum.UNION_disjoint ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n 2. \\<And>i.\n       i \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       finite\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         int (poly_deg h') = i \\<and> card U' = j}\n 3. \\<And>i ja.\n       \\<lbrakk>i \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1};\n        ja \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> ja \\<longrightarrow>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = i \\<and> card U' = j} \\<inter>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = ja \\<and> card U' = j} =\n                         {}", "fix d0::int"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n 2. \\<And>i.\n       i \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       finite\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         int (poly_deg h') = i \\<and> card U' = j}\n 3. \\<And>i ja.\n       \\<lbrakk>i \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1};\n        ja \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> ja \\<longrightarrow>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = i \\<and> card U' = j} \\<inter>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = ja \\<and> card U' = j} =\n                         {}", "have \"{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d0 \\<and> card U' = j} \\<subseteq> set (ps\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     int (poly_deg h') = d0 \\<and> card U' = j}\n    \\<subseteq> set (ps\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n   int (poly_deg h') = d0 \\<and> card U' = j}\n  \\<subseteq> set (ps\\<^sub>+)\n\ngoal (3 subgoals):\n 1. finite {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n 2. \\<And>i.\n       i \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       finite\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         int (poly_deg h') = i \\<and> card U' = j}\n 3. \\<And>i ja.\n       \\<lbrakk>i \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1};\n        ja \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> ja \\<longrightarrow>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = i \\<and> card U' = j} \\<inter>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = ja \\<and> card U' = j} =\n                         {}", "thus \"finite {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d0 \\<and> card U' = j}\""], ["proof (prove)\nusing this:\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n   int (poly_deg h') = d0 \\<and> card U' = j}\n  \\<subseteq> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. finite\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      int (poly_deg h') = d0 \\<and> card U' = j}", "using finite_set"], ["proof (prove)\nusing this:\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n   int (poly_deg h') = d0 \\<and> card U' = j}\n  \\<subseteq> set (ps\\<^sub>+)\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      int (poly_deg h') = d0 \\<and> card U' = j}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {(h', U').\n    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n    int (poly_deg h') = d0 \\<and> card U' = j}\n\ngoal (2 subgoals):\n 1. finite {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n 2. \\<And>i ja.\n       \\<lbrakk>i \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1};\n        ja \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\\<rbrakk>\n       \\<Longrightarrow> i \\<noteq> ja \\<longrightarrow>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = i \\<and> card U' = j} \\<inter>\n                         {(h', U').\n                          (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                          int (poly_deg h') = ja \\<and> card U' = j} =\n                         {}", "qed blast+"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                  {(h', U').\n                   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                   int (poly_deg h') = d0 \\<and> card U' = j}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                  int (poly_deg h') = d0 \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>(\\<Union>d0\\<in>{int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n                  {(h', U').\n                   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                   int (poly_deg h') = d0 \\<and> card U' = j}).\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                  int (poly_deg h') = d0 \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>d0=\\<b> ps (Suc j)..int (\\<b> ps j) - 1. ?f d0 (j - 1))\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        \\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = d0 \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n    (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        int d - d0 + int (j - 1) gchoose (j - 1))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "assume \"d0 \\<in> {\\<b> ps (Suc j)..int (\\<b> ps j) - 1}\""], ["proof (state)\nthis:\n  d0 \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "hence \"\\<b> ps (Suc j) \\<le> d0\" and \"d0 < int (\\<b> ps j)\""], ["proof (prove)\nusing this:\n  d0 \\<in> {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n\ngoal (1 subgoal):\n 1. int (\\<b> ps (Suc j)) \\<le> d0 &&& d0 < int (\\<b> ps j)", "by simp_all"], ["proof (state)\nthis:\n  int (\\<b> ps (Suc j)) \\<le> d0\n  d0 < int (\\<b> ps j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "hence \"\\<b> ps (Suc j) \\<le> nat d0\" and \"nat d0 < \\<b> ps j\""], ["proof (prove)\nusing this:\n  int (\\<b> ps (Suc j)) \\<le> d0\n  d0 < int (\\<b> ps j)\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc j) \\<le> nat d0 &&& nat d0 < \\<b> ps j", "by simp_all"], ["proof (state)\nthis:\n  \\<b> ps (Suc j) \\<le> nat d0\n  nat d0 < \\<b> ps j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "have \"(\\<Sum>(h, U)\\<in>{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d0 \\<and> card U' = j}. ?f (poly_deg h) (card U - 1)) =\n            (\\<Sum>(h, U)\\<in>{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d0 \\<and> card U' = j}. ?f d0 (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - d0 + int (j - 1) gchoose (j - 1))", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - d0 + int (j - 1) gchoose (j - 1))", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "have \"\\<dots> = card {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = nat d0 \\<and> card U' = j} * ?f d0 (j - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - d0 + int (j - 1) gchoose (j - 1)) =\n    int (card\n          {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n           poly_deg h' = nat d0 \\<and> card U' = j}) *\n    (int d - d0 + int (j - 1) gchoose (j - 1))", "using \\<open>\\<b> ps (Suc j) \\<le> d0\\<close>"], ["proof (prove)\nusing this:\n  int (\\<b> ps (Suc j)) \\<le> d0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - d0 + int (j - 1) gchoose (j - 1)) =\n    int (card\n          {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n           poly_deg h' = nat d0 \\<and> card U' = j}) *\n    (int d - d0 + int (j - 1) gchoose (j - 1))", "by (simp add: int_eq_iff)"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - d0 + int (j - 1) gchoose (j - 1)) =\n  int (card\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         poly_deg h' = nat d0 \\<and> card U' = j}) *\n  (int d - d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - d0 + int (j - 1) gchoose (j - 1)) =\n  int (card\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         poly_deg h' = nat d0 \\<and> card U' = j}) *\n  (int d - d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "have \"\\<dots> = ?f d0 (j - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card\n          {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n           poly_deg h' = nat d0 \\<and> card U' = j}) *\n    (int d - d0 + int (j - 1) gchoose (j - 1)) =\n    int d - d0 + int (j - 1) gchoose (j - 1)", "using fin_X assms(5, 6) \\<open>Suc 0 \\<le> j\\<close> \\<open>j \\<le> n\\<close> \\<open>\\<b> ps (Suc j) \\<le> nat d0\\<close> \\<open>nat d0 < \\<b> ps j\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  standard_decomp k ps\n  exact_decomp X 0 ps\n  Suc 0 \\<le> j\n  j \\<le> n\n  \\<b> ps (Suc j) \\<le> nat d0\n  nat d0 < \\<b> ps j\n\ngoal (1 subgoal):\n 1. int (card\n          {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n           poly_deg h' = nat d0 \\<and> card U' = j}) *\n    (int d - d0 + int (j - 1) gchoose (j - 1)) =\n    int d - d0 + int (j - 1) gchoose (j - 1)", "by (simp only: n_def lem_6_1_2'(3))"], ["proof (state)\nthis:\n  int (card\n        {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n         poly_deg h' = nat d0 \\<and> card U' = j}) *\n  (int d - d0 + int (j - 1) gchoose (j - 1)) =\n  int d - d0 + int (j - 1) gchoose (j - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {int (\\<b> ps\n                      (Suc j))..int (\\<b> ps j) - 1} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                    int (poly_deg h') = x \\<and> card U' = j}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - x + int (j - 1) gchoose (j - 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  int d - d0 + int (j - 1) gchoose (j - 1)", "show \"(\\<Sum>(h, U)\\<in>{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d0 \\<and> card U' = j}.\n                      ?f (poly_deg h) (card U - 1)) = ?f d0 (j - 1)\""], ["proof (prove)\nusing this:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  int d - d0 + int (j - 1) gchoose (j - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 int (poly_deg h') = d0 \\<and> card U' = j}.\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    int d - d0 + int (j - 1) gchoose (j - 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               int (poly_deg h') = d0 \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  int d - d0 + int (j - 1) gchoose (j - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                  int (poly_deg h') = d0 \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      int d - d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                  int (poly_deg h') = d0 \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      int d - d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "have \"\\<dots> = (\\<Sum>d0\\<in>(-) (int d) ` {\\<b> ps (Suc j)..int (\\<b> ps j) - 1}. d0 + int (j - 1) gchoose (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        int d - d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0\\<in>(-) (int d) `\n                  {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n       d0 + int (j - 1) gchoose (j - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        int d - d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0\\<in>(-) (int d) `\n                  {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n       d0 + int (j - 1) gchoose (j - 1))", "have \"inj_on ((-) (int d)) {\\<b> ps (Suc j)..int (\\<b> ps j) - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) (int d)) {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj_on ((-) (int d)) {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        int d - d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0\\<in>(-) (int d) `\n                  {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n       d0 + int (j - 1) gchoose (j - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on ((-) (int d)) {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n        int d - d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0\\<in>(-) (int d) `\n                  {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n       d0 + int (j - 1) gchoose (j - 1))", "by (simp only: sum.reindex o_def)"], ["proof (state)\nthis:\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      int d - d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0\\<in>(-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n     d0 + int (j - 1) gchoose (j - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      int d - d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0\\<in>(-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n     d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>d0 = int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1.\n      int d - d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0\\<in>(-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n     d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "have \"\\<dots> = (\\<Sum>d0\\<in>{0..int d - (\\<b> ps (Suc j))}-{0..int d - \\<b> ps j}. d0 + int (j - 1) gchoose (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d0\\<in>(-) (int d) `\n                  {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n       d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                  {0..int d - int (\\<b> ps j)}.\n       d0 + int (j - 1) gchoose (j - 1))", "using _ refl"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>d0\\<in>(-) (int d) `\n                  {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n       d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                  {0..int d - int (\\<b> ps j)}.\n       d0 + int (j - 1) gchoose (j - 1))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "have \"(-) (int d) ` {\\<b> ps (Suc j)..int (\\<b> ps j) - 1} = {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n    {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))}", "by (simp only: image_diff_atLeastAtMost)"], ["proof (state)\nthis:\n  (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n  {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))}\n\ngoal (1 subgoal):\n 1. (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "also"], ["proof (state)\nthis:\n  (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n  {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))}\n\ngoal (1 subgoal):\n 1. (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "have \"\\<dots> = {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "from \\<open>\\<b> ps j \\<le> d\\<close>"], ["proof (chain)\npicking this:\n  \\<b> ps j \\<le> d", "have \"int (\\<b> ps j) - 1 \\<le> int d\""], ["proof (prove)\nusing this:\n  \\<b> ps j \\<le> d\n\ngoal (1 subgoal):\n 1. int (\\<b> ps j) - 1 \\<le> int d", "by simp"], ["proof (state)\nthis:\n  int (\\<b> ps j) - 1 \\<le> int d\n\ngoal (1 subgoal):\n 1. {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (\\<b> ps j) - 1 \\<le> int d\n\ngoal (1 subgoal):\n 1. {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "by auto"], ["proof (state)\nthis:\n  {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))} =\n  {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {int d - (int (\\<b> ps j) - 1)..int d - int (\\<b> ps (Suc j))} =\n  {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}\n\ngoal (1 subgoal):\n 1. (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "finally"], ["proof (chain)\npicking this:\n  (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n  {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "show \"(-) (int d) ` {\\<b> ps (Suc j)..int (\\<b> ps j) - 1} =\n                    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}\""], ["proof (prove)\nusing this:\n  (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n  {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}\n\ngoal (1 subgoal):\n 1. (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n    {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}", "."], ["proof (state)\nthis:\n  (-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1} =\n  {0..int d - int (\\<b> ps (Suc j))} - {0..int d - int (\\<b> ps j)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>d0\\<in>(-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n     d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                {0..int d - int (\\<b> ps j)}.\n     d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>d0\\<in>(-) (int d) ` {int (\\<b> ps (Suc j))..int (\\<b> ps j) - 1}.\n     d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                {0..int d - int (\\<b> ps j)}.\n     d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "have \"\\<dots> = (\\<Sum>d0=0..int d - (\\<b> ps (Suc j)). d0 + int (j - 1) gchoose (j - 1)) -\n                    (\\<Sum>d0=0..int d - \\<b> ps j. d0 + int (j - 1) gchoose (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                  {0..int d - int (\\<b> ps j)}.\n       d0 + int (j - 1) gchoose (j - 1)) =\n    (\\<Sum>d0 = 0..int d - int (\\<b> ps (Suc j)).\n        d0 + int (j - 1) gchoose (j - 1)) -\n    (\\<Sum>d0 = 0..int d - int (\\<b> ps j).\n        d0 + int (j - 1) gchoose (j - 1))", "by (rule sum_diff) (auto simp: \\<open>\\<b> ps (Suc j) \\<le> \\<b> ps j\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                {0..int d - int (\\<b> ps j)}.\n     d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0 = 0..int d - int (\\<b> ps (Suc j)).\n      d0 + int (j - 1) gchoose (j - 1)) -\n  (\\<Sum>d0 = 0..int d - int (\\<b> ps j). d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>d0\\<in>{0..int d - int (\\<b> ps (Suc j))} -\n                {0..int d - int (\\<b> ps j)}.\n     d0 + int (j - 1) gchoose (j - 1)) =\n  (\\<Sum>d0 = 0..int d - int (\\<b> ps (Suc j)).\n      d0 + int (j - 1) gchoose (j - 1)) -\n  (\\<Sum>d0 = 0..int d - int (\\<b> ps j). d0 + int (j - 1) gchoose (j - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "from \\<open>\\<b> ps (Suc j) \\<le> d\\<close> \\<open>\\<b> ps j \\<le> d\\<close>"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc j) \\<le> d\n  \\<b> ps j \\<le> d", "have \"\\<dots> = ?f (\\<b> ps (Suc j)) j - ?f (\\<b> ps j) j\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc j) \\<le> d\n  \\<b> ps j \\<le> d\n\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = 0..int d - int (\\<b> ps (Suc j)).\n        d0 + int (j - 1) gchoose (j - 1)) -\n    (\\<Sum>d0 = 0..int d - int (\\<b> ps j).\n        d0 + int (j - 1) gchoose (j - 1)) =\n    int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n    (int d - int (\\<b> ps j) + int j gchoose j)", "by (simp add: gchoose_rising_sum, simp add: int_j ac_simps \\<open>0 < j\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>d0 = 0..int d - int (\\<b> ps (Suc j)).\n      d0 + int (j - 1) gchoose (j - 1)) -\n  (\\<Sum>d0 = 0..int d - int (\\<b> ps j).\n      d0 + int (j - 1) gchoose (j - 1)) =\n  int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n  (int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       (\\<Sum>(h, U)\n              \\<in>{(h', U').\n                    (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = x}.\n          int d - int (poly_deg h) + int (card U - 1) gchoose\n          (card U - 1)) =\n       int d - int (\\<b> ps (Suc x)) + int x gchoose x -\n       (int d - int (\\<b> ps x) + int x gchoose x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n  (int d - int (\\<b> ps j) + int j gchoose j)", "show \"(\\<Sum>(h, U)\\<in>{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}. ?f (poly_deg h) (card U - 1)) =\n                    ?f (\\<b> ps (Suc j)) j - ?f (\\<b> ps j) j\""], ["proof (prove)\nusing this:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n  (int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(h, U)\n           \\<in>{(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n       int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n    int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n    (int d - int (\\<b> ps j) + int j gchoose j)", "."], ["proof (state)\nthis:\n  (\\<Sum>(h, U)\n         \\<in>{(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n     int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n  (int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>j = 1..n.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n      (int d - int (\\<b> ps j) + int j gchoose j))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n.\n      \\<Sum>(h, U)\n            \\<in>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> card U' = j}.\n        int d - int (poly_deg h) + int (card U - 1) gchoose (card U - 1)) =\n  (\\<Sum>j = 1..n.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n      (int d - int (\\<b> ps j) + int j gchoose j))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = (\\<Sum>j=1..n. ?f (\\<b> ps (Suc j)) j) - (\\<Sum>j=1..n. ?f (\\<b> ps j) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 1..n.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n        (int d - int (\\<b> ps j) + int j gchoose j)) =\n    (\\<Sum>j = 1..n. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n    (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j)", "by (fact sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n      (int d - int (\\<b> ps j) + int j gchoose j)) =\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose j -\n      (int d - int (\\<b> ps j) + int j gchoose j)) =\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = ?f (\\<b> ps (Suc n)) n + (\\<Sum>j=1..n-1. ?f (\\<b> ps (Suc j)) j) - (\\<Sum>j=1..n. ?f (\\<b> ps j) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 1..n. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n    (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n +\n    (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n    (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j)", "by (simp only: sum_tail_nat[OF \\<open>0 < n\\<close> \\<open>1 \\<le> n\\<close>])"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n +\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n +\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = ?f (\\<b> ps (Suc n)) n - ?f (\\<b> ps 1) 1 +\n                  ((\\<Sum>j=1..n-1. ?f (\\<b> ps (Suc j)) j) - (\\<Sum>j=1..n-1. ?f (\\<b> ps (Suc j)) (Suc j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n +\n    (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n    (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) +\n    ((\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n     (\\<Sum>j = 1..n - 1.\n         int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j))", "by (simp only: sum.atLeast_Suc_atMost[OF \\<open>1 \\<le> n\\<close>] sum_atLeast_Suc_shift[OF \\<open>0 < n\\<close> \\<open>1 \\<le> n\\<close>])"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n +\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) +\n  ((\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n   (\\<Sum>j = 1..n - 1.\n       int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n +\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n  (\\<Sum>j = 1..n. int d - int (\\<b> ps j) + int j gchoose j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) +\n  ((\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n   (\\<Sum>j = 1..n - 1.\n       int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = ?f (\\<b> ps (Suc n)) n - ?f (\\<b> ps 1) 1 -\n                  (\\<Sum>j=1..n-1. ?f (\\<b> ps (Suc j)) (Suc j) - ?f (\\<b> ps (Suc j)) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) +\n    ((\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n     (\\<Sum>j = 1..n - 1.\n         int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j))", "by (simp only: sum_subtractf)"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) +\n  ((\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n   (\\<Sum>j = 1..n - 1.\n       int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j)) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) +\n  ((\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose j) -\n   (\\<Sum>j = 1..n - 1.\n       int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j)) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j))\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = ?f (\\<b> ps (Suc n)) n - 1 - ((int d - \\<b> ps (Suc 0)) gchoose (Suc 0)) -\n                  (\\<Sum>j=1..n-1. (int d - \\<b> ps (Suc j) + j) gchoose (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "have \"?f (\\<b> ps 1) 1 = 1 + ((int d - \\<b> ps (Suc 0)) gchoose (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps 1) + int 1 gchoose 1 =\n    1 + (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0)", "by (simp add: plus_Suc_gbinomial)"], ["proof (state)\nthis:\n  int d - int (\\<b> ps 1) + int 1 gchoose 1 =\n  1 + (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0)\n\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "moreover"], ["proof (state)\nthis:\n  int d - int (\\<b> ps 1) + int 1 gchoose 1 =\n  1 + (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0)\n\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"(\\<Sum>j=1..n-1. ?f (\\<b> ps (Suc j)) (Suc j) - ?f (\\<b> ps (Suc j)) j) =\n                              (\\<Sum>j=1..n-1. (int d - \\<b> ps (Suc j) + j) gchoose (Suc j))\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "by (rule sum.cong) (simp add: plus_Suc_gbinomial)"], ["proof (state)\nthis:\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "ultimately"], ["proof (chain)\npicking this:\n  int d - int (\\<b> ps 1) + int 1 gchoose 1 =\n  1 + (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0)\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "show ?thesis"], ["proof (prove)\nusing this:\n  int d - int (\\<b> ps 1) + int 1 gchoose 1 =\n  1 + (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0)\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n    (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n        (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "by (simp only:)"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n -\n  (int d - int (\\<b> ps 1) + int 1 gchoose 1) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int (Suc j) gchoose Suc j -\n      (int d - int (\\<b> ps (Suc j)) + int j gchoose j)) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n  (\\<Sum>j = 1..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = ?f (\\<b> ps (Suc n)) n - 1 - (\\<Sum>j=0..n-1. (int d - \\<b> ps (Suc j) + j) gchoose (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n    (\\<Sum>j = 1..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (\\<Sum>j = 0..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)", "by (simp only: sum.atLeast_Suc_atMost[OF le0], simp)"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = 0..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (int d - int (\\<b> ps (Suc 0)) gchoose Suc 0) -\n  (\\<Sum>j = 1..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = 0..n - 1. int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = ?f (\\<b> ps (Suc n)) n - 1 - (\\<Sum>j=Suc 0..Suc (n-1). (int d - \\<b> ps j + j - 1) gchoose j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (\\<Sum>j = 0..n - 1.\n        int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j) =\n    int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (\\<Sum>j = Suc 0..Suc (n - 1).\n        int d - int (\\<b> ps j) + int j - 1 gchoose j)", "by (simp only: sum.shift_bounds_cl_Suc_ivl, simp add: ac_simps)"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = 0..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = Suc 0..Suc (n - 1).\n      int d - int (\\<b> ps j) + int j - 1 gchoose j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = 0..n - 1.\n      int d - int (\\<b> ps (Suc j)) + int j gchoose Suc j) =\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = Suc 0..Suc (n - 1).\n      int d - int (\\<b> ps j) + int j - 1 gchoose j)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = Hilbert_poly (\\<b> ps) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (\\<Sum>j = Suc 0..Suc (n - 1).\n        int d - int (\\<b> ps j) + int j - 1 gchoose j) =\n    Hilbert_poly (\\<b> ps) (int d)", "using \\<open>0 < n\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n    (\\<Sum>j = Suc 0..Suc (n - 1).\n        int d - int (\\<b> ps j) + int j - 1 gchoose j) =\n    Hilbert_poly (\\<b> ps) (int d)", "by (simp add: Hilbert_poly_def Let_def n_def)"], ["proof (state)\nthis:\n  int d - int (\\<b> ps (Suc n)) + int n gchoose n - 1 -\n  (\\<Sum>j = Suc 0..Suc (n - 1).\n      int d - int (\\<b> ps j) + int j - 1 gchoose j) =\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "finally"], ["proof (chain)\npicking this:\n  int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  Hilbert_poly (\\<b> ps) (int d)", "have eq2: \"int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) = Hilbert_poly (\\<b> ps) (int d)\""], ["proof (prove)\nusing this:\n  int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n    Hilbert_poly (\\<b> ps) (int d)", "."], ["proof (state)\nthis:\n  int (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "from assms(4, 2, 3)"], ["proof (chain)\npicking this:\n  cone_decomp T ps\n  valid_decomp X ps\n  hom_decomp ps", "have \"Hilbert_fun T d = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n  valid_decomp X ps\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. Hilbert_fun T d = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d)", "by (rule Hilbert_fun_cone_decomp)"], ["proof (state)\nthis:\n  Hilbert_fun T d = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  Hilbert_fun T d = (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = (\\<Sum>hU\\<in>(set ps - set (ps\\<^sub>+)) \\<union> set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d) =\n    (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n       Hilbert_fun (cone hU) d)", "by (simp only: eq0)"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d) =\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n     Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps. Hilbert_fun (cone hU) d) =\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n     Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) + (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n       Hilbert_fun (cone hU) d) =\n    (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n    (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)", "using fin2 finite_set"], ["proof (prove)\nusing this:\n  finite (set ps - set (ps\\<^sub>+))\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n       Hilbert_fun (cone hU) d) =\n    (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n    (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)", "by (rule sum.union_disjoint) blast"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n     Hilbert_fun (cone hU) d) =\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+) \\<union> set (ps\\<^sub>+).\n     Hilbert_fun (cone hU) d) =\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} + (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n    (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n    card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} +\n    (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)", "by (simp only: eq1)"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} +\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  (\\<Sum>hU\\<in>set ps - set (ps\\<^sub>+). Hilbert_fun (cone hU) d) +\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d) =\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} +\n  (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "have \"int \\<dots> = card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} + Hilbert_poly (\\<b> ps) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} +\n         (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "by (simp only: eq2 int_plus)"], ["proof (state)\nthis:\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} +\n       (\\<Sum>hU\\<in>set (ps\\<^sub>+). Hilbert_fun (cone hU) d)) =\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "finally"], ["proof (chain)\npicking this:\n  int (Hilbert_fun T d) =\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (Hilbert_fun T d) =\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "."], ["proof (state)\nthis:\n  int (Hilbert_fun T d) =\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Hilbert_fun_eq_Hilbert_poly:\n  assumes \"X \\<noteq> {}\" and \"valid_decomp X ps\" and \"hom_decomp ps\" and \"cone_decomp T ps\"\n    and \"standard_decomp k ps\" and \"exact_decomp X 0 ps\" and \"\\<b> ps 0 \\<le> d\"\n  shows \"int (Hilbert_fun (T::(_ \\<Rightarrow>\\<^sub>0 'a::field) set) d) = Hilbert_poly (\\<b> ps) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "from fin_X"], ["proof (chain)\npicking this:\n  finite X", "have \"\\<b> ps (Suc 0) \\<le> \\<b> ps 0\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) \\<le> \\<b> ps 0", "using le0"], ["proof (prove)\nusing this:\n  finite X\n  0 \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) \\<le> \\<b> ps 0", "by (rule \\<b>_decreasing)"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) \\<le> \\<b> ps 0\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) \\<le> \\<b> ps 0\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps 0 \\<le> d", "by fact"], ["proof (state)\nthis:\n  \\<b> ps 0 \\<le> d\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "finally"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc 0) \\<le> d", "have \"\\<b> ps (Suc 0) \\<le> d\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc 0) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) \\<le> d", "."], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) \\<le> d\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "with assms(1-6)"], ["proof (chain)\npicking this:\n  X \\<noteq> {}\n  valid_decomp X ps\n  hom_decomp ps\n  cone_decomp T ps\n  standard_decomp k ps\n  exact_decomp X 0 ps\n  \\<b> ps (Suc 0) \\<le> d", "have \"int (Hilbert_fun T d) =\n                int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) + Hilbert_poly (\\<b> ps) (int d)\""], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  valid_decomp X ps\n  hom_decomp ps\n  cone_decomp T ps\n  standard_decomp k ps\n  exact_decomp X 0 ps\n  \\<b> ps (Suc 0) \\<le> d\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) =\n    int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d)", "by (rule Hilbert_fun_eq_Hilbert_poly_plus_card)"], ["proof (state)\nthis:\n  int (Hilbert_fun T d) =\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "also"], ["proof (state)\nthis:\n  int (Hilbert_fun T d) =\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "have \"\\<dots> = Hilbert_poly (\\<b> ps) (int d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d) =\n    Hilbert_poly (\\<b> ps) (int d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d) =\n    Hilbert_poly (\\<b> ps) (int d)", "have eq: \"{h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "assume \"(h, {}) \\<in> set ps\" and \"poly_deg h = d\""], ["proof (state)\nthis:\n  (h, {}) \\<in> set ps\n  poly_deg h = d\n\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "from fin_X this(1) le0"], ["proof (chain)\npicking this:\n  finite X\n  (h, {}) \\<in> set ps\n  0 \\<le> ?n", "have \"poly_deg h < \\<b> ps 0\""], ["proof (prove)\nusing this:\n  finite X\n  (h, {}) \\<in> set ps\n  0 \\<le> ?n\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "by (rule \\<b>)"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "with assms(7)"], ["proof (chain)\npicking this:\n  \\<b> ps 0 \\<le> d\n  poly_deg h < \\<b> ps 0", "have False"], ["proof (prove)\nusing this:\n  \\<b> ps 0 \\<le> d\n  poly_deg h < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>poly_deg h = d\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?h49, {}) \\<in> set ps; poly_deg ?h49 = d\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h49, {}) \\<in> set ps; poly_deg ?h49 = d\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}", "by blast"], ["proof (state)\nthis:\n  {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d} = {}\n\ngoal (1 subgoal):\n 1. int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d) =\n    Hilbert_poly (\\<b> ps) (int d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n    Hilbert_poly (\\<b> ps) (int d) =\n    Hilbert_poly (\\<b> ps) (int d)", "by (simp add: eq)"], ["proof (state)\nthis:\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d) =\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = d}) +\n  Hilbert_poly (\\<b> ps) (int d) =\n  Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "finally"], ["proof (chain)\npicking this:\n  int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)\n\ngoal (1 subgoal):\n 1. int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)", "."], ["proof (state)\nthis:\n  int (Hilbert_fun T d) = Hilbert_poly (\\<b> ps) (int d)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Dub\\'{e}'s Bound\\<close>"], ["", "context\n  fixes f :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::field\"\n  fixes F\n  assumes n_gr_1: \"1 < card X\" and fin_F: \"finite F\" and F_sub: \"F \\<subseteq> P[X]\" and f_in: \"f \\<in> F\"\n    and hom_F: \"\\<And>f'. f' \\<in> F \\<Longrightarrow> homogeneous f'\" and f_max: \"\\<And>f'. f' \\<in> F \\<Longrightarrow> poly_deg f' \\<le> poly_deg f\"\n    and d_gr_0: \"0 < poly_deg f\" and ideal_f_neq: \"ideal {f} \\<noteq> ideal F\"\nbegin"], ["", "private"], ["", "abbreviation (input) \"n \\<equiv> card X\""], ["", "private"], ["", "abbreviation (input) \"d \\<equiv> poly_deg f\""], ["", "lemma f_in_Polys: \"f \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> P[X]", "using f_in F_sub"], ["proof (prove)\nusing this:\n  f \\<in> F\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[X]", ".."], ["", "lemma hom_f: \"homogeneous f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous f", "using f_in"], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. homogeneous f", "by (rule hom_F)"], ["", "lemma f_not_0: \"f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "using d_gr_0"], ["proof (prove)\nusing this:\n  0 < poly_deg f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["", "lemma X_not_empty: \"X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {}", "using n_gr_1"], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {}", "by auto"], ["", "lemma n_gr_0: \"0 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card X", "using \\<open>1 < n\\<close>"], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. 0 < card X", "by simp"], ["", "corollary int_n_minus_1 [simp]: \"int (n - Suc 0) = int n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card X - Suc 0) = int (card X) - 1", "using n_gr_0"], ["proof (prove)\nusing this:\n  0 < card X\n\ngoal (1 subgoal):\n 1. int (card X - Suc 0) = int (card X) - 1", "by simp"], ["", "lemma int_n_minus_2 [simp]: \"int (n - Suc (Suc 0)) = int n - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card X - Suc (Suc 0)) = int (card X) - 2", "using n_gr_1"], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. int (card X - Suc (Suc 0)) = int (card X) - 2", "by simp"], ["", "lemma cone_f_X_sub: \"cone (f, X) \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (f, X) \\<subseteq> P[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cone (f, X) \\<subseteq> P[X]", "have \"cone (f, X) = cone (f * 1, X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (f, X) = cone (f * 1, X)", "by simp"], ["proof (state)\nthis:\n  cone (f, X) = cone (f * 1, X)\n\ngoal (1 subgoal):\n 1. cone (f, X) \\<subseteq> P[X]", "also"], ["proof (state)\nthis:\n  cone (f, X) = cone (f * 1, X)\n\ngoal (1 subgoal):\n 1. cone (f, X) \\<subseteq> P[X]", "from f_in_Polys"], ["proof (chain)\npicking this:\n  f \\<in> P[X]", "have \"\\<dots> \\<subseteq> cone (1, X)\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. cone (f * 1, X) \\<subseteq> cone (1, X)", "by (rule cone_mono_1)"], ["proof (state)\nthis:\n  cone (f * 1, X) \\<subseteq> cone (1, X)\n\ngoal (1 subgoal):\n 1. cone (f, X) \\<subseteq> P[X]", "finally"], ["proof (chain)\npicking this:\n  cone (f, X) \\<subseteq> cone (1, X)", "show ?thesis"], ["proof (prove)\nusing this:\n  cone (f, X) \\<subseteq> cone (1, X)\n\ngoal (1 subgoal):\n 1. cone (f, X) \\<subseteq> P[X]", "by simp"], ["proof (state)\nthis:\n  cone (f, X) \\<subseteq> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_Int_Polys_eq_cone: \"ideal {f} \\<inter> P[X] = cone (f, X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal {f} \\<inter> P[X] = cone (f, X)", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "assume \"p \\<in> ideal {f} \\<inter> P[X]\""], ["proof (state)\nthis:\n  p \\<in> ideal {f} \\<inter> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "hence \"p \\<in> ideal {f}\" and \"p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  p \\<in> ideal {f} \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. p \\<in> ideal {f} &&& p \\<in> P[X]", "by simp_all"], ["proof (state)\nthis:\n  p \\<in> ideal {f}\n  p \\<in> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "have \"finite {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {f}", "by simp"], ["proof (state)\nthis:\n  finite {f}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "then"], ["proof (chain)\npicking this:\n  finite {f}", "obtain q where \"p = (\\<Sum>f'\\<in>{f}. q f' * f')\""], ["proof (prove)\nusing this:\n  finite {f}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = (\\<Sum>f'\\<in>{f}. q f' * f') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p \\<in> ideal {f}\\<close>"], ["proof (prove)\nusing this:\n  finite {f}\n  p \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = (\\<Sum>f'\\<in>{f}. q f' * f') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal.span_finiteE)"], ["proof (state)\nthis:\n  p = (\\<Sum>f'\\<in>{f}. q f' * f')\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "hence p: \"p = q f * f\""], ["proof (prove)\nusing this:\n  p = (\\<Sum>f'\\<in>{f}. q f' * f')\n\ngoal (1 subgoal):\n 1. p = q f * f", "by simp"], ["proof (state)\nthis:\n  p = q f * f\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "with \\<open>p \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> P[X]\n  p = q f * f", "have \"f * q f \\<in> P[X]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n  p = q f * f\n\ngoal (1 subgoal):\n 1. f * q f \\<in> P[X]", "by (simp only: mult.commute)"], ["proof (state)\nthis:\n  f * q f \\<in> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "hence \"q f \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f * q f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q f \\<in> P[X]", "using f_in_Polys f_not_0"], ["proof (prove)\nusing this:\n  f * q f \\<in> P[X]\n  f \\<in> P[X]\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q f \\<in> P[X]", "by (rule times_in_PolysD)"], ["proof (state)\nthis:\n  q f \\<in> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ideal {f} \\<inter> P[X] \\<Longrightarrow> x \\<in> cone (f, X)\n 2. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "with p"], ["proof (chain)\npicking this:\n  p = q f * f\n  q f \\<in> P[X]", "show \"p \\<in> cone (f, X)\""], ["proof (prove)\nusing this:\n  p = q f * f\n  q f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. p \\<in> cone (f, X)", "by (rule coneI)"], ["proof (state)\nthis:\n  p \\<in> cone (f, X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "assume \"p \\<in> cone (f, X)\""], ["proof (state)\nthis:\n  p \\<in> cone (f, X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "then"], ["proof (chain)\npicking this:\n  p \\<in> cone (f, X)", "obtain q where \"q \\<in> P[X]\" and p: \"p = q * f\""], ["proof (prove)\nusing this:\n  p \\<in> cone (f, X)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[X]; p = q * f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[X]\n  p = q * f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "have \"f \\<in> ideal {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> ideal {f}", "by (rule ideal.span_base) simp"], ["proof (state)\nthis:\n  f \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (f, X) \\<Longrightarrow> x \\<in> ideal {f} \\<inter> P[X]", "with \\<open>q \\<in> P[X]\\<close> f_in_Polys"], ["proof (chain)\npicking this:\n  q \\<in> P[X]\n  f \\<in> P[X]\n  f \\<in> ideal {f}", "show \"p \\<in> ideal {f} \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n  f \\<in> P[X]\n  f \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. p \\<in> ideal {f} \\<inter> P[X]", "unfolding p"], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n  f \\<in> P[X]\n  f \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. q * f \\<in> ideal {f} \\<inter> P[X]", "by (intro IntI ideal.span_scale Polys_closed_times)"], ["proof (state)\nthis:\n  p \\<in> ideal {f} \\<inter> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition P_ps where\n  \"P_ps = (SOME x. valid_decomp X (snd x) \\<and> standard_decomp d (snd x) \\<and>\n                        exact_decomp X 0 (snd x) \\<and> cone_decomp (fst x) (snd x) \\<and> hom_decomp (snd x) \\<and>\n                        direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], fst x])\""], ["", "private"], ["", "definition P where \"P = fst P_ps\""], ["", "private"], ["", "definition ps where \"ps = snd P_ps\""], ["", "lemma\n  shows valid_ps: \"valid_decomp X ps\" (is ?thesis1)\n    and std_ps: \"standard_decomp d ps\" (is ?thesis2)\n    and ext_ps: \"exact_decomp X 0 ps\" (is ?thesis3)\n    and cn_ps: \"cone_decomp P ps\" (is ?thesis4)\n    and hom_ps: \"hom_decomp ps\" (is ?thesis5)\n    and decomp_F: \"direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\" (is ?thesis6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_decomp X ps &&&\n     standard_decomp (poly_deg f) ps &&& exact_decomp X 0 ps) &&&\n    cone_decomp P ps &&&\n    hom_decomp ps &&&\n    direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "note fin_X"], ["proof (state)\nthis:\n  finite X\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "moreover"], ["proof (state)\nthis:\n  finite X\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "from fin_F"], ["proof (chain)\npicking this:\n  finite F", "have \"finite (F - {f})\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (F - {f})", "by simp"], ["proof (state)\nthis:\n  finite (F - {f})\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "moreover"], ["proof (state)\nthis:\n  finite (F - {f})\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "from F_sub"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]", "have \"F - {f} \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. F - {f} \\<subseteq> P[X]", "by blast"], ["proof (state)\nthis:\n  F - {f} \\<subseteq> P[X]\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  finite (F - {f})\n  F - {f} \\<subseteq> P[X]", "obtain P' ps' where 1: \"valid_decomp X ps'\" and 2: \"standard_decomp d ps'\"\n    and 3: \"cone_decomp P' ps'\" and 40: \"(\\<And>f'. f' \\<in> F - {f} \\<Longrightarrow> homogeneous f') \\<Longrightarrow> hom_decomp ps'\"\n    and 50: \"direct_decomp (ideal (insert f (F - {f})) \\<inter> P[X]) [ideal {f} \\<inter> P[X], P']\""], ["proof (prove)\nusing this:\n  finite X\n  finite (F - {f})\n  F - {f} \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>ps' P'.\n        \\<lbrakk>valid_decomp X ps'; standard_decomp (poly_deg f) ps';\n         cone_decomp P' ps';\n         (\\<And>f'.\n             f' \\<in> F - {f} \\<Longrightarrow>\n             homogeneous f') \\<Longrightarrow>\n         hom_decomp ps';\n         direct_decomp (ideal (insert f (F - {f})) \\<inter> P[X])\n          [ideal {f} \\<inter> P[X], P']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f_in_Polys f_max"], ["proof (prove)\nusing this:\n  finite X\n  finite (F - {f})\n  F - {f} \\<subseteq> P[X]\n  f \\<in> P[X]\n  ?f'47 \\<in> F \\<Longrightarrow> poly_deg ?f'47 \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. (\\<And>ps' P'.\n        \\<lbrakk>valid_decomp X ps'; standard_decomp (poly_deg f) ps';\n         cone_decomp P' ps';\n         (\\<And>f'.\n             f' \\<in> F - {f} \\<Longrightarrow>\n             homogeneous f') \\<Longrightarrow>\n         hom_decomp ps';\n         direct_decomp (ideal (insert f (F - {f})) \\<inter> P[X])\n          [ideal {f} \\<inter> P[X], P']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal_decompE) blast+"], ["proof (state)\nthis:\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'\n  cone_decomp P' ps'\n  (\\<And>f'.\n      f' \\<in> F - {f} \\<Longrightarrow> homogeneous f') \\<Longrightarrow>\n  hom_decomp ps'\n  direct_decomp (ideal (insert f (F - {f})) \\<inter> P[X])\n   [ideal {f} \\<inter> P[X], P']\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "have 4: \"hom_decomp ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp ps'", "by (intro 40 hom_F) simp"], ["proof (state)\nthis:\n  hom_decomp ps'\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "from 50 f_in"], ["proof (chain)\npicking this:\n  direct_decomp (ideal (insert f (F - {f})) \\<inter> P[X])\n   [ideal {f} \\<inter> P[X], P']\n  f \\<in> F", "have 5: \"direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P']\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f (F - {f})) \\<inter> P[X])\n   [ideal {f} \\<inter> P[X], P']\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P']", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P']\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "let ?ps = \"exact X (poly_deg f) ps'\""], ["proof (state)\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "from fin_X 1 2"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'", "have \"valid_decomp X ?ps\" and \"standard_decomp d ?ps\" and \"exact_decomp X 0 ?ps\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact X (poly_deg f) ps') &&&\n    standard_decomp (poly_deg f) (exact X (poly_deg f) ps') &&&\n    exact_decomp X 0 (exact X (poly_deg f) ps')", "by (rule exact)+"], ["proof (state)\nthis:\n  valid_decomp X (exact X (poly_deg f) ps')\n  standard_decomp (poly_deg f) (exact X (poly_deg f) ps')\n  exact_decomp X 0 (exact X (poly_deg f) ps')\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "moreover"], ["proof (state)\nthis:\n  valid_decomp X (exact X (poly_deg f) ps')\n  standard_decomp (poly_deg f) (exact X (poly_deg f) ps')\n  exact_decomp X 0 (exact X (poly_deg f) ps')\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "from fin_X 1 2 3"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'\n  cone_decomp P' ps'", "have \"cone_decomp P' ?ps\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'\n  cone_decomp P' ps'\n\ngoal (1 subgoal):\n 1. cone_decomp P' (exact X (poly_deg f) ps')", "by (rule cone_decomp_exact)"], ["proof (state)\nthis:\n  cone_decomp P' (exact X (poly_deg f) ps')\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "moreover"], ["proof (state)\nthis:\n  cone_decomp P' (exact X (poly_deg f) ps')\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "from fin_X 1 2 4"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'\n  hom_decomp ps'", "have \"hom_decomp ?ps\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps'\n  standard_decomp (poly_deg f) ps'\n  hom_decomp ps'\n\ngoal (1 subgoal):\n 1. hom_decomp (exact X (poly_deg f) ps')", "by (rule hom_decomp_exact)"], ["proof (state)\nthis:\n  hom_decomp (exact X (poly_deg f) ps')\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X (exact X (poly_deg f) ps')\n  standard_decomp (poly_deg f) (exact X (poly_deg f) ps')\n  exact_decomp X 0 (exact X (poly_deg f) ps')\n  cone_decomp P' (exact X (poly_deg f) ps')\n  hom_decomp (exact X (poly_deg f) ps')", "have \"valid_decomp X (snd (P', ?ps)) \\<and> standard_decomp d (snd (P', ?ps)) \\<and>\n                    exact_decomp X 0 (snd (P', ?ps)) \\<and> cone_decomp (fst (P', ?ps)) (snd (P', ?ps)) \\<and>\n                    hom_decomp (snd (P', ?ps)) \\<and>\n                    direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], fst (P', ?ps)]\""], ["proof (prove)\nusing this:\n  valid_decomp X (exact X (poly_deg f) ps')\n  standard_decomp (poly_deg f) (exact X (poly_deg f) ps')\n  exact_decomp X 0 (exact X (poly_deg f) ps')\n  cone_decomp P' (exact X (poly_deg f) ps')\n  hom_decomp (exact X (poly_deg f) ps')\n\ngoal (1 subgoal):\n 1. valid_decomp X (snd (P', exact X (poly_deg f) ps')) \\<and>\n    standard_decomp (poly_deg f) (snd (P', exact X (poly_deg f) ps')) \\<and>\n    exact_decomp X 0 (snd (P', exact X (poly_deg f) ps')) \\<and>\n    cone_decomp (fst (P', exact X (poly_deg f) ps'))\n     (snd (P', exact X (poly_deg f) ps')) \\<and>\n    hom_decomp (snd (P', exact X (poly_deg f) ps')) \\<and>\n    direct_decomp (ideal F \\<inter> P[X])\n     [ideal {f} \\<inter> P[X], fst (P', exact X (poly_deg f) ps')]", "using 5"], ["proof (prove)\nusing this:\n  valid_decomp X (exact X (poly_deg f) ps')\n  standard_decomp (poly_deg f) (exact X (poly_deg f) ps')\n  exact_decomp X 0 (exact X (poly_deg f) ps')\n  cone_decomp P' (exact X (poly_deg f) ps')\n  hom_decomp (exact X (poly_deg f) ps')\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P']\n\ngoal (1 subgoal):\n 1. valid_decomp X (snd (P', exact X (poly_deg f) ps')) \\<and>\n    standard_decomp (poly_deg f) (snd (P', exact X (poly_deg f) ps')) \\<and>\n    exact_decomp X 0 (snd (P', exact X (poly_deg f) ps')) \\<and>\n    cone_decomp (fst (P', exact X (poly_deg f) ps'))\n     (snd (P', exact X (poly_deg f) ps')) \\<and>\n    hom_decomp (snd (P', exact X (poly_deg f) ps')) \\<and>\n    direct_decomp (ideal F \\<inter> P[X])\n     [ideal {f} \\<inter> P[X], fst (P', exact X (poly_deg f) ps')]", "by simp"], ["proof (state)\nthis:\n  valid_decomp X (snd (P', exact X (poly_deg f) ps')) \\<and>\n  standard_decomp (poly_deg f) (snd (P', exact X (poly_deg f) ps')) \\<and>\n  exact_decomp X 0 (snd (P', exact X (poly_deg f) ps')) \\<and>\n  cone_decomp (fst (P', exact X (poly_deg f) ps'))\n   (snd (P', exact X (poly_deg f) ps')) \\<and>\n  hom_decomp (snd (P', exact X (poly_deg f) ps')) \\<and>\n  direct_decomp (ideal F \\<inter> P[X])\n   [ideal {f} \\<inter> P[X], fst (P', exact X (poly_deg f) ps')]\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "hence \"?thesis1 \\<and> ?thesis2 \\<and> ?thesis3 \\<and> ?thesis4 \\<and> ?thesis5 \\<and> ?thesis6\""], ["proof (prove)\nusing this:\n  valid_decomp X (snd (P', exact X (poly_deg f) ps')) \\<and>\n  standard_decomp (poly_deg f) (snd (P', exact X (poly_deg f) ps')) \\<and>\n  exact_decomp X 0 (snd (P', exact X (poly_deg f) ps')) \\<and>\n  cone_decomp (fst (P', exact X (poly_deg f) ps'))\n   (snd (P', exact X (poly_deg f) ps')) \\<and>\n  hom_decomp (snd (P', exact X (poly_deg f) ps')) \\<and>\n  direct_decomp (ideal F \\<inter> P[X])\n   [ideal {f} \\<inter> P[X], fst (P', exact X (poly_deg f) ps')]\n\ngoal (1 subgoal):\n 1. valid_decomp X ps \\<and>\n    standard_decomp (poly_deg f) ps \\<and>\n    exact_decomp X 0 ps \\<and>\n    cone_decomp P ps \\<and>\n    hom_decomp ps \\<and>\n    direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "unfolding P_def ps_def P_ps_def"], ["proof (prove)\nusing this:\n  valid_decomp X (snd (P', exact X (poly_deg f) ps')) \\<and>\n  standard_decomp (poly_deg f) (snd (P', exact X (poly_deg f) ps')) \\<and>\n  exact_decomp X 0 (snd (P', exact X (poly_deg f) ps')) \\<and>\n  cone_decomp (fst (P', exact X (poly_deg f) ps'))\n   (snd (P', exact X (poly_deg f) ps')) \\<and>\n  hom_decomp (snd (P', exact X (poly_deg f) ps')) \\<and>\n  direct_decomp (ideal F \\<inter> P[X])\n   [ideal {f} \\<inter> P[X], fst (P', exact X (poly_deg f) ps')]\n\ngoal (1 subgoal):\n 1. valid_decomp X\n     (snd (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x])) \\<and>\n    standard_decomp (poly_deg f)\n     (snd (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x])) \\<and>\n    exact_decomp X 0\n     (snd (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x])) \\<and>\n    cone_decomp\n     (fst (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x]))\n     (snd (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x])) \\<and>\n    hom_decomp\n     (snd (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x])) \\<and>\n    direct_decomp (ideal F \\<inter> P[X])\n     [ideal {f} \\<inter> P[X],\n      fst (SOME x.\n              valid_decomp X (snd x) \\<and>\n              standard_decomp (poly_deg f) (snd x) \\<and>\n              exact_decomp X 0 (snd x) \\<and>\n              cone_decomp (fst x) (snd x) \\<and>\n              hom_decomp (snd x) \\<and>\n              direct_decomp (ideal F \\<inter> P[X])\n               [ideal {f} \\<inter> P[X], fst x])]", "by (rule someI)"], ["proof (state)\nthis:\n  valid_decomp X ps \\<and>\n  standard_decomp (poly_deg f) ps \\<and>\n  exact_decomp X 0 ps \\<and>\n  cone_decomp P ps \\<and>\n  hom_decomp ps \\<and>\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\n\ngoal (6 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f) ps\n 3. exact_decomp X 0 ps\n 4. cone_decomp P ps\n 5. hom_decomp ps\n 6. direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "thus ?thesis1 and ?thesis2 and ?thesis3 and ?thesis4 and ?thesis5 and ?thesis6"], ["proof (prove)\nusing this:\n  valid_decomp X ps \\<and>\n  standard_decomp (poly_deg f) ps \\<and>\n  exact_decomp X 0 ps \\<and>\n  cone_decomp P ps \\<and>\n  hom_decomp ps \\<and>\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\n\ngoal (1 subgoal):\n 1. (valid_decomp X ps &&&\n     standard_decomp (poly_deg f) ps &&& exact_decomp X 0 ps) &&&\n    cone_decomp P ps &&&\n    hom_decomp ps &&&\n    direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]", "by simp_all"], ["proof (state)\nthis:\n  valid_decomp X ps\n  standard_decomp (poly_deg f) ps\n  exact_decomp X 0 ps\n  cone_decomp P ps\n  hom_decomp ps\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P_sub: \"P \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> P[X]", "using valid_ps cn_ps"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  cone_decomp P ps\n\ngoal (1 subgoal):\n 1. P \\<subseteq> P[X]", "by (rule valid_cone_decomp_subset_Polys)"], ["", "lemma ps_not_Nil: \"ps\\<^sub>+ \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "assume \"ps\\<^sub>+ = []\""], ["proof (state)\nthis:\n  ps\\<^sub>+ = []\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have \"Keys P \\<subseteq> (\\<Union>hU\\<in>set ps. keys (fst hU))\" (is \"_ \\<subseteq> ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys P \\<subseteq> (\\<Union>hU\\<in>set ps. keys (fst hU))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "assume \"t \\<in> Keys P\""], ["proof (state)\nthis:\n  t \\<in> Keys P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "then"], ["proof (chain)\npicking this:\n  t \\<in> Keys P", "obtain p where \"p \\<in> P\" and \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  t \\<in> Keys P\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> P; t \\<in> keys p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  p \\<in> P\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "from cn_ps"], ["proof (chain)\npicking this:\n  cone_decomp P ps", "have \"direct_decomp P (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp P ps\n\ngoal (1 subgoal):\n 1. direct_decomp P (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp P (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "then"], ["proof (chain)\npicking this:\n  direct_decomp P (map cone ps)", "obtain qs where qs: \"qs \\<in> listset (map cone ps)\" and p: \"p = sum_list qs\""], ["proof (prove)\nusing this:\n  direct_decomp P (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> listset (map cone ps); p = sum_list qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p \\<in> P\\<close>"], ["proof (prove)\nusing this:\n  direct_decomp P (map cone ps)\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> listset (map cone ps); p = sum_list qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  qs \\<in> listset (map cone ps)\n  p = sum_list qs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "from \\<open>t \\<in> keys p\\<close> keys_sum_list_subset"], ["proof (chain)\npicking this:\n  t \\<in> keys p\n  keys (sum_list ?ps) \\<subseteq> Keys (set ?ps)", "have \"t \\<in> Keys (set qs)\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  keys (sum_list ?ps) \\<subseteq> Keys (set ?ps)\n\ngoal (1 subgoal):\n 1. t \\<in> Keys (set qs)", "unfolding p"], ["proof (prove)\nusing this:\n  t \\<in> keys (sum_list qs)\n  keys (sum_list ?ps) \\<subseteq> Keys (set ?ps)\n\ngoal (1 subgoal):\n 1. t \\<in> Keys (set qs)", ".."], ["proof (state)\nthis:\n  t \\<in> Keys (set qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "then"], ["proof (chain)\npicking this:\n  t \\<in> Keys (set qs)", "obtain q where \"q \\<in> set qs\" and \"t \\<in> keys q\""], ["proof (prove)\nusing this:\n  t \\<in> Keys (set qs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set qs; t \\<in> keys q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  q \\<in> set qs\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> set qs", "obtain i where \"i < length qs\" and \"q = qs ! i\""], ["proof (prove)\nusing this:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length qs; q = qs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length qs\n  q = qs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "with qs"], ["proof (chain)\npicking this:\n  qs \\<in> listset (map cone ps)\n  i < length qs\n  q = qs ! i", "have \"i < length ps\" and \"q \\<in> (map cone ps) ! i\""], ["proof (prove)\nusing this:\n  qs \\<in> listset (map cone ps)\n  i < length qs\n  q = qs ! i\n\ngoal (1 subgoal):\n 1. i < length ps &&& q \\<in> map cone ps ! i", "by (simp_all add: listsetD del: nth_map)"], ["proof (state)\nthis:\n  i < length ps\n  q \\<in> map cone ps ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "hence \"q \\<in> cone (ps ! i)\""], ["proof (prove)\nusing this:\n  i < length ps\n  q \\<in> map cone ps ! i\n\ngoal (1 subgoal):\n 1. q \\<in> cone (ps ! i)", "by simp"], ["proof (state)\nthis:\n  q \\<in> cone (ps ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "obtain h U where eq: \"ps ! i = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. ps ! i = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. ps ! i = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ps ! i = (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "from \\<open>i < length ps\\<close> this[symmetric]"], ["proof (chain)\npicking this:\n  i < length ps\n  (h, U) = ps ! i", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  i < length ps\n  (h, U) = ps ! i\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "have \"U = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow> False", "assume \"U \\<noteq> {}\""], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow> False", "with \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}", "have \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow> False", "with \\<open>ps\\<^sub>+ = []\\<close>"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ = []\n  (h, U) \\<in> set (ps\\<^sub>+)", "show False"], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "with \\<open>q \\<in> cone (ps ! i)\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> cone (ps ! i)\n  U = {}", "have \"q \\<in> range (\\<lambda>c. c \\<cdot> h)\""], ["proof (prove)\nusing this:\n  q \\<in> cone (ps ! i)\n  U = {}\n\ngoal (1 subgoal):\n 1. q \\<in> range (\\<lambda>c. c \\<cdot> h)", "by (simp only: eq cone_empty)"], ["proof (state)\nthis:\n  q \\<in> range (\\<lambda>c. c \\<cdot> h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "then"], ["proof (chain)\npicking this:\n  q \\<in> range (\\<lambda>c. c \\<cdot> h)", "obtain c where \"q = c \\<cdot> h\""], ["proof (prove)\nusing this:\n  q \\<in> range (\\<lambda>c. c \\<cdot> h)\n\ngoal (1 subgoal):\n 1. (\\<And>c. q = c \\<cdot> h \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q = c \\<cdot> h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "also"], ["proof (state)\nthis:\n  q = c \\<cdot> h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "have \"keys \\<dots> \\<subseteq> keys h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (c \\<cdot> h) \\<subseteq> keys h", "by (fact keys_map_scale_subset)"], ["proof (state)\nthis:\n  keys (c \\<cdot> h) \\<subseteq> keys h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "finally"], ["proof (chain)\npicking this:\n  keys q \\<subseteq> keys h", "have \"t \\<in> keys h\""], ["proof (prove)\nusing this:\n  keys q \\<subseteq> keys h\n\ngoal (1 subgoal):\n 1. t \\<in> keys h", "using \\<open>t \\<in> keys q\\<close>"], ["proof (prove)\nusing this:\n  keys q \\<subseteq> keys h\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys h", ".."], ["proof (state)\nthis:\n  t \\<in> keys h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "hence \"t \\<in> keys (fst (h, U))\""], ["proof (prove)\nusing this:\n  t \\<in> keys h\n\ngoal (1 subgoal):\n 1. t \\<in> keys (fst (h, U))", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys (fst (h, U))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys P \\<Longrightarrow>\n       x \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", "with \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  t \\<in> keys (fst (h, U))", "show \"t \\<in> ?A\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  t \\<in> keys (fst (h, U))\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))", ".."], ["proof (state)\nthis:\n  t \\<in> (\\<Union>hU\\<in>set ps. keys (fst hU))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Keys P \\<subseteq> (\\<Union>hU\\<in>set ps. keys (fst hU))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Keys P \\<subseteq> (\\<Union>hU\\<in>set ps. keys (fst hU))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from finite_set finite_keys"], ["proof (chain)\npicking this:\n  finite (set ?xs)\n  finite (keys ?f)", "have \"finite ?A\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite (\\<Union>hU\\<in>set ps. keys (fst hU))", "by (rule finite_UN_I)"], ["proof (state)\nthis:\n  finite (\\<Union>hU\\<in>set ps. keys (fst hU))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Keys P \\<subseteq> (\\<Union>hU\\<in>set ps. keys (fst hU))\n  finite (\\<Union>hU\\<in>set ps. keys (fst hU))", "have \"finite (Keys P)\""], ["proof (prove)\nusing this:\n  Keys P \\<subseteq> (\\<Union>hU\\<in>set ps. keys (fst hU))\n  finite (\\<Union>hU\\<in>set ps. keys (fst hU))\n\ngoal (1 subgoal):\n 1. finite (Keys P)", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (Keys P)\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have \"\\<exists>q\\<in>ideal F. q \\<in> P[X] \\<and> q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>ideal F.\n       q \\<in> P[X] \\<and> q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>ideal F.\n               q \\<in> P[X] \\<and>\n               q \\<noteq> 0 \\<and>\n               \\<not> lpp f adds lpp q) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>q\\<in>ideal F. q \\<in> P[X] \\<and> q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>ideal F.\n             q \\<in> P[X] \\<and>\n             q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>ideal F.\n               q \\<in> P[X] \\<and>\n               q \\<noteq> 0 \\<and>\n               \\<not> lpp f adds lpp q) \\<Longrightarrow>\n    False", "hence adds: \"lpp f adds lpp q\" if \"q \\<in> ideal F\" and \"q \\<in> P[X]\" and \"q \\<noteq> 0\" for q"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>q\\<in>ideal F.\n             q \\<in> P[X] \\<and>\n             q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q)\n\ngoal (1 subgoal):\n 1. lpp f adds lpp q", "using that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>q\\<in>ideal F.\n             q \\<in> P[X] \\<and>\n             q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q)\n  q \\<in> ideal F\n  q \\<in> P[X]\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp f adds lpp q", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?q47 \\<in> ideal F; ?q47 \\<in> P[X]; ?q47 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> lpp f adds lpp ?q47\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>ideal F.\n               q \\<in> P[X] \\<and>\n               q \\<noteq> 0 \\<and>\n               \\<not> lpp f adds lpp q) \\<Longrightarrow>\n    False", "from fin_X _ F_sub"], ["proof (chain)\npicking this:\n  finite X\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  F \\<subseteq> P[X]", "have \"ideal {f} = ideal F\""], ["proof (prove)\nusing this:\n  finite X\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. ideal {f} = ideal F", "proof (rule punit.pmdl_eqI_adds_lt_dgrad_p_set[simplified, OF dickson_grading_varnum,\n          where m=0, simplified dgrad_p_set_varnum])"], ["proof (state)\ngoal (3 subgoals):\n 1. {f} \\<subseteq> P[X]\n 2. ideal {f} \\<subseteq> ideal F\n 3. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "from f_in_Polys"], ["proof (chain)\npicking this:\n  f \\<in> P[X]", "show \"{f} \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. {f} \\<subseteq> P[X]", "by simp"], ["proof (state)\nthis:\n  {f} \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. ideal {f} \\<subseteq> ideal F\n 2. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ideal {f} \\<subseteq> ideal F\n 2. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "from f_in"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"{f} \\<subseteq> F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. {f} \\<subseteq> F", "by simp"], ["proof (state)\nthis:\n  {f} \\<subseteq> F\n\ngoal (2 subgoals):\n 1. ideal {f} \\<subseteq> ideal F\n 2. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "thus \"ideal {f} \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  {f} \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal {f} \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal {f} \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "assume \"q \\<in> ideal F\" and \"q \\<in> P[X]\" and \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<in> ideal F\n  q \\<in> P[X]\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "hence \"lpp f adds lpp q\""], ["proof (prove)\nusing this:\n  q \\<in> ideal F\n  q \\<in> P[X]\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp f adds lpp q", "by (rule adds)"], ["proof (state)\nthis:\n  lpp f adds lpp q\n\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>fa \\<in> ideal F; fa \\<in> P[X]; fa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>{f}.\n                            g \\<noteq> 0 \\<and> lpp g adds lpp fa", "with f_not_0"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  lpp f adds lpp q", "show \"\\<exists>g\\<in>{f}. g \\<noteq> 0 \\<and> lpp g adds lpp q\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  lpp f adds lpp q\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>{f}. g \\<noteq> 0 \\<and> lpp g adds lpp q", "by blast"], ["proof (state)\nthis:\n  \\<exists>g\\<in>{f}. g \\<noteq> 0 \\<and> lpp g adds lpp q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal {f} = ideal F\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>ideal F.\n               q \\<in> P[X] \\<and>\n               q \\<noteq> 0 \\<and>\n               \\<not> lpp f adds lpp q) \\<Longrightarrow>\n    False", "with ideal_f_neq"], ["proof (chain)\npicking this:\n  ideal {f} \\<noteq> ideal F\n  ideal {f} = ideal F", "show False"], ["proof (prove)\nusing this:\n  ideal {f} \\<noteq> ideal F\n  ideal {f} = ideal F\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>ideal F.\n     q \\<in> P[X] \\<and> q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>ideal F.\n     q \\<in> P[X] \\<and> q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q", "obtain q0 where \"q0 \\<in> ideal F\" and \"q0 \\<in> P[X]\" and \"q0 \\<noteq> 0\"\n    and nadds_q0: \"\\<not> lpp f adds lpp q0\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>ideal F.\n     q \\<in> P[X] \\<and> q \\<noteq> 0 \\<and> \\<not> lpp f adds lpp q\n\ngoal (1 subgoal):\n 1. (\\<And>q0.\n        \\<lbrakk>q0 \\<in> ideal F; q0 \\<in> P[X]; q0 \\<noteq> 0;\n         \\<not> lpp f adds lpp q0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q0 \\<in> ideal F\n  q0 \\<in> P[X]\n  q0 \\<noteq> 0\n  \\<not> lpp f adds lpp q0\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "define q where \"q = hom_component q0 (deg_pm (lpp q0))\""], ["proof (state)\nthis:\n  q = hom_component q0 (deg_pm (lpp q0))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from hom_F \\<open>q0 \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  ?f'47 \\<in> F \\<Longrightarrow> homogeneous ?f'47\n  q0 \\<in> ideal F", "have \"q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  ?f'47 \\<in> F \\<Longrightarrow> homogeneous ?f'47\n  q0 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. q \\<in> ideal F", "unfolding q_def"], ["proof (prove)\nusing this:\n  ?f'47 \\<in> F \\<Longrightarrow> homogeneous ?f'47\n  q0 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. hom_component q0 (deg_pm (lpp q0)) \\<in> ideal F", "by (rule homogeneous_ideal)"], ["proof (state)\nthis:\n  q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from homogeneous_set_Polys \\<open>q0 \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  homogeneous_set P[?X]\n  q0 \\<in> P[X]", "have \"q \\<in> P[X]\""], ["proof (prove)\nusing this:\n  homogeneous_set P[?X]\n  q0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", "unfolding q_def"], ["proof (prove)\nusing this:\n  homogeneous_set P[?X]\n  q0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. hom_component q0 (deg_pm (lpp q0)) \\<in> P[X]", "by (rule homogeneous_setD)"], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from \\<open>q0 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q0 \\<noteq> 0", "have \"q \\<noteq> 0\" and \"lpp q = lpp q0\""], ["proof (prove)\nusing this:\n  q0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& lpp q = lpp q0", "unfolding q_def"], ["proof (prove)\nusing this:\n  q0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hom_component q0 (deg_pm (lpp q0)) \\<noteq> 0 &&&\n    lpp (hom_component q0 (deg_pm (lpp q0))) = lpp q0", "by (rule hom_component_lpp)+"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  lpp q = lpp q0\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from nadds_q0 this(2)"], ["proof (chain)\npicking this:\n  \\<not> lpp f adds lpp q0\n  lpp q = lpp q0", "have nadds_q: \"\\<not> lpp f adds lpp q\""], ["proof (prove)\nusing this:\n  \\<not> lpp f adds lpp q0\n  lpp q = lpp q0\n\ngoal (1 subgoal):\n 1. \\<not> lpp f adds lpp q", "by simp"], ["proof (state)\nthis:\n  \\<not> lpp f adds lpp q\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have hom_q: \"homogeneous q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous q", "by (simp only: q_def homogeneous_hom_component)"], ["proof (state)\nthis:\n  homogeneous q\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from nadds_q"], ["proof (chain)\npicking this:\n  \\<not> lpp f adds lpp q", "obtain x where x: \"\\<not> lookup (lpp f) x \\<le> lookup (lpp q) x\""], ["proof (prove)\nusing this:\n  \\<not> lpp f adds lpp q\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<not> lookup (lpp f) x \\<le> lookup (lpp q) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: adds_poly_mapping le_fun_def)"], ["proof (state)\nthis:\n  \\<not> lookup (lpp f) x \\<le> lookup (lpp q) x\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "obtain y where \"y \\<in> X\" and \"y \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from n_gr_1"], ["proof (chain)\npicking this:\n  1 < card X", "have \"2 \\<le> n\""], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. 2 \\<le> card X", "by simp"], ["proof (state)\nthis:\n  2 \\<le> card X\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card X", "obtain Y where \"Y \\<subseteq> X\" and \"card Y = 2\""], ["proof (prove)\nusing this:\n  2 \\<le> card X\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<subseteq> X; card Y = 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule card_geq_ex_subset)"], ["proof (state)\nthis:\n  Y \\<subseteq> X\n  card Y = 2\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2)"], ["proof (chain)\npicking this:\n  card Y = 2", "obtain u v where \"u \\<noteq> v\" and \"Y = {u, v}\""], ["proof (prove)\nusing this:\n  card Y = 2\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<noteq> v; Y = {u, v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule card_2_E)"], ["proof (state)\nthis:\n  u \\<noteq> v\n  Y = {u, v}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this"], ["proof (chain)\npicking this:\n  u \\<noteq> v\n  Y = {u, v}", "obtain y where \"y \\<in> Y\" and \"y \\<noteq> x\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  Y = {u, v}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> Y; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> Y\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1) \\<open>Y \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> Y\n  Y \\<subseteq> X", "have \"y \\<in> X\""], ["proof (prove)\nusing this:\n  y \\<in> Y\n  Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. y \\<in> X", ".."], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> X; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>y \\<noteq> x\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> X\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> X\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "define q' where \"q' = (\\<lambda>k. punit.monom_mult 1 (Poly_Mapping.single y k) q)\""], ["proof (state)\nthis:\n  q' = (\\<lambda>k. local.punit.monom_mult (1::'a) (monomial k y) q)\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have inj1: \"inj q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj q'", "by (auto intro!: injI simp: q'_def \\<open>q \\<noteq> 0\\<close> dest: punit.monom_mult_inj_2 monomial_inj)"], ["proof (state)\nthis:\n  inj q'\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have q'_in: \"q' k \\<in> ideal F \\<inter> P[X]\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' k \\<in> ideal F \\<inter> P[X]", "unfolding q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial k y) q\n    \\<in> ideal F \\<inter> P[X]", "using \\<open>q \\<in> ideal F\\<close> \\<open>q \\<in> P[X]\\<close> \\<open>y \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> ideal F\n  q \\<in> P[X]\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial k y) q\n    \\<in> ideal F \\<inter> P[X]", "by (intro IntI punit.pmdl_closed_monom_mult[simplified] Polys_closed_monom_mult PPs_closed_single)"], ["proof (state)\nthis:\n  q' ?k47 \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have lpp_q': \"lpp (q' k) = Poly_Mapping.single y k + lpp q\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp (q' k) = monomial k y + lpp q", "using \\<open>q \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (q' k) = monomial k y + lpp q", "by (simp add: q'_def punit.lt_monom_mult)"], ["proof (state)\nthis:\n  lpp (q' ?k47) = monomial ?k47 y + lpp q\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have inj2: \"inj_on (deg_pm \\<circ> lpp) (range q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (deg_pm \\<circ> lpp) (range q')", "by (auto intro!: inj_onI simp: lpp_q' deg_pm_plus deg_pm_single dest: monomial_inj)"], ["proof (state)\nthis:\n  inj_on (deg_pm \\<circ> lpp) (range q')\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "have \"(deg_pm \\<circ> lpp) ` range q' \\<subseteq> deg_pm ` Keys P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (deg_pm \\<circ> lpp) ` range q' \\<subseteq> deg_pm ` Keys P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "assume \"d \\<in> (deg_pm \\<circ> lpp) ` range q'\""], ["proof (state)\nthis:\n  d \\<in> (deg_pm \\<circ> lpp) ` range q'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "then"], ["proof (chain)\npicking this:\n  d \\<in> (deg_pm \\<circ> lpp) ` range q'", "obtain k where d: \"d = deg_pm (lpp (q' k))\" (is \"_ = deg_pm ?t\")"], ["proof (prove)\nusing this:\n  d \\<in> (deg_pm \\<circ> lpp) ` range q'\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        d = deg_pm (lpp (q' k)) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d = deg_pm (lpp (q' k))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "from hom_q"], ["proof (chain)\npicking this:\n  homogeneous q", "have hom_q': \"homogeneous (q' k)\""], ["proof (prove)\nusing this:\n  homogeneous q\n\ngoal (1 subgoal):\n 1. homogeneous (q' k)", "by (simp add: q'_def homogeneous_monom_mult)"], ["proof (state)\nthis:\n  homogeneous (q' k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "from \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have \"q' k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q' k \\<noteq> 0", "by (simp add: q'_def punit.monom_mult_eq_zero_iff)"], ["proof (state)\nthis:\n  q' k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "hence \"?t \\<in> keys (q' k)\""], ["proof (prove)\nusing this:\n  q' k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (q' k) \\<in> keys (q' k)", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp (q' k) \\<in> keys (q' k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "with hom_q'"], ["proof (chain)\npicking this:\n  homogeneous (q' k)\n  lpp (q' k) \\<in> keys (q' k)", "have deg_q': \"d = poly_deg (q' k)\""], ["proof (prove)\nusing this:\n  homogeneous (q' k)\n  lpp (q' k) \\<in> keys (q' k)\n\ngoal (1 subgoal):\n 1. d = poly_deg (q' k)", "unfolding d"], ["proof (prove)\nusing this:\n  homogeneous (q' k)\n  lpp (q' k) \\<in> keys (q' k)\n\ngoal (1 subgoal):\n 1. deg_pm (lpp (q' k)) = poly_deg (q' k)", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  d = poly_deg (q' k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "from decomp_F q'_in"], ["proof (chain)\npicking this:\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\n  q' ?k47 \\<in> ideal F \\<inter> P[X]", "obtain qs where \"qs \\<in> listset [ideal {f} \\<inter> P[X], P]\" and \"q' k = sum_list qs\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\n  q' ?k47 \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> listset [ideal {f} \\<inter> P[X], P];\n         q' k = sum_list qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  qs \\<in> listset [ideal {f} \\<inter> P[X], P]\n  q' k = sum_list qs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "moreover"], ["proof (state)\nthis:\n  qs \\<in> listset [ideal {f} \\<inter> P[X], P]\n  q' k = sum_list qs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "from this(1)"], ["proof (chain)\npicking this:\n  qs \\<in> listset [ideal {f} \\<inter> P[X], P]", "obtain f0 p0 where f0: \"f0 \\<in> ideal {f} \\<inter> P[X]\" and p0: \"p0 \\<in> P\"\n      and \"qs = [f0, p0]\""], ["proof (prove)\nusing this:\n  qs \\<in> listset [ideal {f} \\<inter> P[X], P]\n\ngoal (1 subgoal):\n 1. (\\<And>f0 p0.\n        \\<lbrakk>f0 \\<in> ideal {f} \\<inter> P[X]; p0 \\<in> P;\n         qs = [f0, p0]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  f0 \\<in> ideal {f} \\<inter> P[X]\n  p0 \\<in> P\n  qs = [f0, p0]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "ultimately"], ["proof (chain)\npicking this:\n  qs \\<in> listset [ideal {f} \\<inter> P[X], P]\n  q' k = sum_list qs\n  f0 \\<in> ideal {f} \\<inter> P[X]\n  p0 \\<in> P\n  qs = [f0, p0]", "have q': \"q' k = f0 + p0\""], ["proof (prove)\nusing this:\n  qs \\<in> listset [ideal {f} \\<inter> P[X], P]\n  q' k = sum_list qs\n  f0 \\<in> ideal {f} \\<inter> P[X]\n  p0 \\<in> P\n  qs = [f0, p0]\n\ngoal (1 subgoal):\n 1. q' k = f0 + p0", "by simp"], ["proof (state)\nthis:\n  q' k = f0 + p0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "define f1 where \"f1 = hom_component f0 d\""], ["proof (state)\nthis:\n  f1 = hom_component f0 d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "define p1 where \"p1 = hom_component p0 d\""], ["proof (state)\nthis:\n  p1 = hom_component p0 d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "from hom_q"], ["proof (chain)\npicking this:\n  homogeneous q", "have \"homogeneous (q' k)\""], ["proof (prove)\nusing this:\n  homogeneous q\n\ngoal (1 subgoal):\n 1. homogeneous (q' k)", "by (simp add: q'_def homogeneous_monom_mult)"], ["proof (state)\nthis:\n  homogeneous (q' k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "hence \"q' k = hom_component (q' k) d\""], ["proof (prove)\nusing this:\n  homogeneous (q' k)\n\ngoal (1 subgoal):\n 1. q' k = hom_component (q' k) d", "by (simp add: hom_component_of_homogeneous deg_q')"], ["proof (state)\nthis:\n  q' k = hom_component (q' k) d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "also"], ["proof (state)\nthis:\n  q' k = hom_component (q' k) d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "have \"\\<dots> = f1 + p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component (q' k) d = f1 + p1", "by (simp only: q' hom_component_plus f1_def p1_def)"], ["proof (state)\nthis:\n  hom_component (q' k) d = f1 + p1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "finally"], ["proof (chain)\npicking this:\n  q' k = f1 + p1", "have \"q' k = f1 + p1\""], ["proof (prove)\nusing this:\n  q' k = f1 + p1\n\ngoal (1 subgoal):\n 1. q' k = f1 + p1", "."], ["proof (state)\nthis:\n  q' k = f1 + p1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "have \"keys p1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys p1 \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "assume \"keys p1 = {}\""], ["proof (state)\nthis:\n  keys p1 = {}\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "with \\<open>q' k = f1 + p1\\<close> \\<open>q' k \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q' k = f1 + p1\n  q' k \\<noteq> 0\n  keys p1 = {}", "have t: \"?t = lpp f1\" and \"f1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q' k = f1 + p1\n  q' k \\<noteq> 0\n  keys p1 = {}\n\ngoal (1 subgoal):\n 1. lpp (q' k) = lpp f1 &&& f1 \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  lpp (q' k) = lpp f1\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "from f0"], ["proof (chain)\npicking this:\n  f0 \\<in> ideal {f} \\<inter> P[X]", "have \"f0 \\<in> ideal {f}\""], ["proof (prove)\nusing this:\n  f0 \\<in> ideal {f} \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. f0 \\<in> ideal {f}", "by simp"], ["proof (state)\nthis:\n  f0 \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f0 \\<in> ideal {f}", "have \"f1 \\<in> ideal {f}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f0 \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. f1 \\<in> ideal {f}", "unfolding f1_def"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f0 \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. hom_component f0 d \\<in> ideal {f}", "by (rule homogeneous_ideal) (simp add: hom_f)"], ["proof (state)\nthis:\n  f1 \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "with punit.is_Groebner_basis_singleton"], ["proof (chain)\npicking this:\n  punit.is_Groebner_basis {?f}\n  f1 \\<in> ideal {f}", "obtain g where \"g \\<in> {f}\" and \"lpp g adds lpp f1\""], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis {?f}\n  f1 \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> {f}; lpp g adds lpp f1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>f1 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis {?f}\n  f1 \\<in> ideal {f}\n  f1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> {f}; lpp g adds lpp f1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.GB_adds_lt[simplified])"], ["proof (state)\nthis:\n  g \\<in> {f}\n  lpp g adds lpp f1\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "hence \"lpp f adds ?t\""], ["proof (prove)\nusing this:\n  g \\<in> {f}\n  lpp g adds lpp f1\n\ngoal (1 subgoal):\n 1. lpp f adds lpp (q' k)", "by (simp add: t)"], ["proof (state)\nthis:\n  lpp f adds lpp (q' k)\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "hence \"lookup (lpp f) x \\<le> lookup ?t x\""], ["proof (prove)\nusing this:\n  lpp f adds lpp (q' k)\n\ngoal (1 subgoal):\n 1. lookup (lpp f) x \\<le> lookup (lpp (q' k)) x", "by (simp add: adds_poly_mapping le_fun_def)"], ["proof (state)\nthis:\n  lookup (lpp f) x \\<le> lookup (lpp (q' k)) x\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lookup (lpp f) x \\<le> lookup (lpp (q' k)) x\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "have \"\\<dots> = lookup (lpp q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lpp (q' k)) x = lookup (lpp q) x", "by (simp add: lpp_q' lookup_add lookup_single \\<open>y \\<noteq> x\\<close>)"], ["proof (state)\nthis:\n  lookup (lpp (q' k)) x = lookup (lpp q) x\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lookup (lpp f) x \\<le> lookup (lpp q) x", "have \"lookup (lpp f) x \\<le> lookup (lpp q) x\""], ["proof (prove)\nusing this:\n  lookup (lpp f) x \\<le> lookup (lpp q) x\n\ngoal (1 subgoal):\n 1. lookup (lpp f) x \\<le> lookup (lpp q) x", "."], ["proof (state)\nthis:\n  lookup (lpp f) x \\<le> lookup (lpp q) x\n\ngoal (1 subgoal):\n 1. keys p1 = {} \\<Longrightarrow> False", "with x"], ["proof (chain)\npicking this:\n  \\<not> lookup (lpp f) x \\<le> lookup (lpp q) x\n  lookup (lpp f) x \\<le> lookup (lpp q) x", "show False"], ["proof (prove)\nusing this:\n  \\<not> lookup (lpp f) x \\<le> lookup (lpp q) x\n  lookup (lpp f) x \\<le> lookup (lpp q) x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys p1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "then"], ["proof (chain)\npicking this:\n  keys p1 \\<noteq> {}", "obtain t where \"t \\<in> keys p1\""], ["proof (prove)\nusing this:\n  keys p1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> keys p1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys p1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "hence \"d = deg_pm t\""], ["proof (prove)\nusing this:\n  t \\<in> keys p1\n\ngoal (1 subgoal):\n 1. d = deg_pm t", "by (simp add: p1_def keys_hom_component)"], ["proof (state)\nthis:\n  d = deg_pm t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "from cn_ps hom_ps"], ["proof (chain)\npicking this:\n  cone_decomp P ps\n  hom_decomp ps", "have \"homogeneous_set P\""], ["proof (prove)\nusing this:\n  cone_decomp P ps\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. homogeneous_set P", "by (intro homogeneous_set_cone_decomp)"], ["proof (state)\nthis:\n  homogeneous_set P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "hence \"p1 \\<in> P\""], ["proof (prove)\nusing this:\n  homogeneous_set P\n\ngoal (1 subgoal):\n 1. p1 \\<in> P", "using \\<open>p0 \\<in> P\\<close>"], ["proof (prove)\nusing this:\n  homogeneous_set P\n  p0 \\<in> P\n\ngoal (1 subgoal):\n 1. p1 \\<in> P", "unfolding p1_def"], ["proof (prove)\nusing this:\n  homogeneous_set P\n  p0 \\<in> P\n\ngoal (1 subgoal):\n 1. hom_component p0 d \\<in> P", "by (rule homogeneous_setD)"], ["proof (state)\nthis:\n  p1 \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "with \\<open>t \\<in> keys p1\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys p1\n  p1 \\<in> P", "have \"t \\<in> Keys P\""], ["proof (prove)\nusing this:\n  t \\<in> keys p1\n  p1 \\<in> P\n\ngoal (1 subgoal):\n 1. t \\<in> Keys P", "by (rule in_KeysI)"], ["proof (state)\nthis:\n  t \\<in> Keys P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (deg_pm \\<circ> lpp) ` range q' \\<Longrightarrow>\n       x \\<in> deg_pm ` Keys P", "with \\<open>d = deg_pm t\\<close>"], ["proof (chain)\npicking this:\n  d = deg_pm t\n  t \\<in> Keys P", "show \"d \\<in> deg_pm ` Keys P\""], ["proof (prove)\nusing this:\n  d = deg_pm t\n  t \\<in> Keys P\n\ngoal (1 subgoal):\n 1. d \\<in> deg_pm ` Keys P", "by (rule image_eqI)"], ["proof (state)\nthis:\n  d \\<in> deg_pm ` Keys P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (deg_pm \\<circ> lpp) ` range q' \\<subseteq> deg_pm ` Keys P\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (deg_pm \\<circ> lpp) ` range q' \\<subseteq> deg_pm ` Keys P\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "from inj1 inj2"], ["proof (chain)\npicking this:\n  inj q'\n  inj_on (deg_pm \\<circ> lpp) (range q')", "have \"infinite ((deg_pm \\<circ> lpp) ` range q')\""], ["proof (prove)\nusing this:\n  inj q'\n  inj_on (deg_pm \\<circ> lpp) (range q')\n\ngoal (1 subgoal):\n 1. infinite ((deg_pm \\<circ> lpp) ` range q')", "by (simp add: finite_image_iff o_def)"], ["proof (state)\nthis:\n  infinite ((deg_pm \\<circ> lpp) ` range q')\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (deg_pm \\<circ> lpp) ` range q' \\<subseteq> deg_pm ` Keys P\n  infinite ((deg_pm \\<circ> lpp) ` range q')", "have \"infinite (deg_pm ` Keys P)\""], ["proof (prove)\nusing this:\n  (deg_pm \\<circ> lpp) ` range q' \\<subseteq> deg_pm ` Keys P\n  infinite ((deg_pm \\<circ> lpp) ` range q')\n\ngoal (1 subgoal):\n 1. infinite (deg_pm ` Keys P)", "by (rule infinite_super)"], ["proof (state)\nthis:\n  infinite (deg_pm ` Keys P)\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "hence \"infinite (Keys P)\""], ["proof (prove)\nusing this:\n  infinite (deg_pm ` Keys P)\n\ngoal (1 subgoal):\n 1. infinite (Keys P)", "by blast"], ["proof (state)\nthis:\n  infinite (Keys P)\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  infinite (Keys P)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>finite (Keys P)\\<close>"], ["proof (prove)\nusing this:\n  infinite (Keys P)\n  finite (Keys P)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition N where \"N = normal_form F ` P[X]\""], ["", "private"], ["", "definition qs where \"qs = (SOME qs'. valid_decomp X qs' \\<and> standard_decomp 0 qs' \\<and>\n                                    monomial_decomp qs' \\<and> cone_decomp N qs' \\<and> exact_decomp X 0 qs' \\<and>\n                                    (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> \\<b> qs' 0))\""], ["", "private"], ["", "definition \"aa \\<equiv> \\<b> ps\""], ["", "private"], ["", "definition \"bb \\<equiv> \\<b> qs\""], ["", "private"], ["", "abbreviation (input) \"cc \\<equiv> (\\<lambda>i. aa i + bb i)\""], ["", "lemma\n  shows valid_qs: \"valid_decomp X qs\" (is ?thesis1)\n    and std_qs: \"standard_decomp 0 qs\" (is ?thesis2)\n    and mon_qs: \"monomial_decomp qs\" (is ?thesis3)\n    and hom_qs: \"hom_decomp qs\" (is ?thesis6)\n    and cn_qs: \"cone_decomp N qs\" (is ?thesis4)\n    and ext_qs: \"exact_decomp X 0 qs\" (is ?thesis5)\n    and deg_RGB: \"g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_decomp X qs &&& standard_decomp 0 qs &&& monomial_decomp qs) &&&\n    (hom_decomp qs &&& cone_decomp N qs) &&&\n    exact_decomp X 0 qs &&&\n    (g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0)", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. valid_decomp X qs\n 2. standard_decomp 0 qs\n 3. monomial_decomp qs\n 4. hom_decomp qs\n 5. cone_decomp N qs\n 6. exact_decomp X 0 qs\n 7. g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "obtain qs' where 1: \"valid_decomp X qs'\" and 2: \"standard_decomp 0 qs'\"\n    and 3: \"monomial_decomp qs'\" and 4: \"cone_decomp (normal_form F ` P[X]) qs'\"\n    and 5: \"exact_decomp X 0 qs'\"\n    and 60: \"\\<And>g. (\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> \\<b> qs' 0\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>qs'.\n        \\<lbrakk>valid_decomp X qs'; standard_decomp 0 qs';\n         monomial_decomp qs'; cone_decomp (normal_form F ` P[X]) qs';\n         exact_decomp X 0 qs';\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs' 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule normal_form_exact_decompE) blast"], ["proof (state)\nthis:\n  valid_decomp X qs'\n  standard_decomp 0 qs'\n  monomial_decomp qs'\n  cone_decomp (normal_form F ` P[X]) qs'\n  exact_decomp X 0 qs'\n  \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n   ?g47 \\<in> punit.reduced_GB F\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?g47 \\<le> \\<b> qs' 0\n\ngoal (7 subgoals):\n 1. valid_decomp X qs\n 2. standard_decomp 0 qs\n 3. monomial_decomp qs\n 4. hom_decomp qs\n 5. cone_decomp N qs\n 6. exact_decomp X 0 qs\n 7. g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0", "from hom_F"], ["proof (chain)\npicking this:\n  ?f'47 \\<in> F \\<Longrightarrow> homogeneous ?f'47", "have \"\\<And>g. g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> \\<b> qs' 0\""], ["proof (prove)\nusing this:\n  ?f'47 \\<in> F \\<Longrightarrow> homogeneous ?f'47\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> punit.reduced_GB F \\<Longrightarrow>\n       poly_deg g \\<le> \\<b> qs' 0", "by (rule 60)"], ["proof (state)\nthis:\n  ?g47 \\<in> punit.reduced_GB F \\<Longrightarrow>\n  poly_deg ?g47 \\<le> \\<b> qs' 0\n\ngoal (7 subgoals):\n 1. valid_decomp X qs\n 2. standard_decomp 0 qs\n 3. monomial_decomp qs\n 4. hom_decomp qs\n 5. cone_decomp N qs\n 6. exact_decomp X 0 qs\n 7. g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0", "with 1 2 3 4 5"], ["proof (chain)\npicking this:\n  valid_decomp X qs'\n  standard_decomp 0 qs'\n  monomial_decomp qs'\n  cone_decomp (normal_form F ` P[X]) qs'\n  exact_decomp X 0 qs'\n  ?g47 \\<in> punit.reduced_GB F \\<Longrightarrow>\n  poly_deg ?g47 \\<le> \\<b> qs' 0", "have \"valid_decomp X qs' \\<and> standard_decomp 0 qs' \\<and>\n                        monomial_decomp qs' \\<and> cone_decomp N qs' \\<and> exact_decomp X 0 qs' \\<and>\n                        (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> \\<b> qs' 0)\""], ["proof (prove)\nusing this:\n  valid_decomp X qs'\n  standard_decomp 0 qs'\n  monomial_decomp qs'\n  cone_decomp (normal_form F ` P[X]) qs'\n  exact_decomp X 0 qs'\n  ?g47 \\<in> punit.reduced_GB F \\<Longrightarrow>\n  poly_deg ?g47 \\<le> \\<b> qs' 0\n\ngoal (1 subgoal):\n 1. valid_decomp X qs' \\<and>\n    standard_decomp 0 qs' \\<and>\n    monomial_decomp qs' \\<and>\n    cone_decomp N qs' \\<and>\n    exact_decomp X 0 qs' \\<and>\n    (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> \\<b> qs' 0)", "by (simp add: N_def)"], ["proof (state)\nthis:\n  valid_decomp X qs' \\<and>\n  standard_decomp 0 qs' \\<and>\n  monomial_decomp qs' \\<and>\n  cone_decomp N qs' \\<and>\n  exact_decomp X 0 qs' \\<and>\n  (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> \\<b> qs' 0)\n\ngoal (7 subgoals):\n 1. valid_decomp X qs\n 2. standard_decomp 0 qs\n 3. monomial_decomp qs\n 4. hom_decomp qs\n 5. cone_decomp N qs\n 6. exact_decomp X 0 qs\n 7. g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0", "hence \"?thesis1 \\<and> ?thesis2 \\<and> ?thesis3 \\<and> ?thesis4 \\<and> ?thesis5 \\<and> (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> bb 0)\""], ["proof (prove)\nusing this:\n  valid_decomp X qs' \\<and>\n  standard_decomp 0 qs' \\<and>\n  monomial_decomp qs' \\<and>\n  cone_decomp N qs' \\<and>\n  exact_decomp X 0 qs' \\<and>\n  (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> \\<b> qs' 0)\n\ngoal (1 subgoal):\n 1. valid_decomp X qs \\<and>\n    standard_decomp 0 qs \\<and>\n    monomial_decomp qs \\<and>\n    cone_decomp N qs \\<and>\n    exact_decomp X 0 qs \\<and>\n    (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> bb 0)", "unfolding qs_def bb_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs' \\<and>\n  standard_decomp 0 qs' \\<and>\n  monomial_decomp qs' \\<and>\n  cone_decomp N qs' \\<and>\n  exact_decomp X 0 qs' \\<and>\n  (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> \\<b> qs' 0)\n\ngoal (1 subgoal):\n 1. valid_decomp X\n     (SOME qs'.\n         valid_decomp X qs' \\<and>\n         standard_decomp 0 qs' \\<and>\n         monomial_decomp qs' \\<and>\n         cone_decomp N qs' \\<and>\n         exact_decomp X 0 qs' \\<and>\n         (\\<forall>g\\<in>punit.reduced_GB F.\n             poly_deg g \\<le> \\<b> qs' 0)) \\<and>\n    standard_decomp 0\n     (SOME qs'.\n         valid_decomp X qs' \\<and>\n         standard_decomp 0 qs' \\<and>\n         monomial_decomp qs' \\<and>\n         cone_decomp N qs' \\<and>\n         exact_decomp X 0 qs' \\<and>\n         (\\<forall>g\\<in>punit.reduced_GB F.\n             poly_deg g \\<le> \\<b> qs' 0)) \\<and>\n    monomial_decomp\n     (SOME qs'.\n         valid_decomp X qs' \\<and>\n         standard_decomp 0 qs' \\<and>\n         monomial_decomp qs' \\<and>\n         cone_decomp N qs' \\<and>\n         exact_decomp X 0 qs' \\<and>\n         (\\<forall>g\\<in>punit.reduced_GB F.\n             poly_deg g \\<le> \\<b> qs' 0)) \\<and>\n    cone_decomp N\n     (SOME qs'.\n         valid_decomp X qs' \\<and>\n         standard_decomp 0 qs' \\<and>\n         monomial_decomp qs' \\<and>\n         cone_decomp N qs' \\<and>\n         exact_decomp X 0 qs' \\<and>\n         (\\<forall>g\\<in>punit.reduced_GB F.\n             poly_deg g \\<le> \\<b> qs' 0)) \\<and>\n    exact_decomp X 0\n     (SOME qs'.\n         valid_decomp X qs' \\<and>\n         standard_decomp 0 qs' \\<and>\n         monomial_decomp qs' \\<and>\n         cone_decomp N qs' \\<and>\n         exact_decomp X 0 qs' \\<and>\n         (\\<forall>g\\<in>punit.reduced_GB F.\n             poly_deg g \\<le> \\<b> qs' 0)) \\<and>\n    (\\<forall>g\\<in>punit.reduced_GB F.\n        poly_deg g\n        \\<le> \\<b>\n               (SOME qs'.\n                   valid_decomp X qs' \\<and>\n                   standard_decomp 0 qs' \\<and>\n                   monomial_decomp qs' \\<and>\n                   cone_decomp N qs' \\<and>\n                   exact_decomp X 0 qs' \\<and>\n                   (\\<forall>g\\<in>punit.reduced_GB F.\n                       poly_deg g \\<le> \\<b> qs' 0))\n               0)", "by (rule someI)"], ["proof (state)\nthis:\n  valid_decomp X qs \\<and>\n  standard_decomp 0 qs \\<and>\n  monomial_decomp qs \\<and>\n  cone_decomp N qs \\<and>\n  exact_decomp X 0 qs \\<and>\n  (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> bb 0)\n\ngoal (7 subgoals):\n 1. valid_decomp X qs\n 2. standard_decomp 0 qs\n 3. monomial_decomp qs\n 4. hom_decomp qs\n 5. cone_decomp N qs\n 6. exact_decomp X 0 qs\n 7. g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0", "thus ?thesis1 and ?thesis2 and ?thesis3 and ?thesis4 and ?thesis5\n    and \"g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0\""], ["proof (prove)\nusing this:\n  valid_decomp X qs \\<and>\n  standard_decomp 0 qs \\<and>\n  monomial_decomp qs \\<and>\n  cone_decomp N qs \\<and>\n  exact_decomp X 0 qs \\<and>\n  (\\<forall>g\\<in>punit.reduced_GB F. poly_deg g \\<le> bb 0)\n\ngoal (1 subgoal):\n 1. (valid_decomp X qs &&& standard_decomp 0 qs &&& monomial_decomp qs) &&&\n    cone_decomp N qs &&&\n    exact_decomp X 0 qs &&&\n    (g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0)", "by simp_all"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  monomial_decomp qs\n  cone_decomp N qs\n  exact_decomp X 0 qs\n  g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> bb 0\n\ngoal (1 subgoal):\n 1. hom_decomp qs", "from \\<open>?thesis3\\<close>"], ["proof (chain)\npicking this:\n  monomial_decomp qs", "show ?thesis6"], ["proof (prove)\nusing this:\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp qs", "by (rule monomial_decomp_imp_hom_decomp)"], ["proof (state)\nthis:\n  hom_decomp qs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_sub: \"N \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq> P[X]", "using valid_qs cn_qs"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  cone_decomp N qs\n\ngoal (1 subgoal):\n 1. N \\<subseteq> P[X]", "by (rule valid_cone_decomp_subset_Polys)"], ["", "lemma decomp_Polys: \"direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"direct_decomp P[X] [ideal F \\<inter> P[X], N]\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], N]", "unfolding N_def"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "by (rule direct_decomp_ideal_normal_form)"], ["proof (state)\nthis:\n  direct_decomp P[X] [ideal F \\<inter> P[X], N]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]", "hence \"direct_decomp P[X] ([N] @ [ideal {f} \\<inter> P[X], P])\""], ["proof (prove)\nusing this:\n  direct_decomp P[X] [ideal F \\<inter> P[X], N]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] ([N] @ [ideal {f} \\<inter> P[X], P])", "using decomp_F"], ["proof (prove)\nusing this:\n  direct_decomp P[X] [ideal F \\<inter> P[X], N]\n  direct_decomp (ideal F \\<inter> P[X]) [ideal {f} \\<inter> P[X], P]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] ([N] @ [ideal {f} \\<inter> P[X], P])", "by (rule direct_decomp_direct_decomp)"], ["proof (state)\nthis:\n  direct_decomp P[X] ([N] @ [ideal {f} \\<inter> P[X], P])\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]", "hence \"direct_decomp P[X] ([ideal {f} \\<inter> P[X], P] @ [N])\""], ["proof (prove)\nusing this:\n  direct_decomp P[X] ([N] @ [ideal {f} \\<inter> P[X], P])\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] ([ideal {f} \\<inter> P[X], P] @ [N])", "using perm_append_swap"], ["proof (prove)\nusing this:\n  direct_decomp P[X] ([N] @ [ideal {f} \\<inter> P[X], P])\n  ?xs @ ?ys <~~> ?ys @ ?xs\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] ([ideal {f} \\<inter> P[X], P] @ [N])", "by (rule direct_decomp_perm)"], ["proof (state)\nthis:\n  direct_decomp P[X] ([ideal {f} \\<inter> P[X], P] @ [N])\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]", "thus ?thesis"], ["proof (prove)\nusing this:\n  direct_decomp P[X] ([ideal {f} \\<inter> P[X], P] @ [N])\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]", "by simp"], ["proof (state)\nthis:\n  direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aa_Suc_n [simp]: \"aa (Suc n) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = poly_deg f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = poly_deg f", "from fin_X ext_ps le_refl"], ["proof (chain)\npicking this:\n  finite X\n  exact_decomp X 0 ps\n  ?n \\<le> ?n", "have \"aa (Suc n) = \\<a> ps\""], ["proof (prove)\nusing this:\n  finite X\n  exact_decomp X 0 ps\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = \\<a> ps", "unfolding aa_def"], ["proof (prove)\nusing this:\n  finite X\n  exact_decomp X 0 ps\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) = \\<a> ps", "by (rule \\<b>_card_X)"], ["proof (state)\nthis:\n  aa (Suc (card X)) = \\<a> ps\n\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = poly_deg f", "also"], ["proof (state)\nthis:\n  aa (Suc (card X)) = \\<a> ps\n\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = poly_deg f", "from fin_X valid_ps std_ps ps_not_Nil"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps\n  standard_decomp (poly_deg f) ps\n  ps\\<^sub>+ \\<noteq> []", "have \"\\<dots> = d\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n  standard_decomp (poly_deg f) ps\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<a> ps = poly_deg f", "by (rule \\<a>_nonempty_unique)"], ["proof (state)\nthis:\n  \\<a> ps = poly_deg f\n\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = poly_deg f", "finally"], ["proof (chain)\npicking this:\n  aa (Suc (card X)) = poly_deg f", "show ?thesis"], ["proof (prove)\nusing this:\n  aa (Suc (card X)) = poly_deg f\n\ngoal (1 subgoal):\n 1. aa (Suc (card X)) = poly_deg f", "."], ["proof (state)\nthis:\n  aa (Suc (card X)) = poly_deg f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bb_Suc_n [simp]: \"bb (Suc n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = 0", "from fin_X ext_qs le_refl"], ["proof (chain)\npicking this:\n  finite X\n  exact_decomp X 0 qs\n  ?n \\<le> ?n", "have \"bb (Suc n) = \\<a> qs\""], ["proof (prove)\nusing this:\n  finite X\n  exact_decomp X 0 qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = \\<a> qs", "unfolding bb_def"], ["proof (prove)\nusing this:\n  finite X\n  exact_decomp X 0 qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> qs (Suc (card X)) = \\<a> qs", "by (rule \\<b>_card_X)"], ["proof (state)\nthis:\n  bb (Suc (card X)) = \\<a> qs\n\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = 0", "also"], ["proof (state)\nthis:\n  bb (Suc (card X)) = \\<a> qs\n\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = 0", "from std_qs"], ["proof (chain)\npicking this:\n  standard_decomp 0 qs", "have \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  standard_decomp 0 qs\n\ngoal (1 subgoal):\n 1. \\<a> qs = 0", "unfolding \\<a>_def[OF fin_X]"], ["proof (prove)\nusing this:\n  standard_decomp 0 qs\n\ngoal (1 subgoal):\n 1. (LEAST k. standard_decomp k qs) = 0", "by (rule Least_eq_0)"], ["proof (state)\nthis:\n  \\<a> qs = 0\n\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = 0", "finally"], ["proof (chain)\npicking this:\n  bb (Suc (card X)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  bb (Suc (card X)) = 0\n\ngoal (1 subgoal):\n 1. bb (Suc (card X)) = 0", "."], ["proof (state)\nthis:\n  bb (Suc (card X)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hilbert_fun_X:\n  assumes \"d \\<le> z\"\n  shows \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) z =\n            ((z - d) + (n - 1)) choose (n - 1) + Hilbert_fun P z + Hilbert_fun N z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "define ss where \"ss = [ideal {f} \\<inter> P[X], P, N]\""], ["proof (state)\nthis:\n  ss = [ideal {f} \\<inter> P[X], P, N]\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "have \"homogeneous_set A \\<and> phull.subspace A\" if \"A \\<in> set ss\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "from that"], ["proof (chain)\npicking this:\n  A \\<in> set ss", "have \"A = ideal {f} \\<inter> P[X] \\<or> A = P \\<or> A = N\""], ["proof (prove)\nusing this:\n  A \\<in> set ss\n\ngoal (1 subgoal):\n 1. A = ideal {f} \\<inter> P[X] \\<or> A = P \\<or> A = N", "by (simp add: ss_def)"], ["proof (state)\nthis:\n  A = ideal {f} \\<inter> P[X] \\<or> A = P \\<or> A = N\n\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = ideal {f} \\<inter> P[X] \\<or> A = P \\<or> A = N\n\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. A = ideal {f} \\<inter> P[X] \\<Longrightarrow>\n    homogeneous_set A \\<and> phull.subspace A\n 2. A = P \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A\n 3. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "assume A: \"A = ideal {f} \\<inter> P[X]\""], ["proof (state)\nthis:\n  A = ideal {f} \\<inter> P[X]\n\ngoal (3 subgoals):\n 1. A = ideal {f} \\<inter> P[X] \\<Longrightarrow>\n    homogeneous_set A \\<and> phull.subspace A\n 2. A = P \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A\n 3. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous_set (ideal {f} \\<inter> P[X]) \\<and>\n    phull.subspace (ideal {f} \\<inter> P[X])", "by (intro conjI homogeneous_set_IntI phull.subspace_inter homogeneous_set_homogeneous_ideal\n            homogeneous_set_Polys subspace_ideal subspace_Polys) (simp add: hom_f)"], ["proof (state)\nthis:\n  homogeneous_set A \\<and> phull.subspace A\n\ngoal (2 subgoals):\n 1. A = P \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A\n 2. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. A = P \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A\n 2. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "assume A: \"A = P\""], ["proof (state)\nthis:\n  A = P\n\ngoal (2 subgoals):\n 1. A = P \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A\n 2. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "from cn_ps hom_ps"], ["proof (chain)\npicking this:\n  cone_decomp P ps\n  hom_decomp ps", "show ?thesis"], ["proof (prove)\nusing this:\n  cone_decomp P ps\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "unfolding A"], ["proof (prove)\nusing this:\n  cone_decomp P ps\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. homogeneous_set P \\<and> phull.subspace P", "by (intro conjI homogeneous_set_cone_decomp subspace_cone_decomp)"], ["proof (state)\nthis:\n  homogeneous_set A \\<and> phull.subspace A\n\ngoal (1 subgoal):\n 1. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "assume A: \"A = N\""], ["proof (state)\nthis:\n  A = N\n\ngoal (1 subgoal):\n 1. A = N \\<Longrightarrow> homogeneous_set A \\<and> phull.subspace A", "from cn_qs hom_qs"], ["proof (chain)\npicking this:\n  cone_decomp N qs\n  hom_decomp qs", "show ?thesis"], ["proof (prove)\nusing this:\n  cone_decomp N qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. homogeneous_set A \\<and> phull.subspace A", "unfolding A"], ["proof (prove)\nusing this:\n  cone_decomp N qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. homogeneous_set N \\<and> phull.subspace N", "by (intro conjI homogeneous_set_cone_decomp subspace_cone_decomp)"], ["proof (state)\nthis:\n  homogeneous_set A \\<and> phull.subspace A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  homogeneous_set A \\<and> phull.subspace A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?A47 \\<in> set ss \\<Longrightarrow>\n  homogeneous_set ?A47 \\<and> phull.subspace ?A47\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "hence 1: \"\\<And>A. A \\<in> set ss \\<Longrightarrow> homogeneous_set A\" and 2: \"\\<And>A. A \\<in> set ss \\<Longrightarrow> phull.subspace A\""], ["proof (prove)\nusing this:\n  ?A47 \\<in> set ss \\<Longrightarrow>\n  homogeneous_set ?A47 \\<and> phull.subspace ?A47\n\ngoal (1 subgoal):\n 1. (\\<And>A. A \\<in> set ss \\<Longrightarrow> homogeneous_set A) &&&\n    (\\<And>A. A \\<in> set ss \\<Longrightarrow> phull.subspace A)", "by simp_all"], ["proof (state)\nthis:\n  ?A47 \\<in> set ss \\<Longrightarrow> homogeneous_set ?A47\n  ?A47 \\<in> set ss \\<Longrightarrow> phull.subspace ?A47\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "have \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) z = (\\<Sum>p\\<in>set ss. Hilbert_fun p z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = (\\<Sum>p\\<in>set ss. Hilbert_fun p z)", "using fin_X subset_refl decomp_Polys"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z = (\\<Sum>p\\<in>set ss. Hilbert_fun p z)", "unfolding ss_def"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    (\\<Sum>p\\<in>set [ideal {f} \\<inter> P[X], P, N]. Hilbert_fun p z)", "proof (rule Hilbert_fun_direct_decomp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       homogeneous_set s\n 2. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       phull.subspace s", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       homogeneous_set s\n 2. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       phull.subspace s", "assume \"A \\<in> set [ideal {f} \\<inter> P[X], P, N]\""], ["proof (state)\nthis:\n  A \\<in> set [ideal {f} \\<inter> P[X], P, N]\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       homogeneous_set s\n 2. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       phull.subspace s", "hence \"A \\<in> set ss\""], ["proof (prove)\nusing this:\n  A \\<in> set [ideal {f} \\<inter> P[X], P, N]\n\ngoal (1 subgoal):\n 1. A \\<in> set ss", "by (simp only: ss_def)"], ["proof (state)\nthis:\n  A \\<in> set ss\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       homogeneous_set s\n 2. \\<And>s.\n       s \\<in> set [ideal {f} \\<inter> P[X], P, N] \\<Longrightarrow>\n       phull.subspace s", "thus \"homogeneous_set A\" and \"phull.subspace A\""], ["proof (prove)\nusing this:\n  A \\<in> set ss\n\ngoal (1 subgoal):\n 1. homogeneous_set A &&& phull.subspace A", "by (rule 1, rule 2)"], ["proof (state)\nthis:\n  homogeneous_set A\n  phull.subspace A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Hilbert_fun P[X] z = (\\<Sum>p\\<in>set ss. Hilbert_fun p z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "also"], ["proof (state)\nthis:\n  Hilbert_fun P[X] z = (\\<Sum>p\\<in>set ss. Hilbert_fun p z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "have \"\\<dots> = (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>set ss. Hilbert_fun p z) =\n    (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z)", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>set ss. Hilbert_fun p z) =\n    (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ss \\<Longrightarrow>\n       Hilbert_fun x z = count_list ss x * Hilbert_fun x z", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ss \\<Longrightarrow>\n       Hilbert_fun x z = count_list ss x * Hilbert_fun x z", "assume \"p \\<in> set ss\""], ["proof (state)\nthis:\n  p \\<in> set ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ss \\<Longrightarrow>\n       Hilbert_fun x z = count_list ss x * Hilbert_fun x z", "hence \"count_list ss p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<in> set ss\n\ngoal (1 subgoal):\n 1. count_list ss p \\<noteq> 0", "by (simp only: count_list_eq_0_iff not_not)"], ["proof (state)\nthis:\n  count_list ss p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ss \\<Longrightarrow>\n       Hilbert_fun x z = count_list ss x * Hilbert_fun x z", "hence \"count_list ss p = 1 \\<or> 1 < count_list ss p\""], ["proof (prove)\nusing this:\n  count_list ss p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_list ss p = 1 \\<or> 1 < count_list ss p", "by auto"], ["proof (state)\nthis:\n  count_list ss p = 1 \\<or> 1 < count_list ss p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ss \\<Longrightarrow>\n       Hilbert_fun x z = count_list ss x * Hilbert_fun x z", "thus \"Hilbert_fun p z = count_list ss p * Hilbert_fun p z\""], ["proof (prove)\nusing this:\n  count_list ss p = 1 \\<or> 1 < count_list ss p\n\ngoal (1 subgoal):\n 1. Hilbert_fun p z = count_list ss p * Hilbert_fun p z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. count_list ss p = 1 \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z\n 2. 1 < count_list ss p \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z", "assume \"1 < count_list ss p\""], ["proof (state)\nthis:\n  1 < count_list ss p\n\ngoal (2 subgoals):\n 1. count_list ss p = 1 \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z\n 2. 1 < count_list ss p \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z", "with decomp_Polys"], ["proof (chain)\npicking this:\n  direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\n  1 < count_list ss p", "have \"p = {0}\""], ["proof (prove)\nusing this:\n  direct_decomp P[X] [ideal {f} \\<inter> P[X], P, N]\n  1 < count_list ss p\n\ngoal (1 subgoal):\n 1. p = {0}", "unfolding ss_def[symmetric]"], ["proof (prove)\nusing this:\n  direct_decomp P[X] ss\n  1 < count_list ss p\n\ngoal (1 subgoal):\n 1. p = {0}", "using phull.subspace_0"], ["proof (prove)\nusing this:\n  direct_decomp P[X] ss\n  1 < count_list ss p\n  phull.subspace ?S \\<Longrightarrow> 0 \\<in> ?S\n\ngoal (1 subgoal):\n 1. p = {0}", "by (rule direct_decomp_repeated_eq_zero) (rule 2)"], ["proof (state)\nthis:\n  p = {0}\n\ngoal (2 subgoals):\n 1. count_list ss p = 1 \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z\n 2. 1 < count_list ss p \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = {0}\n\ngoal (1 subgoal):\n 1. Hilbert_fun p z = count_list ss p * Hilbert_fun p z", "by simp"], ["proof (state)\nthis:\n  Hilbert_fun p z = count_list ss p * Hilbert_fun p z\n\ngoal (1 subgoal):\n 1. count_list ss p = 1 \\<Longrightarrow>\n    Hilbert_fun p z = count_list ss p * Hilbert_fun p z", "qed simp"], ["proof (state)\nthis:\n  Hilbert_fun p z = count_list ss p * Hilbert_fun p z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>set ss. Hilbert_fun p z) =\n  (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>set ss. Hilbert_fun p z) =\n  (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "have \"\\<dots> = sum_list (map (\\<lambda>p. Hilbert_fun p z) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z) =\n    (\\<Sum>p\\<leftarrow>ss. Hilbert_fun p z)", "by (rule sym) (rule sum_list_map_eq_sum_count)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z) =\n  (\\<Sum>p\\<leftarrow>ss. Hilbert_fun p z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>set ss. count_list ss p * Hilbert_fun p z) =\n  (\\<Sum>p\\<leftarrow>ss. Hilbert_fun p z)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "have \"\\<dots> = Hilbert_fun (cone (f, X)) z + Hilbert_fun P z + Hilbert_fun N z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<leftarrow>ss. Hilbert_fun p z) =\n    Hilbert_fun (cone (f, X)) z + Hilbert_fun P z + Hilbert_fun N z", "by (simp add: ss_def ideal_Int_Polys_eq_cone)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<leftarrow>ss. Hilbert_fun p z) =\n  Hilbert_fun (cone (f, X)) z + Hilbert_fun P z + Hilbert_fun N z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<leftarrow>ss. Hilbert_fun p z) =\n  Hilbert_fun (cone (f, X)) z + Hilbert_fun P z + Hilbert_fun N z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "have \"Hilbert_fun (cone (f, X)) z = (z - d + (n - 1)) choose (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (f, X)) z =\n    z - poly_deg f + (card X - 1) choose (card X - 1)", "using f_not_0 f_in_Polys fin_X hom_f X_not_empty"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  f \\<in> P[X]\n  finite X\n  homogeneous f\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Hilbert_fun (cone (f, X)) z =\n    z - poly_deg f + (card X - 1) choose (card X - 1)", "by (simp add: Hilbert_fun_cone_nonempty assms)"], ["proof (state)\nthis:\n  Hilbert_fun (cone (f, X)) z =\n  z - poly_deg f + (card X - 1) choose (card X - 1)\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "finally"], ["proof (chain)\npicking this:\n  Hilbert_fun P[X] z =\n  z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n  Hilbert_fun N z", "show ?thesis"], ["proof (prove)\nusing this:\n  Hilbert_fun P[X] z =\n  z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n  Hilbert_fun N z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "."], ["proof (state)\nthis:\n  Hilbert_fun P[X] z =\n  z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n  Hilbert_fun N z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dube_eq_0:\n  \"(\\<lambda>z::int. (z + int n - 1) gchoose (n - 1)) =\n    (\\<lambda>z::int. ((z - d + n - 1) gchoose (n - 1)) + Hilbert_poly aa z + Hilbert_poly bb z)\"\n    (is \"?f = ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n        Hilbert_poly aa z +\n        Hilbert_poly bb z)", "proof (rule poly_fun_eqI_ge)"], ["proof (state)\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "fix z::int"], ["proof (state)\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "let ?z = \"nat z\""], ["proof (state)\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "assume \"max (aa 0) (bb 0) \\<le> z\""], ["proof (state)\nthis:\n  int (max (aa 0) (bb 0)) \\<le> z\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "hence \"aa 0 \\<le> nat z\" and \"bb 0 \\<le> nat z\" and \"0 \\<le> z\""], ["proof (prove)\nusing this:\n  int (max (aa 0) (bb 0)) \\<le> z\n\ngoal (1 subgoal):\n 1. aa 0 \\<le> nat z &&& bb 0 \\<le> nat z &&& 0 \\<le> z", "by simp_all"], ["proof (state)\nthis:\n  aa 0 \\<le> nat z\n  bb 0 \\<le> nat z\n  0 \\<le> z\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "from this(3)"], ["proof (chain)\npicking this:\n  0 \\<le> z", "have int_z: \"int ?z = z\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. int (nat z) = z", "by simp"], ["proof (state)\nthis:\n  int (nat z) = z\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "have \"d \\<le> aa 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f \\<le> aa 0", "unfolding aa_Suc_n[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aa (Suc (card X)) \\<le> aa 0", "using fin_X le0"], ["proof (prove)\nusing this:\n  finite X\n  0 \\<le> ?n\n\ngoal (1 subgoal):\n 1. aa (Suc (card X)) \\<le> aa 0", "unfolding aa_def"], ["proof (prove)\nusing this:\n  finite X\n  0 \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> \\<b> ps 0", "by (rule \\<b>_decreasing)"], ["proof (state)\nthis:\n  poly_deg f \\<le> aa 0\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "hence \"d \\<le> ?z\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> aa 0\n\ngoal (1 subgoal):\n 1. poly_deg f \\<le> nat z", "using \\<open>aa 0 \\<le> nat z\\<close>"], ["proof (prove)\nusing this:\n  poly_deg f \\<le> aa 0\n  aa 0 \\<le> nat z\n\ngoal (1 subgoal):\n 1. poly_deg f \\<le> nat z", "by (rule le_trans)"], ["proof (state)\nthis:\n  poly_deg f \\<le> nat z\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "hence int_zd: \"int (?z - d) = z - int d\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> nat z\n\ngoal (1 subgoal):\n 1. int (nat z - poly_deg f) = z - int (poly_deg f)", "using int_z"], ["proof (prove)\nusing this:\n  poly_deg f \\<le> nat z\n  int (nat z) = z\n\ngoal (1 subgoal):\n 1. int (nat z - poly_deg f) = z - int (poly_deg f)", "by linarith"], ["proof (state)\nthis:\n  int (nat z - poly_deg f) = z - int (poly_deg f)\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "from \\<open>d \\<le> ?z\\<close>"], ["proof (chain)\npicking this:\n  poly_deg f \\<le> nat z", "have \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) ?z =\n                      ((?z - d) + (n - 1)) choose (n - 1) + Hilbert_fun P ?z + Hilbert_fun N ?z\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> nat z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] (nat z) =\n    nat z - poly_deg f + (card X - 1) choose (card X - 1) +\n    Hilbert_fun P (nat z) +\n    Hilbert_fun N (nat z)", "by (rule Hilbert_fun_X)"], ["proof (state)\nthis:\n  Hilbert_fun P[X] (nat z) =\n  nat z - poly_deg f + (card X - 1) choose (card X - 1) +\n  Hilbert_fun P (nat z) +\n  Hilbert_fun N (nat z)\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "also"], ["proof (state)\nthis:\n  Hilbert_fun P[X] (nat z) =\n  nat z - poly_deg f + (card X - 1) choose (card X - 1) +\n  Hilbert_fun P (nat z) +\n  Hilbert_fun N (nat z)\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "have \"int \\<dots> = (z - d + (n - 1)) gchoose (n - 1) + Hilbert_poly aa z + Hilbert_poly bb z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat z - poly_deg f + (card X - 1) choose (card X - 1) +\n         Hilbert_fun P (nat z) +\n         Hilbert_fun N (nat z)) =\n    z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n    Hilbert_poly aa z +\n    Hilbert_poly bb z", "using X_not_empty valid_ps hom_ps cn_ps std_ps ext_ps \\<open>aa 0 \\<le> nat z\\<close>\n          valid_qs hom_qs cn_qs std_qs ext_qs \\<open>bb 0 \\<le> nat z\\<close> \\<open>0 \\<le> z\\<close>"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  valid_decomp X ps\n  hom_decomp ps\n  cone_decomp P ps\n  standard_decomp (poly_deg f) ps\n  exact_decomp X 0 ps\n  aa 0 \\<le> nat z\n  valid_decomp X qs\n  hom_decomp qs\n  cone_decomp N qs\n  standard_decomp 0 qs\n  exact_decomp X 0 qs\n  bb 0 \\<le> nat z\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. int (nat z - poly_deg f + (card X - 1) choose (card X - 1) +\n         Hilbert_fun P (nat z) +\n         Hilbert_fun N (nat z)) =\n    z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n    Hilbert_poly aa z +\n    Hilbert_poly bb z", "by (simp add: Hilbert_fun_eq_Hilbert_poly int_z aa_def bb_def int_binomial int_zd)"], ["proof (state)\nthis:\n  int (nat z - poly_deg f + (card X - 1) choose (card X - 1) +\n       Hilbert_fun P (nat z) +\n       Hilbert_fun N (nat z)) =\n  z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa z +\n  Hilbert_poly bb z\n\ngoal (3 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)\n 3. \\<And>a.\n       ?b \\<le> a \\<Longrightarrow>\n       a + int (card X) - 1 gchoose (card X - 1) =\n       a - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       Hilbert_poly aa a +\n       Hilbert_poly bb a", "finally"], ["proof (chain)\npicking this:\n  int (Hilbert_fun P[X] (nat z)) =\n  z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa z +\n  Hilbert_poly bb z", "show \"?f z = ?g z\""], ["proof (prove)\nusing this:\n  int (Hilbert_fun P[X] (nat z)) =\n  z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa z +\n  Hilbert_poly bb z\n\ngoal (1 subgoal):\n 1. z + int (card X) - 1 gchoose (card X - 1) =\n    z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n    Hilbert_poly aa z +\n    Hilbert_poly bb z", "using fin_X X_not_empty \\<open>0 \\<le> z\\<close>"], ["proof (prove)\nusing this:\n  int (Hilbert_fun P[X] (nat z)) =\n  z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa z +\n  Hilbert_poly bb z\n  finite X\n  X \\<noteq> {}\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. z + int (card X) - 1 gchoose (card X - 1) =\n    z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n    Hilbert_poly aa z +\n    Hilbert_poly bb z", "by (simp add: Hilbert_fun_Polys int_binomial) smt"], ["proof (state)\nthis:\n  z + int (card X) - 1 gchoose (card X - 1) =\n  z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa z +\n  Hilbert_poly bb z\n\ngoal (2 subgoals):\n 1. poly_fun (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n 2. poly_fun\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         Hilbert_poly aa z +\n         Hilbert_poly bb z)", "qed (simp_all add: poly_fun_Hilbert_poly)"], ["", "corollary dube_eq_1:\n  \"(\\<lambda>z::int. (z + int n - 1) gchoose (n - 1)) =\n    (\\<lambda>z::int. ((z - d + n - 1) gchoose (n - 1)) + ((z - d + n) gchoose n) + ((z + n) gchoose n) - 2 -\n           (\\<Sum>i=1..n. ((z - aa i + i - 1) gchoose i) + ((z - bb i + i - 1) gchoose i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n        (z - int (poly_deg f) + int (card X) gchoose card X) +\n        (z + int (card X) gchoose card X) -\n        2 -\n        (\\<Sum>i = 1..card X.\n            z - int (aa i) + int i - 1 gchoose i +\n            (z - int (bb i) + int i - 1 gchoose i)))", "by (simp only: dube_eq_0) (auto simp: Hilbert_poly_def Let_def sum.distrib)"], ["", "lemma dube_eq_2:\n  assumes \"j < n\"\n  shows \"(\\<lambda>z::int. (z + int n - int j - 1) gchoose (n - j - 1)) =\n          (\\<lambda>z::int. ((z - d + n - int j - 1) gchoose (n - j - 1)) + ((z - d + n - j) gchoose (n - j)) +\n                    ((z + n - j) gchoose (n - j)) - 2 -\n                    (\\<Sum>i=Suc j..n. ((z - aa i + i - j - 1) gchoose (i - j)) + ((z - bb i + i - j - 1) gchoose (i - j))))\"\n    (is \"?f = ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "let ?h = \"\\<lambda>z i. ((z + (int i - aa i - 1)) gchoose i) + ((z + (int i - bb i - 1)) gchoose i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "let ?hj = \"\\<lambda>z i. ((z + (int i - aa i - 1) - j) gchoose (i - j)) + ((z + (int i - bb i - 1) - j) gchoose (i - j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X", "have 1: \"j \\<le> n - Suc 0\" and 2: \"j \\<le> n\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. j \\<le> card X - Suc 0 &&& j \\<le> card X", "by simp_all"], ["proof (state)\nthis:\n  j \\<le> card X - Suc 0\n  j \\<le> card X\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have eq1: \"(bw_diff ^^ j) (\\<lambda>z. \\<Sum>i=1..j. ?h z i) = (\\<lambda>_. if j = 0 then 0 else 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = 1..j.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>_. if j = 0 then 0 else 2)", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = 1..j.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>_. if j = 0 then 0 else 2)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "case 0"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow>\n    (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = 1..j.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>_. if j = 0 then 0 else 2)\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = 0\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = 1..j.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>_. if j = 0 then 0 else 2)", "by simp"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = 1..j.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>_. if j = 0 then 0 else 2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "case (Suc j0)"], ["proof (state)\nthis:\n  j = Suc j0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "hence \"j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j = Suc j0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "have \"(\\<lambda>z::int. \\<Sum>i = 1..j. ?h z i) = (\\<lambda>z::int. (\\<Sum>i = 1..j0. ?h z i) + ?h z j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z.\n        \\<Sum>i = 1..j.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        (\\<Sum>i = 1..j0.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) +\n        (z + (int j - int (aa j) - 1) gchoose j +\n         (z + (int j - int (bb j) - 1) gchoose j)))", "by (simp add: \\<open>j = Suc j0\\<close>)"], ["proof (state)\nthis:\n  (\\<lambda>z.\n      \\<Sum>i = 1..j.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) +\n      (z + (int j - int (aa j) - 1) gchoose j +\n       (z + (int j - int (bb j) - 1) gchoose j)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>z.\n      \\<Sum>i = 1..j.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) +\n      (z + (int j - int (aa j) - 1) gchoose j +\n       (z + (int j - int (bb j) - 1) gchoose j)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "have \"(bw_diff ^^ j) \\<dots> = (\\<lambda>z::int. (\\<Sum>i = 1..j0. (bw_diff ^^ j) (\\<lambda>z. ?h z i) z) + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         (\\<Sum>i = 1..j0.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i)) +\n         (z + (int j - int (aa j) - 1) gchoose j +\n          (z + (int j - int (bb j) - 1) gchoose j))) =\n    (\\<lambda>z.\n        (\\<Sum>i = 1..j0.\n            (bw_diff ^^ j)\n             (\\<lambda>z.\n                 z + (int i - int (aa i) - 1) gchoose i +\n                 (z + (int i - int (bb i) - 1) gchoose i))\n             z) +\n        2)", "by (simp add: bw_diff_gbinomial_pow)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       (\\<Sum>i = 1..j0.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) +\n       (z + (int j - int (aa j) - 1) gchoose j +\n        (z + (int j - int (bb j) - 1) gchoose j))) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          (bw_diff ^^ j)\n           (\\<lambda>z.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i))\n           z) +\n      2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "moreover"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       (\\<Sum>i = 1..j0.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) +\n       (z + (int j - int (aa j) - 1) gchoose j +\n        (z + (int j - int (bb j) - 1) gchoose j))) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          (bw_diff ^^ j)\n           (\\<lambda>z.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i))\n           z) +\n      2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "have \"(\\<Sum>i = 1..j0. (bw_diff ^^ j) (\\<lambda>z. ?h z i) z) = (\\<Sum>i = 1..j0. 0)\" for z::int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..j0.\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i))\n         z) =\n    (\\<Sum>i = 1..j0. 0)", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..j0.\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i))\n         z) =\n    (\\<Sum>i = 1..j0. 0)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..j0} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..j0} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       0", "assume \"i \\<in> {1..j0}\""], ["proof (state)\nthis:\n  i \\<in> {1..j0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..j0} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       0", "hence \"\\<not> j \\<le> i\""], ["proof (prove)\nusing this:\n  i \\<in> {1..j0}\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> i", "by (simp add: \\<open>j = Suc j0\\<close>)"], ["proof (state)\nthis:\n  \\<not> j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..j0} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       0", "thus \"(bw_diff ^^ j) (\\<lambda>z. ?h z i) z = 0\""], ["proof (prove)\nusing this:\n  \\<not> j \\<le> i\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i))\n     z =\n    0", "by (simp add: bw_diff_gbinomial_pow)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z + (int i - int (aa i) - 1) gchoose i +\n       (z + (int i - int (bb i) - 1) gchoose i))\n   z =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 1..j0.\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))\n       ?z47) =\n  (\\<Sum>i = 1..j0. 0)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            \\<Sum>i = 1..j.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i)) =\n       (\\<lambda>_. if j = 0 then 0 else 2)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>z.\n      \\<Sum>i = 1..j.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) +\n      (z + (int j - int (aa j) - 1) gchoose j +\n       (z + (int j - int (bb j) - 1) gchoose j)))\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       (\\<Sum>i = 1..j0.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) +\n       (z + (int j - int (aa j) - 1) gchoose j +\n        (z + (int j - int (bb j) - 1) gchoose j))) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          (bw_diff ^^ j)\n           (\\<lambda>z.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i))\n           z) +\n      2)\n  (\\<Sum>i = 1..j0.\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))\n       ?z47) =\n  (\\<Sum>i = 1..j0. 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>z.\n      \\<Sum>i = 1..j.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) +\n      (z + (int j - int (aa j) - 1) gchoose j +\n       (z + (int j - int (bb j) - 1) gchoose j)))\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       (\\<Sum>i = 1..j0.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) +\n       (z + (int j - int (aa j) - 1) gchoose j +\n        (z + (int j - int (bb j) - 1) gchoose j))) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j0.\n          (bw_diff ^^ j)\n           (\\<lambda>z.\n               z + (int i - int (aa i) - 1) gchoose i +\n               (z + (int i - int (bb i) - 1) gchoose i))\n           z) +\n      2)\n  (\\<Sum>i = 1..j0.\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))\n       ?z47) =\n  (\\<Sum>i = 1..j0. 0)\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = 1..j.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>_. if j = 0 then 0 else 2)", "by (simp add: \\<open>j \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = 1..j.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>_. if j = 0 then 0 else 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = 1..j.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>_. if j = 0 then 0 else 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have eq2: \"(bw_diff ^^ j) (\\<lambda>z. \\<Sum>i=Suc j..n. ?h z i) = (\\<lambda>z. (\\<Sum>i=Suc j..n. ?hj z i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "have \"(bw_diff ^^ j) (\\<lambda>z. \\<Sum>i=Suc j..n. ?h z i) = (\\<lambda>z. \\<Sum>i=Suc j..n. (bw_diff ^^ j) (\\<lambda>z. ?h z i) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           (bw_diff ^^ j)\n            (\\<lambda>z.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n            z)", "by simp"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         (bw_diff ^^ j)\n          (\\<lambda>z.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n          z)\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         (bw_diff ^^ j)\n          (\\<lambda>z.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n          z)\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "have \"\\<dots> = (\\<lambda>z. (\\<Sum>i=Suc j..n. ?hj z i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           (bw_diff ^^ j)\n            (\\<lambda>z.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n            z) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "proof (intro ext sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. {Suc j..card X} = {Suc j..card X}\n 2. \\<And>z x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       z + (int x - int (aa x) - 1) - int j gchoose (x - j) +\n       (z + (int x - int (bb x) - 1) - int j gchoose (x - j))", "fix z i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z. {Suc j..card X} = {Suc j..card X}\n 2. \\<And>z x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       z + (int x - int (aa x) - 1) - int j gchoose (x - j) +\n       (z + (int x - int (bb x) - 1) - int j gchoose (x - j))", "assume \"i \\<in> {Suc j..n}\""], ["proof (state)\nthis:\n  i \\<in> {Suc j..card X}\n\ngoal (2 subgoals):\n 1. \\<And>z. {Suc j..card X} = {Suc j..card X}\n 2. \\<And>z x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       z + (int x - int (aa x) - 1) - int j gchoose (x - j) +\n       (z + (int x - int (bb x) - 1) - int j gchoose (x - j))", "hence \"j \\<le> i\""], ["proof (prove)\nusing this:\n  i \\<in> {Suc j..card X}\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by simp"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>z. {Suc j..card X} = {Suc j..card X}\n 2. \\<And>z x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       (bw_diff ^^ j)\n        (\\<lambda>z.\n            z + (int x - int (aa x) - 1) gchoose x +\n            (z + (int x - int (bb x) - 1) gchoose x))\n        z =\n       z + (int x - int (aa x) - 1) - int j gchoose (x - j) +\n       (z + (int x - int (bb x) - 1) - int j gchoose (x - j))", "thus \"(bw_diff ^^ j) (\\<lambda>z. ?h z i) z = ?hj z i\""], ["proof (prove)\nusing this:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i))\n     z =\n    z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n    (z + (int i - int (bb i) - 1) - int j gchoose (i - j))", "by (simp add: bw_diff_gbinomial_pow)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z + (int i - int (aa i) - 1) gchoose i +\n       (z + (int i - int (bb i) - 1) gchoose i))\n   z =\n  z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n  (z + (int i - int (bb i) - 1) - int j gchoose (i - j))\n\ngoal (1 subgoal):\n 1. \\<And>z. {Suc j..card X} = {Suc j..card X}", "qed (fact refl)"], ["proof (state)\nthis:\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         (bw_diff ^^ j)\n          (\\<lambda>z.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n          z) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n         (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "finally"], ["proof (chain)\npicking this:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n         (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n         (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         \\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        \\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))", "."], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n         (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       \\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      \\<Sum>i = Suc j..card X.\n         z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n         (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "from 1"], ["proof (chain)\npicking this:\n  j \\<le> card X - Suc 0", "have \"?f = (bw_diff ^^ j) (\\<lambda>z::int. (z + (int n - 1)) gchoose (n - 1))\""], ["proof (prove)\nusing this:\n  j \\<le> card X - Suc 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (bw_diff ^^ j) (\\<lambda>z. z + (int (card X) - 1) gchoose (card X - 1))", "by (simp add: bw_diff_gbinomial_pow) (simp only: algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n  (bw_diff ^^ j) (\\<lambda>z. z + (int (card X) - 1) gchoose (card X - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n  (bw_diff ^^ j) (\\<lambda>z. z + (int (card X) - 1) gchoose (card X - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have \"\\<dots> = (bw_diff ^^ j) (\\<lambda>z::int. (z + int n - 1) gchoose (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z. z + (int (card X) - 1) gchoose (card X - 1)) =\n    (bw_diff ^^ j) (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))", "by (simp only: algebra_simps)"], ["proof (state)\nthis:\n  (bw_diff ^^ j) (\\<lambda>z. z + (int (card X) - 1) gchoose (card X - 1)) =\n  (bw_diff ^^ j) (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ j) (\\<lambda>z. z + (int (card X) - 1) gchoose (card X - 1)) =\n  (bw_diff ^^ j) (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have \"\\<dots> = (bw_diff ^^ j)\n          (\\<lambda>z::int. ((z - d + n - 1) gchoose (n - 1)) + ((z - d + n) gchoose n) + ((z + n) gchoose n) - 2 -\n            (\\<Sum>i=1..n. ((z - aa i + i - 1) gchoose i) + ((z - bb i + i - 1) gchoose i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j) (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1)) =\n    (bw_diff ^^ j)\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         (z - int (poly_deg f) + int (card X) gchoose card X) +\n         (z + int (card X) gchoose card X) -\n         2 -\n         (\\<Sum>i = 1..card X.\n             z - int (aa i) + int i - 1 gchoose i +\n             (z - int (bb i) + int i - 1 gchoose i)))", "by (simp only: dube_eq_1)"], ["proof (state)\nthis:\n  (bw_diff ^^ j) (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1)) =\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       (z - int (poly_deg f) + int (card X) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z - int (aa i) + int i - 1 gchoose i +\n           (z - int (bb i) + int i - 1 gchoose i)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ j) (\\<lambda>z. z + int (card X) - 1 gchoose (card X - 1)) =\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       (z - int (poly_deg f) + int (card X) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z - int (aa i) + int i - 1 gchoose i +\n           (z - int (bb i) + int i - 1 gchoose i)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have \"\\<dots> = (bw_diff ^^ j)\n          (\\<lambda>z::int. ((z + (int n - d - 1)) gchoose (n - 1)) + ((z + (int n - d)) gchoose n) +\n                    ((z + n) gchoose n) - 2 - (\\<Sum>i=1..n. ?h z i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n         (z - int (poly_deg f) + int (card X) gchoose card X) +\n         (z + int (card X) gchoose card X) -\n         2 -\n         (\\<Sum>i = 1..card X.\n             z - int (aa i) + int i - 1 gchoose i +\n             (z - int (bb i) + int i - 1 gchoose i))) =\n    (bw_diff ^^ j)\n     (\\<lambda>z.\n         z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n         (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n         (z + int (card X) gchoose card X) -\n         2 -\n         (\\<Sum>i = 1..card X.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i)))", "by (simp only: algebra_simps)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       (z - int (poly_deg f) + int (card X) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z - int (aa i) + int i - 1 gchoose i +\n           (z - int (bb i) + int i - 1 gchoose i))) =\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n       (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n       (z - int (poly_deg f) + int (card X) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z - int (aa i) + int i - 1 gchoose i +\n           (z - int (bb i) + int i - 1 gchoose i))) =\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n       (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have \"\\<dots> = (\\<lambda>z::int. ((z + (int n - d - 1) - j) gchoose (n - 1 - j)) +\n            ((z + (int n - d) - j) gchoose (n - j)) + ((z + n - j) gchoose (n - j)) - (if j = 0 then 2 else 0) -\n            (bw_diff ^^ j) (\\<lambda>z. \\<Sum>i=1..n. ?h z i) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n         (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n         (z + int (card X) gchoose card X) -\n         2 -\n         (\\<Sum>i = 1..card X.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i))) =\n    (\\<lambda>z.\n        z + (int (card X) - int (poly_deg f) - 1) - int j gchoose\n        (card X - 1 - j) +\n        (z + (int (card X) - int (poly_deg f)) - int j gchoose\n         (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        (if j = 0 then 2 else 0) -\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             \\<Sum>i = 1..card X.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n         z)", "using 1 2"], ["proof (prove)\nusing this:\n  j \\<le> card X - Suc 0\n  j \\<le> card X\n\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n         (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n         (z + int (card X) gchoose card X) -\n         2 -\n         (\\<Sum>i = 1..card X.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i))) =\n    (\\<lambda>z.\n        z + (int (card X) - int (poly_deg f) - 1) - int j gchoose\n        (card X - 1 - j) +\n        (z + (int (card X) - int (poly_deg f)) - int j gchoose\n         (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        (if j = 0 then 2 else 0) -\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             \\<Sum>i = 1..card X.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n         z)", "by (simp add: bw_diff_const_pow bw_diff_gbinomial_pow del: bw_diff_sum_pow)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n       (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))) =\n  (\\<lambda>z.\n      z + (int (card X) - int (poly_deg f) - 1) - int j gchoose\n      (card X - 1 - j) +\n      (z + (int (card X) - int (poly_deg f)) - int j gchoose (card X - j)) +\n      (z + int (card X) - int j gchoose (card X - j)) -\n      (if j = 0 then 2 else 0) -\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = 1..card X.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z)\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       z + (int (card X) - int (poly_deg f) - 1) gchoose (card X - 1) +\n       (z + (int (card X) - int (poly_deg f)) gchoose card X) +\n       (z + int (card X) gchoose card X) -\n       2 -\n       (\\<Sum>i = 1..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))) =\n  (\\<lambda>z.\n      z + (int (card X) - int (poly_deg f) - 1) - int j gchoose\n      (card X - 1 - j) +\n      (z + (int (card X) - int (poly_deg f)) - int j gchoose (card X - j)) +\n      (z + int (card X) - int j gchoose (card X - j)) -\n      (if j = 0 then 2 else 0) -\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = 1..card X.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z)\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "from \\<open>j \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  j \\<le> card X", "have \"(\\<lambda>z. \\<Sum>i=1..n. ?h z i) = (\\<lambda>z. (\\<Sum>i=1..j. ?h z i) + (\\<Sum>i=Suc j..n. ?h z i))\""], ["proof (prove)\nusing this:\n  j \\<le> card X\n\ngoal (1 subgoal):\n 1. (\\<lambda>z.\n        \\<Sum>i = 1..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) =\n    (\\<lambda>z.\n        (\\<Sum>i = 1..j.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)) +\n        (\\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) gchoose i +\n            (z + (int i - int (bb i) - 1) gchoose i)))", "by (simp add: sum_split_nat_ivl)"], ["proof (state)\nthis:\n  (\\<lambda>z.\n      \\<Sum>i = 1..card X.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) +\n      (\\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (\\<lambda>z.\n      \\<Sum>i = 1..card X.\n         z + (int i - int (aa i) - 1) gchoose i +\n         (z + (int i - int (bb i) - 1) gchoose i)) =\n  (\\<lambda>z.\n      (\\<Sum>i = 1..j.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)) +\n      (\\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) gchoose i +\n          (z + (int i - int (bb i) - 1) gchoose i)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have \"(bw_diff ^^ j) \\<dots> = (\\<lambda>z. (bw_diff ^^ j) (\\<lambda>z. \\<Sum>i=1..j. ?h z i) z + (bw_diff ^^ j) (\\<lambda>z. \\<Sum>i=Suc j..n. ?h z i) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bw_diff ^^ j)\n     (\\<lambda>z.\n         (\\<Sum>i = 1..j.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i)) +\n         (\\<Sum>i = Suc j..card X.\n             z + (int i - int (aa i) - 1) gchoose i +\n             (z + (int i - int (bb i) - 1) gchoose i))) =\n    (\\<lambda>z.\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             \\<Sum>i = 1..j.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n         z +\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             \\<Sum>i = Suc j..card X.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n         z)", "by (simp only: bw_diff_plus_pow)"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       (\\<Sum>i = 1..j.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) +\n       (\\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))) =\n  (\\<lambda>z.\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = 1..j.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z +\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = Suc j..card X.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z)\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (bw_diff ^^ j)\n   (\\<lambda>z.\n       (\\<Sum>i = 1..j.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i)) +\n       (\\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) gchoose i +\n           (z + (int i - int (bb i) - 1) gchoose i))) =\n  (\\<lambda>z.\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = 1..j.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z +\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = Suc j..card X.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z)\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "have \"\\<dots> = (\\<lambda>z. (if j = 0 then 0 else 2) + (\\<Sum>i=Suc j..n. ?hj z i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z.\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             \\<Sum>i = 1..j.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n         z +\n        (bw_diff ^^ j)\n         (\\<lambda>z.\n             \\<Sum>i = Suc j..card X.\n                z + (int i - int (aa i) - 1) gchoose i +\n                (z + (int i - int (bb i) - 1) gchoose i))\n         z) =\n    (\\<lambda>z.\n        (if j = 0 then 0 else 2) +\n        (\\<Sum>i = Suc j..card X.\n            z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n            (z + (int i - int (bb i) - 1) - int j gchoose (i - j))))", "by (simp only: eq1 eq2)"], ["proof (state)\nthis:\n  (\\<lambda>z.\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = 1..j.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z +\n      (bw_diff ^^ j)\n       (\\<lambda>z.\n           \\<Sum>i = Suc j..card X.\n              z + (int i - int (aa i) - 1) gchoose i +\n              (z + (int i - int (bb i) - 1) gchoose i))\n       z) =\n  (\\<lambda>z.\n      (if j = 0 then 0 else 2) +\n      (\\<Sum>i = Suc j..card X.\n          z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n          (z + (int i - int (bb i) - 1) - int j gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n  (\\<lambda>z.\n      z + (int (card X) - int (poly_deg f) - 1) - int j gchoose\n      (card X - 1 - j) +\n      (z + (int (card X) - int (poly_deg f)) - int j gchoose (card X - j)) +\n      (z + int (card X) - int j gchoose (card X - j)) -\n      (if j = 0 then 2 else 0) -\n      ((if j = 0 then 0 else 2) +\n       (\\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n  (\\<lambda>z.\n      z + (int (card X) - int (poly_deg f) - 1) - int j gchoose\n      (card X - 1 - j) +\n      (z + (int (card X) - int (poly_deg f)) - int j gchoose (card X - j)) +\n      (z + int (card X) - int j gchoose (card X - j)) -\n      (if j = 0 then 2 else 0) -\n      ((if j = 0 then 0 else 2) +\n       (\\<Sum>i = Suc j..card X.\n           z + (int i - int (aa i) - 1) - int j gchoose (i - j) +\n           (z + (int i - int (bb i) - 1) - int j gchoose (i - j)))))\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n    (\\<lambda>z.\n        z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n        (card X - j - 1) +\n        (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n        (z + int (card X) - int j gchoose (card X - j)) -\n        2 -\n        (\\<Sum>i = Suc j..card X.\n            z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n            (z - int (bb i) + int i - int j - 1 gchoose (i - j))))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>z. z + int (card X) - int j - 1 gchoose (card X - j - 1)) =\n  (\\<lambda>z.\n      z - int (poly_deg f) + int (card X) - int j - 1 gchoose\n      (card X - j - 1) +\n      (z - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n      (z + int (card X) - int j gchoose (card X - j)) -\n      2 -\n      (\\<Sum>i = Suc j..card X.\n          z - int (aa i) + int i - int j - 1 gchoose (i - j) +\n          (z - int (bb i) + int i - int j - 1 gchoose (i - j))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dube_eq_3:\n  assumes \"j < n\"\n  shows \"(1::int) = (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - j) * ((int d - 1) gchoose (n - j)) - 1 -\n                    (\\<Sum>i=Suc j..n. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X", "have 1: \"int (n - Suc j) = int n - j - 1\" and 2: \"int (n - j) = int n - j\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. int (card X - Suc j) = int (card X) - int j - 1 &&&\n    int (card X - j) = int (card X) - int j", "by simp_all"], ["proof (state)\nthis:\n  int (card X - Suc j) = int (card X) - int j - 1\n  int (card X - j) = int (card X) - int j\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X", "have \"int n - int j - 1 = int (n - j - 1)\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. int (card X) - int j - 1 = int (card X - j - 1)", "by simp"], ["proof (state)\nthis:\n  int (card X) - int j - 1 = int (card X - j - 1)\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "hence eq1: \"int n - int j - 1 gchoose (n - Suc j) = 1\""], ["proof (prove)\nusing this:\n  int (card X) - int j - 1 = int (card X - j - 1)\n\ngoal (1 subgoal):\n 1. int (card X) - int j - 1 gchoose (card X - Suc j) = 1", "by simp"], ["proof (state)\nthis:\n  int (card X) - int j - 1 gchoose (card X - Suc j) = 1\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X", "have \"int n - int j = int (n - j)\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. int (card X) - int j = int (card X - j)", "by simp"], ["proof (state)\nthis:\n  int (card X) - int j = int (card X - j)\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "hence eq2: \"int n - int j gchoose (n - j) = 1\""], ["proof (prove)\nusing this:\n  int (card X) - int j = int (card X - j)\n\ngoal (1 subgoal):\n 1. int (card X) - int j gchoose (card X - j) = 1", "by simp"], ["proof (state)\nthis:\n  int (card X) - int j gchoose (card X - j) = 1\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have eq3: \"int n - d - j - 1 gchoose (n - Suc j) = (- 1)^(n - Suc j) * (int d - 1 gchoose (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card X) - int (poly_deg f) - int j - 1 gchoose (card X - Suc j) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j))", "by (simp add: gbinomial_int_negated_upper[of \"int n - d - j - 1\"] 1)"], ["proof (state)\nthis:\n  int (card X) - int (poly_deg f) - int j - 1 gchoose (card X - Suc j) =\n  (- 1) ^ (card X - Suc j) * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have eq4: \"int n - d - j gchoose (n - j) = (- 1)^(n - j) * (int d - 1 gchoose (n - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card X) - int (poly_deg f) - int j gchoose (card X - j) =\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j))", "by (simp add: gbinomial_int_negated_upper[of \"int n - d - j\"] 2)"], ["proof (state)\nthis:\n  int (card X) - int (poly_deg f) - int j gchoose (card X - j) =\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j))\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have eq5: \"(\\<Sum>i = Suc j..n. int i - aa i - j - 1 gchoose (i - j) + (int i - bb i - j - 1 gchoose (i - j))) =\n        (\\<Sum>i=Suc j..n. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc j..card X.\n        int i - int (aa i) - int j - 1 gchoose (i - j) +\n        (int i - int (bb i) - int j - 1 gchoose (i - j))) =\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc j..card X.\n        int i - int (aa i) - int j - 1 gchoose (i - j) +\n        (int i - int (bb i) - int j - 1 gchoose (i - j))) =\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       int x - int (aa x) - int j - 1 gchoose (x - j) +\n       (int x - int (bb x) - int j - 1 gchoose (x - j)) =\n       (- 1) ^ (x - j) *\n       (int (aa x) gchoose (x - j) + (int (bb x) gchoose (x - j)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       int x - int (aa x) - int j - 1 gchoose (x - j) +\n       (int x - int (bb x) - int j - 1 gchoose (x - j)) =\n       (- 1) ^ (x - j) *\n       (int (aa x) gchoose (x - j) + (int (bb x) gchoose (x - j)))", "assume \"i \\<in> {Suc j..n}\""], ["proof (state)\nthis:\n  i \\<in> {Suc j..card X}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       int x - int (aa x) - int j - 1 gchoose (x - j) +\n       (int x - int (bb x) - int j - 1 gchoose (x - j)) =\n       (- 1) ^ (x - j) *\n       (int (aa x) gchoose (x - j) + (int (bb x) gchoose (x - j)))", "hence \"j \\<le> i\""], ["proof (prove)\nusing this:\n  i \\<in> {Suc j..card X}\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by simp"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       int x - int (aa x) - int j - 1 gchoose (x - j) +\n       (int x - int (bb x) - int j - 1 gchoose (x - j)) =\n       (- 1) ^ (x - j) *\n       (int (aa x) gchoose (x - j) + (int (bb x) gchoose (x - j)))", "hence 3: \"int (i - j) = int i - j\""], ["proof (prove)\nusing this:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. int (i - j) = int i - int j", "by simp"], ["proof (state)\nthis:\n  int (i - j) = int i - int j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Suc j..card X} \\<Longrightarrow>\n       int x - int (aa x) - int j - 1 gchoose (x - j) +\n       (int x - int (bb x) - int j - 1 gchoose (x - j)) =\n       (- 1) ^ (x - j) *\n       (int (aa x) gchoose (x - j) + (int (bb x) gchoose (x - j)))", "show \"int i - aa i - j - 1 gchoose (i - j) + (int i - bb i - j - 1 gchoose (i - j)) =\n          (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int i - int (aa i) - int j - 1 gchoose (i - j) +\n    (int i - int (bb i) - int j - 1 gchoose (i - j)) =\n    (- 1) ^ (i - j) *\n    (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))", "by (simp add: gbinomial_int_negated_upper[of \"int i - aa i - j - 1\"]\n            gbinomial_int_negated_upper[of \"int i - bb i - j - 1\"] 3 distrib_left)"], ["proof (state)\nthis:\n  int i - int (aa i) - int j - 1 gchoose (i - j) +\n  (int i - int (bb i) - int j - 1 gchoose (i - j)) =\n  (- 1) ^ (i - j) *\n  (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc j..card X.\n      int i - int (aa i) - int j - 1 gchoose (i - j) +\n      (int i - int (bb i) - int j - 1 gchoose (i - j))) =\n  (\\<Sum>i = Suc j..card X.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from fun_cong[OF dube_eq_2, OF assms, of 0]"], ["proof (chain)\npicking this:\n  0 + int (card X) - int j - 1 gchoose (card X - j - 1) =\n  0 - int (poly_deg f) + int (card X) - int j - 1 gchoose (card X - j - 1) +\n  (0 - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n  (0 + int (card X) - int j gchoose (card X - j)) -\n  2 -\n  (\\<Sum>i = Suc j..card X.\n      0 - int (aa i) + int i - int j - 1 gchoose (i - j) +\n      (0 - int (bb i) + int i - int j - 1 gchoose (i - j)))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 + int (card X) - int j - 1 gchoose (card X - j - 1) =\n  0 - int (poly_deg f) + int (card X) - int j - 1 gchoose (card X - j - 1) +\n  (0 - int (poly_deg f) + int (card X) - int j gchoose (card X - j)) +\n  (0 + int (card X) - int j gchoose (card X - j)) -\n  2 -\n  (\\<Sum>i = Suc j..card X.\n      0 - int (aa i) + int i - int j - 1 gchoose (i - j) +\n      (0 - int (bb i) + int i - int j - 1 gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (simp add: eq1 eq2 eq3 eq4 eq5)"], ["proof (state)\nthis:\n  1 =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dube_aux_1:\n  assumes \"(h, {}) \\<in> set ps \\<union> set qs\"\n  shows \"poly_deg h < max (aa 1) (bb 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h < max (aa 1) (bb 1)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "define z where \"z = poly_deg h\""], ["proof (state)\nthis:\n  z = poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "assume \"\\<not> z < max (aa 1) (bb 1)\""], ["proof (state)\nthis:\n  \\<not> z < max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "let ?S = \"\\<lambda>A. {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "have fin: \"finite (?S A)\" if \"finite A\" for A::\"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "have \"(\\<lambda>t. (t, {})) ` ?S A \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n    \\<subseteq> A", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n  \\<subseteq> A\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "hence \"finite ((\\<lambda>t. (t, {}::'x set)) ` ?S A)\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n  \\<subseteq> A\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z})", "using that"], ["proof (prove)\nusing this:\n  (\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n  \\<subseteq> A\n  finite A\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z})", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z})\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "moreover"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z})\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "have \"inj_on (\\<lambda>t. (t, {}::'x set)) (?S A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>t. (t, {})) {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "by (rule inj_onI) simp"], ["proof (state)\nthis:\n  inj_on (\\<lambda>t. (t, {})) {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   ((\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z})\n  inj_on (\\<lambda>t. (t, {})) {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>t. (t, {})) ` {h. (h, {}) \\<in> A \\<and> poly_deg h = z})\n  inj_on (\\<lambda>t. (t, {})) {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}", "by (rule finite_imageD)"], ["proof (state)\nthis:\n  finite {h. (h, {}) \\<in> A \\<and> poly_deg h = z}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?A48 \\<Longrightarrow>\n  finite {h. (h, {}) \\<in> ?A48 \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have 1: \"finite (?S (set ps))\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}", "by (rule fin)"], ["proof (state)\nthis:\n  finite {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have 2: \"finite (?S (set qs))\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}", "by (rule fin)"], ["proof (state)\nthis:\n  finite {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "from \\<open>\\<not> z < max (aa 1) (bb 1)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> z < max (aa 1) (bb 1)", "have \"aa 1 \\<le> z\" and \"bb 1 \\<le> z\""], ["proof (prove)\nusing this:\n  \\<not> z < max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. aa 1 \\<le> z &&& bb 1 \\<le> z", "by simp_all"], ["proof (state)\nthis:\n  aa 1 \\<le> z\n  bb 1 \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "have \"d \\<le> aa 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f \\<le> aa 1", "unfolding aa_Suc_n[symmetric] aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> \\<b> ps 1", "using fin_X"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> \\<b> ps 1", "by (rule \\<b>_decreasing) simp"], ["proof (state)\nthis:\n  poly_deg f \\<le> aa 1\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "hence \"d \\<le> z\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> aa 1\n\ngoal (1 subgoal):\n 1. poly_deg f \\<le> z", "using \\<open>aa 1 \\<le> z\\<close>"], ["proof (prove)\nusing this:\n  poly_deg f \\<le> aa 1\n  aa 1 \\<le> z\n\ngoal (1 subgoal):\n 1. poly_deg f \\<le> z", "by (rule le_trans)"], ["proof (state)\nthis:\n  poly_deg f \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "hence eq: \"int (z - d) = int z - int d\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> z\n\ngoal (1 subgoal):\n 1. int (z - poly_deg f) = int z - int (poly_deg f)", "by simp"], ["proof (state)\nthis:\n  int (z - poly_deg f) = int z - int (poly_deg f)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "from \\<open>d \\<le> z\\<close>"], ["proof (chain)\npicking this:\n  poly_deg f \\<le> z", "have \"Hilbert_fun (P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) z =\n                        ((z - d) + (n - 1)) choose (n - 1) + Hilbert_fun P z + Hilbert_fun N z\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> z\n\ngoal (1 subgoal):\n 1. Hilbert_fun P[X] z =\n    z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n    Hilbert_fun N z", "by (rule Hilbert_fun_X)"], ["proof (state)\nthis:\n  Hilbert_fun P[X] z =\n  z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n  Hilbert_fun N z\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Hilbert_fun P[X] z =\n  z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n  Hilbert_fun N z\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "have \"int \\<dots> = ((int z - d + (n - 1)) gchoose (n - 1) + Hilbert_poly aa z + Hilbert_poly bb z) +\n                        (int (card (?S (set ps))) + int (card (?S (set qs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (z - poly_deg f + (card X - 1) choose (card X - 1) +\n         Hilbert_fun P z +\n         Hilbert_fun N z) =\n    int z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n    Hilbert_poly aa (int z) +\n    Hilbert_poly bb (int z) +\n    (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n     int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}))", "using X_not_empty valid_ps hom_ps cn_ps std_ps ext_ps \\<open>aa 1 \\<le> z\\<close>\n          valid_qs hom_qs cn_qs std_qs ext_qs \\<open>bb 1 \\<le> z\\<close>"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  valid_decomp X ps\n  hom_decomp ps\n  cone_decomp P ps\n  standard_decomp (poly_deg f) ps\n  exact_decomp X 0 ps\n  aa 1 \\<le> z\n  valid_decomp X qs\n  hom_decomp qs\n  cone_decomp N qs\n  standard_decomp 0 qs\n  exact_decomp X 0 qs\n  bb 1 \\<le> z\n\ngoal (1 subgoal):\n 1. int (z - poly_deg f + (card X - 1) choose (card X - 1) +\n         Hilbert_fun P z +\n         Hilbert_fun N z) =\n    int z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n    Hilbert_poly aa (int z) +\n    Hilbert_poly bb (int z) +\n    (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n     int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}))", "by (simp add: Hilbert_fun_eq_Hilbert_poly_plus_card aa_def bb_def int_binomial eq)"], ["proof (state)\nthis:\n  int (z - poly_deg f + (card X - 1) choose (card X - 1) + Hilbert_fun P z +\n       Hilbert_fun N z) =\n  int z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}))\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  int (Hilbert_fun P[X] z) =\n  int z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}))", "have \"((int z - d + n - 1) gchoose (n - 1) + Hilbert_poly aa z + Hilbert_poly bb z) +\n                  (int (card (?S (set ps))) + int (card (?S (set qs)))) = int z + n - 1 gchoose (n - 1)\""], ["proof (prove)\nusing this:\n  int (Hilbert_fun P[X] z) =\n  int z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}))\n\ngoal (1 subgoal):\n 1. int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n    Hilbert_poly aa (int z) +\n    Hilbert_poly bb (int z) +\n    (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n     int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z})) =\n    int z + int (card X) - 1 gchoose (card X - 1)", "using fin_X X_not_empty"], ["proof (prove)\nusing this:\n  int (Hilbert_fun P[X] z) =\n  int z - int (poly_deg f) + int (card X - 1) gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}))\n  finite X\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n    Hilbert_poly aa (int z) +\n    Hilbert_poly bb (int z) +\n    (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n     int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z})) =\n    int z + int (card X) - 1 gchoose (card X - 1)", "by (simp add: Hilbert_fun_Polys int_binomial algebra_simps)"], ["proof (state)\nthis:\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z})) =\n  int z + int (card X) - 1 gchoose (card X - 1)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z})) =\n  int z + int (card X) - 1 gchoose (card X - 1)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "have \"\\<dots> = (int z - d + n - 1) gchoose (n - 1) + Hilbert_poly aa z + Hilbert_poly bb z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int z + int (card X) - 1 gchoose (card X - 1) =\n    int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n    Hilbert_poly aa (int z) +\n    Hilbert_poly bb (int z)", "by (fact dube_eq_0[THEN fun_cong])"], ["proof (state)\nthis:\n  int z + int (card X) - 1 gchoose (card X - 1) =\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z})) =\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z)", "have \"int (card (?S (set ps))) + int (card (?S (set qs))) = 0\""], ["proof (prove)\nusing this:\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z) +\n  (int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n   int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z})) =\n  int z - int (poly_deg f) + int (card X) - 1 gchoose (card X - 1) +\n  Hilbert_poly aa (int z) +\n  Hilbert_poly bb (int z)\n\ngoal (1 subgoal):\n 1. int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n    int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}) =\n    0", "by simp"], ["proof (state)\nthis:\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n  int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "hence \"card (?S (set ps)) = 0\" and \"card (?S (set qs)) = 0\""], ["proof (prove)\nusing this:\n  int (card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}) +\n  int (card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}) =\n  0\n\ngoal (1 subgoal):\n 1. card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z} = 0 &&&\n    card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z} = 0", "by simp_all"], ["proof (state)\nthis:\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z} = 0\n  card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z} = 0\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "with 1 2"], ["proof (chain)\npicking this:\n  finite {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}\n  finite {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z} = 0\n  card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z} = 0", "have \"?S (set ps \\<union> set qs) = {}\""], ["proof (prove)\nusing this:\n  finite {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z}\n  finite {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z}\n  card {h. (h, {}) \\<in> set ps \\<and> poly_deg h = z} = 0\n  card {h. (h, {}) \\<in> set qs \\<and> poly_deg h = z} = 0\n\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z} = {}", "by auto"], ["proof (state)\nthis:\n  {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z} = {}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z} = {}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  (h, {}) \\<in> set ps \\<union> set qs", "have \"h \\<in> ?S (set ps \\<union> set qs)\""], ["proof (prove)\nusing this:\n  (h, {}) \\<in> set ps \\<union> set qs\n\ngoal (1 subgoal):\n 1. h \\<in> {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z}", "by (simp add: z_def)"], ["proof (state)\nthis:\n  h \\<in> {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z} = {}\n  h \\<in> {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z}", "have \"h \\<in> {}\""], ["proof (prove)\nusing this:\n  {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z} = {}\n  h \\<in> {h. (h, {}) \\<in> set ps \\<union> set qs \\<and> poly_deg h = z}\n\ngoal (1 subgoal):\n 1. h \\<in> {}", "by (rule subst)"], ["proof (state)\nthis:\n  h \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < max (aa 1) (bb 1) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  h \\<in> {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows aa_n: \"aa n = d\" and bb_n: \"bb n = 0\" and bb_0: \"bb 0 \\<le> max (aa 1) (bb 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa (card X) = poly_deg f &&&\n    bb (card X) = 0 &&& bb 0 \\<le> max (aa 1) (bb 1)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "let ?j = \"n - Suc 0\""], ["proof (state)\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "from n_gr_0"], ["proof (chain)\npicking this:\n  0 < card X", "have \"?j < n\" and eq1: \"Suc ?j = n\" and eq2: \"n - ?j = 1\""], ["proof (prove)\nusing this:\n  0 < card X\n\ngoal (1 subgoal):\n 1. card X - Suc 0 < card X &&&\n    Suc (card X - Suc 0) = card X &&& card X - (card X - Suc 0) = 1", "by simp_all"], ["proof (state)\nthis:\n  card X - Suc 0 < card X\n  Suc (card X - Suc 0) = card X\n  card X - (card X - Suc 0) = 1\n\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "from this(1)"], ["proof (chain)\npicking this:\n  card X - Suc 0 < card X", "have \"(1::int) = (- 1)^(n - Suc ?j) * ((int d - 1) gchoose (n - Suc ?j)) +\n                    (- 1)^(n - ?j) * ((int d - 1) gchoose (n - ?j)) - 1 -\n                    (\\<Sum>i=Suc ?j..n. (- 1)^(i - ?j) * ((int (aa i) gchoose (i - ?j)) + (int (bb i) gchoose (i - ?j))))\""], ["proof (prove)\nusing this:\n  card X - Suc 0 < card X\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc (card X - Suc 0)) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc (card X - Suc 0))) +\n    (- 1) ^ (card X - (card X - Suc 0)) *\n    (int (poly_deg f) - 1 gchoose (card X - (card X - Suc 0))) -\n    1 -\n    (\\<Sum>i = Suc (card X - Suc 0)..card X.\n        (- 1) ^ (i - (card X - Suc 0)) *\n        (int (aa i) gchoose (i - (card X - Suc 0)) +\n         (int (bb i) gchoose (i - (card X - Suc 0)))))", "by (rule dube_eq_3)"], ["proof (state)\nthis:\n  1 =\n  (- 1) ^ (card X - Suc (card X - Suc 0)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - Suc 0))) +\n  (- 1) ^ (card X - (card X - Suc 0)) *\n  (int (poly_deg f) - 1 gchoose (card X - (card X - Suc 0))) -\n  1 -\n  (\\<Sum>i = Suc (card X - Suc 0)..card X.\n      (- 1) ^ (i - (card X - Suc 0)) *\n      (int (aa i) gchoose (i - (card X - Suc 0)) +\n       (int (bb i) gchoose (i - (card X - Suc 0)))))\n\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "hence eq: \"aa n + bb n = d\""], ["proof (prove)\nusing this:\n  1 =\n  (- 1) ^ (card X - Suc (card X - Suc 0)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - Suc 0))) +\n  (- 1) ^ (card X - (card X - Suc 0)) *\n  (int (poly_deg f) - 1 gchoose (card X - (card X - Suc 0))) -\n  1 -\n  (\\<Sum>i = Suc (card X - Suc 0)..card X.\n      (- 1) ^ (i - (card X - Suc 0)) *\n      (int (aa i) gchoose (i - (card X - Suc 0)) +\n       (int (bb i) gchoose (i - (card X - Suc 0)))))\n\ngoal (1 subgoal):\n 1. aa (card X) + bb (card X) = poly_deg f", "by (simp add: eq1 eq2)"], ["proof (state)\nthis:\n  aa (card X) + bb (card X) = poly_deg f\n\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "hence \"aa n \\<le> d\""], ["proof (prove)\nusing this:\n  aa (card X) + bb (card X) = poly_deg f\n\ngoal (1 subgoal):\n 1. aa (card X) \\<le> poly_deg f", "by simp"], ["proof (state)\nthis:\n  aa (card X) \\<le> poly_deg f\n\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "moreover"], ["proof (state)\nthis:\n  aa (card X) \\<le> poly_deg f\n\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "have \"d \\<le> aa n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f \\<le> aa (card X)", "unfolding aa_Suc_n[symmetric] aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> \\<b> ps (card X)", "using fin_X"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> \\<b> ps (card X)", "by (rule \\<b>_decreasing) simp"], ["proof (state)\nthis:\n  poly_deg f \\<le> aa (card X)\n\ngoal (3 subgoals):\n 1. aa (card X) = poly_deg f\n 2. bb (card X) = 0\n 3. bb 0 \\<le> max (aa 1) (bb 1)", "ultimately"], ["proof (chain)\npicking this:\n  aa (card X) \\<le> poly_deg f\n  poly_deg f \\<le> aa (card X)", "show \"aa n = d\""], ["proof (prove)\nusing this:\n  aa (card X) \\<le> poly_deg f\n  poly_deg f \\<le> aa (card X)\n\ngoal (1 subgoal):\n 1. aa (card X) = poly_deg f", "by (rule antisym)"], ["proof (state)\nthis:\n  aa (card X) = poly_deg f\n\ngoal (2 subgoals):\n 1. bb (card X) = 0\n 2. bb 0 \\<le> max (aa 1) (bb 1)", "with eq"], ["proof (chain)\npicking this:\n  aa (card X) + bb (card X) = poly_deg f\n  aa (card X) = poly_deg f", "show \"bb n = 0\""], ["proof (prove)\nusing this:\n  aa (card X) + bb (card X) = poly_deg f\n  aa (card X) = poly_deg f\n\ngoal (1 subgoal):\n 1. bb (card X) = 0", "by simp"], ["proof (state)\nthis:\n  bb (card X) = 0\n\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "have \"bb 0 = \\<b> qs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb 0 = \\<b> qs 0", "by (simp only: bb_def)"], ["proof (state)\nthis:\n  bb 0 = \\<b> qs 0\n\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "also"], ["proof (state)\nthis:\n  bb 0 = \\<b> qs 0\n\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "from fin_X"], ["proof (chain)\npicking this:\n  finite X", "have \"\\<dots> \\<le> max (aa 1) (bb 1)\" (is \"_ \\<le> ?m\")"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<b> qs 0 \\<le> max (aa 1) (bb 1)", "proof (rule \\<b>_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "from fin_X ext_qs"], ["proof (chain)\npicking this:\n  finite X\n  exact_decomp X 0 qs", "have \"\\<a> qs = bb (Suc n)\""], ["proof (prove)\nusing this:\n  finite X\n  exact_decomp X 0 qs\n\ngoal (1 subgoal):\n 1. \\<a> qs = bb (Suc (card X))", "by (simp add: \\<b>_card_X bb_def)"], ["proof (state)\nthis:\n  \\<a> qs = bb (Suc (card X))\n\ngoal (2 subgoals):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "also"], ["proof (state)\nthis:\n  \\<a> qs = bb (Suc (card X))\n\ngoal (2 subgoals):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "have \"\\<dots> \\<le> bb 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb (Suc (card X)) \\<le> bb 1", "unfolding bb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> qs (Suc (card X)) \\<le> \\<b> qs 1", "using fin_X"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<b> qs (Suc (card X)) \\<le> \\<b> qs 1", "by (rule \\<b>_decreasing) simp"], ["proof (state)\nthis:\n  bb (Suc (card X)) \\<le> bb 1\n\ngoal (2 subgoals):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "also"], ["proof (state)\nthis:\n  bb (Suc (card X)) \\<le> bb 1\n\ngoal (2 subgoals):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "have \"\\<dots> \\<le> ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb 1 \\<le> max (aa 1) (bb 1)", "by (rule max.cobounded2)"], ["proof (state)\nthis:\n  bb 1 \\<le> max (aa 1) (bb 1)\n\ngoal (2 subgoals):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "finally"], ["proof (chain)\npicking this:\n  \\<a> qs \\<le> max (aa 1) (bb 1)", "show \"\\<a> qs \\<le> ?m\""], ["proof (prove)\nusing this:\n  \\<a> qs \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. \\<a> qs \\<le> max (aa 1) (bb 1)", "."], ["proof (state)\nthis:\n  \\<a> qs \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "fix h U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "assume \"(h, U) \\<in> set qs\""], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set qs; 0 \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < max (aa 1) (bb 1)", "show \"poly_deg h < ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h < max (aa 1) (bb 1)", "proof (cases \"card U = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card U = 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)\n 2. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "case True"], ["proof (state)\nthis:\n  card U = 0\n\ngoal (2 subgoals):\n 1. card U = 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)\n 2. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "from fin_X valid_qs \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X qs\n  (h, U) \\<in> set qs", "have \"finite U\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. finite U", "by (rule valid_decompD_finite)"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. card U = 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)\n 2. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "with True"], ["proof (chain)\npicking this:\n  card U = 0\n  finite U", "have \"U = {}\""], ["proof (prove)\nusing this:\n  card U = 0\n  finite U\n\ngoal (1 subgoal):\n 1. U = {}", "by simp"], ["proof (state)\nthis:\n  U = {}\n\ngoal (2 subgoals):\n 1. card U = 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)\n 2. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "with \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set qs\n  U = {}", "have \"(h, {}) \\<in> set ps \\<union> set qs\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set qs\n  U = {}\n\ngoal (1 subgoal):\n 1. (h, {}) \\<in> set ps \\<union> set qs", "by simp"], ["proof (state)\nthis:\n  (h, {}) \\<in> set ps \\<union> set qs\n\ngoal (2 subgoals):\n 1. card U = 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)\n 2. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (h, {}) \\<in> set ps \\<union> set qs\n\ngoal (1 subgoal):\n 1. poly_deg h < max (aa 1) (bb 1)", "by (rule dube_aux_1)"], ["proof (state)\nthis:\n  poly_deg h < max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "case False"], ["proof (state)\nthis:\n  card U \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "hence \"1 \\<le> card U\""], ["proof (prove)\nusing this:\n  card U \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> card U", "by simp"], ["proof (state)\nthis:\n  1 \\<le> card U\n\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "with fin_X \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  (h, U) \\<in> set qs\n  1 \\<le> card U", "have \"poly_deg h < bb 1\""], ["proof (prove)\nusing this:\n  finite X\n  (h, U) \\<in> set qs\n  1 \\<le> card U\n\ngoal (1 subgoal):\n 1. poly_deg h < bb 1", "unfolding bb_def"], ["proof (prove)\nusing this:\n  finite X\n  (h, U) \\<in> set qs\n  1 \\<le> card U\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> qs 1", "by (rule \\<b>)"], ["proof (state)\nthis:\n  poly_deg h < bb 1\n\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "also"], ["proof (state)\nthis:\n  poly_deg h < bb 1\n\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "have \"\\<dots> \\<le> ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb 1 \\<le> max (aa 1) (bb 1)", "by (rule max.cobounded2)"], ["proof (state)\nthis:\n  bb 1 \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. card U \\<noteq> 0 \\<Longrightarrow> poly_deg h < max (aa 1) (bb 1)", "finally"], ["proof (chain)\npicking this:\n  poly_deg h < max (aa 1) (bb 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg h < max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. poly_deg h < max (aa 1) (bb 1)", "."], ["proof (state)\nthis:\n  poly_deg h < max (aa 1) (bb 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg h < max (aa 1) (bb 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<b> qs 0 \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "finally"], ["proof (chain)\npicking this:\n  bb 0 \\<le> max (aa 1) (bb 1)", "show \"bb 0 \\<le> ?m\""], ["proof (prove)\nusing this:\n  bb 0 \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "."], ["proof (state)\nthis:\n  bb 0 \\<le> max (aa 1) (bb 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dube_eq_4:\n  assumes \"j < n\"\n  shows \"(1::int) = 2 * (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) - 1 -\n                    (\\<Sum>i=Suc j..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X", "have \"Suc j \\<le> n\" and \"0 < n\" and 1: \"Suc (n - Suc j) = n - j\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. Suc j \\<le> card X &&& 0 < card X &&& Suc (card X - Suc j) = card X - j", "by simp_all"], ["proof (state)\nthis:\n  Suc j \\<le> card X\n  0 < card X\n  Suc (card X - Suc j) = card X - j\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have 2: \"(- 1) ^ (n - Suc j) = - ((- (1::int)) ^ (n - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) = - ((- 1) ^ (card X - j))", "by (simp flip: 1)"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) = - ((- 1) ^ (card X - j))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X", "have \"(1::int) = (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - j) * ((int d - 1) gchoose (n - j)) - 1 -\n                    (\\<Sum>i=Suc j..n. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. 1 =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (rule dube_eq_3)"], ["proof (state)\nthis:\n  1 =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  1 =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have \"\\<dots> = (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - j) * ((int d - 1) gchoose (n - j)) - 1 -\n                    (- 1)^(n - j) * ((int (aa n) gchoose (n - j)) + (int (bb n) gchoose (n - j))) -\n                    (\\<Sum>i=Suc j..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (- 1) ^ (card X - j) *\n    (int (aa (card X)) gchoose (card X - j) +\n     (int (bb (card X)) gchoose (card X - j))) -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "using \\<open>0 < n\\<close> \\<open>Suc j \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  0 < card X\n  Suc j \\<le> card X\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (- 1) ^ (card X - j) *\n    (int (aa (card X)) gchoose (card X - j) +\n     (int (bb (card X)) gchoose (card X - j))) -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (simp only: sum_tail_nat)"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (- 1) ^ (card X - j) *\n  (int (aa (card X)) gchoose (card X - j) +\n   (int (bb (card X)) gchoose (card X - j))) -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (- 1) ^ (card X - j) *\n  (int (aa (card X)) gchoose (card X - j) +\n   (int (bb (card X)) gchoose (card X - j))) -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have \"\\<dots> = (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - j) * (((int d - 1) gchoose (n - j)) - (int d gchoose (n - j))) - 1 -\n                    (\\<Sum>i=Suc j..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (- 1) ^ (card X - j) *\n    (int (aa (card X)) gchoose (card X - j) +\n     (int (bb (card X)) gchoose (card X - j))) -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - j) -\n     (int (poly_deg f) gchoose (card X - j))) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "using assms"], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n    1 -\n    (- 1) ^ (card X - j) *\n    (int (aa (card X)) gchoose (card X - j) +\n     (int (bb (card X)) gchoose (card X - j))) -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - j) -\n     (int (poly_deg f) gchoose (card X - j))) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (simp add: aa_n bb_n gbinomial_0_left right_diff_distrib)"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (- 1) ^ (card X - j) *\n  (int (aa (card X)) gchoose (card X - j) +\n   (int (bb (card X)) gchoose (card X - j))) -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - j) -\n   (int (poly_deg f) gchoose (card X - j))) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) * (int (poly_deg f) - 1 gchoose (card X - j)) -\n  1 -\n  (- 1) ^ (card X - j) *\n  (int (aa (card X)) gchoose (card X - j) +\n   (int (bb (card X)) gchoose (card X - j))) -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - j) -\n   (int (poly_deg f) gchoose (card X - j))) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have \"(- 1)^(n - j) * (((int d - 1) gchoose (n - j)) - (int d gchoose (n - j))) =\n              (- 1)^(n - Suc j) * (((int d - 1 + 1) gchoose (Suc (n - Suc j))) - ((int d - 1) gchoose (Suc (n - Suc j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - j) -\n     (int (poly_deg f) gchoose (card X - j))) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 + 1 gchoose Suc (card X - Suc j) -\n     (int (poly_deg f) - 1 gchoose Suc (card X - Suc j)))", "by (simp add: 1 2 flip: mult_minus_right)"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - j) -\n   (int (poly_deg f) gchoose (card X - j))) =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 + 1 gchoose Suc (card X - Suc j) -\n   (int (poly_deg f) - 1 gchoose Suc (card X - Suc j)))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - j) -\n   (int (poly_deg f) gchoose (card X - j))) =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 + 1 gchoose Suc (card X - Suc j) -\n   (int (poly_deg f) - 1 gchoose Suc (card X - Suc j)))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have \"\\<dots> = (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 + 1 gchoose Suc (card X - Suc j) -\n     (int (poly_deg f) - 1 gchoose Suc (card X - Suc j))) =\n    (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j))", "by (simp only: gbinomial_int_Suc_Suc, simp)"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 + 1 gchoose Suc (card X - Suc j) -\n   (int (poly_deg f) - 1 gchoose Suc (card X - Suc j))) =\n  (- 1) ^ (card X - Suc j) * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "finally"], ["proof (chain)\npicking this:\n  1 =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 =\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by simp"], ["proof (state)\nthis:\n  1 =\n  2 * (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cc_Suc:\n  assumes \"j < n - 1\"\n  shows \"int (cc (Suc j)) = 2 + 2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) +\n                   (\\<Sum>i=j+2..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from assms"], ["proof (chain)\npicking this:\n  j < card X - 1", "have \"j < n\" and \"Suc j \\<le> n - 1\""], ["proof (prove)\nusing this:\n  j < card X - 1\n\ngoal (1 subgoal):\n 1. j < card X &&& Suc j \\<le> card X - 1", "by simp_all"], ["proof (state)\nthis:\n  j < card X\n  Suc j \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "hence \"n - j = Suc (n - Suc j)\""], ["proof (prove)\nusing this:\n  j < card X\n  Suc j \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. card X - j = Suc (card X - Suc j)", "by simp"], ["proof (state)\nthis:\n  card X - j = Suc (card X - Suc j)\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "hence eq: \"(- 1) ^ (n - Suc j) = - ((- (1::int)) ^ (n - j))\""], ["proof (prove)\nusing this:\n  card X - j = Suc (card X - Suc j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) = - ((- 1) ^ (card X - j))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) = - ((- 1) ^ (card X - j))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "from \\<open>j < n\\<close>"], ["proof (chain)\npicking this:\n  j < card X", "have \"(1::int) = 2 * (- 1)^(n - Suc j) * ((int d - 1) gchoose (n - Suc j)) - 1 -\n             (\\<Sum>i=Suc j..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\nusing this:\n  j < card X\n\ngoal (1 subgoal):\n 1. 1 =\n    2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (rule dube_eq_4)"], ["proof (state)\nthis:\n  1 =\n  2 * (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "also"], ["proof (state)\nthis:\n  1 =\n  2 * (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "have \"\\<dots> = cc (Suc j) - 2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) - 1 -\n             (\\<Sum>i=j+2..n-1. (- 1)^(i - j) * ((int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    int (aa (Suc j) + bb (Suc j)) -\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "using \\<open>Suc j \\<le> n - 1\\<close>"], ["proof (prove)\nusing this:\n  Suc j \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - Suc j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = Suc j..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    int (aa (Suc j) + bb (Suc j)) -\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    1 -\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (simp add: sum.atLeast_Suc_atMost eq)"], ["proof (state)\nthis:\n  2 * (- 1) ^ (card X - Suc j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = Suc j..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  int (aa (Suc j) + bb (Suc j)) -\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "finally"], ["proof (chain)\npicking this:\n  1 =\n  int (aa (Suc j) + bb (Suc j)) -\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 =\n  int (aa (Suc j) + bb (Suc j)) -\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  1 -\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by simp"], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j)) =\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cc_n_minus_1: \"cc (n - 1) = 2 * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "let ?j = \"n - 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "from n_gr_1"], ["proof (chain)\npicking this:\n  1 < card X", "have 1: \"Suc ?j = n - 1\" and \"?j < n - 1\" and 2: \"Suc (n - 1) = n\"\n    and 3: \"n - (n - Suc 0) = Suc 0\" and 4: \"n - ?j = 2\""], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. (Suc (card X - 2) = card X - 1 &&& card X - 2 < card X - 1) &&&\n    Suc (card X - 1) = card X &&&\n    card X - (card X - Suc 0) = Suc 0 &&& card X - (card X - 2) = 2", "by simp_all"], ["proof (state)\nthis:\n  Suc (card X - 2) = card X - 1\n  card X - 2 < card X - 1\n  Suc (card X - 1) = card X\n  card X - (card X - Suc 0) = Suc 0\n  card X - (card X - 2) = 2\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "have \"int (cc (n - 1)) = int (cc (Suc ?j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 1) + bb (card X - 1)) =\n    int (aa (Suc (card X - 2)) + bb (Suc (card X - 2)))", "by (simp only: 1)"], ["proof (state)\nthis:\n  int (aa (card X - 1) + bb (card X - 1)) =\n  int (aa (Suc (card X - 2)) + bb (Suc (card X - 2)))\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  int (aa (card X - 1) + bb (card X - 1)) =\n  int (aa (Suc (card X - 2)) + bb (Suc (card X - 2)))\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "from \\<open>?j < n - 1\\<close>"], ["proof (chain)\npicking this:\n  card X - 2 < card X - 1", "have \"\\<dots> = 2 + 2 * (- 1) ^ (n - ?j) * (int d - 1 gchoose (n - Suc ?j)) +\n         (\\<Sum>i = ?j+2..n-1. (- 1) ^ (i - ?j) * (int (aa i) gchoose (i - ?j) + (int (bb i) gchoose (i - ?j))))\""], ["proof (prove)\nusing this:\n  card X - 2 < card X - 1\n\ngoal (1 subgoal):\n 1. int (aa (Suc (card X - 2)) + bb (Suc (card X - 2))) =\n    2 +\n    2 * (- 1) ^ (card X - (card X - 2)) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 2))) +\n    (\\<Sum>i = card X - 2 + 2..card X - 1.\n        (- 1) ^ (i - (card X - 2)) *\n        (int (aa i) gchoose (i - (card X - 2)) +\n         (int (bb i) gchoose (i - (card X - 2)))))", "by (rule cc_Suc)"], ["proof (state)\nthis:\n  int (aa (Suc (card X - 2)) + bb (Suc (card X - 2))) =\n  2 +\n  2 * (- 1) ^ (card X - (card X - 2)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 2))) +\n  (\\<Sum>i = card X - 2 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 2)) *\n      (int (aa i) gchoose (i - (card X - 2)) +\n       (int (bb i) gchoose (i - (card X - 2)))))\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  int (aa (Suc (card X - 2)) + bb (Suc (card X - 2))) =\n  2 +\n  2 * (- 1) ^ (card X - (card X - 2)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 2))) +\n  (\\<Sum>i = card X - 2 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 2)) *\n      (int (aa i) gchoose (i - (card X - 2)) +\n       (int (bb i) gchoose (i - (card X - 2)))))\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "have \"\\<dots> = int (2 * d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    2 * (- 1) ^ (card X - (card X - 2)) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 2))) +\n    (\\<Sum>i = card X - 2 + 2..card X - 1.\n        (- 1) ^ (i - (card X - 2)) *\n        (int (aa i) gchoose (i - (card X - 2)) +\n         (int (bb i) gchoose (i - (card X - 2))))) =\n    int (2 * poly_deg f)", "by (simp add: 1 2 3 4)"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - (card X - 2)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 2))) +\n  (\\<Sum>i = card X - 2 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 2)) *\n      (int (aa i) gchoose (i - (card X - 2)) +\n       (int (bb i) gchoose (i - (card X - 2))))) =\n  int (2 * poly_deg f)\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "finally"], ["proof (chain)\npicking this:\n  int (aa (card X - 1) + bb (card X - 1)) = int (2 * poly_deg f)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (aa (card X - 1) + bb (card X - 1)) = int (2 * poly_deg f)\n\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "by (simp only: int_int_eq)"], ["proof (state)\nthis:\n  aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Since the case @{prop \"n = 2\"} is settled, we can concentrate on @{prop \"2 < n\"} now.\\<close>"], ["", "context\n  assumes n_gr_2: \"2 < n\"\nbegin"], ["", "lemma cc_n_minus_2: \"cc (n - 2) \\<le> d\\<^sup>2 + 2 * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "let ?j = \"n - 3\""], ["proof (state)\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "from n_gr_2"], ["proof (chain)\npicking this:\n  2 < card X", "have 1: \"Suc ?j = n - 2\" and \"?j < n - 1\" and 2: \"Suc (n - 2) = n - Suc 0\"\n    and 3: \"n - (n - 2) = 2\" and 4: \"n - ?j = 3\""], ["proof (prove)\nusing this:\n  2 < card X\n\ngoal (1 subgoal):\n 1. (Suc (card X - 3) = card X - 2 &&& card X - 3 < card X - 1) &&&\n    Suc (card X - 2) = card X - Suc 0 &&&\n    card X - (card X - 2) = 2 &&& card X - (card X - 3) = 3", "by simp_all"], ["proof (state)\nthis:\n  Suc (card X - 3) = card X - 2\n  card X - 3 < card X - 1\n  Suc (card X - 2) = card X - Suc 0\n  card X - (card X - 2) = 2\n  card X - (card X - 3) = 3\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"int (cc (n - 2)) = int (cc (Suc ?j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 2) + bb (card X - 2)) =\n    int (aa (Suc (card X - 3)) + bb (Suc (card X - 3)))", "by (simp only: 1)"], ["proof (state)\nthis:\n  int (aa (card X - 2) + bb (card X - 2)) =\n  int (aa (Suc (card X - 3)) + bb (Suc (card X - 3)))\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  int (aa (card X - 2) + bb (card X - 2)) =\n  int (aa (Suc (card X - 3)) + bb (Suc (card X - 3)))\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "from \\<open>?j < n - 1\\<close>"], ["proof (chain)\npicking this:\n  card X - 3 < card X - 1", "have \"\\<dots> = 2 + 2 * (- 1) ^ (n - ?j) * (int d - 1 gchoose (n - Suc ?j)) +\n         (\\<Sum>i = ?j+2..n-1. (- 1) ^ (i - ?j) * (int (aa i) gchoose (i - ?j) + (int (bb i) gchoose (i - ?j))))\""], ["proof (prove)\nusing this:\n  card X - 3 < card X - 1\n\ngoal (1 subgoal):\n 1. int (aa (Suc (card X - 3)) + bb (Suc (card X - 3))) =\n    2 +\n    2 * (- 1) ^ (card X - (card X - 3)) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 3))) +\n    (\\<Sum>i = card X - 3 + 2..card X - 1.\n        (- 1) ^ (i - (card X - 3)) *\n        (int (aa i) gchoose (i - (card X - 3)) +\n         (int (bb i) gchoose (i - (card X - 3)))))", "by (rule cc_Suc)"], ["proof (state)\nthis:\n  int (aa (Suc (card X - 3)) + bb (Suc (card X - 3))) =\n  2 +\n  2 * (- 1) ^ (card X - (card X - 3)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 3))) +\n  (\\<Sum>i = card X - 3 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 3)) *\n      (int (aa i) gchoose (i - (card X - 3)) +\n       (int (bb i) gchoose (i - (card X - 3)))))\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  int (aa (Suc (card X - 3)) + bb (Suc (card X - 3))) =\n  2 +\n  2 * (- 1) ^ (card X - (card X - 3)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 3))) +\n  (\\<Sum>i = card X - 3 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 3)) *\n      (int (aa i) gchoose (i - (card X - 3)) +\n       (int (bb i) gchoose (i - (card X - 3)))))\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"\\<dots> = (2 - 2 * (int d - 1 gchoose 2)) + ((int (aa (n - 1)) gchoose 2) + (int (bb (n - 1)) gchoose 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    2 * (- 1) ^ (card X - (card X - 3)) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 3))) +\n    (\\<Sum>i = card X - 3 + 2..card X - 1.\n        (- 1) ^ (i - (card X - 3)) *\n        (int (aa i) gchoose (i - (card X - 3)) +\n         (int (bb i) gchoose (i - (card X - 3))))) =\n    2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n    (int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2))", "by (simp add: 1 2 3 4)"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - (card X - 3)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 3))) +\n  (\\<Sum>i = card X - 3 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 3)) *\n      (int (aa i) gchoose (i - (card X - 3)) +\n       (int (bb i) gchoose (i - (card X - 3))))) =\n  2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2))\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - (card X - 3)) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc (card X - 3))) +\n  (\\<Sum>i = card X - 3 + 2..card X - 1.\n      (- 1) ^ (i - (card X - 3)) *\n      (int (aa i) gchoose (i - (card X - 3)) +\n       (int (bb i) gchoose (i - (card X - 3))))) =\n  2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2))\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"\\<dots> \\<le> (2 - 2 * (int d - 1 gchoose 2)) + (2 * int d gchoose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n    (int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2))\n    \\<le> 2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n          (2 * int (poly_deg f) gchoose 2)", "proof (rule add_left_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "have \"int (aa (n - 1)) gchoose 2 + (int (bb (n - 1)) gchoose 2) \\<le> int (aa (n - 1)) + int (bb (n - 1)) gchoose 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> int (aa (card X - 1)) + int (bb (card X - 1)) gchoose 2", "by (rule gbinomial_int_plus_le) simp_all"], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n  \\<le> int (aa (card X - 1)) + int (bb (card X - 1)) gchoose 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "also"], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n  \\<le> int (aa (card X - 1)) + int (bb (card X - 1)) gchoose 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "have \"\\<dots> = int (2 * d) gchoose 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) + int (bb (card X - 1)) gchoose 2 =\n    int (2 * poly_deg f) gchoose 2", "by (simp flip: cc_n_minus_1)"], ["proof (state)\nthis:\n  int (aa (card X - 1)) + int (bb (card X - 1)) gchoose 2 =\n  int (2 * poly_deg f) gchoose 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "also"], ["proof (state)\nthis:\n  int (aa (card X - 1)) + int (bb (card X - 1)) gchoose 2 =\n  int (2 * poly_deg f) gchoose 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "have \"\\<dots> = 2 * int d gchoose 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (2 * poly_deg f) gchoose 2 = 2 * int (poly_deg f) gchoose 2", "by (simp add: int_ops(7))"], ["proof (state)\nthis:\n  int (2 * poly_deg f) gchoose 2 = 2 * int (poly_deg f) gchoose 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "finally"], ["proof (chain)\npicking this:\n  int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n  \\<le> 2 * int (poly_deg f) gchoose 2", "show \"int (aa (n - 1)) gchoose 2 + (int (bb (n - 1)) gchoose 2) \\<le> 2 * int d gchoose 2\""], ["proof (prove)\nusing this:\n  int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n  \\<le> 2 * int (poly_deg f) gchoose 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n    \\<le> 2 * int (poly_deg f) gchoose 2", "."], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2)\n  \\<le> 2 * int (poly_deg f) gchoose 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2))\n  \\<le> 2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n        (2 * int (poly_deg f) gchoose 2)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (int (aa (card X - 1)) gchoose 2 + (int (bb (card X - 1)) gchoose 2))\n  \\<le> 2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n        (2 * int (poly_deg f) gchoose 2)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"\\<dots> = 2 - fact 2 * (int d - 1 gchoose 2) + (2 * int d gchoose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n    (2 * int (poly_deg f) gchoose 2) =\n    2 - fact 2 * (int (poly_deg f) - 1 gchoose 2) +\n    (2 * int (poly_deg f) gchoose 2)", "by (simp only: fact_2)"], ["proof (state)\nthis:\n  2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (2 * int (poly_deg f) gchoose 2) =\n  2 - fact 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (2 * int (poly_deg f) gchoose 2)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  2 - 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (2 * int (poly_deg f) gchoose 2) =\n  2 - fact 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (2 * int (poly_deg f) gchoose 2)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"\\<dots> = 2 - (int d - 1) * (int d - 2) + (2 * int d gchoose 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - fact 2 * (int (poly_deg f) - 1 gchoose 2) +\n    (2 * int (poly_deg f) gchoose 2) =\n    2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n    (2 * int (poly_deg f) gchoose 2)", "by (simp only: gbinomial_int_mult_fact) (simp add: numeral_2_eq_2 prod.atLeast0_lessThan_Suc)"], ["proof (state)\nthis:\n  2 - fact 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (2 * int (poly_deg f) gchoose 2) =\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  (2 * int (poly_deg f) gchoose 2)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  2 - fact 2 * (int (poly_deg f) - 1 gchoose 2) +\n  (2 * int (poly_deg f) gchoose 2) =\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  (2 * int (poly_deg f) gchoose 2)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"\\<dots> = 2 - (int d - 1) * (int d - 2) + int d * (2 * int d - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n    (2 * int (poly_deg f) gchoose 2) =\n    2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n    int (poly_deg f) * (2 * int (poly_deg f) - 1)", "by (simp add: gbinomial_prod_rev numeral_2_eq_2 prod.atLeast0_lessThan_Suc)"], ["proof (state)\nthis:\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  (2 * int (poly_deg f) gchoose 2) =\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  int (poly_deg f) * (2 * int (poly_deg f) - 1)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "also"], ["proof (state)\nthis:\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  (2 * int (poly_deg f) gchoose 2) =\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  int (poly_deg f) * (2 * int (poly_deg f) - 1)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "have \"\\<dots> = int (d\\<^sup>2 + 2 * d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n    int (poly_deg f) * (2 * int (poly_deg f) - 1) =\n    int ((poly_deg f)\\<^sup>2 + 2 * poly_deg f)", "by (simp add: power2_eq_square) (simp only: algebra_simps)"], ["proof (state)\nthis:\n  2 - (int (poly_deg f) - 1) * (int (poly_deg f) - 2) +\n  int (poly_deg f) * (2 * int (poly_deg f) - 1) =\n  int ((poly_deg f)\\<^sup>2 + 2 * poly_deg f)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "finally"], ["proof (chain)\npicking this:\n  int (aa (card X - 2) + bb (card X - 2))\n  \\<le> int ((poly_deg f)\\<^sup>2 + 2 * poly_deg f)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (aa (card X - 2) + bb (card X - 2))\n  \\<le> int ((poly_deg f)\\<^sup>2 + 2 * poly_deg f)\n\ngoal (1 subgoal):\n 1. aa (card X - 2) + bb (card X - 2)\n    \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "by (simp only: int_int_eq)"], ["proof (state)\nthis:\n  aa (card X - 2) + bb (card X - 2)\n  \\<le> (poly_deg f)\\<^sup>2 + 2 * poly_deg f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cc_Suc_le:\n  assumes \"j < n - 3\"\n  shows \"int (cc (Suc j)) \\<le> 2 + (int (cc (j + 2)) gchoose 2) + (\\<Sum>i=j+4..n-1. int (cc i) gchoose (i - j))\"\n            \\<comment>\\<open>Could be proved without coercing to @{typ int}, because everything is non-negative.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "let ?f = \"\\<lambda>i j. (int (aa i) gchoose (i - j)) + (int (bb i) gchoose (i - j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "let ?S = \"\\<lambda>x y. (\\<Sum>i=j+x..n-y. (- 1)^(i - j) * ?f i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "let ?S3 = \"\\<lambda>x y. (\\<Sum>i=j+x..n-y. (int (cc i) gchoose (i - j)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have ie1: \"int (aa i) gchoose k + (int (bb i) gchoose k) \\<le> int (cc i) gchoose k\" if \"0 < k\" for i k"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i + bb i) gchoose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i + bb i) gchoose k", "from that"], ["proof (chain)\npicking this:\n  0 < k", "have \"int (aa i) gchoose k + (int (bb i) gchoose k) \\<le> int (aa i) + int (bb i) gchoose k\""], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i) + int (bb i) gchoose k", "by (rule gbinomial_int_plus_le) simp_all"], ["proof (state)\nthis:\n  int (aa i) gchoose k + (int (bb i) gchoose k)\n  \\<le> int (aa i) + int (bb i) gchoose k\n\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i + bb i) gchoose k", "also"], ["proof (state)\nthis:\n  int (aa i) gchoose k + (int (bb i) gchoose k)\n  \\<le> int (aa i) + int (bb i) gchoose k\n\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i + bb i) gchoose k", "have \"\\<dots> = int (cc i) gchoose k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa i) + int (bb i) gchoose k = int (aa i + bb i) gchoose k", "by simp"], ["proof (state)\nthis:\n  int (aa i) + int (bb i) gchoose k = int (aa i + bb i) gchoose k\n\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i + bb i) gchoose k", "finally"], ["proof (chain)\npicking this:\n  int (aa i) gchoose k + (int (bb i) gchoose k)\n  \\<le> int (aa i + bb i) gchoose k", "show ?thesis"], ["proof (prove)\nusing this:\n  int (aa i) gchoose k + (int (bb i) gchoose k)\n  \\<le> int (aa i + bb i) gchoose k\n\ngoal (1 subgoal):\n 1. int (aa i) gchoose k + (int (bb i) gchoose k)\n    \\<le> int (aa i + bb i) gchoose k", "."], ["proof (state)\nthis:\n  int (aa i) gchoose k + (int (bb i) gchoose k)\n  \\<le> int (aa i + bb i) gchoose k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?k47 \\<Longrightarrow>\n  int (aa ?i47) gchoose ?k47 + (int (bb ?i47) gchoose ?k47)\n  \\<le> int (aa ?i47 + bb ?i47) gchoose ?k47\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from d_gr_0"], ["proof (chain)\npicking this:\n  0 < poly_deg f", "have \"0 \\<le> int d - 1\""], ["proof (prove)\nusing this:\n  0 < poly_deg f\n\ngoal (1 subgoal):\n 1. 0 \\<le> int (poly_deg f) - 1", "by simp"], ["proof (state)\nthis:\n  0 \\<le> int (poly_deg f) - 1\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from assms"], ["proof (chain)\npicking this:\n  j < card X - 3", "have \"0 < n - Suc j\""], ["proof (prove)\nusing this:\n  j < card X - 3\n\ngoal (1 subgoal):\n 1. 0 < card X - Suc j", "by simp"], ["proof (state)\nthis:\n  0 < card X - Suc j\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have f_nonneg: \"0 \\<le> ?f i j\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))", "by (simp add: gbinomial_int_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> int (aa ?i47) gchoose (?i47 - j) +\n          (int (bb ?i47) gchoose (?i47 - j))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "proof (cases \"n = j + 4\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "case True"], ["proof (state)\nthis:\n  card X = j + 4\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "hence j: \"j = n - 4\""], ["proof (prove)\nusing this:\n  card X = j + 4\n\ngoal (1 subgoal):\n 1. j = card X - 4", "by simp"], ["proof (state)\nthis:\n  j = card X - 4\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have 1: \"n - Suc j = 3\" and \"j < n - 1\" and 2: \"Suc (n - 3) = Suc (Suc j)\" and 3: \"n - (n - 3) = 3\"\n      and 4: \"n - j = 4\" and 5: \"n - Suc 0 = Suc (Suc (Suc j))\" and 6: \"n - 2 = Suc (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card X - Suc j = 3 &&&\n     j < card X - 1 &&& Suc (card X - 3) = Suc (Suc j)) &&&\n    (card X - (card X - 3) = 3 &&& card X - j = 4) &&&\n    card X - Suc 0 = Suc (Suc (Suc j)) &&& card X - 2 = Suc (Suc j)", "by (simp_all add: True)"], ["proof (state)\nthis:\n  card X - Suc j = 3\n  j < card X - 1\n  Suc (card X - 3) = Suc (Suc j)\n  card X - (card X - 3) = 3\n  card X - j = 4\n  card X - Suc 0 = Suc (Suc (Suc j))\n  card X - 2 = Suc (Suc j)\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from \\<open>j < n - 1\\<close>"], ["proof (chain)\npicking this:\n  j < card X - 1", "have \"int (cc (Suc j)) = 2 + 2 * (- 1) ^ (n - j) * (int d - 1 gchoose (n - Suc j)) +\n           (\\<Sum>i = j+2..n-1. (- 1) ^ (i - j) * (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\""], ["proof (prove)\nusing this:\n  j < card X - 1\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (rule cc_Suc)"], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j)) =\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j)) =\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = (2 + ((int (aa (n - 2)) gchoose 2) + (int (bb (n - 2)) gchoose 2))) +\n                    (2 * (int d - 1 gchoose 3) - ((int (aa (n - 1)) gchoose 3) + (int (bb (n - 1)) gchoose 3)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    2 +\n    (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n    (2 * (int (poly_deg f) - 1 gchoose 3) -\n     (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)))", "by (simp add: 1 2 3 4 5 6)"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  2 +\n  (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n  (2 * (int (poly_deg f) - 1 gchoose 3) -\n   (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  2 +\n  (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n  (2 * (int (poly_deg f) - 1 gchoose 3) -\n   (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> \\<le> (2 + ((int (aa (n - 2)) gchoose 2) + (int (bb (n - 2)) gchoose 2))) + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n    (2 * (int (poly_deg f) - 1 gchoose 3) -\n     (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)))\n    \\<le> 2 +\n          (int (aa (card X - 2)) gchoose 2 +\n           (int (bb (card X - 2)) gchoose 2)) +\n          0", "proof (rule add_left_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "from cc_n_minus_1"], ["proof (chain)\npicking this:\n  aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "have eq1: \"int (aa (n - 1)) + int (bb (n - 1)) = 2 * int d\""], ["proof (prove)\nusing this:\n  aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) + int (bb (card X - 1)) = 2 * int (poly_deg f)", "by simp"], ["proof (state)\nthis:\n  int (aa (card X - 1)) + int (bb (card X - 1)) = 2 * int (poly_deg f)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "hence ie2: \"int (aa (n - 1)) \\<le> 2 * int d\""], ["proof (prove)\nusing this:\n  int (aa (card X - 1)) + int (bb (card X - 1)) = 2 * int (poly_deg f)\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) \\<le> 2 * int (poly_deg f)", "by simp"], ["proof (state)\nthis:\n  int (aa (card X - 1)) \\<le> 2 * int (poly_deg f)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "from \\<open>0 \\<le> int d - 1\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> int (poly_deg f) - 1", "have \"int d - 1 gchoose 3 \\<le> int d gchoose 3\""], ["proof (prove)\nusing this:\n  0 \\<le> int (poly_deg f) - 1\n\ngoal (1 subgoal):\n 1. int (poly_deg f) - 1 gchoose 3 \\<le> int (poly_deg f) gchoose 3", "by (rule gbinomial_int_mono) simp"], ["proof (state)\nthis:\n  int (poly_deg f) - 1 gchoose 3 \\<le> int (poly_deg f) gchoose 3\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "hence \"2 * (int d - 1 gchoose 3) \\<le> 2 * (int d gchoose 3)\""], ["proof (prove)\nusing this:\n  int (poly_deg f) - 1 gchoose 3 \\<le> int (poly_deg f) gchoose 3\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3)\n    \\<le> 2 * (int (poly_deg f) gchoose 3)", "by simp"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose 3)\n  \\<le> 2 * (int (poly_deg f) gchoose 3)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "also"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose 3)\n  \\<le> 2 * (int (poly_deg f) gchoose 3)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "from _ ie2"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  int (aa (card X - 1)) \\<le> 2 * int (poly_deg f)", "have \"\\<dots> \\<le> int (aa (n - 1)) gchoose 3 + (2 * int d - int (aa (n - 1)) gchoose 3)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  int (aa (card X - 1)) \\<le> 2 * int (poly_deg f)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) gchoose 3)\n    \\<le> int (aa (card X - 1)) gchoose 3 +\n          (2 * int (poly_deg f) - int (aa (card X - 1)) gchoose 3)", "by (rule binomial_int_ineq_3) simp"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) gchoose 3)\n  \\<le> int (aa (card X - 1)) gchoose 3 +\n        (2 * int (poly_deg f) - int (aa (card X - 1)) gchoose 3)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "also"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) gchoose 3)\n  \\<le> int (aa (card X - 1)) gchoose 3 +\n        (2 * int (poly_deg f) - int (aa (card X - 1)) gchoose 3)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "have \"\\<dots> = int (aa (n - 1)) gchoose 3 + (int (bb (n - 1)) gchoose 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose 3 +\n    (2 * int (poly_deg f) - int (aa (card X - 1)) gchoose 3) =\n    int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)", "by (simp flip: eq1)"], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose 3 +\n  (2 * int (poly_deg f) - int (aa (card X - 1)) gchoose 3) =\n  int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "finally"], ["proof (chain)\npicking this:\n  2 * (int (poly_deg f) - 1 gchoose 3)\n  \\<le> int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)", "show \"2 * (int d - 1 gchoose 3) - (int (aa (n - 1)) gchoose 3 + (int (bb (n - 1)) gchoose 3)) \\<le> 0\""], ["proof (prove)\nusing this:\n  2 * (int (poly_deg f) - 1 gchoose 3)\n  \\<le> int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)\n\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose 3) -\n    (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n    \\<le> 0", "by simp"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose 3) -\n  (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3))\n  \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 +\n  (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n  (2 * (int (poly_deg f) - 1 gchoose 3) -\n   (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)))\n  \\<le> 2 +\n        (int (aa (card X - 2)) gchoose 2 +\n         (int (bb (card X - 2)) gchoose 2)) +\n        0\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 +\n  (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n  (2 * (int (poly_deg f) - 1 gchoose 3) -\n   (int (aa (card X - 1)) gchoose 3 + (int (bb (card X - 1)) gchoose 3)))\n  \\<le> 2 +\n        (int (aa (card X - 2)) gchoose 2 +\n         (int (bb (card X - 2)) gchoose 2)) +\n        0\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = 2 + ((int (aa (n - 2)) gchoose 2) + (int (bb (n - 2)) gchoose 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n    0 =\n    2 +\n    (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2))", "by simp"], ["proof (state)\nthis:\n  2 +\n  (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n  0 =\n  2 + (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 +\n  (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2)) +\n  0 =\n  2 + (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from ie1"], ["proof (chain)\npicking this:\n  0 < ?k47 \\<Longrightarrow>\n  int (aa ?i47) gchoose ?k47 + (int (bb ?i47) gchoose ?k47)\n  \\<le> int (aa ?i47 + bb ?i47) gchoose ?k47", "have \"\\<dots> \\<le> 2 + (int (cc (n - 2)) gchoose 2)\""], ["proof (prove)\nusing this:\n  0 < ?k47 \\<Longrightarrow>\n  int (aa ?i47) gchoose ?k47 + (int (bb ?i47) gchoose ?k47)\n  \\<le> int (aa ?i47 + bb ?i47) gchoose ?k47\n\ngoal (1 subgoal):\n 1. 2 +\n    (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2))\n    \\<le> 2 + (int (aa (card X - 2) + bb (card X - 2)) gchoose 2)", "by (rule add_left_mono) simp"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2))\n  \\<le> 2 + (int (aa (card X - 2) + bb (card X - 2)) gchoose 2)\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 2)) gchoose 2 + (int (bb (card X - 2)) gchoose 2))\n  \\<le> 2 + (int (aa (card X - 2) + bb (card X - 2)) gchoose 2)\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = 2 + (int (cc (j + 2)) gchoose 2) + ?S3 4 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + (int (aa (card X - 2) + bb (card X - 2)) gchoose 2) =\n    2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n    (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "by (simp add: True)"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 2) + bb (card X - 2)) gchoose 2) =\n  2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n  (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal (2 subgoals):\n 1. card X = j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n 2. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "finally"], ["proof (chain)\npicking this:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "show ?thesis"], ["proof (prove)\nusing this:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "."], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "case False"], ["proof (state)\nthis:\n  card X \\<noteq> j + 4\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "with assms"], ["proof (chain)\npicking this:\n  j < card X - 3\n  card X \\<noteq> j + 4", "have \"j + 4 \\<le> n - 1\""], ["proof (prove)\nusing this:\n  j < card X - 3\n  card X \\<noteq> j + 4\n\ngoal (1 subgoal):\n 1. j + 4 \\<le> card X - 1", "by simp"], ["proof (state)\nthis:\n  j + 4 \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from n_gr_1"], ["proof (chain)\npicking this:\n  1 < card X", "have \"0 < n - 1\""], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. 0 < card X - 1", "by simp"], ["proof (state)\nthis:\n  0 < card X - 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from assms"], ["proof (chain)\npicking this:\n  j < card X - 3", "have \"j + 2 \\<le> n - 1\" and \"j + 2 \\<le> n - 2\""], ["proof (prove)\nusing this:\n  j < card X - 3\n\ngoal (1 subgoal):\n 1. j + 2 \\<le> card X - 1 &&& j + 2 \\<le> card X - 2", "by simp_all"], ["proof (state)\nthis:\n  j + 2 \\<le> card X - 1\n  j + 2 \\<le> card X - 2\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "hence \"n - j = Suc (n - Suc j)\""], ["proof (prove)\nusing this:\n  j + 2 \\<le> card X - 1\n  j + 2 \\<le> card X - 2\n\ngoal (1 subgoal):\n 1. card X - j = Suc (card X - Suc j)", "by simp"], ["proof (state)\nthis:\n  card X - j = Suc (card X - Suc j)\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "hence 1: \"(- 1) ^ (n - Suc j) = - ((- (1::int)) ^ (n - j))\""], ["proof (prove)\nusing this:\n  card X - j = Suc (card X - Suc j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - Suc j) = - ((- 1) ^ (card X - j))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (card X - Suc j) = - ((- 1) ^ (card X - j))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from assms"], ["proof (chain)\npicking this:\n  j < card X - 3", "have \"j < n - 1\""], ["proof (prove)\nusing this:\n  j < card X - 3\n\ngoal (1 subgoal):\n 1. j < card X - 1", "by simp"], ["proof (state)\nthis:\n  j < card X - 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "hence \"int (cc (Suc j)) = 2 + 2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) + ?S 2 1\""], ["proof (prove)\nusing this:\n  j < card X - 1\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j)) =\n    2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (rule cc_Suc)"], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j)) =\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j)) =\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = 2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - Suc j) * ((int (aa (n - 1)) gchoose (n - Suc j)) + (int (bb (n - 1)) gchoose (n - Suc j))) +\n                    (2 + ?S 2 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n    (2 +\n     (\\<Sum>i = j + 2..card X - 2.\n         (- 1) ^ (i - j) *\n         (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))", "using \\<open>0 < n - 1\\<close> \\<open>j + 2 \\<le> n - 1\\<close>"], ["proof (prove)\nusing this:\n  0 < card X - 1\n  j + 2 \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. 2 +\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (\\<Sum>i = j + 2..card X - 1.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n    (2 +\n     (\\<Sum>i = j + 2..card X - 2.\n         (- 1) ^ (i - j) *\n         (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))", "by (simp only: sum_tail_nat) (simp flip: numeral_2_eq_2)"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n  (2 +\n   (\\<Sum>i = j + 2..card X - 2.\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 +\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (\\<Sum>i = j + 2..card X - 1.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n  (2 +\n   (\\<Sum>i = j + 2..card X - 2.\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> \\<le> (int (cc (n - 1)) gchoose (n - Suc j)) + (2 + ?S 2 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n    (2 +\n     (\\<Sum>i = j + 2..card X - 2.\n         (- 1) ^ (i - j) *\n         (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n          (2 +\n           (\\<Sum>i = j + 2..card X - 2.\n               (- 1) ^ (i - j) *\n               (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))", "proof (rule add_right_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have rl: \"x - y \\<le> x\" if \"0 \\<le> y\" for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y \\<le> x", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. x - y \\<le> x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> ?y47 \\<Longrightarrow> ?x47 - ?y47 \\<le> ?x47\n\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - Suc j) * ((int (aa (n - 1)) gchoose (n - Suc j)) + (int (bb (n - 1)) gchoose (n - Suc j))) =\n              (-1)^(n - j) * (2 * ((int d - 1) gchoose (n - Suc j)) -\n                    (int (aa (n - 1)) gchoose (n - Suc j)) - (int (bb (n - 1)) gchoose (n - Suc j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))", "by (simp only: 1 algebra_simps)"], ["proof (state)\nthis:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> \\<le> (int (cc (n - 1))) gchoose (n - Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "proof (cases \"even (n - j)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "case True"], ["proof (state)\nthis:\n  even (card X - j)\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "hence \"(- 1) ^ (n - j) * (2 * (int d - 1 gchoose (n - Suc j)) - (int (aa (n - 1)) gchoose (n - Suc j)) -\n                (int (bb (n - 1)) gchoose (n - Suc j))) =\n              2 * (int d - 1 gchoose (n - Suc j)) - ((int (aa (n - 1)) gchoose (n - Suc j)) +\n                                                     (int (bb (n - 1)) gchoose (n - Suc j)))\""], ["proof (prove)\nusing this:\n  even (card X - j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n    2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> \\<le> 2 * (int d - 1 gchoose (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> 2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))", "by (rule rl) (simp add: gbinomial_int_nonneg)"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> 2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> 2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> = (int d - 1 gchoose (n - Suc j)) + (int d - 1 gchoose (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) =\n    int (poly_deg f) - 1 gchoose (card X - Suc j) +\n    (int (poly_deg f) - 1 gchoose (card X - Suc j))", "by simp"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) =\n  int (poly_deg f) - 1 gchoose (card X - Suc j) +\n  (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) =\n  int (poly_deg f) - 1 gchoose (card X - Suc j) +\n  (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> \\<le> (int d - 1) + (int d - 1) gchoose (n - Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (poly_deg f) - 1 gchoose (card X - Suc j) +\n    (int (poly_deg f) - 1 gchoose (card X - Suc j))\n    \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose\n          (card X - Suc j)", "using \\<open>0 < n - Suc j\\<close> \\<open>0 \\<le> int d - 1\\<close> \\<open>0 \\<le> int d - 1\\<close>"], ["proof (prove)\nusing this:\n  0 < card X - Suc j\n  0 \\<le> int (poly_deg f) - 1\n  0 \\<le> int (poly_deg f) - 1\n\ngoal (1 subgoal):\n 1. int (poly_deg f) - 1 gchoose (card X - Suc j) +\n    (int (poly_deg f) - 1 gchoose (card X - Suc j))\n    \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose\n          (card X - Suc j)", "by (rule gbinomial_int_plus_le)"], ["proof (state)\nthis:\n  int (poly_deg f) - 1 gchoose (card X - Suc j) +\n  (int (poly_deg f) - 1 gchoose (card X - Suc j))\n  \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose\n        (card X - Suc j)\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  int (poly_deg f) - 1 gchoose (card X - Suc j) +\n  (int (poly_deg f) - 1 gchoose (card X - Suc j))\n  \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose\n        (card X - Suc j)\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> \\<le> 2 * int d gchoose (n - Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose (card X - Suc j)\n    \\<le> 2 * int (poly_deg f) gchoose (card X - Suc j)", "proof (rule gbinomial_int_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1)\n 2. int (poly_deg f) - 1 + (int (poly_deg f) - 1) \\<le> 2 * int (poly_deg f)", "from \\<open>0 \\<le> int d - 1\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> int (poly_deg f) - 1", "show \"0 \\<le> int d - 1 + (int d - 1)\""], ["proof (prove)\nusing this:\n  0 \\<le> int (poly_deg f) - 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> int (poly_deg f) - 1 + (int (poly_deg f) - 1)\n\ngoal (1 subgoal):\n 1. int (poly_deg f) - 1 + (int (poly_deg f) - 1) \\<le> 2 * int (poly_deg f)", "qed simp"], ["proof (state)\nthis:\n  int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose (card X - Suc j)\n  \\<le> 2 * int (poly_deg f) gchoose (card X - Suc j)\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  int (poly_deg f) - 1 + (int (poly_deg f) - 1) gchoose (card X - Suc j)\n  \\<le> 2 * int (poly_deg f) gchoose (card X - Suc j)\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> = int (cc (n - 1)) gchoose (n - Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * int (poly_deg f) gchoose (card X - Suc j) =\n    int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "by (simp only: cc_n_minus_1) simp"], ["proof (state)\nthis:\n  2 * int (poly_deg f) gchoose (card X - Suc j) =\n  int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (2 subgoals):\n 1. even (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n 2. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "."], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "case False"], ["proof (state)\nthis:\n  odd (card X - j)\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "hence \"(- 1) ^ (n - j) * (2 * (int d - 1 gchoose (n - Suc j)) - (int (aa (n - 1)) gchoose (n - Suc j)) -\n                (int (bb (n - 1)) gchoose (n - Suc j))) =\n              ((int (aa (n - 1)) gchoose (n - Suc j)) + (int (bb (n - 1)) gchoose (n - Suc j))) -\n                2 * (int d - 1 gchoose (n - Suc j))\""], ["proof (prove)\nusing this:\n  odd (card X - j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n    int (aa (card X - 1)) gchoose (card X - Suc j) +\n    (int (bb (card X - 1)) gchoose (card X - Suc j)) -\n    2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n  int (aa (card X - 1)) gchoose (card X - Suc j) +\n  (int (bb (card X - 1)) gchoose (card X - Suc j)) -\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) =\n  int (aa (card X - 1)) gchoose (card X - Suc j) +\n  (int (bb (card X - 1)) gchoose (card X - Suc j)) -\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "have \"\\<dots> \\<le> (int (aa (n - 1)) gchoose (n - Suc j)) + (int (bb (n - 1)) gchoose (n - Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose (card X - Suc j) +\n    (int (bb (card X - 1)) gchoose (card X - Suc j)) -\n    2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n    \\<le> int (aa (card X - 1)) gchoose (card X - Suc j) +\n          (int (bb (card X - 1)) gchoose (card X - Suc j))", "by (rule rl) (simp add: gbinomial_int_nonneg d_gr_0)"], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose (card X - Suc j) +\n  (int (bb (card X - 1)) gchoose (card X - Suc j)) -\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n  \\<le> int (aa (card X - 1)) gchoose (card X - Suc j) +\n        (int (bb (card X - 1)) gchoose (card X - Suc j))\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "also"], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose (card X - Suc j) +\n  (int (bb (card X - 1)) gchoose (card X - Suc j)) -\n  2 * (int (poly_deg f) - 1 gchoose (card X - Suc j))\n  \\<le> int (aa (card X - 1)) gchoose (card X - Suc j) +\n        (int (bb (card X - 1)) gchoose (card X - Suc j))\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "from \\<open>0 < n - Suc j\\<close>"], ["proof (chain)\npicking this:\n  0 < card X - Suc j", "have \"\\<dots> \\<le> int (cc (n - 1)) gchoose (n - Suc j)\""], ["proof (prove)\nusing this:\n  0 < card X - Suc j\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1)) gchoose (card X - Suc j) +\n    (int (bb (card X - 1)) gchoose (card X - Suc j))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "by (rule ie1)"], ["proof (state)\nthis:\n  int (aa (card X - 1)) gchoose (card X - Suc j) +\n  (int (bb (card X - 1)) gchoose (card X - Suc j))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (1 subgoal):\n 1. odd (card X - j) \\<Longrightarrow>\n    (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (card X - j) *\n    (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n     (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "."], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (- 1) ^ (card X - j) *\n  (2 * (int (poly_deg f) - 1 gchoose (card X - Suc j)) -\n   (int (aa (card X - 1)) gchoose (card X - Suc j)) -\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "finally"], ["proof (chain)\npicking this:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "show \"2 * (- 1)^(n - j) * ((int d - 1) gchoose (n - Suc j)) +\n                    (- 1)^(n - Suc j) * ((int (aa (n - 1)) gchoose (n - Suc j)) + (int (bb (n - 1)) gchoose (n - Suc j))) \\<le>\n                    (int (cc (n - 1))) gchoose (n - Suc j)\""], ["proof (prove)\nusing this:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal (1 subgoal):\n 1. 2 * (- 1) ^ (card X - j) *\n    (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n    (- 1) ^ (card X - Suc j) *\n    (int (aa (card X - 1)) gchoose (card X - Suc j) +\n     (int (bb (card X - 1)) gchoose (card X - Suc j)))\n    \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)", "."], ["proof (state)\nthis:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j)))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n  (2 +\n   (\\<Sum>i = j + 2..card X - 2.\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n        (2 +\n         (\\<Sum>i = j + 2..card X - 2.\n             (- 1) ^ (i - j) *\n             (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 * (- 1) ^ (card X - j) *\n  (int (poly_deg f) - 1 gchoose (card X - Suc j)) +\n  (- 1) ^ (card X - Suc j) *\n  (int (aa (card X - 1)) gchoose (card X - Suc j) +\n   (int (bb (card X - 1)) gchoose (card X - Suc j))) +\n  (2 +\n   (\\<Sum>i = j + 2..card X - 2.\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n  \\<le> int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n        (2 +\n         (\\<Sum>i = j + 2..card X - 2.\n             (- 1) ^ (i - j) *\n             (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = 2 + (int (cc (n - 1)) gchoose ((n - 1) - j)) + ((int (aa (j + 2)) gchoose 2) +\n                    (int (bb (j + 2)) gchoose 2)) + ?S 3 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n    (2 +\n     (\\<Sum>i = j + 2..card X - 2.\n         (- 1) ^ (i - j) *\n         (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))) =\n    2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n    (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n    (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "using \\<open>j + 2 \\<le> n - 2\\<close>"], ["proof (prove)\nusing this:\n  j + 2 \\<le> card X - 2\n\ngoal (1 subgoal):\n 1. int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n    (2 +\n     (\\<Sum>i = j + 2..card X - 2.\n         (- 1) ^ (i - j) *\n         (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))) =\n    2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n    (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n    (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by (simp add: sum.atLeast_Suc_atMost numeral_3_eq_3)"], ["proof (state)\nthis:\n  int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n  (2 +\n   (\\<Sum>i = j + 2..card X - 2.\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))) =\n  2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n  (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - Suc j) +\n  (2 +\n   (\\<Sum>i = j + 2..card X - 2.\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))) =\n  2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n  (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> \\<le> 2 + (int (cc (n - 1)) gchoose ((n - 1) - j)) + ((int (aa (j + 2)) gchoose 2) +\n                    (int (bb (j + 2)) gchoose 2)) + ?S3 4 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n    (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n    (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> 2 +\n          (int (aa (card X - 1) + bb (card X - 1)) gchoose\n           (card X - 1 - j)) +\n          (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n          (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "proof (rule add_left_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "from \\<open>j + 4 \\<le> n - 1\\<close>"], ["proof (chain)\npicking this:\n  j + 4 \\<le> card X - 1", "have \"j + 3 \\<le> n - 2\""], ["proof (prove)\nusing this:\n  j + 4 \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. j + 3 \\<le> card X - 2", "by simp"], ["proof (state)\nthis:\n  j + 3 \\<le> card X - 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "hence \"?S 3 2 = ?S 4 2 - ?f (j + 3) j\""], ["proof (prove)\nusing this:\n  j + 3 \\<le> card X - 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n    (\\<Sum>i = j + 4..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) -\n    (int (aa (j + 3)) gchoose (j + 3 - j) +\n     (int (bb (j + 3)) gchoose (j + 3 - j)))", "by (simp add: sum.atLeast_Suc_atMost add.commute)"], ["proof (state)\nthis:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (\\<Sum>i = j + 4..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) -\n  (int (aa (j + 3)) gchoose (j + 3 - j) +\n   (int (bb (j + 3)) gchoose (j + 3 - j)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "hence \"?S 3 2 \\<le> ?S 4 2\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (\\<Sum>i = j + 4..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) -\n  (int (aa (j + 3)) gchoose (j + 3 - j) +\n   (int (bb (j + 3)) gchoose (j + 3 - j)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2.\n              (- 1) ^ (i - j) *\n              (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "using f_nonneg[of \"j + 3\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) =\n  (\\<Sum>i = j + 4..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))) -\n  (int (aa (j + 3)) gchoose (j + 3 - j) +\n   (int (bb (j + 3)) gchoose (j + 3 - j)))\n  0 \\<le> int (aa (j + 3)) gchoose (j + 3 - j) +\n          (int (bb (j + 3)) gchoose (j + 3 - j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2.\n              (- 1) ^ (i - j) *\n              (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> (\\<Sum>i = j + 4..card X - 2.\n            (- 1) ^ (i - j) *\n            (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> (\\<Sum>i = j + 4..card X - 2.\n            (- 1) ^ (i - j) *\n            (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> \\<le> ?S3 4 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 4..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "proof (rule sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "assume \"i \\<in> {j + 4..n - 2}\""], ["proof (state)\nthis:\n  i \\<in> {j + 4..card X - 2}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "hence \"0 < i - j\""], ["proof (prove)\nusing this:\n  i \\<in> {j + 4..card X - 2}\n\ngoal (1 subgoal):\n 1. 0 < i - j", "by simp"], ["proof (state)\nthis:\n  0 < i - j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "from f_nonneg[of i]"], ["proof (chain)\npicking this:\n  0 \\<le> int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))", "have \"(- 1)^(i - j) * ?f i j \\<le> ?f i j\""], ["proof (prove)\nusing this:\n  0 \\<le> int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. (- 1) ^ (i - j) *\n    (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n    \\<le> int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))", "by (smt minus_one_mult_self mult_cancel_right1 pos_zmult_eq_1_iff_lemma zero_less_mult_iff)"], ["proof (state)\nthis:\n  (- 1) ^ (i - j) *\n  (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n  \\<le> int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "also"], ["proof (state)\nthis:\n  (- 1) ^ (i - j) *\n  (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n  \\<le> int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "from \\<open>0 < i - j\\<close>"], ["proof (chain)\npicking this:\n  0 < i - j", "have \"\\<dots> \\<le> int (cc i) gchoose (i - j)\""], ["proof (prove)\nusing this:\n  0 < i - j\n\ngoal (1 subgoal):\n 1. int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))\n    \\<le> int (aa i + bb i) gchoose (i - j)", "by (rule ie1)"], ["proof (state)\nthis:\n  int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))\n  \\<le> int (aa i + bb i) gchoose (i - j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 4..card X - 2} \\<Longrightarrow>\n       (- 1) ^ (i - j) *\n       (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n       \\<le> int (aa i + bb i) gchoose (i - j)", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ (i - j) *\n  (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n  \\<le> int (aa i + bb i) gchoose (i - j)", "show \"(- 1)^(i - j) * ?f i j \\<le> int (cc i) gchoose (i - j)\""], ["proof (prove)\nusing this:\n  (- 1) ^ (i - j) *\n  (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n  \\<le> int (aa i + bb i) gchoose (i - j)\n\ngoal (1 subgoal):\n 1. (- 1) ^ (i - j) *\n    (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n    \\<le> int (aa i + bb i) gchoose (i - j)", "."], ["proof (state)\nthis:\n  (- 1) ^ (i - j) *\n  (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j)))\n  \\<le> int (aa i + bb i) gchoose (i - j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = j + 4..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "show \"?S 3 2 \\<le> ?S3 4 2\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 2.\n        (- 1) ^ (i - j) *\n        (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n    \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))", "."], ["proof (state)\nthis:\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n  (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> 2 +\n        (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n        (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n        (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n  (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n  (\\<Sum>i = j + 3..card X - 2.\n      (- 1) ^ (i - j) *\n      (int (aa i) gchoose (i - j) + (int (bb i) gchoose (i - j))))\n  \\<le> 2 +\n        (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n        (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n        (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = ((int (aa (j + 2)) gchoose 2) + (int (bb (j + 2)) gchoose 2)) + (2 + ?S3 4 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n    (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n    (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j)) =\n    int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n    (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))", "using \\<open>0 < n - 1\\<close> \\<open>j + 4 \\<le> n - 1\\<close>"], ["proof (prove)\nusing this:\n  0 < card X - 1\n  j + 4 \\<le> card X - 1\n\ngoal (1 subgoal):\n 1. 2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n    (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n    (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j)) =\n    int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n    (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))", "by (simp only: sum_tail_nat) (simp flip: numeral_2_eq_2)"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n  (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n  (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j)) =\n  int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n  (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  2 + (int (aa (card X - 1) + bb (card X - 1)) gchoose (card X - 1 - j)) +\n  (int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2)) +\n  (\\<Sum>i = j + 4..card X - 2. int (aa i + bb i) gchoose (i - j)) =\n  int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n  (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "from ie1"], ["proof (chain)\npicking this:\n  0 < ?k47 \\<Longrightarrow>\n  int (aa ?i47) gchoose ?k47 + (int (bb ?i47) gchoose ?k47)\n  \\<le> int (aa ?i47 + bb ?i47) gchoose ?k47", "have \"\\<dots> \\<le> int (cc (j + 2)) gchoose 2 + (2 + ?S3 4 1)\""], ["proof (prove)\nusing this:\n  0 < ?k47 \\<Longrightarrow>\n  int (aa ?i47) gchoose ?k47 + (int (bb ?i47) gchoose ?k47)\n  \\<le> int (aa ?i47 + bb ?i47) gchoose ?k47\n\ngoal (1 subgoal):\n 1. int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n    (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n    \\<le> int (aa (j + 2) + bb (j + 2)) gchoose 2 +\n          (2 +\n           (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))", "by (rule add_right_mono) simp"], ["proof (state)\nthis:\n  int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n  (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n  \\<le> int (aa (j + 2) + bb (j + 2)) gchoose 2 +\n        (2 +\n         (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "also"], ["proof (state)\nthis:\n  int (aa (j + 2)) gchoose 2 + (int (bb (j + 2)) gchoose 2) +\n  (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n  \\<le> int (aa (j + 2) + bb (j + 2)) gchoose 2 +\n        (2 +\n         (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j)))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "have \"\\<dots> = 2 + (int (cc (j + 2)) gchoose 2) + ?S3 4 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (j + 2) + bb (j + 2)) gchoose 2 +\n    (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))) =\n    2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n    (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  int (aa (j + 2) + bb (j + 2)) gchoose 2 +\n  (2 + (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))) =\n  2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n  (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. card X \\<noteq> j + 4 \\<Longrightarrow>\n    int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "finally"], ["proof (chain)\npicking this:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "show ?thesis"], ["proof (prove)\nusing this:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal (1 subgoal):\n 1. int (aa (Suc j) + bb (Suc j))\n    \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n          (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))", "."], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (aa (Suc j) + bb (Suc j))\n  \\<le> 2 + (int (aa (j + 2) + bb (j + 2)) gchoose 2) +\n        (\\<Sum>i = j + 4..card X - 1. int (aa i + bb i) gchoose (i - j))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cc_le:\n  assumes \"0 < j\" and \"j < n - 2\"\n  shows \"cc j \\<le> 2 + (cc (j + 1) choose 2) + (\\<Sum>i=j+3..n-1. cc i choose (Suc (i - j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "define j0 where \"j0 = j - 1\""], ["proof (state)\nthis:\n  j0 = j - 1\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "with assms"], ["proof (chain)\npicking this:\n  0 < j\n  j < card X - 2\n  j0 = j - 1", "have j: \"j = Suc j0\" and \"j0 < n - 3\""], ["proof (prove)\nusing this:\n  0 < j\n  j < card X - 2\n  j0 = j - 1\n\ngoal (1 subgoal):\n 1. j = Suc j0 &&& j0 < card X - 3", "by simp_all"], ["proof (state)\nthis:\n  j = Suc j0\n  j0 < card X - 3\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "have \"int (cc j) = int (cc (Suc j0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa j + bb j) = int (aa (Suc j0) + bb (Suc j0))", "by (simp only: j)"], ["proof (state)\nthis:\n  int (aa j + bb j) = int (aa (Suc j0) + bb (Suc j0))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "also"], ["proof (state)\nthis:\n  int (aa j + bb j) = int (aa (Suc j0) + bb (Suc j0))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "have \"\\<dots> \\<le> 2 + (int (cc (j0 + 2)) gchoose 2) + (\\<Sum>i=j0+4..n-1. int (cc i) gchoose (i - j0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (aa (Suc j0) + bb (Suc j0))\n    \\<le> 2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n          (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))", "using \\<open>j0 < n - 3\\<close>"], ["proof (prove)\nusing this:\n  j0 < card X - 3\n\ngoal (1 subgoal):\n 1. int (aa (Suc j0) + bb (Suc j0))\n    \\<le> 2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n          (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))", "by (rule cc_Suc_le)"], ["proof (state)\nthis:\n  int (aa (Suc j0) + bb (Suc j0))\n  \\<le> 2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n        (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "also"], ["proof (state)\nthis:\n  int (aa (Suc j0) + bb (Suc j0))\n  \\<le> 2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n        (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "have \"\\<dots> = 2 + (int (cc (j + 1)) gchoose 2) + (\\<Sum>i=j0+4..n-1. int (cc i) gchoose (i - j0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n    (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0)) =\n    2 + (int (aa (j + 1) + bb (j + 1)) gchoose 2) +\n    (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))", "by (simp add: j)"], ["proof (state)\nthis:\n  2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n  (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0)) =\n  2 + (int (aa (j + 1) + bb (j + 1)) gchoose 2) +\n  (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "also"], ["proof (state)\nthis:\n  2 + (int (aa (j0 + 2) + bb (j0 + 2)) gchoose 2) +\n  (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0)) =\n  2 + (int (aa (j + 1) + bb (j + 1)) gchoose 2) +\n  (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "have \"(\\<Sum>i=j0+4..n-1. int (cc i) gchoose (i - j0)) = int (\\<Sum>i=j+3..n-1. cc i choose (Suc (i - j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0)) =\n    int (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "unfolding int_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0)) =\n    (\\<Sum>x = j + 3..card X - 1. int (aa x + bb x choose Suc (x - j)))", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. {j0 + 4..card X - 1} = {j + 3..card X - 1}\n 2. \\<And>x.\n       x \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       int (aa x + bb x) gchoose (x - j0) =\n       int (aa x + bb x choose Suc (x - j))", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. {j0 + 4..card X - 1} = {j + 3..card X - 1}\n 2. \\<And>x.\n       x \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       int (aa x + bb x) gchoose (x - j0) =\n       int (aa x + bb x choose Suc (x - j))", "assume \"i \\<in> {j + 3..n - 1}\""], ["proof (state)\nthis:\n  i \\<in> {j + 3..card X - 1}\n\ngoal (2 subgoals):\n 1. {j0 + 4..card X - 1} = {j + 3..card X - 1}\n 2. \\<And>x.\n       x \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       int (aa x + bb x) gchoose (x - j0) =\n       int (aa x + bb x choose Suc (x - j))", "hence \"Suc j0 < i\""], ["proof (prove)\nusing this:\n  i \\<in> {j + 3..card X - 1}\n\ngoal (1 subgoal):\n 1. Suc j0 < i", "by (simp add: j)"], ["proof (state)\nthis:\n  Suc j0 < i\n\ngoal (2 subgoals):\n 1. {j0 + 4..card X - 1} = {j + 3..card X - 1}\n 2. \\<And>x.\n       x \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       int (aa x + bb x) gchoose (x - j0) =\n       int (aa x + bb x choose Suc (x - j))", "hence \"i - j0 = Suc (i - j)\""], ["proof (prove)\nusing this:\n  Suc j0 < i\n\ngoal (1 subgoal):\n 1. i - j0 = Suc (i - j)", "by (simp add: j)"], ["proof (state)\nthis:\n  i - j0 = Suc (i - j)\n\ngoal (2 subgoals):\n 1. {j0 + 4..card X - 1} = {j + 3..card X - 1}\n 2. \\<And>x.\n       x \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       int (aa x + bb x) gchoose (x - j0) =\n       int (aa x + bb x choose Suc (x - j))", "thus \"int (cc i) gchoose (i - j0) = int (cc i choose (Suc (i - j)))\""], ["proof (prove)\nusing this:\n  i - j0 = Suc (i - j)\n\ngoal (1 subgoal):\n 1. int (aa i + bb i) gchoose (i - j0) =\n    int (aa i + bb i choose Suc (i - j))", "by (simp add: int_binomial)"], ["proof (state)\nthis:\n  int (aa i + bb i) gchoose (i - j0) = int (aa i + bb i choose Suc (i - j))\n\ngoal (1 subgoal):\n 1. {j0 + 4..card X - 1} = {j + 3..card X - 1}", "qed (simp add: j)"], ["proof (state)\nthis:\n  (\\<Sum>i = j0 + 4..card X - 1. int (aa i + bb i) gchoose (i - j0)) =\n  int (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "finally"], ["proof (chain)\npicking this:\n  int (aa j + bb j)\n  \\<le> 2 + (int (aa (j + 1) + bb (j + 1)) gchoose 2) +\n        int (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "have \"int (cc j) \\<le> int (2 + (cc (j + 1) choose 2) + (\\<Sum>i = j + 3..n - 1. cc i choose (Suc (i - j))))\""], ["proof (prove)\nusing this:\n  int (aa j + bb j)\n  \\<le> 2 + (int (aa (j + 1) + bb (j + 1)) gchoose 2) +\n        int (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n\ngoal (1 subgoal):\n 1. int (aa j + bb j)\n    \\<le> int (2 + (aa (j + 1) + bb (j + 1) choose 2) +\n               (\\<Sum>i = j + 3..card X - 1.\n                   aa i + bb i choose Suc (i - j)))", "by (simp only: int_plus int_binomial)"], ["proof (state)\nthis:\n  int (aa j + bb j)\n  \\<le> int (2 + (aa (j + 1) + bb (j + 1) choose 2) +\n             (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j)))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (aa j + bb j)\n  \\<le> int (2 + (aa (j + 1) + bb (j + 1) choose 2) +\n             (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j)))\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "by (simp only: zle_int)"], ["proof (state)\nthis:\n  aa j + bb j\n  \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n        (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cc_le_Dube_aux: \"0 < j \\<Longrightarrow> j + 1 \\<le> n \\<Longrightarrow> cc j \\<le> Dube_aux n d j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < j; j + 1 \\<le> card X\\<rbrakk>\n    \\<Longrightarrow> aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "proof (induct j rule: Dube_aux.induct[where n=n])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j + 2 < card X; 0 < j + 1;\n                 j + 1 + 1 \\<le> card X\\<rbrakk>\n                \\<Longrightarrow> aa (j + 1) + bb (j + 1)\n                                  \\<le> Dube_aux (card X) (poly_deg f)\n   (j + 1);\n        \\<And>x.\n           \\<lbrakk>j + 2 < card X; x \\<in> {j + 3..card X - 1}; 0 < x;\n            x + 1 \\<le> card X\\<rbrakk>\n           \\<Longrightarrow> aa x + bb x\n                             \\<le> Dube_aux (card X) (poly_deg f) x;\n        0 < j; j + 1 \\<le> card X\\<rbrakk>\n       \\<Longrightarrow> aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "case step: (1 j)"], ["proof (state)\nthis:\n  \\<lbrakk>j + 2 < card X; 0 < j + 1; j + 1 + 1 \\<le> card X\\<rbrakk>\n  \\<Longrightarrow> aa (j + 1) + bb (j + 1)\n                    \\<le> Dube_aux (card X) (poly_deg f) (j + 1)\n  \\<lbrakk>j + 2 < card X; ?x47 \\<in> {j + 3..card X - 1}; 0 < ?x47;\n   ?x47 + 1 \\<le> card X\\<rbrakk>\n  \\<Longrightarrow> aa ?x47 + bb ?x47\n                    \\<le> Dube_aux (card X) (poly_deg f) ?x47\n  0 < j\n  j + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j + 2 < card X; 0 < j + 1;\n                 j + 1 + 1 \\<le> card X\\<rbrakk>\n                \\<Longrightarrow> aa (j + 1) + bb (j + 1)\n                                  \\<le> Dube_aux (card X) (poly_deg f)\n   (j + 1);\n        \\<And>x.\n           \\<lbrakk>j + 2 < card X; x \\<in> {j + 3..card X - 1}; 0 < x;\n            x + 1 \\<le> card X\\<rbrakk>\n           \\<Longrightarrow> aa x + bb x\n                             \\<le> Dube_aux (card X) (poly_deg f) x;\n        0 < j; j + 1 \\<le> card X\\<rbrakk>\n       \\<Longrightarrow> aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "from step.prems(2)"], ["proof (chain)\npicking this:\n  j + 1 \\<le> card X", "have \"j + 2 < n \\<or> j + 2 = n \\<or> j + 1 = n\""], ["proof (prove)\nusing this:\n  j + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. j + 2 < card X \\<or> j + 2 = card X \\<or> j + 1 = card X", "by auto"], ["proof (state)\nthis:\n  j + 2 < card X \\<or> j + 2 = card X \\<or> j + 1 = card X\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j + 2 < card X; 0 < j + 1;\n                 j + 1 + 1 \\<le> card X\\<rbrakk>\n                \\<Longrightarrow> aa (j + 1) + bb (j + 1)\n                                  \\<le> Dube_aux (card X) (poly_deg f)\n   (j + 1);\n        \\<And>x.\n           \\<lbrakk>j + 2 < card X; x \\<in> {j + 3..card X - 1}; 0 < x;\n            x + 1 \\<le> card X\\<rbrakk>\n           \\<Longrightarrow> aa x + bb x\n                             \\<le> Dube_aux (card X) (poly_deg f) x;\n        0 < j; j + 1 \\<le> card X\\<rbrakk>\n       \\<Longrightarrow> aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "thus ?case"], ["proof (prove)\nusing this:\n  j + 2 < card X \\<or> j + 2 = card X \\<or> j + 1 = card X\n\ngoal (1 subgoal):\n 1. aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "assume *: \"j + 2 < n\""], ["proof (state)\nthis:\n  j + 2 < card X\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "moreover"], ["proof (state)\nthis:\n  j + 2 < card X\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "have \"0 < j + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < j + 1", "by simp"], ["proof (state)\nthis:\n  0 < j + 1\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "moreover"], ["proof (state)\nthis:\n  0 < j + 1\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "from *"], ["proof (chain)\npicking this:\n  j + 2 < card X", "have \"j + 1 + 1 \\<le> n\""], ["proof (prove)\nusing this:\n  j + 2 < card X\n\ngoal (1 subgoal):\n 1. j + 1 + 1 \\<le> card X", "by simp"], ["proof (state)\nthis:\n  j + 1 + 1 \\<le> card X\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "ultimately"], ["proof (chain)\npicking this:\n  j + 2 < card X\n  0 < j + 1\n  j + 1 + 1 \\<le> card X", "have \"cc (j + 1) \\<le> Dube_aux n d (j + 1)\""], ["proof (prove)\nusing this:\n  j + 2 < card X\n  0 < j + 1\n  j + 1 + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. aa (j + 1) + bb (j + 1) \\<le> Dube_aux (card X) (poly_deg f) (j + 1)", "by (rule step.hyps)"], ["proof (state)\nthis:\n  aa (j + 1) + bb (j + 1) \\<le> Dube_aux (card X) (poly_deg f) (j + 1)\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "hence 1: \"cc (j + 1) choose 2 \\<le> Dube_aux n d (j + 1) choose 2\""], ["proof (prove)\nusing this:\n  aa (j + 1) + bb (j + 1) \\<le> Dube_aux (card X) (poly_deg f) (j + 1)\n\ngoal (1 subgoal):\n 1. aa (j + 1) + bb (j + 1) choose 2\n    \\<le> Dube_aux (card X) (poly_deg f) (j + 1) choose 2", "by (rule Binomial_Int.binomial_mono)"], ["proof (state)\nthis:\n  aa (j + 1) + bb (j + 1) choose 2\n  \\<le> Dube_aux (card X) (poly_deg f) (j + 1) choose 2\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "have 2: \"(\\<Sum>i = j + 3..n - 1. cc i choose Suc (i - j)) \\<le>\n              (\\<Sum>i = j + 3..n - 1. Dube_aux n d i choose Suc (i - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n    \\<le> (\\<Sum>i = j + 3..card X - 1.\n              Dube_aux (card X) (poly_deg f) i choose Suc (i - j))", "proof (rule sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "fix i::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "note *"], ["proof (state)\nthis:\n  j + 2 < card X\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "moreover"], ["proof (state)\nthis:\n  j + 2 < card X\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "assume \"i \\<in> {j + 3..n - 1}\""], ["proof (state)\nthis:\n  i \\<in> {j + 3..card X - 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "moreover"], ["proof (state)\nthis:\n  i \\<in> {j + 3..card X - 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "from this \\<open>2 < n\\<close>"], ["proof (chain)\npicking this:\n  i \\<in> {j + 3..card X - 1}\n  2 < card X", "have \"0 < i\" and \"i + 1 \\<le> n\""], ["proof (prove)\nusing this:\n  i \\<in> {j + 3..card X - 1}\n  2 < card X\n\ngoal (1 subgoal):\n 1. 0 < i &&& i + 1 \\<le> card X", "by auto"], ["proof (state)\nthis:\n  0 < i\n  i + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "ultimately"], ["proof (chain)\npicking this:\n  j + 2 < card X\n  i \\<in> {j + 3..card X - 1}\n  0 < i\n  i + 1 \\<le> card X", "have \"cc i \\<le> Dube_aux n d i\""], ["proof (prove)\nusing this:\n  j + 2 < card X\n  i \\<in> {j + 3..card X - 1}\n  0 < i\n  i + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. aa i + bb i \\<le> Dube_aux (card X) (poly_deg f) i", "by (rule step.hyps)"], ["proof (state)\nthis:\n  aa i + bb i \\<le> Dube_aux (card X) (poly_deg f) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {j + 3..card X - 1} \\<Longrightarrow>\n       aa i + bb i choose Suc (i - j)\n       \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "thus \"cc i choose Suc (i - j) \\<le> Dube_aux n d i choose Suc (i - j)\""], ["proof (prove)\nusing this:\n  aa i + bb i \\<le> Dube_aux (card X) (poly_deg f) i\n\ngoal (1 subgoal):\n 1. aa i + bb i choose Suc (i - j)\n    \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)", "by (rule Binomial_Int.binomial_mono)"], ["proof (state)\nthis:\n  aa i + bb i choose Suc (i - j)\n  \\<le> Dube_aux (card X) (poly_deg f) i choose Suc (i - j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n  \\<le> (\\<Sum>i = j + 3..card X - 1.\n            Dube_aux (card X) (poly_deg f) i choose Suc (i - j))\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "from *"], ["proof (chain)\npicking this:\n  j + 2 < card X", "have \"j < n - 2\""], ["proof (prove)\nusing this:\n  j + 2 < card X\n\ngoal (1 subgoal):\n 1. j < card X - 2", "by simp"], ["proof (state)\nthis:\n  j < card X - 2\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "with step.prems(1)"], ["proof (chain)\npicking this:\n  0 < j\n  j < card X - 2", "have \"cc j \\<le> 2 + (cc (j + 1) choose 2) + (\\<Sum>i = j + 3..n - 1. cc i choose Suc (i - j))\""], ["proof (prove)\nusing this:\n  0 < j\n  j < card X - 2\n\ngoal (1 subgoal):\n 1. aa j + bb j\n    \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n          (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))", "by (rule cc_le)"], ["proof (state)\nthis:\n  aa j + bb j\n  \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n        (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "also"], ["proof (state)\nthis:\n  aa j + bb j\n  \\<le> 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n        (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "from * 1 2"], ["proof (chain)\npicking this:\n  j + 2 < card X\n  aa (j + 1) + bb (j + 1) choose 2\n  \\<le> Dube_aux (card X) (poly_deg f) (j + 1) choose 2\n  (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n  \\<le> (\\<Sum>i = j + 3..card X - 1.\n            Dube_aux (card X) (poly_deg f) i choose Suc (i - j))", "have \"\\<dots> \\<le> Dube_aux n d j\""], ["proof (prove)\nusing this:\n  j + 2 < card X\n  aa (j + 1) + bb (j + 1) choose 2\n  \\<le> Dube_aux (card X) (poly_deg f) (j + 1) choose 2\n  (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n  \\<le> (\\<Sum>i = j + 3..card X - 1.\n            Dube_aux (card X) (poly_deg f) i choose Suc (i - j))\n\ngoal (1 subgoal):\n 1. 2 + (aa (j + 1) + bb (j + 1) choose 2) +\n    (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n    \\<le> Dube_aux (card X) (poly_deg f) j", "by simp"], ["proof (state)\nthis:\n  2 + (aa (j + 1) + bb (j + 1) choose 2) +\n  (\\<Sum>i = j + 3..card X - 1. aa i + bb i choose Suc (i - j))\n  \\<le> Dube_aux (card X) (poly_deg f) j\n\ngoal (3 subgoals):\n 1. j + 2 < card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 3. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "finally"], ["proof (chain)\npicking this:\n  aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "show ?thesis"], ["proof (prove)\nusing this:\n  aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n\ngoal (1 subgoal):\n 1. aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "."], ["proof (state)\nthis:\n  aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n\ngoal (2 subgoals):\n 1. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "assume \"j + 2 = n\""], ["proof (state)\nthis:\n  j + 2 = card X\n\ngoal (2 subgoals):\n 1. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "hence \"j = n - 2\" and \"Dube_aux n d j = d\\<^sup>2 + 2 * d\""], ["proof (prove)\nusing this:\n  j + 2 = card X\n\ngoal (1 subgoal):\n 1. j = card X - 2 &&&\n    Dube_aux (card X) (poly_deg f) j = (poly_deg f)\\<^sup>2 + 2 * poly_deg f", "by simp_all"], ["proof (state)\nthis:\n  j = card X - 2\n  Dube_aux (card X) (poly_deg f) j = (poly_deg f)\\<^sup>2 + 2 * poly_deg f\n\ngoal (2 subgoals):\n 1. j + 2 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n 2. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = card X - 2\n  Dube_aux (card X) (poly_deg f) j = (poly_deg f)\\<^sup>2 + 2 * poly_deg f\n\ngoal (1 subgoal):\n 1. aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "by (simp only: cc_n_minus_2)"], ["proof (state)\nthis:\n  aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n\ngoal (1 subgoal):\n 1. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "assume \"j + 1 = n\""], ["proof (state)\nthis:\n  j + 1 = card X\n\ngoal (1 subgoal):\n 1. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "hence \"j = n - 1\" and \"Dube_aux n d j = 2 * d\""], ["proof (prove)\nusing this:\n  j + 1 = card X\n\ngoal (1 subgoal):\n 1. j = card X - 1 &&& Dube_aux (card X) (poly_deg f) j = 2 * poly_deg f", "by simp_all"], ["proof (state)\nthis:\n  j = card X - 1\n  Dube_aux (card X) (poly_deg f) j = 2 * poly_deg f\n\ngoal (1 subgoal):\n 1. j + 1 = card X \\<Longrightarrow>\n    aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = card X - 1\n  Dube_aux (card X) (poly_deg f) j = 2 * poly_deg f\n\ngoal (1 subgoal):\n 1. aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j", "by (simp only: cc_n_minus_1)"], ["proof (state)\nthis:\n  aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aa j + bb j \\<le> Dube_aux (card X) (poly_deg f) j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma Dube_aux:\n  assumes \"g \\<in> punit.reduced_GB F\"\n  shows \"poly_deg g \\<le> Dube_aux n d 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "proof (cases \"n = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "case True"], ["proof (state)\nthis:\n  card X = 2\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F", "have \"poly_deg g \\<le> bb 0\""], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> bb 0", "by (rule deg_RGB)"], ["proof (state)\nthis:\n  poly_deg g \\<le> bb 0\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  poly_deg g \\<le> bb 0\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "have \"\\<dots> \\<le> max (aa 1) (bb 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "by (fact bb_0)"], ["proof (state)\nthis:\n  bb 0 \\<le> max (aa 1) (bb 1)\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  bb 0 \\<le> max (aa 1) (bb 1)\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "have \"\\<dots> \\<le> cc (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (aa 1) (bb 1) \\<le> aa (card X - 1) + bb (card X - 1)", "by (simp add: True)"], ["proof (state)\nthis:\n  max (aa 1) (bb 1) \\<le> aa (card X - 1) + bb (card X - 1)\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  max (aa 1) (bb 1) \\<le> aa (card X - 1) + bb (card X - 1)\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "have \"\\<dots> = 2 * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f", "by (fact cc_n_minus_1)"], ["proof (state)\nthis:\n  aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  aa (card X - 1) + bb (card X - 1) = 2 * poly_deg f\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "have \"\\<dots> = Dube_aux n d 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * poly_deg f = Dube_aux (card X) (poly_deg f) 1", "by (simp add: True)"], ["proof (state)\nthis:\n  2 * poly_deg f = Dube_aux (card X) (poly_deg f) 1\n\ngoal (2 subgoals):\n 1. card X = 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n 2. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "finally"], ["proof (chain)\npicking this:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "."], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "case False"], ["proof (state)\nthis:\n  card X \\<noteq> 2\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "with \\<open>1 < n\\<close>"], ["proof (chain)\npicking this:\n  1 < card X\n  card X \\<noteq> 2", "have \"2 < n\" and \"1 + 1 \\<le> n\""], ["proof (prove)\nusing this:\n  1 < card X\n  card X \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < card X &&& 1 + 1 \\<le> card X", "by simp_all"], ["proof (state)\nthis:\n  2 < card X\n  1 + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F", "have \"poly_deg g \\<le> bb 0\""], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> bb 0", "by (rule deg_RGB)"], ["proof (state)\nthis:\n  poly_deg g \\<le> bb 0\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  poly_deg g \\<le> bb 0\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "have \"\\<dots> \\<le> max (aa 1) (bb 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bb 0 \\<le> max (aa 1) (bb 1)", "by (fact bb_0)"], ["proof (state)\nthis:\n  bb 0 \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  bb 0 \\<le> max (aa 1) (bb 1)\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "have \"\\<dots> \\<le> cc 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (aa 1) (bb 1) \\<le> aa 1 + bb 1", "by simp"], ["proof (state)\nthis:\n  max (aa 1) (bb 1) \\<le> aa 1 + bb 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "also"], ["proof (state)\nthis:\n  max (aa 1) (bb 1) \\<le> aa 1 + bb 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "from \\<open>2 < n\\<close> _ \\<open>1 + 1 \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  2 < card X\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  1 + 1 \\<le> card X", "have \"\\<dots> \\<le> Dube_aux n d 1\""], ["proof (prove)\nusing this:\n  2 < card X\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  1 + 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. aa 1 + bb 1 \\<le> Dube_aux (card X) (poly_deg f) 1", "by (rule cc_le_Dube_aux) simp"], ["proof (state)\nthis:\n  aa 1 + bb 1 \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal (1 subgoal):\n 1. card X \\<noteq> 2 \\<Longrightarrow>\n    poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "finally"], ["proof (chain)\npicking this:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "."], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "theorem Dube:\n  assumes \"finite F\" and \"F \\<subseteq> P[X]\" and \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"g \\<in> punit.reduced_GB F\"\n  shows \"poly_deg g \\<le> Dube (card X) (maxdeg F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "proof (cases \"F \\<subseteq> {0}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "case True"], ["proof (state)\nthis:\n  F \\<subseteq> {0}\n\ngoal (2 subgoals):\n 1. F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"F = {} \\<or> F = {0}\""], ["proof (prove)\nusing this:\n  F \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. F = {} \\<or> F = {0}", "by blast"], ["proof (state)\nthis:\n  F = {} \\<or> F = {0}\n\ngoal (2 subgoals):\n 1. F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "with assms(4)"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F\n  F = {} \\<or> F = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  F = {} \\<or> F = {0}\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "by (auto simp: punit.reduced_GB_empty punit.reduced_GB_singleton)"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "case False"], ["proof (state)\nthis:\n  \\<not> F \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"F - {0} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> F \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. F - {0} \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  F - {0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"F \\<noteq> {}\""], ["proof (prove)\nusing this:\n  F - {0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"poly_deg ` F \\<noteq> {}\""], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly_deg ` F \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  poly_deg ` F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from assms(1)"], ["proof (chain)\npicking this:\n  finite F", "have fin1: \"finite (poly_deg ` F)\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` F)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` F)\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from assms(1)"], ["proof (chain)\npicking this:\n  finite F", "have \"finite (F - {0})\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (F - {0})", "by simp"], ["proof (state)\nthis:\n  finite (F - {0})\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence fin: \"finite (poly_deg ` (F - {0}))\""], ["proof (prove)\nusing this:\n  finite (F - {0})\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` (F - {0}))", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` (F - {0}))\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "moreover"], ["proof (state)\nthis:\n  finite (poly_deg ` (F - {0}))\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from \\<open>F - {0} \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  F - {0} \\<noteq> {}", "have *: \"poly_deg ` (F - {0}) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  F - {0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly_deg ` (F - {0}) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  poly_deg ` (F - {0}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "ultimately"], ["proof (chain)\npicking this:\n  finite (poly_deg ` (F - {0}))\n  poly_deg ` (F - {0}) \\<noteq> {}", "have \"maxdeg (F - {0}) \\<in> poly_deg ` (F - {0})\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` (F - {0}))\n  poly_deg ` (F - {0}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. maxdeg (F - {0}) \\<in> poly_deg ` (F - {0})", "unfolding maxdeg_def"], ["proof (prove)\nusing this:\n  finite (poly_deg ` (F - {0}))\n  poly_deg ` (F - {0}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` (F - {0})) \\<in> poly_deg ` (F - {0})", "by (rule Max_in)"], ["proof (state)\nthis:\n  maxdeg (F - {0}) \\<in> poly_deg ` (F - {0})\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "then"], ["proof (chain)\npicking this:\n  maxdeg (F - {0}) \\<in> poly_deg ` (F - {0})", "obtain f where \"f \\<in> F - {0}\" and md1: \"maxdeg (F - {0}) = poly_deg f\""], ["proof (prove)\nusing this:\n  maxdeg (F - {0}) \\<in> poly_deg ` (F - {0})\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F - {0}; maxdeg (F - {0}) = poly_deg f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f \\<in> F - {0}\n  maxdeg (F - {0}) = poly_deg f\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "note this(2)"], ["proof (state)\nthis:\n  maxdeg (F - {0}) = poly_deg f\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "moreover"], ["proof (state)\nthis:\n  maxdeg (F - {0}) = poly_deg f\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"maxdeg (F - {0}) \\<le> maxdeg F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg (F - {0}) \\<le> maxdeg F", "unfolding maxdeg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` (F - {0})) \\<le> Max (poly_deg ` F)", "using image_mono * fin1"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?f ` ?A \\<subseteq> ?f ` ?B\n  poly_deg ` (F - {0}) \\<noteq> {}\n  finite (poly_deg ` F)\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` (F - {0})) \\<le> Max (poly_deg ` F)", "by (rule Max_mono) blast"], ["proof (state)\nthis:\n  maxdeg (F - {0}) \\<le> maxdeg F\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "ultimately"], ["proof (chain)\npicking this:\n  maxdeg (F - {0}) = poly_deg f\n  maxdeg (F - {0}) \\<le> maxdeg F", "have \"poly_deg f \\<le> maxdeg F\""], ["proof (prove)\nusing this:\n  maxdeg (F - {0}) = poly_deg f\n  maxdeg (F - {0}) \\<le> maxdeg F\n\ngoal (1 subgoal):\n 1. poly_deg f \\<le> maxdeg F", "by simp"], ["proof (state)\nthis:\n  poly_deg f \\<le> maxdeg F\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from \\<open>f \\<in> F - {0}\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F - {0}", "have \"f \\<in> F\" and \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<in> F - {0}\n\ngoal (1 subgoal):\n 1. f \\<in> F &&& f \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  f \\<in> F\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from this(1) assms(2)"], ["proof (chain)\npicking this:\n  f \\<in> F\n  F \\<subseteq> P[X]", "have \"f \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[X]", ".."], ["proof (state)\nthis:\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have f_max: \"poly_deg f' \\<le> poly_deg f\" if \"f' \\<in> F\" for f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f", "proof (cases \"f' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f' = 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f\n 2. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "case True"], ["proof (state)\nthis:\n  f' = 0\n\ngoal (2 subgoals):\n 1. f' = 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f\n 2. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "thus ?thesis"], ["proof (prove)\nusing this:\n  f' = 0\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f", "by simp"], ["proof (state)\nthis:\n  poly_deg f' \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "case False"], ["proof (state)\nthis:\n  f' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "with that"], ["proof (chain)\npicking this:\n  f' \\<in> F\n  f' \\<noteq> 0", "have \"f' \\<in> F - {0}\""], ["proof (prove)\nusing this:\n  f' \\<in> F\n  f' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f' \\<in> F - {0}", "by simp"], ["proof (state)\nthis:\n  f' \\<in> F - {0}\n\ngoal (1 subgoal):\n 1. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "hence \"poly_deg f' \\<in> poly_deg ` (F - {0})\""], ["proof (prove)\nusing this:\n  f' \\<in> F - {0}\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<in> poly_deg ` (F - {0})", "by (rule imageI)"], ["proof (state)\nthis:\n  poly_deg f' \\<in> poly_deg ` (F - {0})\n\ngoal (1 subgoal):\n 1. f' \\<noteq> 0 \\<Longrightarrow> poly_deg f' \\<le> poly_deg f", "with fin"], ["proof (chain)\npicking this:\n  finite (poly_deg ` (F - {0}))\n  poly_deg f' \\<in> poly_deg ` (F - {0})", "show \"poly_deg f' \\<le> poly_deg f\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` (F - {0}))\n  poly_deg f' \\<in> poly_deg ` (F - {0})\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f", "unfolding md1[symmetric] maxdeg_def"], ["proof (prove)\nusing this:\n  finite (poly_deg ` (F - {0}))\n  poly_deg f' \\<in> poly_deg ` (F - {0})\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> Max (poly_deg ` (F - {0}))", "by (rule Max_ge)"], ["proof (state)\nthis:\n  poly_deg f' \\<le> poly_deg f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f'56 \\<in> F \\<Longrightarrow> poly_deg ?f'56 \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"maxdeg F \\<le> poly_deg f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg F \\<le> poly_deg f", "unfolding maxdeg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` F) \\<le> poly_deg f", "using fin1 \\<open>poly_deg ` F \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  finite (poly_deg ` F)\n  poly_deg ` F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` F) \\<le> poly_deg f", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "assume \"d \\<in> poly_deg ` F\""], ["proof (state)\nthis:\n  d \\<in> poly_deg ` F\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "then"], ["proof (chain)\npicking this:\n  d \\<in> poly_deg ` F", "obtain f' where \"f' \\<in> F\" and \"d = poly_deg f'\""], ["proof (prove)\nusing this:\n  d \\<in> poly_deg ` F\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> F; d = poly_deg f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f' \\<in> F\n  d = poly_deg f'\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "note this(2)"], ["proof (state)\nthis:\n  d = poly_deg f'\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "also"], ["proof (state)\nthis:\n  d = poly_deg f'\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "from \\<open>f' \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f' \\<in> F", "have \"poly_deg f' \\<le> poly_deg f\""], ["proof (prove)\nusing this:\n  f' \\<in> F\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f", "by (rule f_max)"], ["proof (state)\nthis:\n  poly_deg f' \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` F \\<Longrightarrow> a \\<le> poly_deg f", "finally"], ["proof (chain)\npicking this:\n  d \\<le> poly_deg f", "show \"d \\<le> poly_deg f\""], ["proof (prove)\nusing this:\n  d \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg f", "."], ["proof (state)\nthis:\n  d \\<le> poly_deg f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  maxdeg F \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "with \\<open>poly_deg f \\<le> maxdeg F\\<close>"], ["proof (chain)\npicking this:\n  poly_deg f \\<le> maxdeg F\n  maxdeg F \\<le> poly_deg f", "have md: \"poly_deg f = maxdeg F\""], ["proof (prove)\nusing this:\n  poly_deg f \\<le> maxdeg F\n  maxdeg F \\<le> poly_deg f\n\ngoal (1 subgoal):\n 1. poly_deg f = maxdeg F", "by (rule antisym)"], ["proof (state)\nthis:\n  poly_deg f = maxdeg F\n\ngoal (1 subgoal):\n 1. \\<not> F \\<subseteq> {0} \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "proof (cases \"ideal {f} = ideal F\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "case True"], ["proof (state)\nthis:\n  ideal {f} = ideal F\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "note assms(4)"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"punit.reduced_GB F = punit.reduced_GB {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.reduced_GB F = punit.reduced_GB {f}", "using punit.finite_reduced_GB_finite punit.reduced_GB_is_reduced_GB_finite"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow> finite (punit.reduced_GB ?F)\n  finite ?F \\<Longrightarrow> punit.is_reduced_GB (punit.reduced_GB ?F)\n\ngoal (1 subgoal):\n 1. punit.reduced_GB F = punit.reduced_GB {f}", "by (rule punit.reduced_GB_unique) (simp_all add: punit.reduced_GB_pmdl_finite[simplified] True)"], ["proof (state)\nthis:\n  punit.reduced_GB F = punit.reduced_GB {f}\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  punit.reduced_GB F = punit.reduced_GB {f}\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"\\<dots> \\<subseteq> {punit.monic f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.reduced_GB {f} \\<subseteq> {punit.monic f}", "by (simp add: punit.reduced_GB_singleton)"], ["proof (state)\nthis:\n  punit.reduced_GB {f} \\<subseteq> {punit.monic f}\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "finally"], ["proof (chain)\npicking this:\n  g \\<in> {punit.monic f}", "have \"g \\<in> {punit.monic f}\""], ["proof (prove)\nusing this:\n  g \\<in> {punit.monic f}\n\ngoal (1 subgoal):\n 1. g \\<in> {punit.monic f}", "."], ["proof (state)\nthis:\n  g \\<in> {punit.monic f}\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"poly_deg g = poly_deg (punit.monic f)\""], ["proof (prove)\nusing this:\n  g \\<in> {punit.monic f}\n\ngoal (1 subgoal):\n 1. poly_deg g = poly_deg (punit.monic f)", "by simp"], ["proof (state)\nthis:\n  poly_deg g = poly_deg (punit.monic f)\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  poly_deg g = poly_deg (punit.monic f)\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from poly_deg_monom_mult_le[where c=\"1 / lcf f\" and t=0 and p=f]"], ["proof (chain)\npicking this:\n  poly_deg (local.punit.monom_mult ((1::'a) / lcf f) 0 f)\n  \\<le> deg_pm 0 + poly_deg f", "have \"\\<dots> \\<le> poly_deg f\""], ["proof (prove)\nusing this:\n  poly_deg (local.punit.monom_mult ((1::'a) / lcf f) 0 f)\n  \\<le> deg_pm 0 + poly_deg f\n\ngoal (1 subgoal):\n 1. poly_deg (punit.monic f) \\<le> poly_deg f", "by (simp add: punit.monic_def)"], ["proof (state)\nthis:\n  poly_deg (punit.monic f) \\<le> poly_deg f\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  poly_deg (punit.monic f) \\<le> poly_deg f\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"\\<dots> = maxdeg F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f = maxdeg F", "by (fact md)"], ["proof (state)\nthis:\n  poly_deg f = maxdeg F\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  poly_deg f = maxdeg F\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"\\<dots> \\<le> Dube (card X) (maxdeg F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg F \\<le> Dube (card X) (maxdeg F)", "by (fact Dube_ge_d)"], ["proof (state)\nthis:\n  maxdeg F \\<le> Dube (card X) (maxdeg F)\n\ngoal (2 subgoals):\n 1. ideal {f} = ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "finally"], ["proof (chain)\npicking this:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "."], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "case False"], ["proof (state)\nthis:\n  ideal {f} \\<noteq> ideal F\n\ngoal (1 subgoal):\n 1. ideal {f} \\<noteq> ideal F \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "proof (cases \"poly_deg f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "case True"], ["proof (state)\nthis:\n  poly_deg f = 0\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"monomial (lookup f 0) 0 = f\""], ["proof (prove)\nusing this:\n  poly_deg f = 0\n\ngoal (1 subgoal):\n 1. monomial (lookup f 0) 0 = f", "by (rule poly_deg_zero_imp_monomial)"], ["proof (state)\nthis:\n  monomial (lookup f 0) 0 = f\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "moreover"], ["proof (state)\nthis:\n  monomial (lookup f 0) 0 = f\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "define c where \"c = lookup f 0\""], ["proof (state)\nthis:\n  c = lookup f 0\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lookup f 0) 0 = f\n  c = lookup f 0", "have f: \"f = monomial c 0\""], ["proof (prove)\nusing this:\n  monomial (lookup f 0) 0 = f\n  c = lookup f 0\n\ngoal (1 subgoal):\n 1. f = monomial c 0", "by simp"], ["proof (state)\nthis:\n  f = monomial c 0\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "with \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  f = monomial c 0", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  f = monomial c 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "from \\<open>f \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"f \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> ideal F", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  f \\<in> ideal F\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"punit.monom_mult (1 / c) 0 f \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult ((1::'a) / c) 0 f \\<in> ideal F", "by (rule punit.pmdl_closed_monom_mult[simplified])"], ["proof (state)\nthis:\n  local.punit.monom_mult ((1::'a) / c) 0 f \\<in> ideal F\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  local.punit.monom_mult ((1::'a) / c) 0 f \\<in> ideal F", "have \"ideal F = UNIV\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  local.punit.monom_mult ((1::'a) / c) 0 f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. ideal F = UNIV", "by (simp add: f punit.monom_mult_monomial ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  ideal F = UNIV\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "with assms(1)"], ["proof (chain)\npicking this:\n  finite F\n  ideal F = UNIV", "have \"punit.reduced_GB F = {1}\""], ["proof (prove)\nusing this:\n  finite F\n  ideal F = UNIV\n\ngoal (1 subgoal):\n 1. punit.reduced_GB F = {1}", "by (simp only: ideal_eq_UNIV_iff_reduced_GB_eq_one_finite)"], ["proof (state)\nthis:\n  punit.reduced_GB F = {1}\n\ngoal (2 subgoals):\n 1. poly_deg f = 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "with assms(4)"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F\n  punit.reduced_GB F = {1}", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  punit.reduced_GB F = {1}\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "by simp"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "case False"], ["proof (state)\nthis:\n  poly_deg f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"0 < poly_deg f\""], ["proof (prove)\nusing this:\n  poly_deg f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly_deg f", "by simp"], ["proof (state)\nthis:\n  0 < poly_deg f\n\ngoal (1 subgoal):\n 1. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"card X \\<le> 1 \\<or> 1 < card X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card X \\<le> 1 \\<or> 1 < card X", "by auto"], ["proof (state)\nthis:\n  card X \\<le> 1 \\<or> 1 < card X\n\ngoal (1 subgoal):\n 1. poly_deg f \\<noteq> 0 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)", "thus ?thesis"], ["proof (prove)\nusing this:\n  card X \\<le> 1 \\<or> 1 < card X\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "note fin_X"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "moreover"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "assume \"card X \\<le> 1\""], ["proof (state)\nthis:\n  card X \\<le> 1\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "moreover"], ["proof (state)\nthis:\n  card X \\<le> 1\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "note assms(2)"], ["proof (state)\nthis:\n  F \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "moreover"], ["proof (state)\nthis:\n  F \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "from \\<open>f \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"f \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> ideal F", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  f \\<in> ideal F\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  card X \\<le> 1\n  F \\<subseteq> P[X]\n  f \\<in> ideal F", "have \"poly_deg g \\<le> poly_deg f\""], ["proof (prove)\nusing this:\n  finite X\n  card X \\<le> 1\n  F \\<subseteq> P[X]\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> poly_deg f", "using \\<open>f \\<noteq> 0\\<close> assms(4)"], ["proof (prove)\nusing this:\n  finite X\n  card X \\<le> 1\n  F \\<subseteq> P[X]\n  f \\<in> ideal F\n  f \\<noteq> 0\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> poly_deg f", "by (rule deg_reduced_GB_univariate_le)"], ["proof (state)\nthis:\n  poly_deg g \\<le> poly_deg f\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  poly_deg g \\<le> poly_deg f\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "have \"\\<dots> \\<le> Dube (card X) (maxdeg F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f \\<le> Dube (card X) (maxdeg F)", "unfolding md"], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg F \\<le> Dube (card X) (maxdeg F)", "by (fact Dube_ge_d)"], ["proof (state)\nthis:\n  poly_deg f \\<le> Dube (card X) (maxdeg F)\n\ngoal (2 subgoals):\n 1. card X \\<le> 1 \\<Longrightarrow>\n    poly_deg g \\<le> Dube (card X) (maxdeg F)\n 2. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "finally"], ["proof (chain)\npicking this:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "."], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "assume \"1 < card X\""], ["proof (state)\nthis:\n  1 < card X\n\ngoal (1 subgoal):\n 1. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "hence \"poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\""], ["proof (prove)\nusing this:\n  1 < card X\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "using assms(1, 2) \\<open>f \\<in> F\\<close> assms(3) f_max \\<open>0 < poly_deg f\\<close> \\<open>ideal {f} \\<noteq> ideal F\\<close> assms(4)"], ["proof (prove)\nusing this:\n  1 < card X\n  finite F\n  F \\<subseteq> P[X]\n  f \\<in> F\n  ?f56 \\<in> F \\<Longrightarrow> homogeneous ?f56\n  ?f'56 \\<in> F \\<Longrightarrow> poly_deg ?f'56 \\<le> poly_deg f\n  0 < poly_deg f\n  ideal {f} \\<noteq> ideal F\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1", "by (rule Dube_aux)"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal (1 subgoal):\n 1. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "also"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube_aux (card X) (poly_deg f) 1\n\ngoal (1 subgoal):\n 1. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "from \\<open>1 < card X\\<close> \\<open>0 < poly_deg f\\<close>"], ["proof (chain)\npicking this:\n  1 < card X\n  0 < poly_deg f", "have \"\\<dots> = Dube (card X) (maxdeg F)\""], ["proof (prove)\nusing this:\n  1 < card X\n  0 < poly_deg f\n\ngoal (1 subgoal):\n 1. Dube_aux (card X) (poly_deg f) 1 = Dube (card X) (maxdeg F)", "by (simp add: Dube_def md)"], ["proof (state)\nthis:\n  Dube_aux (card X) (poly_deg f) 1 = Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. 1 < card X \\<Longrightarrow> poly_deg g \\<le> Dube (card X) (maxdeg F)", "finally"], ["proof (chain)\npicking this:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card X) (maxdeg F)", "."], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg g \\<le> Dube (card X) (maxdeg F)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Dube_is_hom_GB_bound:\n  \"finite F \\<Longrightarrow> F \\<subseteq> P[X] \\<Longrightarrow> is_hom_GB_bound F (Dube (card X) (maxdeg F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; F \\<subseteq> P[X]\\<rbrakk>\n    \\<Longrightarrow> is_hom_GB_bound F (Dube (card X) (maxdeg F))", "by (intro is_hom_GB_boundI Dube)"], ["", "end"], ["", "corollary Dube_indets:\n  assumes \"finite F\" and \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"g \\<in> punit.reduced_GB F\"\n  shows \"poly_deg g \\<le> Dube (card (\\<Union>(indets ` F))) (maxdeg F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card (\\<Union> (indets ` F))) (maxdeg F)", "using _ assms(1) _ assms(2, 3)"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite F\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?f56 \\<in> F \\<Longrightarrow> homogeneous ?f56\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Dube (card (\\<Union> (indets ` F))) (maxdeg F)", "proof (rule Dube)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (\\<Union> (indets ` F))\n 2. F \\<subseteq> P[\\<Union> (indets ` F)]\n 3. \\<And>f. f \\<in> F \\<Longrightarrow> f \\<in> F", "from assms"], ["proof (chain)\npicking this:\n  finite F\n  ?f56 \\<in> F \\<Longrightarrow> homogeneous ?f56\n  g \\<in> punit.reduced_GB F", "show \"finite (\\<Union>(indets ` F))\""], ["proof (prove)\nusing this:\n  finite F\n  ?f56 \\<in> F \\<Longrightarrow> homogeneous ?f56\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (indets ` F))", "by (simp add: finite_indets)"], ["proof (state)\nthis:\n  finite (\\<Union> (indets ` F))\n\ngoal (2 subgoals):\n 1. F \\<subseteq> P[\\<Union> (indets ` F)]\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> f \\<in> F", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. F \\<subseteq> P[\\<Union> (indets ` F)]\n 2. \\<And>f. f \\<in> F \\<Longrightarrow> f \\<in> F", "show \"F \\<subseteq> P[\\<Union>(indets ` F)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> P[\\<Union> (indets ` F)]", "by (auto simp: Polys_alt)"], ["proof (state)\nthis:\n  F \\<subseteq> P[\\<Union> (indets ` F)]\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> f \\<in> F", "qed"], ["", "corollary Dube_is_hom_GB_bound_indets:\n  \"finite F \\<Longrightarrow> is_hom_GB_bound F (Dube (card (\\<Union>(indets ` F))) (maxdeg F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F \\<Longrightarrow>\n    is_hom_GB_bound F (Dube (card (\\<Union> (indets ` F))) (maxdeg F))", "by (intro is_hom_GB_boundI Dube_indets)"], ["", "end"], ["", "(* pm_powerprod *)"], ["", "hide_const (open) pm_powerprod.\\<a> pm_powerprod.\\<b>"], ["", "context extended_ord_pm_powerprod\nbegin"], ["", "lemma Dube_is_GB_cofactor_bound:\n  assumes \"finite X\" and \"finite F\" and \"F \\<subseteq> P[X]\"\n  shows \"is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))", "using assms(1, 3)"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))", "proof (rule hom_GB_bound_is_GB_cofactor_bound)"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "let ?F = \"homogenize None ` extend_indets ` F\""], ["proof (state)\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "let ?X = \"insert None (Some ` X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "from assms(1)"], ["proof (chain)\npicking this:\n  finite X", "have \"finite ?X\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite (insert None (Some ` X))", "by simp"], ["proof (state)\nthis:\n  finite (insert None (Some ` X))\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "moreover"], ["proof (state)\nthis:\n  finite (insert None (Some ` X))\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "from assms(2)"], ["proof (chain)\npicking this:\n  finite F", "have \"finite ?F\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (homogenize None ` extend_indets ` F)", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (homogenize None ` extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "moreover"], ["proof (state)\nthis:\n  finite (homogenize None ` extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "have \"?F \\<subseteq> P[?X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogenize None ` extend_indets ` F\n    \\<subseteq> P[insert None (Some ` X)]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homogenize None ` extend_indets ` F \\<Longrightarrow>\n       x \\<in> P[insert None (Some ` X)]", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homogenize None ` extend_indets ` F \\<Longrightarrow>\n       x \\<in> P[insert None (Some ` X)]", "assume \"f' \\<in> ?F\""], ["proof (state)\nthis:\n  f' \\<in> homogenize None ` extend_indets ` F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homogenize None ` extend_indets ` F \\<Longrightarrow>\n       x \\<in> P[insert None (Some ` X)]", "then"], ["proof (chain)\npicking this:\n  f' \\<in> homogenize None ` extend_indets ` F", "obtain f where \"f \\<in> F\" and f': \"f' = homogenize None (extend_indets f)\""], ["proof (prove)\nusing this:\n  f' \\<in> homogenize None ` extend_indets ` F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f' = homogenize None (extend_indets f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> F\n  f' = homogenize None (extend_indets f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homogenize None ` extend_indets ` F \\<Longrightarrow>\n       x \\<in> P[insert None (Some ` X)]", "from this(1) assms(3)"], ["proof (chain)\npicking this:\n  f \\<in> F\n  F \\<subseteq> P[X]", "have \"f \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[X]", ".."], ["proof (state)\nthis:\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homogenize None ` extend_indets ` F \\<Longrightarrow>\n       x \\<in> P[insert None (Some ` X)]", "hence \"extend_indets f \\<in> P[Some ` X]\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> P[Some ` X]", "by (auto simp: Polys_alt indets_extend_indets)"], ["proof (state)\nthis:\n  extend_indets f \\<in> P[Some ` X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homogenize None ` extend_indets ` F \\<Longrightarrow>\n       x \\<in> P[insert None (Some ` X)]", "thus \"f' \\<in> P[?X]\""], ["proof (prove)\nusing this:\n  extend_indets f \\<in> P[Some ` X]\n\ngoal (1 subgoal):\n 1. f' \\<in> P[insert None (Some ` X)]", "unfolding f'"], ["proof (prove)\nusing this:\n  extend_indets f \\<in> P[Some ` X]\n\ngoal (1 subgoal):\n 1. homogenize None (extend_indets f) \\<in> P[insert None (Some ` X)]", "by (rule homogenize_in_Polys)"], ["proof (state)\nthis:\n  f' \\<in> P[insert None (Some ` X)]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  homogenize None ` extend_indets ` F \\<subseteq> P[insert None (Some ` X)]\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "ultimately"], ["proof (chain)\npicking this:\n  finite (insert None (Some ` X))\n  finite (homogenize None ` extend_indets ` F)\n  homogenize None ` extend_indets ` F \\<subseteq> P[insert None (Some ` X)]", "have \"extended_ord.is_hom_GB_bound ?F (Dube (card ?X) (maxdeg ?F))\""], ["proof (prove)\nusing this:\n  finite (insert None (Some ` X))\n  finite (homogenize None ` extend_indets ` F)\n  homogenize None ` extend_indets ` F \\<subseteq> P[insert None (Some ` X)]\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (card (insert None (Some ` X)))\n       (maxdeg (homogenize None ` extend_indets ` F)))", "by (rule extended_ord.Dube_is_hom_GB_bound)"], ["proof (state)\nthis:\n  extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n   (Dube (card (insert None (Some ` X)))\n     (maxdeg (homogenize None ` extend_indets ` F)))\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "moreover"], ["proof (state)\nthis:\n  extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n   (Dube (card (insert None (Some ` X)))\n     (maxdeg (homogenize None ` extend_indets ` F)))\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "have \"maxdeg ?F = maxdeg F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "have \"maxdeg ?F = maxdeg (extend_indets ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) =\n    maxdeg (extend_indets ` F)", "by (auto simp: indets_extend_indets intro: maxdeg_homogenize)"], ["proof (state)\nthis:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "also"], ["proof (state)\nthis:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "have \"\\<dots> = maxdeg F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxdeg (extend_indets ` F) = maxdeg F", "by (simp add: maxdeg_def image_image)"], ["proof (state)\nthis:\n  maxdeg (extend_indets ` F) = maxdeg F\n\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "finally"], ["proof (chain)\npicking this:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "show \"maxdeg ?F = maxdeg F\""], ["proof (prove)\nusing this:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F\n\ngoal (1 subgoal):\n 1. maxdeg (homogenize None ` extend_indets ` F) = maxdeg F", "."], ["proof (state)\nthis:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "moreover"], ["proof (state)\nthis:\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "from assms(1)"], ["proof (chain)\npicking this:\n  finite X", "have \"card ?X = card X + 1\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. card (insert None (Some ` X)) = card X + 1", "by (simp add: card_image)"], ["proof (state)\nthis:\n  card (insert None (Some ` X)) = card X + 1\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "ultimately"], ["proof (chain)\npicking this:\n  extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n   (Dube (card (insert None (Some ` X)))\n     (maxdeg (homogenize None ` extend_indets ` F)))\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F\n  card (insert None (Some ` X)) = card X + 1", "show \"extended_ord.is_hom_GB_bound ?F (Dube (Suc (card X)) (maxdeg F))\""], ["proof (prove)\nusing this:\n  extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n   (Dube (card (insert None (Some ` X)))\n     (maxdeg (homogenize None ` extend_indets ` F)))\n  maxdeg (homogenize None ` extend_indets ` F) = maxdeg F\n  card (insert None (Some ` X)) = card X + 1\n\ngoal (1 subgoal):\n 1. extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n     (Dube (Suc (card X)) (maxdeg F))", "by simp"], ["proof (state)\nthis:\n  extended_ord.is_hom_GB_bound (homogenize None ` extend_indets ` F)\n   (Dube (Suc (card X)) (maxdeg F))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Dube_is_GB_cofactor_bound_explicit:\n  assumes \"finite X\" and \"finite F\" and \"F \\<subseteq> P[X]\"\n  obtains G where \"punit.is_Groebner_basis G\" and \"ideal G = ideal F\" and \"G \\<subseteq> P[X]\"\n    and \"\\<And>g. g \\<in> G \\<Longrightarrow> \\<exists>q. g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n                            (\\<forall>f. q f \\<in> P[X] \\<and> poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                              (f \\<notin> F \\<longrightarrow> q f = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>q.\n               g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>q.\n               g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  finite F\n  F \\<subseteq> P[X]", "have \"is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\"\n    (is \"is_GB_cofactor_bound _ ?b\")"], ["proof (prove)\nusing this:\n  finite X\n  finite F\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))", "by (rule Dube_is_GB_cofactor_bound)"], ["proof (state)\nthis:\n  is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>q.\n               g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>q.\n               g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms(3)"], ["proof (state)\nthis:\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>q.\n               g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\n  F \\<subseteq> P[X]", "obtain G where \"punit.is_Groebner_basis G\" and \"ideal G = ideal F\" and \"G \\<subseteq> P[X]\"\n    and 1: \"\\<And>g. g \\<in> G \\<Longrightarrow> \\<exists>F' q. finite F' \\<and> F' \\<subseteq> F \\<and> g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n                              (\\<forall>f. q f \\<in> P[X] \\<and> poly_deg (q f * f) \\<le> ?b \\<and> (f \\<notin> F' \\<longrightarrow> q f = 0))\""], ["proof (prove)\nusing this:\n  is_GB_cofactor_bound F (Dube (Suc (card X)) (maxdeg F))\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>F' q.\n               finite F' \\<and>\n               F' \\<subseteq> F \\<and>\n               g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F' \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_GB_cofactor_boundE_Polys) blast"], ["proof (state)\nthis:\n  punit.is_Groebner_basis G\n  ideal G = ideal F\n  G \\<subseteq> P[X]\n  ?g56 \\<in> G \\<Longrightarrow>\n  \\<exists>F' q.\n     finite F' \\<and>\n     F' \\<subseteq> F \\<and>\n     ?g56 = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n     (\\<forall>f.\n         q f \\<in> P[X] \\<and>\n         poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n         (f \\<notin> F' \\<longrightarrow> q f = 0))\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>punit.is_Groebner_basis G; ideal G = ideal F;\n         G \\<subseteq> P[X];\n         \\<And>g.\n            g \\<in> G \\<Longrightarrow>\n            \\<exists>q.\n               g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n               (\\<forall>f.\n                   q f \\<in> P[X] \\<and>\n                   poly_deg (q f * f)\n                   \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n                   (f \\<notin> F \\<longrightarrow> q f = 0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1-3)"], ["proof (chain)\npicking this:\n  punit.is_Groebner_basis G\n  ideal G = ideal F\n  G \\<subseteq> P[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis G\n  ideal G = ideal F\n  G \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow>\n       \\<exists>q.\n          g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n          (\\<forall>f.\n              q f \\<in> P[X] \\<and>\n              poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n              (f \\<notin> F \\<longrightarrow> q f = 0))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow>\n       \\<exists>q.\n          g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n          (\\<forall>f.\n              q f \\<in> P[X] \\<and>\n              poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n              (f \\<notin> F \\<longrightarrow> q f = 0))", "assume \"g \\<in> G\""], ["proof (state)\nthis:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow>\n       \\<exists>q.\n          g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n          (\\<forall>f.\n              q f \\<in> P[X] \\<and>\n              poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n              (f \\<notin> F \\<longrightarrow> q f = 0))", "hence \"\\<exists>F' q. finite F' \\<and> F' \\<subseteq> F \\<and> g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n                              (\\<forall>f. q f \\<in> P[X] \\<and> poly_deg (q f * f) \\<le> ?b \\<and> (f \\<notin> F' \\<longrightarrow> q f = 0))\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<exists>F' q.\n       finite F' \\<and>\n       F' \\<subseteq> F \\<and>\n       g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n       (\\<forall>f.\n           q f \\<in> P[X] \\<and>\n           poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n           (f \\<notin> F' \\<longrightarrow> q f = 0))", "by (rule 1)"], ["proof (state)\nthis:\n  \\<exists>F' q.\n     finite F' \\<and>\n     F' \\<subseteq> F \\<and>\n     g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n     (\\<forall>f.\n         q f \\<in> P[X] \\<and>\n         poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n         (f \\<notin> F' \\<longrightarrow> q f = 0))\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow>\n       \\<exists>q.\n          g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n          (\\<forall>f.\n              q f \\<in> P[X] \\<and>\n              poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n              (f \\<notin> F \\<longrightarrow> q f = 0))", "then"], ["proof (chain)\npicking this:\n  \\<exists>F' q.\n     finite F' \\<and>\n     F' \\<subseteq> F \\<and>\n     g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n     (\\<forall>f.\n         q f \\<in> P[X] \\<and>\n         poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n         (f \\<notin> F' \\<longrightarrow> q f = 0))", "obtain F' q where \"F' \\<subseteq> F\" and g: \"g = (\\<Sum>f\\<in>F'. q f * f)\" and \"\\<And>f. q f \\<in> P[X]\"\n      and \"\\<And>f. poly_deg (q f * f) \\<le> ?b\" and 2: \"\\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\""], ["proof (prove)\nusing this:\n  \\<exists>F' q.\n     finite F' \\<and>\n     F' \\<subseteq> F \\<and>\n     g = (\\<Sum>f\\<in>F'. q f * f) \\<and>\n     (\\<forall>f.\n         q f \\<in> P[X] \\<and>\n         poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n         (f \\<notin> F' \\<longrightarrow> q f = 0))\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>F' \\<subseteq> F; g = (\\<Sum>f\\<in>F'. q f * f);\n         \\<And>f. q f \\<in> P[X];\n         \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F);\n         \\<And>f. f \\<notin> F' \\<Longrightarrow> q f = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F' \\<subseteq> F\n  g = (\\<Sum>f\\<in>F'. q f * f)\n  q ?f56 \\<in> P[X]\n  poly_deg (q ?f56 * ?f56) \\<le> Dube (Suc (card X)) (maxdeg F)\n  ?f56 \\<notin> F' \\<Longrightarrow> q ?f56 = 0\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow>\n       \\<exists>q.\n          g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n          (\\<forall>f.\n              q f \\<in> P[X] \\<and>\n              poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n              (f \\<notin> F \\<longrightarrow> q f = 0))", "show \"\\<exists>q. g = (\\<Sum>f\\<in>F. q f * f) \\<and> (\\<forall>f. q f \\<in> P[X] \\<and> poly_deg (q f * f) \\<le> ?b \\<and> (f \\<notin> F \\<longrightarrow> q f = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n       (\\<forall>f.\n           q f \\<in> P[X] \\<and>\n           poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n           (f \\<notin> F \\<longrightarrow> q f = 0))", "proof (intro exI allI conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. g = (\\<Sum>f\\<in>F. ?q f * f)\n 2. \\<And>f. ?q f \\<in> P[X]\n 3. \\<And>f. poly_deg (?q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 4. \\<And>f. f \\<notin> F \\<Longrightarrow> ?q f = 0", "from assms(2) \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  finite F\n  F' \\<subseteq> F", "have \"(\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)\""], ["proof (prove)\nusing this:\n  finite F\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)", "proof (intro sum.mono_neutral_left ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "assume \"f \\<in> F - F'\""], ["proof (state)\nthis:\n  f \\<in> F - F'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "hence \"f \\<notin> F'\""], ["proof (prove)\nusing this:\n  f \\<in> F - F'\n\ngoal (1 subgoal):\n 1. f \\<notin> F'", "by simp"], ["proof (state)\nthis:\n  f \\<notin> F'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "hence \"q f = 0\""], ["proof (prove)\nusing this:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. q f = 0", "by (rule 2)"], ["proof (state)\nthis:\n  q f = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F\n 3. \\<And>i.\n       \\<lbrakk>finite F; F' \\<subseteq> F; i \\<in> F - F'\\<rbrakk>\n       \\<Longrightarrow> q i * i = 0", "thus \"q f * f = 0\""], ["proof (prove)\nusing this:\n  q f = 0\n\ngoal (1 subgoal):\n 1. q f * f = 0", "by simp"], ["proof (state)\nthis:\n  q f * f = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk> \\<Longrightarrow> finite F\n 2. \\<lbrakk>finite F; F' \\<subseteq> F\\<rbrakk>\n    \\<Longrightarrow> F' \\<subseteq> F", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)\n\ngoal (4 subgoals):\n 1. g = (\\<Sum>f\\<in>F. ?q f * f)\n 2. \\<And>f. ?q f \\<in> P[X]\n 3. \\<And>f. poly_deg (?q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 4. \\<And>f. f \\<notin> F \\<Longrightarrow> ?q f = 0", "thus \"g = (\\<Sum>f\\<in>F. q f * f)\""], ["proof (prove)\nusing this:\n  (\\<Sum>f\\<in>F'. q f * f) = (\\<Sum>f\\<in>F. q f * f)\n\ngoal (1 subgoal):\n 1. g = (\\<Sum>f\\<in>F. q f * f)", "by (simp only: g)"], ["proof (state)\nthis:\n  g = (\\<Sum>f\\<in>F. q f * f)\n\ngoal (3 subgoals):\n 1. \\<And>f. q f \\<in> P[X]\n 2. \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. q f \\<in> P[X]\n 2. \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "fix f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. q f \\<in> P[X]\n 2. \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "assume \"f \\<notin> F\""], ["proof (state)\nthis:\n  f \\<notin> F\n\ngoal (3 subgoals):\n 1. \\<And>f. q f \\<in> P[X]\n 2. \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "with \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F\n  f \\<notin> F", "have \"f \\<notin> F'\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F\n  f \\<notin> F\n\ngoal (1 subgoal):\n 1. f \\<notin> F'", "by blast"], ["proof (state)\nthis:\n  f \\<notin> F'\n\ngoal (3 subgoals):\n 1. \\<And>f. q f \\<in> P[X]\n 2. \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)\n 3. \\<And>f. f \\<notin> F \\<Longrightarrow> q f = 0", "thus \"q f = 0\""], ["proof (prove)\nusing this:\n  f \\<notin> F'\n\ngoal (1 subgoal):\n 1. q f = 0", "by (rule 2)"], ["proof (state)\nthis:\n  q f = 0\n\ngoal (2 subgoals):\n 1. \\<And>f. q f \\<in> P[X]\n 2. \\<And>f. poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F)", "qed fact+"], ["proof (state)\nthis:\n  \\<exists>q.\n     g = (\\<Sum>f\\<in>F. q f * f) \\<and>\n     (\\<forall>f.\n         q f \\<in> P[X] \\<and>\n         poly_deg (q f * f) \\<le> Dube (Suc (card X)) (maxdeg F) \\<and>\n         (f \\<notin> F \\<longrightarrow> q f = 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Dube_is_GB_cofactor_bound_indets:\n  assumes \"finite F\"\n  shows \"is_GB_cofactor_bound F (Dube (Suc (card (\\<Union>(indets ` F)))) (maxdeg F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_GB_cofactor_bound F\n     (Dube (Suc (card (\\<Union> (indets ` F)))) (maxdeg F))", "using _ assms _"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite F\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n\ngoal (1 subgoal):\n 1. is_GB_cofactor_bound F\n     (Dube (Suc (card (\\<Union> (indets ` F)))) (maxdeg F))", "proof (rule Dube_is_GB_cofactor_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (\\<Union> (indets ` F))\n 2. F \\<subseteq> P[\\<Union> (indets ` F)]", "from assms"], ["proof (chain)\npicking this:\n  finite F", "show \"finite (\\<Union>(indets ` F))\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (indets ` F))", "by (simp add: finite_indets)"], ["proof (state)\nthis:\n  finite (\\<Union> (indets ` F))\n\ngoal (1 subgoal):\n 1. F \\<subseteq> P[\\<Union> (indets ` F)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<subseteq> P[\\<Union> (indets ` F)]", "show \"F \\<subseteq> P[\\<Union>(indets ` F)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> P[\\<Union> (indets ` F)]", "by (auto simp: Polys_alt)"], ["proof (state)\nthis:\n  F \\<subseteq> P[\\<Union> (indets ` F)]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* extended_ord_pm_powerprod *)"], ["", "end"], ["", "(* theory *)"]]}